#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 256 40 24900 25300
    bytecblock "d" 0x00 "akita_dao" 0x0000000000000000 "u" "version" "disbursement_id" 0x004d
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0xcd9ad67e 0x1c9ebbdb 0x8f49262d 0x5656acf9 0x3c60dfa0 0x5424a591 0x3ec40aa4 0xbd3cd090 0xea9180dd 0x33e92c94 0x3ea11832 // method "create(string,uint64)void", method "createDisbursement(pay,string,uint64,uint64,string)uint64", method "editDisbursement(uint64,string,uint64,uint64,string)void", method "createUserAllocations(pay,uint64,(address,uint64)[])void", method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void", method "finalizeDisbursement(uint64)void", method "claimRewards((uint64,uint64)[])void", method "reclaimRewards(uint64,(address,uint64)[])void", method "update(string)void", method "updateAkitaDAO(uint64)void", method "optin(pay,uint64)void"
    txna ApplicationArgs 0
    match main_create_route@5 main_createDisbursement_route@6 main_editDisbursement_route@7 main_createUserAllocations_route@8 main_createAsaUserAllocations_route@9 main_finalizeDisbursement_route@10 main_claimRewards_route@11 main_reclaimRewards_route@12 main_update_route@13 main_updateAkitaDAO_route@14 main_optin_route@15

main_after_if_else@19:
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    intc_1 // 0
    return

main_optin_route@15:
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    callsub optin
    intc_0 // 1
    return

main_updateAkitaDAO_route@14:
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_0 // 1
    return

main_update_route@13:
    // smart_contracts/utils/base-contracts/base.ts:20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_0 // 1
    return

main_reclaimRewards_route@12:
    // smart_contracts/rewards/contract.algo.ts:326
    // reclaimRewards(id: uint64, reclaims: arc4Reclaims): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/rewards/contract.algo.ts:326
    // reclaimRewards(id: uint64, reclaims: arc4Reclaims): void {
    callsub reclaimRewards
    intc_0 // 1
    return

main_claimRewards_route@11:
    // smart_contracts/rewards/contract.algo.ts:272
    // claimRewards(rewards: arc4Claims): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    // smart_contracts/rewards/contract.algo.ts:272
    // claimRewards(rewards: arc4Claims): void {
    callsub claimRewards
    intc_0 // 1
    return

main_finalizeDisbursement_route@10:
    // smart_contracts/rewards/contract.algo.ts:252
    // finalizeDisbursement(id: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/rewards/contract.algo.ts:252
    // finalizeDisbursement(id: uint64): void {
    callsub finalizeDisbursement
    intc_0 // 1
    return

main_createAsaUserAllocations_route@9:
    // smart_contracts/rewards/contract.algo.ts:198-203
    // createAsaUserAllocations(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/rewards/contract.algo.ts:198-203
    // createAsaUserAllocations(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    callsub createAsaUserAllocations
    intc_0 // 1
    return

main_createUserAllocations_route@8:
    // smart_contracts/rewards/contract.algo.ts:154-158
    // createUserAllocations(
    //   payment: gtxn.PaymentTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/rewards/contract.algo.ts:154-158
    // createUserAllocations(
    //   payment: gtxn.PaymentTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    callsub createUserAllocations
    intc_0 // 1
    return

main_editDisbursement_route@7:
    // smart_contracts/rewards/contract.algo.ts:132-138
    // editDisbursement(
    //   id: uint64,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    extract 2 0
    // smart_contracts/rewards/contract.algo.ts:132-138
    // editDisbursement(
    //   id: uint64,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): void {
    callsub editDisbursement
    intc_0 // 1
    return

main_createDisbursement_route@6:
    // smart_contracts/rewards/contract.algo.ts:95-101
    // createDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/rewards/contract.algo.ts:95-101
    // createDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): uint64 {
    callsub createDisbursement
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_create_route@5:
    // smart_contracts/rewards/contract.algo.ts:87
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/rewards/contract.algo.ts:54
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/rewards/contract.algo.ts:87
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_0 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.create(version: bytes, akitaDAO: uint64) -> void:
create:
    // smart_contracts/rewards/contract.algo.ts:87-88
    // @abimethod({ onCreate: 'require' })
    // create(version: string, akitaDAO: uint64): void {
    proto 2 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 5 // "version"
    // smart_contracts/rewards/contract.algo.ts:89
    // this.version.value = version
    frame_dig -2
    app_global_put
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_2 // "akita_dao"
    // smart_contracts/rewards/contract.algo.ts:90
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/rewards/contract.algo.ts::Rewards.createDisbursement(mbrPayment: uint64, title: bytes, timeToUnlock: uint64, expiration: uint64, note: bytes) -> uint64:
createDisbursement:
    // smart_contracts/rewards/contract.algo.ts:95-101
    // createDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): uint64 {
    proto 5 1
    // smart_contracts/rewards/constants.ts:3
    // export const RewardsGlobalStateKeyDisbursementID = 'disbursement_id'
    intc_1 // 0
    bytec 6 // "disbursement_id"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:81
    // this.disbursementID.value += 1
    intc_0 // 1
    +
    // smart_contracts/rewards/constants.ts:3
    // export const RewardsGlobalStateKeyDisbursementID = 'disbursement_id'
    bytec 6 // "disbursement_id"
    // smart_contracts/rewards/contract.algo.ts:81
    // this.disbursementID.value += 1
    swap
    app_global_put
    // smart_contracts/rewards/base.ts:8
    // disbursements: 35_300 + (400 * (Bytes(title).length + Bytes(note).length)),
    frame_dig -4
    len
    dup
    frame_dig -1
    len
    dup
    cover 2
    +
    pushint 400 // 400
    *
    pushint 35300 // 35300
    +
    // smart_contracts/rewards/contract.algo.ts:108-115
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -5
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:111
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:108-115
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz createDisbursement_bool_false@3
    frame_dig -5
    gtxns Amount
    frame_dig 3
    ==
    bz createDisbursement_bool_false@3
    intc_0 // 1

createDisbursement_bool_merge@4:
    // smart_contracts/rewards/contract.algo.ts:108-115
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:118
    // creator: new Address(Txn.sender),
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:120
    // title: new Str(title),
    frame_dig 1
    itob
    extract 6 2
    frame_dig -4
    concat
    // smart_contracts/rewards/contract.algo.ts:122
    // timeToUnlock: new UintN64(timeToUnlock),
    frame_dig -3
    itob
    // smart_contracts/rewards/contract.algo.ts:123
    // expiration: new UintN64(expiration),
    frame_dig -2
    itob
    // smart_contracts/rewards/contract.algo.ts:126
    // note: new Str(note),
    frame_dig 2
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    uncover 4
    // smart_contracts/rewards/contract.algo.ts:119
    // finalized: new Bool(false),
    bytec_1 // 0x00
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    concat
    bytec 7 // 0x004d
    concat
    dig 4
    len
    pushint 77 // 77
    +
    swap
    // smart_contracts/rewards/contract.algo.ts:103
    // const arc4Zero = new UintN64(0)
    bytec_3 // 0x0000000000000000
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    concat
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/rewards/contract.algo.ts:103
    // const arc4Zero = new UintN64(0)
    bytec_3 // 0x0000000000000000
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    concat
    // smart_contracts/rewards/contract.algo.ts:103
    // const arc4Zero = new UintN64(0)
    bytec_3 // 0x0000000000000000
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:117
    // this.disbursements(id).value = new arc4DisbursementDetails({
    frame_dig 0
    dup
    cover 2
    itob
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   creator: new Address(Txn.sender),
    //   finalized: new Bool(false),
    //   title: new Str(title),
    //   amount: arc4Zero,
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   allocations: arc4Zero,
    //   distributed: arc4Zero,
    //   note: new Str(note),
    // })
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:129
    // return id
    frame_bury 0
    retsub

createDisbursement_bool_false@3:
    intc_1 // 0
    b createDisbursement_bool_merge@4


// smart_contracts/rewards/contract.algo.ts::Rewards.editDisbursement(id: uint64, title: bytes, timeToUnlock: uint64, expiration: uint64, note: bytes) -> void:
editDisbursement:
    // smart_contracts/rewards/contract.algo.ts:132-138
    // editDisbursement(
    //   id: uint64,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): void {
    proto 5 0
    // smart_contracts/rewards/contract.algo.ts:139
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -5
    itob
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:139
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:141
    // const disbursement = this.disbursements(id).value.copy()
    dup
    box_get
    assert // Box must have value
    // smart_contracts/rewards/contract.algo.ts:142
    // assert(Txn.sender === disbursement.creator.native, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    dig 1
    extract 0 32 // on error: Index access is out of bounds
    swap
    dig 1
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:143
    // assert(disbursement.finalized.native === false, ERR_DISBURSEMENT_ALREADY_FINAL)
    dig 1
    intc_2 // 256
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    dup
    intc_1 // 0
    getbit
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:147
    // title: new Str(title),
    frame_dig -4
    len
    itob
    extract 6 2
    frame_dig -4
    concat
    // smart_contracts/rewards/contract.algo.ts:148
    // timeToUnlock: new UintN64(timeToUnlock),
    frame_dig -3
    itob
    // smart_contracts/rewards/contract.algo.ts:149
    // expiration: new UintN64(expiration),
    frame_dig -2
    itob
    // smart_contracts/rewards/contract.algo.ts:150
    // note: new Str(note),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/rewards/contract.algo.ts:145-151
    // this.disbursements(id).value = new arc4DisbursementDetails({
    //   ...disbursement,
    //   title: new Str(title),
    //   timeToUnlock: new UintN64(timeToUnlock),
    //   expiration: new UintN64(expiration),
    //   note: new Str(note),
    // })
    dig 6
    extract 35 8 // on error: Index access is out of bounds
    dig 7
    extract 59 8 // on error: Index access is out of bounds
    uncover 8
    extract 67 8 // on error: Index access is out of bounds
    uncover 8
    uncover 8
    concat
    bytec 7 // 0x004d
    concat
    dig 7
    len
    pushint 77 // 77
    +
    swap
    uncover 4
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts/rewards/contract.algo.ts::Rewards.createUserAllocations(payment: uint64, id: uint64, allocations: bytes) -> void:
createUserAllocations:
    // smart_contracts/rewards/contract.algo.ts:154-158
    // createUserAllocations(
    //   payment: gtxn.PaymentTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    proto 3 0
    pushbytes ""
    dup
    // smart_contracts/rewards/contract.algo.ts:159
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -2
    itob
    dup
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:159
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:161
    // const disbursement = decodeArc4<DisbursementDetails>(this.disbursements(id).value.bytes)
    box_get
    assert // Box must have value
    intc_2 // 256
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    // smart_contracts/rewards/contract.algo.ts:162
    // assert(!disbursement.finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:164
    // let sum: uint64 = 0
    intc_1 // 0
    // smart_contracts/rewards/contract.algo.ts:165
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createUserAllocations_while_top@1:
    // smart_contracts/rewards/contract.algo.ts:165
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    dup
    frame_bury 1
    frame_dig 5
    >
    bz createUserAllocations_after_while@3
    // smart_contracts/rewards/contract.algo.ts:168
    // address: allocations[i].address,
    frame_dig -1
    extract 2 0
    frame_dig 5
    dup
    cover 2
    intc_3 // 40
    *
    intc_3 // 40
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/rewards/contract.algo.ts:166-170
    // const userAllocationsKey = new arc4UserAllocationsKey({
    //   disbursementID: new UintN64(id),
    //   address: allocations[i].address,
    //   asset: arc4Zero,
    // })
    frame_dig 2
    concat
    // smart_contracts/utils/constants.ts:13
    // export const arc4Zero = new UintN64(0)
    bytec_3 // 0x0000000000000000
    // smart_contracts/rewards/contract.algo.ts:166-170
    // const userAllocationsKey = new arc4UserAllocationsKey({
    //   disbursementID: new UintN64(id),
    //   address: allocations[i].address,
    //   asset: arc4Zero,
    // })
    concat
    // smart_contracts/rewards/constants.ts:6
    // export const RewardsBoxPrefixUserAllocations = 'u'
    bytec 4 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:171
    // assert(!this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // Allocation already exists
    // smart_contracts/rewards/contract.algo.ts:173
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount.native
    swap
    pushint 32 // 32
    extract_uint64
    dup
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:175
    // const newAllocAmount = new UintN64(this.disbursements(id).value.allocations.native + 1)
    frame_dig 3
    dup
    box_get
    assert // Box must have value
    dup
    pushint 59 // 59
    extract_uint64
    intc_0 // 1
    +
    itob
    // smart_contracts/rewards/contract.algo.ts:176
    // this.disbursements(id).value.allocations = newAllocAmount
    replace2 59
    dig 1
    box_del
    pop
    dup2
    box_put
    // smart_contracts/rewards/contract.algo.ts:178
    // this.disbursements(id).value.amount.native + allocations[i].amount.native
    dup
    pushint 35 // 35
    extract_uint64
    dig 3
    +
    // smart_contracts/rewards/contract.algo.ts:177-179
    // const newAmount = new UintN64(
    //   this.disbursements(id).value.amount.native + allocations[i].amount.native
    // )
    itob
    // smart_contracts/rewards/contract.algo.ts:180
    // this.disbursements(id).value.amount = newAmount
    replace2 35
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/rewards/contract.algo.ts:181
    // sum += allocations[i].amount.native
    frame_dig 4
    +
    frame_bury 4
    // smart_contracts/rewards/contract.algo.ts:165
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_0 // 1
    +
    frame_bury 5
    b createUserAllocations_while_top@1

createUserAllocations_after_while@3:
    // smart_contracts/rewards/base.ts:9
    // userAllocations: 25_300
    intc 5 // 25300
    // smart_contracts/rewards/contract.algo.ts:186
    // const mbrAmount: uint64 = costs.userAllocations * allocations.length
    frame_dig 1
    *
    frame_bury 0
    // smart_contracts/rewards/contract.algo.ts:188-195
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:191
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:188-195
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz createUserAllocations_bool_false@6
    frame_dig -3
    gtxns Amount
    // smart_contracts/rewards/contract.algo.ts:192
    // amount: mbrAmount + sum,
    frame_dig 0
    frame_dig 4
    +
    // smart_contracts/rewards/contract.algo.ts:188-195
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz createUserAllocations_bool_false@6
    intc_0 // 1

createUserAllocations_bool_merge@7:
    // smart_contracts/rewards/contract.algo.ts:188-195
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    retsub

createUserAllocations_bool_false@6:
    intc_1 // 0
    b createUserAllocations_bool_merge@7


// smart_contracts/rewards/contract.algo.ts::Rewards.createAsaUserAllocations(mbrPayment: uint64, assetXfer: uint64, id: uint64, allocations: bytes) -> void:
createAsaUserAllocations:
    // smart_contracts/rewards/contract.algo.ts:198-203
    // createAsaUserAllocations(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   id: uint64,
    //   allocations: arc4UserAllocations
    // ): void {
    proto 4 0
    pushbytes ""
    dup
    // smart_contracts/rewards/contract.algo.ts:204
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -2
    itob
    dup
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:204
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:206
    // const disbursement = decodeArc4<DisbursementDetails>(this.disbursements(id).value.bytes)
    box_get
    assert // Box must have value
    intc_2 // 256
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    // smart_contracts/rewards/contract.algo.ts:207
    // assert(!disbursement.finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:209
    // let matchSum: uint64 = 0
    intc_1 // 0
    // smart_contracts/rewards/contract.algo.ts:210
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createAsaUserAllocations_while_top@1:
    // smart_contracts/rewards/contract.algo.ts:210
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    dup
    frame_bury 1
    frame_dig 5
    >
    bz createAsaUserAllocations_after_while@3
    // smart_contracts/rewards/contract.algo.ts:213
    // address: allocations[i].address,
    frame_dig -1
    extract 2 0
    frame_dig 5
    dup
    cover 2
    intc_3 // 40
    *
    intc_3 // 40
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/rewards/contract.algo.ts:214
    // asset: new UintN64(assetXfer.xferAsset.id),
    frame_dig -3
    gtxns XferAsset
    itob
    // smart_contracts/rewards/contract.algo.ts:211-215
    // const userAllocationsKey = new arc4UserAllocationsKey({
    //   disbursementID: new UintN64(id),
    //   address: allocations[i].address,
    //   asset: new UintN64(assetXfer.xferAsset.id),
    // })
    swap
    frame_dig 2
    concat
    swap
    concat
    // smart_contracts/rewards/constants.ts:6
    // export const RewardsBoxPrefixUserAllocations = 'u'
    bytec 4 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:216
    // assert(!this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // Allocation already exists
    // smart_contracts/rewards/contract.algo.ts:218
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount.native
    swap
    pushint 32 // 32
    extract_uint64
    dup
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:220
    // const newAllocAmount = new UintN64(this.disbursements(id).value.allocations.native + 1)
    frame_dig 3
    dup
    box_get
    assert // Box must have value
    dup
    pushint 59 // 59
    extract_uint64
    intc_0 // 1
    +
    itob
    // smart_contracts/rewards/contract.algo.ts:221
    // this.disbursements(id).value.allocations = newAllocAmount
    replace2 59
    dig 1
    box_del
    pop
    dup2
    box_put
    // smart_contracts/rewards/contract.algo.ts:223
    // this.disbursements(id).value.amount.native + allocations[i].amount.native
    dup
    pushint 35 // 35
    extract_uint64
    dig 3
    +
    // smart_contracts/rewards/contract.algo.ts:222-224
    // const newAmount = new UintN64(
    //   this.disbursements(id).value.amount.native + allocations[i].amount.native
    // )
    itob
    // smart_contracts/rewards/contract.algo.ts:225
    // this.disbursements(id).value.amount = newAmount
    replace2 35
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/rewards/contract.algo.ts:226
    // matchSum += allocations[i].amount.native
    frame_dig 4
    +
    frame_bury 4
    // smart_contracts/rewards/contract.algo.ts:210
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_0 // 1
    +
    frame_bury 5
    b createAsaUserAllocations_while_top@1

createAsaUserAllocations_after_while@3:
    // smart_contracts/rewards/base.ts:9
    // userAllocations: 25_300
    intc 5 // 25300
    // smart_contracts/rewards/contract.algo.ts:231
    // const mbrAmount: uint64 = costs.userAllocations * allocations.length
    frame_dig 1
    *
    frame_bury 0
    // smart_contracts/rewards/contract.algo.ts:233-240
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:236
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:233-240
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz createAsaUserAllocations_bool_false@6
    frame_dig -4
    gtxns Amount
    frame_dig 0
    ==
    bz createAsaUserAllocations_bool_false@6
    intc_0 // 1

createAsaUserAllocations_bool_merge@7:
    // smart_contracts/rewards/contract.algo.ts:233-240
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:242-249
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: matchSum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -3
    gtxns AssetReceiver
    // smart_contracts/rewards/contract.algo.ts:245
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:242-249
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: matchSum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    bz createAsaUserAllocations_bool_false@10
    frame_dig -3
    gtxns AssetAmount
    frame_dig 4
    ==
    bz createAsaUserAllocations_bool_false@10
    intc_0 // 1

createAsaUserAllocations_bool_merge@11:
    // smart_contracts/rewards/contract.algo.ts:242-249
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: matchSum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    assert // Invalid transfer
    retsub

createAsaUserAllocations_bool_false@10:
    intc_1 // 0
    b createAsaUserAllocations_bool_merge@11

createAsaUserAllocations_bool_false@6:
    intc_1 // 0
    b createAsaUserAllocations_bool_merge@7


// smart_contracts/rewards/contract.algo.ts::Rewards.finalizeDisbursement(id: uint64) -> void:
finalizeDisbursement:
    // smart_contracts/rewards/contract.algo.ts:252
    // finalizeDisbursement(id: uint64): void {
    proto 1 0
    // smart_contracts/rewards/contract.algo.ts:253
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -1
    itob
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:253
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:255
    // const disbursement = decodeArc4<DisbursementDetails>(this.disbursements(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    intc_2 // 256
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    dig 2
    pushint 35 // 35
    extract_uint64
    cover 3
    dig 2
    pushint 43 // 43
    extract_uint64
    dup
    cover 2
    cover 4
    dig 3
    pushint 51 // 51
    extract_uint64
    cover 4
    uncover 3
    pushint 59 // 59
    extract_uint64
    cover 3
    // smart_contracts/rewards/contract.algo.ts:256
    // assert(Txn.sender === disbursement.creator.native, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    uncover 3
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:257
    // assert(!disbursement.finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:259
    // disbursement.timeToUnlock >= Global.latestTimestamp || disbursement.timeToUnlock === 0,
    global LatestTimestamp
    >=
    bnz finalizeDisbursement_bool_true@2
    frame_dig 2
    bnz finalizeDisbursement_bool_false@3

finalizeDisbursement_bool_true@2:
    intc_0 // 1

finalizeDisbursement_bool_merge@4:
    // smart_contracts/rewards/contract.algo.ts:258-261
    // assert(
    //   disbursement.timeToUnlock >= Global.latestTimestamp || disbursement.timeToUnlock === 0,
    //   ERR_INVALID_DISBURSEMENT_UNLOCK_TIME
    // )
    assert // Invalid disbursement unlock time
    // smart_contracts/rewards/contract.algo.ts:263
    // disbursement.expiration >= Global.latestTimestamp + 60 || disbursement.expiration === 0,
    global LatestTimestamp
    pushint 60 // 60
    +
    frame_dig 3
    <=
    bnz finalizeDisbursement_bool_true@6
    frame_dig 3
    bnz finalizeDisbursement_bool_false@7

finalizeDisbursement_bool_true@6:
    intc_0 // 1

finalizeDisbursement_bool_merge@8:
    // smart_contracts/rewards/contract.algo.ts:262-265
    // assert(
    //   disbursement.expiration >= Global.latestTimestamp + 60 || disbursement.expiration === 0,
    //   ERR_INVALID_DISBURSEMENT_EXPIRATION_TIME
    // )
    assert // Invalid disbursement expiration time
    // smart_contracts/rewards/contract.algo.ts:266
    // assert(disbursement.amount > 0, ERR_DISBURSEMENTS_CANNOT_BE_EMPTY)
    frame_dig 1
    assert // Disbursements cannot be empty
    // smart_contracts/rewards/contract.algo.ts:267
    // assert(disbursement.allocations > 0, ERR_DISBURSEMENTS_MUST_HAVE_ALLOCATIONS)
    frame_dig 4
    assert // Disbursements must have allocations
    // smart_contracts/rewards/contract.algo.ts:269
    // this.disbursements(id).value.finalized = new Bool(true)
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    intc_2 // 256
    intc_0 // 1
    setbit
    dig 1
    box_del
    pop
    box_put
    retsub

finalizeDisbursement_bool_false@7:
    intc_1 // 0
    b finalizeDisbursement_bool_merge@8

finalizeDisbursement_bool_false@3:
    intc_1 // 0
    b finalizeDisbursement_bool_merge@4


// smart_contracts/rewards/contract.algo.ts::Rewards.claimRewards(rewards: bytes) -> void:
claimRewards:
    // smart_contracts/rewards/contract.algo.ts:272
    // claimRewards(rewards: arc4Claims): void {
    proto 1 0
    intc_1 // 0
    dup
    pushbytes ""
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    intc_1 // 0

claimRewards_while_top@1:
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    frame_dig 3
    >
    bz claimRewards_after_while@10
    // smart_contracts/rewards/contract.algo.ts:274
    // assert(this.disbursements(rewards[i].id.native).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 8 // on error: Index access is out of bounds
    dig 1
    intc_1 // 0
    extract_uint64
    itob
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:274
    // assert(this.disbursements(rewards[i].id.native).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:276
    // const disbursement = decodeArc4<DisbursementDetails>(this.disbursements(rewards[i].id.native).value.bytes)
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 0
    dup
    pushint 75 // 75
    extract_uint16
    dig 1
    pushint 35 // 35
    extract_uint64
    dig 2
    pushint 43 // 43
    extract_uint64
    dig 3
    pushint 51 // 51
    extract_uint64
    dig 4
    pushint 59 // 59
    extract_uint64
    dig 5
    pushint 67 // 67
    extract_uint64
    dig 6
    len
    dig 7
    uncover 7
    uncover 2
    substring3
    extract 2 0
    frame_bury 1
    // smart_contracts/rewards/contract.algo.ts:277
    // assert(disbursement.timeToUnlock <= Global.latestTimestamp - 60, ERR_DISBURSEMENT_LOCKED)
    global LatestTimestamp
    pushint 60 // 60
    -
    uncover 4
    >=
    assert // Disbursement is locked
    // smart_contracts/rewards/contract.algo.ts:278
    // assert(disbursement.expiration >= Global.latestTimestamp, ERR_DISBURSEMENT_LOCKED)
    global LatestTimestamp
    uncover 3
    <=
    assert // Disbursement is locked
    // smart_contracts/rewards/contract.algo.ts:279
    // assert(disbursement.amount > disbursement.distributed, ERR_DISBURSEMENT_FULLY_DISTRIBUTED)
    dig 2
    <
    assert // Disbursement is fully distributed
    // smart_contracts/rewards/contract.algo.ts:283
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:284
    // asset: rewards[i].asset,
    dig 6
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/rewards/contract.algo.ts:281-285
    // const userAllocationsKey = new arc4UserAllocationsKey({
    //   disbursementID: rewards[i].id,
    //   address: new Address(Txn.sender),
    //   asset: rewards[i].asset,
    // })
    swap
    uncover 6
    concat
    swap
    concat
    // smart_contracts/rewards/constants.ts:6
    // export const RewardsBoxPrefixUserAllocations = 'u'
    bytec 4 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:286
    // assert(this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Allocation does not exist
    // smart_contracts/rewards/contract.algo.ts:287
    // const userAllocation = this.userAllocations(userAllocationsKey).value
    dup
    box_get
    assert // Box must have value
    btoi
    dup
    cover 7
    // smart_contracts/rewards/contract.algo.ts:289
    // const newAllocAmount = new UintN64(disbursement.allocations - 1)
    uncover 2
    intc_0 // 1
    -
    itob
    // smart_contracts/rewards/contract.algo.ts:290
    // this.disbursements(rewards[i].id.native).value.allocations = newAllocAmount
    uncover 4
    swap
    replace2 59
    dig 4
    box_del
    pop
    dig 4
    dig 1
    box_put
    // smart_contracts/rewards/contract.algo.ts:291
    // const newAmount = new UintN64(disbursement.amount - userAllocation)
    uncover 3
    uncover 2
    -
    itob
    // smart_contracts/rewards/contract.algo.ts:292
    // this.disbursements(rewards[i].id.native).value.distributed = newAmount
    replace2 67
    dig 2
    box_del
    pop
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:293
    // this.userAllocations(userAllocationsKey).delete()
    box_del
    pop
    // smart_contracts/rewards/contract.algo.ts:301
    // const isAlgo = rewards[i].asset.native === 0
    pushint 8 // 8
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/rewards/contract.algo.ts:303
    // if (!isAlgo) {
    bz claimRewards_else_body@6
    // smart_contracts/rewards/contract.algo.ts:305
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:312
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_begin
    // smart_contracts/rewards/contract.algo.ts:297
    // amount: 24_900,
    intc 4 // 24900
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:295-299
    // const creatorMBRRefund = itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: 24_900,
    //   fee,
    // })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:312
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_next
    frame_dig 1
    itxn_field Note
    frame_dig 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/rewards/contract.algo.ts:304-310
    // const assetXfer = itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   assetAmount: userAllocation,
    //   xferAsset: rewards[i].asset.native,
    //   fee,
    //   note: disbursement.note,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:312
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_submit

claimRewards_after_if_else@9:
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b claimRewards_while_top@1

claimRewards_else_body@6:
    // smart_contracts/rewards/contract.algo.ts:315
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:321
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_begin
    // smart_contracts/rewards/contract.algo.ts:297
    // amount: 24_900,
    intc 4 // 24900
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:295-299
    // const creatorMBRRefund = itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: 24_900,
    //   fee,
    // })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:321
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_next
    frame_dig 1
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/rewards/contract.algo.ts:314-319
    // const payment = itxn.payment({
    //   receiver: Txn.sender,
    //   amount: userAllocation,
    //   fee,
    //   note: disbursement.note,
    // })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:321
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_submit
    b claimRewards_after_if_else@9

claimRewards_after_while@10:
    retsub


// smart_contracts/rewards/contract.algo.ts::Rewards.reclaimRewards(id: uint64, reclaims: bytes) -> void:
reclaimRewards:
    // smart_contracts/rewards/contract.algo.ts:326
    // reclaimRewards(id: uint64, reclaims: arc4Reclaims): void {
    proto 2 0
    pushbytes ""
    // smart_contracts/rewards/contract.algo.ts:327
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    frame_dig -2
    itob
    dup
    // smart_contracts/rewards/constants.ts:5
    // export const RewardsBoxPrefixDisbursements = 'd'
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:327
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:328
    // const disbursement = decodeArc4<DisbursementDetails>(this.disbursements(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    uncover 2
    dup
    intc_2 // 256
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    dig 1
    pushint 51 // 51
    extract_uint64
    uncover 2
    pushint 59 // 59
    extract_uint64
    cover 3
    // smart_contracts/rewards/contract.algo.ts:330
    // assert(disbursement.creator.native === Txn.sender, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    uncover 3
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:331
    // assert(disbursement.finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    swap
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:332
    // assert(disbursement.expiration <= Global.latestTimestamp, ERR_DISBURSEMENT_NOT_EXPIRED)
    global LatestTimestamp
    <=
    assert // Disbursement has not expired
    // smart_contracts/rewards/contract.algo.ts:334
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    intc_1 // 0

reclaimRewards_while_top@1:
    // smart_contracts/rewards/contract.algo.ts:334
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    frame_dig 5
    >
    bz reclaimRewards_after_while@9
    // smart_contracts/rewards/contract.algo.ts:337
    // address: reclaims[i].address,
    frame_dig -1
    extract 2 0
    frame_dig 5
    intc_3 // 40
    *
    intc_3 // 40
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/rewards/contract.algo.ts:338
    // asset: reclaims[i].asset,
    dig 1
    extract 32 8 // on error: Index access is out of bounds
    // smart_contracts/rewards/contract.algo.ts:335-339
    // const userAllocationsKey = new arc4UserAllocationsKey({
    //   disbursementID: new UintN64(id),
    //   address: reclaims[i].address,
    //   asset: reclaims[i].asset,
    // })
    swap
    frame_dig 1
    concat
    swap
    concat
    // smart_contracts/rewards/constants.ts:6
    // export const RewardsBoxPrefixUserAllocations = 'u'
    bytec 4 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:340
    // assert(this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Allocation does not exist
    // smart_contracts/rewards/contract.algo.ts:342
    // const userAllocation = this.userAllocations(userAllocationsKey).value
    dup
    box_get
    assert // Box must have value
    btoi
    dup
    cover 3
    // smart_contracts/rewards/contract.algo.ts:343
    // this.disbursements(id).value.amount = new UintN64(userAllocation)
    itob
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 35
    dig 1
    box_del
    pop
    dup2
    box_put
    // smart_contracts/rewards/contract.algo.ts:344
    // const newAllocAmount = new UintN64(disbursement.allocations - 1)
    frame_dig 4
    intc_0 // 1
    -
    itob
    // smart_contracts/rewards/contract.algo.ts:345
    // this.disbursements(id).value.allocations = newAllocAmount
    replace2 59
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/rewards/contract.algo.ts:346
    // this.userAllocations(userAllocationsKey).delete()
    box_del
    pop
    // smart_contracts/rewards/contract.algo.ts:348
    // const isAlgo = reclaims[i].asset.native === 0
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/rewards/contract.algo.ts:350
    // if (!isAlgo) {
    bz reclaimRewards_else_body@6
    // smart_contracts/rewards/contract.algo.ts:364
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_begin
    frame_dig 0
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig 3
    dup
    itxn_field AssetReceiver
    // smart_contracts/rewards/contract.algo.ts:351-356
    // const xfer = itxn.assetTransfer({
    //   assetReceiver: disbursement.creator.native,
    //   assetAmount: userAllocation,
    //   xferAsset: reclaims[i].asset.native,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:364
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_next
    // smart_contracts/rewards/constants.ts:8
    // export const allocationMBR: uint64 = 24_900
    intc 4 // 24900
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:358-362
    // const mbrRefund = itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: allocationMBR,
    //   fee,
    // })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:364
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_submit

reclaimRewards_after_if_else@8:
    // smart_contracts/rewards/contract.algo.ts:334
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig 5
    intc_0 // 1
    +
    frame_bury 5
    b reclaimRewards_while_top@1

reclaimRewards_else_body@6:
    // smart_contracts/rewards/contract.algo.ts:366-370
    // itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: userAllocation + allocationMBR,
    //   fee,
    // }).submit()
    itxn_begin
    // smart_contracts/rewards/constants.ts:8
    // export const allocationMBR: uint64 = 24_900
    intc 4 // 24900
    // smart_contracts/rewards/contract.algo.ts:368
    // amount: userAllocation + allocationMBR,
    +
    itxn_field Amount
    frame_dig 3
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:366-370
    // itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: userAllocation + allocationMBR,
    //   fee,
    // }).submit()
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:366-370
    // itxn.payment({
    //   receiver: disbursement.creator.native,
    //   amount: userAllocation + allocationMBR,
    //   fee,
    // }).submit()
    itxn_submit
    b reclaimRewards_after_if_else@8

reclaimRewards_after_while@9:
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:20-21
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:22
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_1 // 0
    bytec_2 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:22
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 5 // "version"
    // smart_contracts/utils/base-contracts/base.ts:23
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_1 // 0
    bytec_2 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:29
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/optin.ts::ContractWithOptIn.optin(payment: uint64, asset: uint64) -> void:
optin:
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/utils/base-contracts/optin.ts:27
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@3
    frame_dig -2
    gtxns Amount
    // smart_contracts/utils/base-contracts/optin.ts:28
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@3
    intc_0 // 1

optin_bool_merge@4:
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/utils/base-contracts/optin.ts:33-38
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/optin.ts:34
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/utils/base-contracts/optin.ts:35
    // assetAmount: 0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/optin.ts:33-38
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/base-contracts/optin.ts:37
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/optin.ts:33-38
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    itxn_submit
    retsub

optin_bool_false@3:
    intc_1 // 0
    b optin_bool_merge@4
