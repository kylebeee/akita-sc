#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 25300 35300
    bytecblock "d" "u" 0x151f7c75 "akita_dao" 0x80004d 0x004f00000000 "disbursement_id"
    // smart_contracts/rewards/contract.algo.ts:55
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@19
    pushbytess 0x1c9ebbdb 0x8f49262d 0x5656acf9 0x3c60dfa0 0x5424a591 0x7b7dc5fc 0xaf1a14f2 0x3ec40aa4 0xbd3cd090 0x33e92c94 0x854dede0 0xd54bbad9 0x3ea11832 // method "createDisbursement(pay,string,uint64,uint64,string)uint64", method "editDisbursement(uint64,string,uint64,uint64,string)void", method "createUserAllocations(pay,uint64,(address,uint64)[])void", method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void", method "finalizeDisbursement(uint64)void", method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64", method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64", method "claimRewards((uint64,uint64)[])void", method "reclaimRewards(uint64,(address,uint64)[])void", method "updateAkitaDAO(uint64)void", method "opUp()void", method "mbr(string,string)(uint64,uint64)", method "optin(pay,uint64)void"
    txna ApplicationArgs 0
    match createDisbursement editDisbursement createUserAllocations createAsaUserAllocations finalizeDisbursement createInstantDisbursement createInstantAsaDisbursement claimRewards reclaimRewards updateAkitaDAO main_opUp_route@15 mbr optin
    err

main_opUp_route@15:
    // smart_contracts/utils/base-contracts/base.ts:41
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@19:
    // smart_contracts/rewards/contract.algo.ts:55
    // export class Rewards extends classes(BaseRewards, AkitaBaseContract, ContractWithOptIn) {
    pushbytes 0xcd9ad67e // method "create(string,uint64)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts/rewards/contract.algo.ts::Rewards.create[routing]() -> void:
create:
    // smart_contracts/rewards/contract.algo.ts:88
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/rewards/contract.algo.ts:90
    // this.version.value = version
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_3 // "akita_dao"
    // smart_contracts/rewards/contract.algo.ts:91
    // this.akitaDAO.value = Application(akitaDAO)
    swap
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:88
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.createDisbursement[routing]() -> void:
createDisbursement:
    // smart_contracts/rewards/contract.algo.ts:96-102
    // createDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/rewards/contract.algo.ts:103
    // const id = this.newDisbursementID()
    callsub newDisbursementID
    // smart_contracts/rewards/contract.algo.ts:105
    // const costs = this.mbr(title, note)
    dig 4
    dig 2
    callsub smart_contracts/rewards/base.ts::BaseRewards.mbr
    // smart_contracts/rewards/contract.algo.ts:106
    // const mbrAmount = costs.disbursements
    intc_0 // 0
    extract_uint64
    // smart_contracts/rewards/contract.algo.ts:108-115
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 6
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:111
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:108-115
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 7
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:118
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: false,
    //   title,
    //   amount: 0,
    //   timeToUnlock,
    //   expiration,
    //   allocations: 0,
    //   distributed: 0,
    //   note,
    // }
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    swap
    pushbytes 0x00004d
    concat
    dig 1
    len
    pushint 77 // 77
    +
    // smart_contracts/rewards/contract.algo.ts:121
    // amount: 0,
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: false,
    //   title,
    //   amount: 0,
    //   timeToUnlock,
    //   expiration,
    //   allocations: 0,
    //   distributed: 0,
    //   note,
    // }
    itob
    uncover 2
    dig 1
    concat
    uncover 7
    itob
    concat
    uncover 6
    itob
    concat
    dig 1
    concat
    swap
    concat
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    uncover 2
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:117
    // this.disbursements(id).value = {
    swap
    itob
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    dig 1
    concat
    // smart_contracts/rewards/contract.algo.ts:117-127
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: false,
    //   title,
    //   amount: 0,
    //   timeToUnlock,
    //   expiration,
    //   allocations: 0,
    //   distributed: 0,
    //   note,
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/rewards/contract.algo.ts:96-102
    // createDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): uint64 {
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.editDisbursement[routing]() -> void:
editDisbursement:
    // smart_contracts/rewards/contract.algo.ts:132-138
    // editDisbursement(
    //   id: uint64,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/rewards/contract.algo.ts:139
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    uncover 5
    itob
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:139
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:141
    // const { creator, finalized } = this.disbursements(id).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 1
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    // smart_contracts/rewards/contract.algo.ts:142
    // assert(Txn.sender === creator, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    uncover 2
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:143
    // assert(finalized === false, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:145
    // this.disbursements(id).value.title = title
    dup
    box_get
    pop
    dup
    pushint 33 // 33
    extract_uint16
    dig 1
    intc_0 // 0
    dig 2
    extract3
    uncover 8
    concat
    dig 2
    pushint 75 // 75
    extract_uint16
    dig 3
    len
    uncover 4
    dig 2
    uncover 2
    substring3
    uncover 2
    swap
    concat
    dig 1
    uncover 3
    -
    uncover 2
    uncover 7
    +
    swap
    -
    itob
    extract 6 2
    replace2 75
    dig 1
    box_del
    pop
    dig 1
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:146
    // this.disbursements(id).value.timeToUnlock = timeToUnlock
    dup
    pushint 43 // 43
    uncover 5
    box_replace
    // smart_contracts/rewards/contract.algo.ts:147
    // this.disbursements(id).value.expiration = expiration
    dup
    pushint 51 // 51
    uncover 4
    box_replace
    // smart_contracts/rewards/contract.algo.ts:148
    // this.disbursements(id).value.note = note
    dup
    box_get
    pop
    dup
    pushint 75 // 75
    extract_uint16
    intc_0 // 0
    swap
    extract3
    uncover 2
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/rewards/contract.algo.ts:132-138
    // editDisbursement(
    //   id: uint64,
    //   title: string,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   note: string
    // ): void {
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.createUserAllocations[routing]() -> void:
createUserAllocations:
    // smart_contracts/rewards/contract.algo.ts:151-155
    // createUserAllocations(
    //   payment: gtxn.PaymentTxn,
    //   id: uint64,
    //   allocations: UserAllocation[]
    // ): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint64)[])
    // smart_contracts/rewards/contract.algo.ts:156
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:156
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:158
    // const { finalized, title, note } = this.disbursements(id).value
    dup
    box_get
    pop
    swap
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 33 // 33
    extract_uint16
    dig 2
    pushint 75 // 75
    extract_uint16
    dig 3
    uncover 2
    dig 2
    substring3
    extract 2 0
    cover 3
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    // smart_contracts/rewards/contract.algo.ts:159
    // assert(!finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:161
    // let sum: uint64 = 0
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:162
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createUserAllocations_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:162
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup
    dig 7
    <
    bz createUserAllocations_after_while@4
    // smart_contracts/rewards/contract.algo.ts:165
    // address: allocations[i].address,
    dig 7
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    // smart_contracts/rewards/contract.algo.ts:166
    // asset: 0,
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:163-167
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: id,
    //   address: allocations[i].address,
    //   asset: 0,
    // }
    itob
    concat
    dig 8
    concat
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:169
    // assert(!this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // Allocation already exists
    // smart_contracts/rewards/contract.algo.ts:171
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    swap
    intc_3 // 32
    extract_uint64
    dup
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:172
    // this.disbursements(id).value.allocations += 1
    dig 6
    dup
    pushint 59 // 59
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    dig 1
    pushint 59 // 59
    uncover 2
    box_replace
    // smart_contracts/rewards/contract.algo.ts:173
    // this.disbursements(id).value.amount += allocations[i].amount
    dup
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    dig 2
    +
    itob
    pushint 35 // 35
    swap
    box_replace
    // smart_contracts/rewards/contract.algo.ts:175
    // sum += allocations[i].amount
    dig 3
    +
    bury 3
    // smart_contracts/rewards/contract.algo.ts:162
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_1 // 1
    +
    bury 1
    b createUserAllocations_while_top@2

createUserAllocations_after_while@4:
    // smart_contracts/rewards/contract.algo.ts:178
    // const costs = this.mbr(title, note)
    dig 3
    dig 3
    callsub smart_contracts/rewards/base.ts::BaseRewards.mbr
    // smart_contracts/rewards/contract.algo.ts:179
    // const mbrAmount: uint64 = costs.userAllocations * allocations.length
    intc_2 // 8
    extract_uint64
    dig 7
    *
    // smart_contracts/rewards/contract.algo.ts:181-188
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 9
    dup
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:184
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:181-188
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/rewards/contract.algo.ts:185
    // amount: mbrAmount + sum,
    uncover 2
    dig 4
    +
    // smart_contracts/rewards/contract.algo.ts:181-188
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    // smart_contracts/rewards/contract.algo.ts:151-155
    // createUserAllocations(
    //   payment: gtxn.PaymentTxn,
    //   id: uint64,
    //   allocations: UserAllocation[]
    // ): void {
    return // on error: Invalid payment


// smart_contracts/rewards/contract.algo.ts::Rewards.createAsaUserAllocations[routing]() -> void:
createAsaUserAllocations:
    // smart_contracts/rewards/contract.algo.ts:191-196
    // createAsaUserAllocations(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   id: uint64,
    //   allocations: UserAllocation[]
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint64)[])
    // smart_contracts/rewards/contract.algo.ts:197
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:197
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:199
    // const { finalized, title, note } = this.disbursements(id).value
    dup
    box_get
    pop
    swap
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 33 // 33
    extract_uint16
    dig 2
    pushint 75 // 75
    extract_uint16
    dig 3
    uncover 2
    dig 2
    substring3
    extract 2 0
    cover 3
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    // smart_contracts/rewards/contract.algo.ts:200
    // assert(!finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:202
    // let matchSum: uint64 = 0
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:203
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createAsaUserAllocations_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:203
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup
    dig 7
    <
    bz createAsaUserAllocations_after_while@4
    // smart_contracts/rewards/contract.algo.ts:206
    // address: allocations[i].address,
    dig 7
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    // smart_contracts/rewards/contract.algo.ts:207
    // asset: assetXfer.xferAsset.id,
    dig 11
    gtxns XferAsset
    // smart_contracts/rewards/contract.algo.ts:204-208
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: id,
    //   address: allocations[i].address,
    //   asset: assetXfer.xferAsset.id,
    // }
    itob
    concat
    dig 8
    concat
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:209
    // assert(!this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // Allocation already exists
    // smart_contracts/rewards/contract.algo.ts:211
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    swap
    intc_3 // 32
    extract_uint64
    dup
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:213
    // this.disbursements(id).value.allocations += 1
    dig 6
    dup
    pushint 59 // 59
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    dig 1
    pushint 59 // 59
    uncover 2
    box_replace
    // smart_contracts/rewards/contract.algo.ts:214
    // this.disbursements(id).value.amount += allocations[i].amount
    dup
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    dig 2
    +
    itob
    pushint 35 // 35
    swap
    box_replace
    // smart_contracts/rewards/contract.algo.ts:216
    // matchSum += allocations[i].amount
    dig 3
    +
    bury 3
    // smart_contracts/rewards/contract.algo.ts:203
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_1 // 1
    +
    bury 1
    b createAsaUserAllocations_while_top@2

createAsaUserAllocations_after_while@4:
    // smart_contracts/rewards/contract.algo.ts:220
    // const costs = this.mbr(title, note)
    dig 3
    dig 3
    callsub smart_contracts/rewards/base.ts::BaseRewards.mbr
    // smart_contracts/rewards/contract.algo.ts:221
    // const mbrAmount: uint64 = costs.userAllocations * allocations.length
    intc_2 // 8
    extract_uint64
    dig 7
    *
    // smart_contracts/rewards/contract.algo.ts:223-230
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 10
    dup
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:226
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:223-230
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:232-239
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: matchSum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    dig 8
    dup
    gtxns AssetReceiver
    // smart_contracts/rewards/contract.algo.ts:235
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:232-239
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: matchSum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    swap
    gtxns AssetAmount
    dig 3
    ==
    &&
    // smart_contracts/rewards/contract.algo.ts:191-196
    // createAsaUserAllocations(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   id: uint64,
    //   allocations: UserAllocation[]
    // ): void {
    return // on error: Invalid transfer


// smart_contracts/rewards/contract.algo.ts::Rewards.finalizeDisbursement[routing]() -> void:
finalizeDisbursement:
    // smart_contracts/rewards/contract.algo.ts:242
    // finalizeDisbursement(id: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/rewards/contract.algo.ts:243
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    itob
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:243
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:245
    // const { creator, finalized, timeToUnlock, expiration, amount, allocations } = this.disbursements(id).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 1
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 2
    pushint 43 // 43
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    cover 4
    dig 3
    pushint 51 // 51
    intc_2 // 8
    box_extract
    btoi
    cover 4
    dig 3
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    cover 4
    uncover 3
    pushint 59 // 59
    intc_2 // 8
    box_extract
    btoi
    cover 3
    // smart_contracts/rewards/contract.algo.ts:246
    // assert(Txn.sender === creator, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    uncover 3
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:247
    // assert(!finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    !
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:249
    // timeToUnlock >= Global.latestTimestamp || timeToUnlock === 0,
    global LatestTimestamp
    >=
    bnz finalizeDisbursement_bool_true@3
    dig 3
    bnz finalizeDisbursement_bool_false@4

finalizeDisbursement_bool_true@3:
    intc_1 // 1

finalizeDisbursement_bool_merge@5:
    // smart_contracts/rewards/contract.algo.ts:248-251
    // assert(
    //   timeToUnlock >= Global.latestTimestamp || timeToUnlock === 0,
    //   ERR_INVALID_DISBURSEMENT_UNLOCK_TIME
    // )
    assert // Invalid disbursement unlock time
    // smart_contracts/rewards/contract.algo.ts:253
    // expiration >= Global.latestTimestamp + 60 || expiration === 0,
    global LatestTimestamp
    pushint 60 // 60
    +
    dig 3
    <=
    bnz finalizeDisbursement_bool_true@7
    dig 2
    bnz finalizeDisbursement_bool_false@8

finalizeDisbursement_bool_true@7:
    intc_1 // 1

finalizeDisbursement_bool_merge@9:
    // smart_contracts/rewards/contract.algo.ts:252-255
    // assert(
    //   expiration >= Global.latestTimestamp + 60 || expiration === 0,
    //   ERR_INVALID_DISBURSEMENT_EXPIRATION_TIME
    // )
    assert // Invalid disbursement expiration time
    // smart_contracts/rewards/contract.algo.ts:256
    // assert(amount > 0, ERR_DISBURSEMENTS_CANNOT_BE_EMPTY)
    dig 1
    assert // Disbursements cannot be empty
    // smart_contracts/rewards/contract.algo.ts:257
    // assert(allocations > 0, ERR_DISBURSEMENTS_MUST_HAVE_ALLOCATIONS)
    dup
    assert // Disbursements must have allocations
    // smart_contracts/rewards/contract.algo.ts:259
    // this.disbursements(id).value.finalized = true
    dig 4
    dup
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    intc_3 // 32
    swap
    box_replace
    // smart_contracts/rewards/contract.algo.ts:242
    // finalizeDisbursement(id: uint64): void {
    intc_1 // 1
    return

finalizeDisbursement_bool_false@8:
    intc_0 // 0
    b finalizeDisbursement_bool_merge@9

finalizeDisbursement_bool_false@4:
    intc_0 // 0
    b finalizeDisbursement_bool_merge@5


// smart_contracts/rewards/contract.algo.ts::Rewards.createInstantDisbursement[routing]() -> void:
createInstantDisbursement:
    // smart_contracts/rewards/contract.algo.ts:262-267
    // createInstantDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   allocations: UserAllocation[]
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    dup
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint64)[])
    // smart_contracts/rewards/contract.algo.ts:268
    // const id = this.newDisbursementID()
    callsub newDisbursementID
    swap
    // smart_contracts/rewards/contract.algo.ts:270
    // const mbrAmount: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc 4 // 25300
    *
    intc 5 // 35300
    +
    // smart_contracts/rewards/contract.algo.ts:272
    // let sum: uint64 = 0
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createInstantDisbursement_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup
    dig 5
    <
    bz createInstantDisbursement_after_while@4
    // smart_contracts/rewards/contract.algo.ts:276
    // address: allocations[i].address,
    dig 5
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    // smart_contracts/rewards/contract.algo.ts:277
    // asset: 0,
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:274-278
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: id,
    //   address: allocations[i].address,
    //   asset: 0,
    // }
    itob
    concat
    dig 6
    itob
    concat
    // smart_contracts/rewards/contract.algo.ts:280
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    uncover 2
    concat
    // smart_contracts/rewards/contract.algo.ts:280
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    dig 1
    itob
    box_put
    // smart_contracts/rewards/contract.algo.ts:281
    // sum += allocations[i].amount
    dig 3
    +
    bury 3
    // smart_contracts/rewards/contract.algo.ts:273
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_1 // 1
    +
    bury 1
    b createInstantDisbursement_while_top@2

createInstantDisbursement_after_while@4:
    // smart_contracts/rewards/contract.algo.ts:284-291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 8
    dup
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:287
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:284-291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/rewards/contract.algo.ts:288
    // amount: mbrAmount + sum,
    dig 4
    dig 4
    dup
    cover 4
    +
    // smart_contracts/rewards/contract.algo.ts:284-291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + sum,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:294
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:293-303
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: true,
    //   title: '',
    //   amount: sum,
    //   timeToUnlock,
    //   expiration,
    //   allocations: allocations.length,
    //   distributed: 0,
    //   note: '',
    // }
    intc_0 // 0
    itob
    swap
    bytec 4 // 0x80004d
    concat
    uncover 2
    itob
    concat
    dig 9
    itob
    concat
    dig 8
    itob
    concat
    dig 6
    itob
    concat
    swap
    concat
    bytec 5 // 0x004f00000000
    concat
    // smart_contracts/rewards/contract.algo.ts:293
    // this.disbursements(id).value = {
    dig 4
    itob
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    dig 1
    concat
    // smart_contracts/rewards/contract.algo.ts:293-303
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: true,
    //   title: '',
    //   amount: sum,
    //   timeToUnlock,
    //   expiration,
    //   allocations: allocations.length,
    //   distributed: 0,
    //   note: '',
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/rewards/contract.algo.ts:262-267
    // createInstantDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   allocations: UserAllocation[]
    // ): uint64 {
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.createInstantAsaDisbursement[routing]() -> void:
createInstantAsaDisbursement:
    // smart_contracts/rewards/contract.algo.ts:308-314
    // createInstantAsaDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   allocations: UserAllocation[]
    // ): uint64 {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    dup
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint64)[])
    // smart_contracts/rewards/contract.algo.ts:315
    // const id = this.newDisbursementID()
    callsub newDisbursementID
    swap
    // smart_contracts/rewards/contract.algo.ts:317
    // const mbrAmount: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc 4 // 25300
    *
    intc 5 // 35300
    +
    // smart_contracts/rewards/contract.algo.ts:319
    // let sum: uint64 = 0
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:320
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup

createInstantAsaDisbursement_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:320
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    dup
    dig 5
    <
    bz createInstantAsaDisbursement_after_while@4
    // smart_contracts/rewards/contract.algo.ts:323
    // address: allocations[i].address,
    dig 5
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    // smart_contracts/rewards/contract.algo.ts:324
    // asset: assetXfer.xferAsset.id,
    dig 11
    gtxns XferAsset
    // smart_contracts/rewards/contract.algo.ts:321-325
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: id,
    //   address: allocations[i].address,
    //   asset: assetXfer.xferAsset.id,
    // }
    itob
    concat
    dig 6
    itob
    concat
    // smart_contracts/rewards/contract.algo.ts:327
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    uncover 2
    concat
    // smart_contracts/rewards/contract.algo.ts:327
    // this.userAllocations(userAllocationsKey).value = allocations[i].amount
    dig 1
    itob
    box_put
    // smart_contracts/rewards/contract.algo.ts:328
    // sum += allocations[i].amount
    dig 3
    +
    bury 3
    // smart_contracts/rewards/contract.algo.ts:320
    // for (let i: uint64 = 0; i < allocations.length; i += 1) {
    intc_1 // 1
    +
    bury 1
    b createInstantAsaDisbursement_while_top@2

createInstantAsaDisbursement_after_while@4:
    // smart_contracts/rewards/contract.algo.ts:331-338
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 9
    dup
    gtxns Receiver
    // smart_contracts/rewards/contract.algo.ts:334
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:331-338
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    dig 4
    ==
    &&
    assert // Invalid payment
    // smart_contracts/rewards/contract.algo.ts:340-347
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: sum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    dig 8
    dup
    gtxns AssetReceiver
    // smart_contracts/rewards/contract.algo.ts:343
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/rewards/contract.algo.ts:340-347
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: sum,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    swap
    gtxns AssetAmount
    dig 3
    dup
    cover 3
    ==
    &&
    assert // Invalid transfer
    // smart_contracts/rewards/contract.algo.ts:350
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:349-359
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: true,
    //   title: '',
    //   amount: sum,
    //   timeToUnlock,
    //   expiration,
    //   allocations: allocations.length,
    //   distributed: 0,
    //   note: '',
    // }
    intc_0 // 0
    itob
    swap
    bytec 4 // 0x80004d
    concat
    uncover 2
    itob
    concat
    dig 9
    itob
    concat
    dig 8
    itob
    concat
    dig 6
    itob
    concat
    swap
    concat
    bytec 5 // 0x004f00000000
    concat
    // smart_contracts/rewards/contract.algo.ts:349
    // this.disbursements(id).value = {
    dig 4
    itob
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    dig 1
    concat
    // smart_contracts/rewards/contract.algo.ts:349-359
    // this.disbursements(id).value = {
    //   creator: Txn.sender,
    //   finalized: true,
    //   title: '',
    //   amount: sum,
    //   timeToUnlock,
    //   expiration,
    //   allocations: allocations.length,
    //   distributed: 0,
    //   note: '',
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/rewards/contract.algo.ts:308-314
    // createInstantAsaDisbursement(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   timeToUnlock: uint64,
    //   expiration: uint64,
    //   allocations: UserAllocation[]
    // ): uint64 {
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.claimRewards[routing]() -> void:
claimRewards:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/rewards/contract.algo.ts:364
    // claimRewards(rewards: ClaimDetails[]): void {
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 16 // 16
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64)[])
    // smart_contracts/rewards/contract.algo.ts:365
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    intc_0 // 0

claimRewards_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:365
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    dup
    dig 2
    <
    bz claimRewards_after_while@11
    // smart_contracts/rewards/contract.algo.ts:366
    // assert(this.disbursements(rewards[i].id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    dig 2
    extract 2 0
    dig 1
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    extract 0 8
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    dig 1
    concat
    // smart_contracts/rewards/contract.algo.ts:366
    // assert(this.disbursements(rewards[i].id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:368
    // const { timeToUnlock, expiration, amount, distributed, creator, note } = this.disbursements(rewards[i].id).value
    dup
    box_get
    pop
    swap
    dup
    pushint 43 // 43
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushint 51 // 51
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 67 // 67
    intc_2 // 8
    box_extract
    btoi
    dig 4
    intc_0 // 0
    intc_3 // 32
    box_extract
    bury 14
    dig 5
    pushint 75 // 75
    extract_uint16
    dig 6
    len
    uncover 7
    cover 2
    substring3
    extract 2 0
    bury 12
    // smart_contracts/rewards/contract.algo.ts:369
    // assert(timeToUnlock <= Global.latestTimestamp, ERR_DISBURSEMENT_LOCKED)
    global LatestTimestamp
    uncover 4
    >=
    assert // Disbursement is locked
    // smart_contracts/rewards/contract.algo.ts:370
    // assert(expiration >= Global.latestTimestamp, ERR_DISBURSEMENT_LOCKED)
    global LatestTimestamp
    uncover 3
    <=
    assert // Disbursement is locked
    // smart_contracts/rewards/contract.algo.ts:371
    // assert(amount > distributed, ERR_DISBURSEMENT_FULLY_DISTRIBUTED)
    >
    assert // Disbursement is fully distributed
    // smart_contracts/rewards/contract.algo.ts:375
    // address: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:376
    // asset: rewards[i].asset,
    uncover 3
    intc_2 // 8
    extract_uint64
    dup
    bury 8
    // smart_contracts/rewards/contract.algo.ts:373-377
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: rewards[i].id,
    //   address: Txn.sender,
    //   asset: rewards[i].asset,
    // }
    dup
    itob
    uncover 2
    swap
    concat
    uncover 3
    concat
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:378
    // assert(this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Allocation does not exist
    // smart_contracts/rewards/contract.algo.ts:379
    // const userAllocation = this.userAllocations(userAllocationsKey).value
    dup
    box_get
    pop
    btoi
    dup
    cover 4
    // smart_contracts/rewards/contract.algo.ts:381
    // this.disbursements(rewards[i].id).value.allocations -= 1
    dig 3
    pushint 59 // 59
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    -
    itob
    dig 4
    pushint 59 // 59
    uncover 2
    box_replace
    // smart_contracts/rewards/contract.algo.ts:382
    // this.disbursements(rewards[i].id).value.distributed += userAllocation
    dig 3
    pushint 67 // 67
    intc_2 // 8
    box_extract
    btoi
    +
    itob
    uncover 3
    pushint 67 // 67
    uncover 2
    box_replace
    // smart_contracts/rewards/contract.algo.ts:383
    // this.userAllocations(userAllocationsKey).delete()
    box_del
    pop
    // smart_contracts/rewards/contract.algo.ts:392
    // if (!isAlgo) {
    bz claimRewards_else_body@7
    // smart_contracts/rewards/contract.algo.ts:394
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:400
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_begin
    // smart_contracts/rewards/contract.algo.ts:387
    // amount: UserAllocationMBR,
    intc 4 // 25300
    itxn_field Amount
    dig 7
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:385-388
    // const creatorMBRRefund = itxn.payment({
    //   receiver: creator,
    //   amount: UserAllocationMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:400
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_next
    dig 6
    itxn_field Note
    dig 5
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/rewards/contract.algo.ts:393-398
    // const assetXfer = itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   assetAmount: userAllocation,
    //   xferAsset: rewards[i].asset,
    //   note,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:400
    // itxn.submitGroup(creatorMBRRefund, assetXfer)
    itxn_submit

claimRewards_after_if_else@10:
    // smart_contracts/rewards/contract.algo.ts:365
    // for (let i: uint64 = 0; i < rewards.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b claimRewards_while_top@2

claimRewards_else_body@7:
    // smart_contracts/rewards/contract.algo.ts:403
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:408
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_begin
    // smart_contracts/rewards/contract.algo.ts:387
    // amount: UserAllocationMBR,
    intc 4 // 25300
    itxn_field Amount
    dig 7
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:385-388
    // const creatorMBRRefund = itxn.payment({
    //   receiver: creator,
    //   amount: UserAllocationMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:408
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_next
    dig 6
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/rewards/contract.algo.ts:402-406
    // const payment = itxn.payment({
    //   receiver: Txn.sender,
    //   amount: userAllocation,
    //   note,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:408
    // itxn.submitGroup(creatorMBRRefund, payment)
    itxn_submit
    b claimRewards_after_if_else@10

claimRewards_after_while@11:
    // smart_contracts/rewards/contract.algo.ts:364
    // claimRewards(rewards: ClaimDetails[]): void {
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.reclaimRewards[routing]() -> void:
reclaimRewards:
    pushbytes ""
    // smart_contracts/rewards/contract.algo.ts:413
    // reclaimRewards(id: uint64, reclaims: AllocationReclaimDetails[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint64)[])
    // smart_contracts/rewards/contract.algo.ts:414
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/rewards/contract.algo.ts:70
    // disbursements = BoxMap<uint64, DisbursementDetails>({ keyPrefix: RewardsBoxPrefixDisbursements })
    bytec_0 // "d"
    swap
    concat
    dupn 2
    // smart_contracts/rewards/contract.algo.ts:414
    // assert(this.disbursements(id).exists, ERR_DISBURSEMENT_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Disbursement does not exist
    // smart_contracts/rewards/contract.algo.ts:415
    // const { creator, finalized, expiration } = this.disbursements(id).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dup
    uncover 2
    dup
    intc_3 // 32
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    pushint 51 // 51
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/rewards/contract.algo.ts:417
    // assert(creator === Txn.sender, ERR_YOU_ARE_NOT_THE_CREATOR)
    txn Sender
    uncover 3
    ==
    assert // You are not the creator of this disbursement
    // smart_contracts/rewards/contract.algo.ts:418
    // assert(finalized, ERR_DISBURSEMENT_ALREADY_FINAL)
    swap
    assert // Disbursement already final
    // smart_contracts/rewards/contract.algo.ts:419
    // assert(expiration <= Global.latestTimestamp, ERR_DISBURSEMENT_NOT_EXPIRED)
    global LatestTimestamp
    <=
    assert // Disbursement has not expired
    // smart_contracts/rewards/contract.algo.ts:421
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    intc_0 // 0

reclaimRewards_while_top@2:
    // smart_contracts/rewards/contract.algo.ts:421
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    dup
    dig 5
    <
    bz reclaimRewards_after_while@10
    // smart_contracts/rewards/contract.algo.ts:424
    // address: reclaims[i].address,
    dig 5
    extract 2 0
    dig 1
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    // smart_contracts/rewards/contract.algo.ts:425
    // asset: reclaims[i].asset,
    swap
    // smart_contracts/rewards/contract.algo.ts:424-425
    // address: reclaims[i].address,
    // asset: reclaims[i].asset,
    intc_3 // 32
    // smart_contracts/rewards/contract.algo.ts:425
    // asset: reclaims[i].asset,
    extract_uint64
    dup
    bury 9
    // smart_contracts/rewards/contract.algo.ts:422-426
    // const userAllocationsKey: UserAllocationsKey = {
    //   disbursementID: id,
    //   address: reclaims[i].address,
    //   asset: reclaims[i].asset,
    // }
    dup
    itob
    uncover 2
    swap
    concat
    dig 5
    concat
    // smart_contracts/rewards/contract.algo.ts:76
    // userAllocations = BoxMap<UserAllocationsKey, uint64>({ keyPrefix: RewardsBoxPrefixUserAllocations })
    bytec_1 // "u"
    swap
    concat
    // smart_contracts/rewards/contract.algo.ts:427
    // assert(this.userAllocations(userAllocationsKey).exists, ERR_ALLOCATION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Allocation does not exist
    // smart_contracts/rewards/contract.algo.ts:429
    // const userAllocation = this.userAllocations(userAllocationsKey).value
    dup
    box_get
    pop
    btoi
    dup
    cover 3
    // smart_contracts/rewards/contract.algo.ts:431
    // this.disbursements(id).value.allocations -= 1
    dig 6
    dup
    pushint 59 // 59
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    -
    itob
    dig 1
    pushint 59 // 59
    uncover 2
    box_replace
    // smart_contracts/rewards/contract.algo.ts:432
    // this.disbursements(id).value.amount -= userAllocation
    dup
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    uncover 2
    -
    itob
    pushint 35 // 35
    swap
    box_replace
    // smart_contracts/rewards/contract.algo.ts:433
    // this.userAllocations(userAllocationsKey).delete()
    box_del
    pop
    // smart_contracts/rewards/contract.algo.ts:437
    // if (!isAlgo) {
    bz reclaimRewards_else_body@7
    // smart_contracts/rewards/contract.algo.ts:449
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_begin
    dig 7
    itxn_field XferAsset
    itxn_field AssetAmount
    dig 1
    dup
    itxn_field AssetReceiver
    // smart_contracts/rewards/contract.algo.ts:438-442
    // const xfer = itxn.assetTransfer({
    //   assetReceiver: creator,
    //   assetAmount: userAllocation,
    //   xferAsset: reclaims[i].asset,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:449
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_next
    // smart_contracts/rewards/contract.algo.ts:446
    // amount: UserAllocationMBR,
    intc 4 // 25300
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:444-447
    // const mbrRefund = itxn.payment({
    //   receiver: creator,
    //   amount: UserAllocationMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:449
    // itxn.submitGroup(xfer, mbrRefund)
    itxn_submit

reclaimRewards_after_if_else@9:
    // smart_contracts/rewards/contract.algo.ts:421
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b reclaimRewards_while_top@2

reclaimRewards_else_body@7:
    // smart_contracts/rewards/contract.algo.ts:451-456
    // itxn
    //   .payment({
    //     receiver: creator,
    //     amount: userAllocation + UserAllocationMBR,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/rewards/contract.algo.ts:454
    // amount: userAllocation + UserAllocationMBR,
    intc 4 // 25300
    +
    itxn_field Amount
    dig 1
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:451-455
    // itxn
    //   .payment({
    //     receiver: creator,
    //     amount: userAllocation + UserAllocationMBR,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:451-456
    // itxn
    //   .payment({
    //     receiver: creator,
    //     amount: userAllocation + UserAllocationMBR,
    //   })
    //   .submit()
    itxn_submit
    b reclaimRewards_after_if_else@9

reclaimRewards_after_while@10:
    // smart_contracts/rewards/contract.algo.ts:413
    // reclaimRewards(id: uint64, reclaims: AllocationReclaimDetails[]): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_3 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_3 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:38
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/rewards/base.ts::BaseRewards.mbr[routing]() -> void:
mbr:
    // smart_contracts/rewards/base.ts:7
    // mbr(title: string, note: string): RewardsMBRData {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    callsub smart_contracts/rewards/base.ts::BaseRewards.mbr
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/optin.ts::ContractWithOptIn.optin[routing]() -> void:
optin:
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/utils/base-contracts/optin.ts:27
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/utils/base-contracts/optin.ts:28
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/utils/base-contracts/optin.ts:33-37
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset
    // }).submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/optin.ts:34
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/utils/base-contracts/optin.ts:35
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/optin.ts:33-37
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::Rewards.newDisbursementID() -> uint64:
newDisbursementID:
    // smart_contracts/rewards/contract.algo.ts:81
    // const id = this.disbursementID.value
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:60
    // disbursementID = GlobalState<uint64>({ key: RewardsGlobalStateKeyDisbursementID })
    bytec 6 // "disbursement_id"
    // smart_contracts/rewards/contract.algo.ts:81
    // const id = this.disbursementID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:82
    // this.disbursementID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/rewards/contract.algo.ts:60
    // disbursementID = GlobalState<uint64>({ key: RewardsGlobalStateKeyDisbursementID })
    bytec 6 // "disbursement_id"
    // smart_contracts/rewards/contract.algo.ts:82
    // this.disbursementID.value += 1
    swap
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:83
    // return id
    retsub


// smart_contracts/rewards/base.ts::BaseRewards.mbr(title: bytes, note: bytes) -> bytes:
smart_contracts/rewards/base.ts::BaseRewards.mbr:
    // smart_contracts/rewards/base.ts:7
    // mbr(title: string, note: string): RewardsMBRData {
    proto 2 1
    // smart_contracts/rewards/base.ts:9
    // disbursements: MinDisbursementsMBR + (BoxCostPerByte * (Bytes(title).length + Bytes(note).length)),
    frame_dig -2
    len
    frame_dig -1
    len
    +
    pushint 400 // 400
    *
    intc 5 // 35300
    +
    // smart_contracts/rewards/base.ts:8-11
    // return {
    //   disbursements: MinDisbursementsMBR + (BoxCostPerByte * (Bytes(title).length + Bytes(note).length)),
    //   userAllocations: UserAllocationMBR
    // }
    itob
    // smart_contracts/rewards/base.ts:10
    // userAllocations: UserAllocationMBR
    intc 4 // 25300
    // smart_contracts/rewards/base.ts:8-11
    // return {
    //   disbursements: MinDisbursementsMBR + (BoxCostPerByte * (Bytes(title).length + Bytes(note).length)),
    //   userAllocations: UserAllocationMBR
    // }
    itob
    concat
    retsub
