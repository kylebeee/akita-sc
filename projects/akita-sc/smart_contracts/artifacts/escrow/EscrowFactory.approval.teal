#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 2 32 400
    bytecblock 0x151f7c75 0x0000 ""
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0xb551d5ff 0xd85cf184 0x607e7046 0x8a39e79f 0x4c9fb656 0x3c1a6f33 0x2b5602a3 0x13dc508a 0x475d3773 // method "newCost()uint64", method "new(pay)uint64", method "register(pay,uint64)void", method "delete(uint64)void", method "exists(address)bool", method "get(address)byte[]", method "mustGet(address)byte[]", method "getList(address[])byte[][]", method "mustGetList(address[])byte[][]"
    txna ApplicationArgs 0
    match main_newCost_route@3 main_new_route@4 main_register_route@5 main_delete_route@6 main_exists_route@7 main_get_route@8 main_mustGet_route@9 main_getList_route@10 main_mustGetList_route@11

main_after_if_else@18:
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    intc_1 // 0
    return

main_mustGetList_route@11:
    // smart_contracts/escrow/factory.algo.ts:178
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    // smart_contracts/escrow/factory.algo.ts:178
    // @abimethod({ readonly: true })
    callsub mustGetList
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getList_route@10:
    // smart_contracts/escrow/factory.algo.ts:163
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    // smart_contracts/escrow/factory.algo.ts:163
    // @abimethod({ readonly: true })
    callsub getList
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_mustGet_route@9:
    // smart_contracts/escrow/factory.algo.ts:156
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    // smart_contracts/escrow/factory.algo.ts:156
    // @abimethod({ readonly: true })
    callsub mustGet
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_route@8:
    // smart_contracts/escrow/factory.algo.ts:147
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    // smart_contracts/escrow/factory.algo.ts:147
    // @abimethod({ readonly: true })
    callsub get
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_exists_route@7:
    // smart_contracts/escrow/factory.algo.ts:141
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    // smart_contracts/escrow/factory.algo.ts:141
    // @abimethod({ readonly: true })
    callsub exists
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_route@6:
    // smart_contracts/escrow/factory.algo.ts:112
    // delete(id: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escrow/factory.algo.ts:112
    // delete(id: uint64): void {
    callsub delete
    intc_0 // 1
    return

main_register_route@5:
    // smart_contracts/escrow/factory.algo.ts:81
    // register(payment: gtxn.PaymentTxn, app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escrow/factory.algo.ts:81
    // register(payment: gtxn.PaymentTxn, app: uint64): void {
    callsub register
    intc_0 // 1
    return

main_new_route@4:
    // smart_contracts/escrow/factory.algo.ts:38
    // new(payment: gtxn.PaymentTxn): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/escrow/factory.algo.ts:38
    // new(payment: gtxn.PaymentTxn): uint64 {
    callsub new
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_newCost_route@3:
    // smart_contracts/escrow/factory.algo.ts:32
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub newCost
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@14:
    // smart_contracts/escrow/factory.algo.ts:16
    // export class EscrowFactory extends Contract implements EscrowFactoryInterface {
    txn OnCompletion
    bnz main_after_if_else@18
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_1 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_1 // 0
    swap

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 3
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@5
    frame_dig 4
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 3
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 4
    intc_2 // 2
    +
    frame_bury 3
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@5:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// smart_contracts/escrow/factory.algo.ts::bytes16(acc: bytes) -> bytes:
bytes16:
    // smart_contracts/escrow/factory.algo.ts:12
    // function bytes16(acc: Account): bytes<16> {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:13
    // return acc.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_1 // 0
    dig 1
    >=
    intc_1 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.getCreator() -> bytes:
getCreator:
    // smart_contracts/escrow/factory.algo.ts:26
    // const nonAppCaller = Global.callerApplicationId === 0
    global CallerApplicationID
    // smart_contracts/escrow/factory.algo.ts:27-29
    // return nonAppCaller
    //   ? Bytes(bytes16(Txn.sender))
    //   : Bytes(itob(Global.callerApplicationId))
    bnz getCreator_ternary_false@2
    // smart_contracts/escrow/factory.algo.ts:28
    // ? Bytes(bytes16(Txn.sender))
    txn Sender
    callsub bytes16
    // smart_contracts/escrow/factory.algo.ts:27-29
    // return nonAppCaller
    //   ? Bytes(bytes16(Txn.sender))
    //   : Bytes(itob(Global.callerApplicationId))
    retsub

getCreator_ternary_false@2:
    // smart_contracts/escrow/factory.algo.ts:29
    // : Bytes(itob(Global.callerApplicationId))
    global CallerApplicationID
    itob
    // smart_contracts/escrow/factory.algo.ts:27-29
    // return nonAppCaller
    //   ? Bytes(bytes16(Txn.sender))
    //   : Bytes(itob(Global.callerApplicationId))
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.newCost() -> uint64:
newCost:
    // smart_contracts/escrow/factory.algo.ts:34
    // const creator = this.getCreator()
    callsub getCreator
    // smart_contracts/escrow/factory.algo.ts:35
    // return (MinPages + this.mbr(creator.length) + Global.minBalance)
    len
    // smart_contracts/escrow/factory.algo.ts:22
    // return MinWalletIDsByAccountsMbr + (length * BoxCostPerByte)
    intc 4 // 400
    *
    // smart_contracts/escrow/factory.algo.ts:35
    // return (MinPages + this.mbr(creator.length) + Global.minBalance)
    pushint 108900 // 108900
    +
    global MinBalance
    +
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.new(payment: uint64) -> uint64:
new:
    // smart_contracts/escrow/factory.algo.ts:38
    // new(payment: gtxn.PaymentTxn): uint64 {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:39
    // const nonAppCaller = Global.callerApplicationId === 0
    global CallerApplicationID
    // smart_contracts/escrow/factory.algo.ts:40
    // const creator = this.getCreator()
    callsub getCreator
    // smart_contracts/escrow/factory.algo.ts:49-56
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: childAppMBR + Global.minBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -1
    gtxns Receiver
    // smart_contracts/escrow/factory.algo.ts:52
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/escrow/factory.algo.ts:49-56
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: childAppMBR + Global.minBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -1
    gtxns Amount
    // smart_contracts/escrow/factory.algo.ts:53
    // amount: childAppMBR + Global.minBalance,
    pushint 150000 // 150000
    global MinBalance
    +
    // smart_contracts/escrow/factory.algo.ts:49-56
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: childAppMBR + Global.minBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/escrow/factory.algo.ts:58-62
    // const newEscrow = escrow.call.create(
    //   {
    //     args: [creator],
    //   }
    // ).itxn.createdApp
    itxn_begin
    // smart_contracts/escrow/factory.algo.ts:60
    // args: [creator],
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/escrow/factory.algo.ts:58-62
    // const newEscrow = escrow.call.create(
    //   {
    //     args: [creator],
    //   }
    // ).itxn.createdApp
    pushbytes 0x8e79358d // method "create(byte[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/escrow/factory.algo.ts:42
    // const escrow = compileArc4(Escrow);
    intc_0 // 1
    itxn_field GlobalNumByteSlice
    pushbytes base64(CoEBQw==)
    itxn_field ClearStateProgramPages
    pushbytes base64(CiACAQAxG0EAHIIDBI55NY0EZal7zAQkN408NhoAjgMAHwAQAAIjQzEZgQUSRDEYRIgAUSJDMRkURDEYRDYaAYgAJSJDMRkURDEYFEQ2GgFXAgCIAAIiQ4oBAIAHY3JlYXRvcov/Z4mKAQAxADIJEkSxMgqL/7IgsgcjsggishAjsgGziTEAMgkSRLEyCbIJIrIQI7IBs4k=)
    itxn_field ApprovalProgramPages
    // smart_contracts/escrow/factory.algo.ts:58-62
    // const newEscrow = escrow.call.create(
    //   {
    //     args: [creator],
    //   }
    // ).itxn.createdApp
    intc_1 // 0
    itxn_field OnCompletion
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/escrow/factory.algo.ts:62
    // ).itxn.createdApp
    gitxn 0 CreatedApplicationID
    dup
    cover 2
    // smart_contracts/escrow/factory.algo.ts:64-69
    // itxn
    //   .payment({
    //     receiver: newEscrow.address,
    //     amount: Global.minBalance
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escrow/factory.algo.ts:66
    // receiver: newEscrow.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/escrow/factory.algo.ts:67
    // amount: Global.minBalance
    global MinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/escrow/factory.algo.ts:64-68
    // itxn
    //   .payment({
    //     receiver: newEscrow.address,
    //     amount: Global.minBalance
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/escrow/factory.algo.ts:64-69
    // itxn
    //   .payment({
    //     receiver: newEscrow.address,
    //     amount: Global.minBalance
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/escrow/factory.algo.ts:71-76
    // escrow.call.rekey({
    //   appId: newEscrow.id,
    //   args: [
    //     nonAppCaller ? Txn.sender : Global.callerApplicationAddress
    //   ]
    // })
    itxn_begin
    // smart_contracts/escrow/factory.algo.ts:74
    // nonAppCaller ? Txn.sender : Global.callerApplicationAddress
    bnz new_ternary_false@4
    txn Sender

new_ternary_merge@5:
    // smart_contracts/escrow/factory.algo.ts:71-76
    // escrow.call.rekey({
    //   appId: newEscrow.id,
    //   args: [
    //     nonAppCaller ? Txn.sender : Global.callerApplicationAddress
    //   ]
    // })
    pushbytes 0x65a97bcc // method "rekey(address)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_1 // 0
    itxn_field OnCompletion
    frame_dig 0
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/escrow/factory.algo.ts:78
    // return newEscrow.id
    swap
    retsub

new_ternary_false@4:
    // smart_contracts/escrow/factory.algo.ts:74
    // nonAppCaller ? Txn.sender : Global.callerApplicationAddress
    global CallerApplicationAddress
    b new_ternary_merge@5


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.register(payment: uint64, app: uint64) -> void:
register:
    // smart_contracts/escrow/factory.algo.ts:81
    // register(payment: gtxn.PaymentTxn, app: uint64): void {
    proto 2 0
    // smart_contracts/escrow/factory.algo.ts:83
    // assert(Global.callerApplicationId !== 0)
    global CallerApplicationID
    assert
    // smart_contracts/escrow/factory.algo.ts:86
    // assert(app === 0 || Application(app).creator === Global.currentApplicationAddress, ERR_INVALID_APP)
    frame_dig -1
    bz register_bool_true@2
    frame_dig -1
    app_params_get AppCreator
    assert // application exists
    global CurrentApplicationAddress
    ==
    bz register_bool_false@3

register_bool_true@2:
    intc_0 // 1

register_bool_merge@4:
    // smart_contracts/escrow/factory.algo.ts:86
    // assert(app === 0 || Application(app).creator === Global.currentApplicationAddress, ERR_INVALID_APP)
    assert // invalid app to register
    // smart_contracts/escrow/factory.algo.ts:89
    // if (Application(app).creator === Global.currentApplicationAddress) {
    frame_dig -1
    app_params_get AppCreator
    assert // application exists
    global CurrentApplicationAddress
    ==
    bz register_else_body@6
    // smart_contracts/escrow/factory.algo.ts:90
    // [creator] = op.AppGlobal.getExBytes(Global.callerApplicationId, Bytes(EscrowGlobalStateKeysCreator))
    global CallerApplicationID
    pushbytes "creator"
    app_global_get_ex
    pop
    dup
    // smart_contracts/escrow/factory.algo.ts:91
    // assert(btoi(creator) === Global.callerApplicationId, ERR_INVALID_CREATOR)
    btoi
    global CallerApplicationID
    ==
    assert // invalid creator

register_after_if_else@7:
    // smart_contracts/escrow/factory.algo.ts:97
    // const appAddress = bytes16(Application(app).address)
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    callsub bytes16
    // smart_contracts/escrow/factory.algo.ts:98
    // assert(!this.walletIDsByAccounts(appAddress).exists, ERR_ALREADY_REGISTERED)
    dup
    box_len
    bury 1
    !
    assert // already registered
    // smart_contracts/escrow/factory.algo.ts:100-107
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(creator.length),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/escrow/factory.algo.ts:103
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/escrow/factory.algo.ts:100-107
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(creator.length),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/escrow/factory.algo.ts:104
    // amount: this.mbr(creator.length),
    uncover 3
    dup
    cover 3
    len
    // smart_contracts/escrow/factory.algo.ts:22
    // return MinWalletIDsByAccountsMbr + (length * BoxCostPerByte)
    intc 4 // 400
    *
    pushint 8900 // 8900
    +
    // smart_contracts/escrow/factory.algo.ts:100-107
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(creator.length),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/escrow/factory.algo.ts:109
    // this.walletIDsByAccounts(appAddress).value = creator
    dig 1
    box_del
    pop
    box_put
    retsub

register_else_body@6:
    // smart_contracts/escrow/factory.algo.ts:93
    // creator = Bytes(itob(Global.callerApplicationId))
    global CallerApplicationID
    itob
    // smart_contracts/escrow/factory.algo.ts:94
    // app = Global.callerApplicationId
    global CallerApplicationID
    frame_bury -1
    b register_after_if_else@7

register_bool_false@3:
    intc_1 // 0
    b register_bool_merge@4


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.delete(id: uint64) -> void:
delete:
    // smart_contracts/escrow/factory.algo.ts:112
    // delete(id: uint64): void {
    proto 1 0
    bytec_2 // ""
    // smart_contracts/escrow/factory.algo.ts:113
    // const caller = Global.callerApplicationId
    global CallerApplicationID
    // smart_contracts/escrow/factory.algo.ts:114
    // const key = bytes16(Application(id).address)
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    callsub bytes16
    dupn 2
    // smart_contracts/escrow/factory.algo.ts:115
    // assert(this.walletIDsByAccounts(key).exists, ERR_DOESNT_EXIST)
    box_len
    bury 1
    assert // does not exist
    // smart_contracts/escrow/factory.algo.ts:117
    // const creator = this.walletIDsByAccounts(key).value
    box_get
    pop
    dup
    // smart_contracts/escrow/factory.algo.ts:118
    // if (creator.length === 8) {
    len
    dup
    cover 2
    pushint 8 // 8
    ==
    dup
    cover 2
    bz delete_else_body@2
    // smart_contracts/escrow/factory.algo.ts:119
    // assert(caller === btoi(creator), ERR_FORBIDDEN);
    btoi
    frame_dig 1
    ==
    assert // only the creator wallet can delete a spending account

delete_after_if_else@3:
    // smart_contracts/escrow/factory.algo.ts:126
    // const childAppMBR: uint64 = Global.minBalance + this.mbr(creator.length)
    global MinBalance
    // smart_contracts/escrow/factory.algo.ts:22
    // return MinWalletIDsByAccountsMbr + (length * BoxCostPerByte)
    frame_dig 3
    intc 4 // 400
    *
    pushint 8900 // 8900
    +
    // smart_contracts/escrow/factory.algo.ts:126
    // const childAppMBR: uint64 = Global.minBalance + this.mbr(creator.length)
    +
    frame_bury 0
    // smart_contracts/escrow/factory.algo.ts:128
    // spendingAccount.call.delete({ appId: id })
    itxn_begin
    pushbytes 0x24378d3c // method "delete()void"
    itxn_field ApplicationArgs
    pushint 5 // 5
    itxn_field OnCompletion
    frame_dig -1
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/escrow/factory.algo.ts:130
    // this.walletIDsByAccounts(key).delete()
    frame_dig 2
    box_del
    pop
    // smart_contracts/escrow/factory.algo.ts:132-137
    // itxn
    //   .payment({
    //     receiver: creator.length === 8 ? Global.callerApplicationAddress : Txn.sender,
    //     amount: childAppMBR
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escrow/factory.algo.ts:134
    // receiver: creator.length === 8 ? Global.callerApplicationAddress : Txn.sender,
    frame_dig 4
    bz delete_ternary_false@6
    global CallerApplicationAddress

delete_ternary_merge@7:
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/escrow/factory.algo.ts:132-136
    // itxn
    //   .payment({
    //     receiver: creator.length === 8 ? Global.callerApplicationAddress : Txn.sender,
    //     amount: childAppMBR
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/escrow/factory.algo.ts:132-137
    // itxn
    //   .payment({
    //     receiver: creator.length === 8 ? Global.callerApplicationAddress : Txn.sender,
    //     amount: childAppMBR
    //   })
    //   .submit()
    itxn_submit
    retsub

delete_ternary_false@6:
    // smart_contracts/escrow/factory.algo.ts:134
    // receiver: creator.length === 8 ? Global.callerApplicationAddress : Txn.sender,
    txn Sender
    b delete_ternary_merge@7

delete_else_body@2:
    // smart_contracts/escrow/factory.algo.ts:121
    // assert(Bytes(bytes16(Txn.sender)) === creator, ERR_FORBIDDEN);
    txn Sender
    callsub bytes16
    ==
    assert // only the creator wallet can delete a spending account
    b delete_after_if_else@3


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.exists(address: bytes) -> uint64:
exists:
    // smart_contracts/escrow/factory.algo.ts:141-142
    // @abimethod({ readonly: true })
    // exists(address: Address): boolean {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:143
    // return this.walletIDsByAccounts(bytes16(address.native)).exists
    frame_dig -1
    callsub bytes16
    box_len
    bury 1
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.get(address: bytes) -> bytes:
get:
    // smart_contracts/escrow/factory.algo.ts:147-148
    // @abimethod({ readonly: true })
    // get(address: Address): bytes {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:149
    // if (!this.walletIDsByAccounts(bytes16(address.native)).exists) {
    frame_dig -1
    callsub bytes16
    box_len
    bury 1
    bnz get_after_if_else@2
    // smart_contracts/escrow/factory.algo.ts:150
    // return Bytes('')
    bytec_2 // ""
    retsub

get_after_if_else@2:
    // smart_contracts/escrow/factory.algo.ts:152
    // return this.walletIDsByAccounts(bytes16(address.native)).value
    frame_dig -1
    callsub bytes16
    box_get
    assert // Box must have value
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.mustGet(address: bytes) -> bytes:
mustGet:
    // smart_contracts/escrow/factory.algo.ts:156-157
    // @abimethod({ readonly: true })
    // mustGet(address: Address): bytes {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:158
    // assert(this.walletIDsByAccounts(bytes16(address.native)).exists, 'Account not found')
    frame_dig -1
    callsub bytes16
    box_len
    bury 1
    assert // Account not found
    // smart_contracts/escrow/factory.algo.ts:159
    // return this.walletIDsByAccounts(bytes16(address.native)).value
    frame_dig -1
    callsub bytes16
    box_get
    assert // Box must have value
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.getList(addresses: bytes) -> bytes:
getList:
    // smart_contracts/escrow/factory.algo.ts:163-164
    // @abimethod({ readonly: true })
    // getList(addresses: DynamicArray<Address>): DynamicArray<DynamicBytes> {
    proto 1 1
    intc_1 // 0
    // smart_contracts/escrow/factory.algo.ts:165
    // const apps = new DynamicArray<DynamicBytes>()
    bytec_1 // 0x0000
    // smart_contracts/escrow/factory.algo.ts:166
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    intc_1 // 0

getList_while_top@1:
    // smart_contracts/escrow/factory.algo.ts:166
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    frame_dig 2
    >
    bz getList_after_while@6
    // smart_contracts/escrow/factory.algo.ts:167
    // const address = addresses[i]
    frame_dig -1
    extract 2 0
    frame_dig 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    // smart_contracts/escrow/factory.algo.ts:168
    // if (this.walletIDsByAccounts(bytes16(address.native)).exists) {
    callsub bytes16
    box_len
    bury 1
    bz getList_else_body@4
    // smart_contracts/escrow/factory.algo.ts:169
    // apps.push(new DynamicBytes(this.walletIDsByAccounts(bytes16(address.native)).value))
    frame_dig 0
    callsub bytes16
    box_get
    assert // Box must have value
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_dig 1
    swap
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 1

getList_after_if_else@5:
    // smart_contracts/escrow/factory.algo.ts:166
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b getList_while_top@1

getList_else_body@4:
    // smart_contracts/escrow/factory.algo.ts:171
    // apps.push(new DynamicBytes(''))
    frame_dig 1
    bytec_1 // 0x0000
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 1
    b getList_after_if_else@5

getList_after_while@6:
    // smart_contracts/escrow/factory.algo.ts:174
    // return apps
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/escrow/factory.algo.ts::EscrowFactory.mustGetList(addresses: bytes) -> bytes:
mustGetList:
    // smart_contracts/escrow/factory.algo.ts:178-179
    // @abimethod({ readonly: true })
    // mustGetList(addresses: DynamicArray<Address>): DynamicArray<DynamicBytes> {
    proto 1 1
    // smart_contracts/escrow/factory.algo.ts:180
    // const apps = new DynamicArray<DynamicBytes>()
    bytec_1 // 0x0000
    // smart_contracts/escrow/factory.algo.ts:181
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    intc_1 // 0

mustGetList_while_top@1:
    // smart_contracts/escrow/factory.algo.ts:181
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    frame_dig -1
    intc_1 // 0
    extract_uint16
    frame_dig 1
    >
    bz mustGetList_after_while@3
    // smart_contracts/escrow/factory.algo.ts:182
    // const address = addresses[i]
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/escrow/factory.algo.ts:183
    // assert(this.walletIDsByAccounts(bytes16(address.native)).exists, 'Account not found')
    dup
    callsub bytes16
    box_len
    bury 1
    assert // Account not found
    // smart_contracts/escrow/factory.algo.ts:184
    // apps.push(new DynamicBytes(this.walletIDsByAccounts(bytes16(address.native)).value))
    callsub bytes16
    box_get
    assert // Box must have value
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_dig 0
    swap
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 0
    // smart_contracts/escrow/factory.algo.ts:181
    // for (let i: uint64 = 0; i < addresses.length; i++) {
    intc_0 // 1
    +
    frame_bury 1
    b mustGetList_while_top@1

mustGetList_after_while@3:
    // smart_contracts/escrow/factory.algo.ts:186
    // return apps
    retsub
