#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 4
    bytecblock "akita_dao" "type" "box_count" "votes_one" "votes_two" "votes_three" "votes_four" "votes_five" "end_time" "gate_id" "max_selected" "option_count" 0x151f7c75
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txn NumAppArgs
    bz main_after_if_else@11
    pushbytess 0x9fa835a8 0x2a21d467 0x55af84b9 0xea9180dd 0x33e92c94 // method "create(uint64,uint8,uint64,uint64,string,string[],uint64)void", method "deleteBoxes(address)void", method "vote(pay,uint64[],byte[][])void", method "update(string)void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@3 main_deleteBoxes_route@4 main_vote_route@5 main_update_route@6 main_updateAkitaDAO_route@7

main_after_if_else@11:
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    intc_0 // 0
    return

main_updateAkitaDAO_route@7:
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@6:
    // smart_contracts/utils/base-contracts/base.ts:19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_vote_route@5:
    // smart_contracts/poll/contract.algo.ts:159
    // vote(payment: gtxn.PaymentTxn, votes: uint64[], args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/poll/contract.algo.ts:159
    // vote(payment: gtxn.PaymentTxn, votes: uint64[], args: GateArgs): void {
    callsub vote
    intc_1 // 1
    return

main_deleteBoxes_route@4:
    // smart_contracts/poll/contract.algo.ts:143
    // deleteBoxes(address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txna ApplicationArgs 1
    // smart_contracts/poll/contract.algo.ts:143
    // deleteBoxes(address: Address): void {
    callsub deleteBoxes
    intc_1 // 1
    return

main_create_route@3:
    // smart_contracts/poll/contract.algo.ts:97
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/poll/contract.algo.ts:53
    // export class Poll extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    extract 2 0
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    btoi
    // smart_contracts/poll/contract.algo.ts:97
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/poll/contract.algo.ts::Poll.create(akitaDAO: uint64, type: bytes, endTime: uint64, maxSelected: uint64, question: bytes, options: bytes, gateID: uint64) -> void:
create:
    // smart_contracts/poll/contract.algo.ts:97-106
    // @abimethod({ onCreate: 'require' })
    // create(
    //   akitaDAO: uint64,
    //   type: PollType,
    //   endTime: uint64,
    //   maxSelected: uint64,
    //   question: string,
    //   options: DynamicArray<Str>,
    //   gateID: uint64
    // ): void {
    proto 7 0
    intc_0 // 0
    // smart_contracts/poll/contract.algo.ts:107
    // assert(Global.callerApplicationId !== 0, ERR_BAD_DEPLOYER)
    global CallerApplicationID
    assert // Must be deployed by an application
    // smart_contracts/poll/contract.algo.ts:108
    // assert(Global.latestTimestamp < endTime, ERR_INVALID_END_TIME)
    global LatestTimestamp
    frame_dig -5
    <
    assert // End time must be in the future
    // smart_contracts/poll/contract.algo.ts:109
    // assert(type.native < 4, ERR_INVALID_POLL_TYPE)
    frame_dig -6
    btoi
    intc_3 // 4
    <
    assert // Invalid poll type
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_0 // "akita_dao"
    // smart_contracts/poll/contract.algo.ts:111
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -7
    app_global_put
    // smart_contracts/poll/constants.ts:3
    // export const PollGlobalStateKeyType = 'type'
    bytec_1 // "type"
    // smart_contracts/poll/contract.algo.ts:112
    // this.type.value = type
    frame_dig -6
    app_global_put
    // smart_contracts/poll/constants.ts:4
    // export const PollGlobalStateKeyGateID = 'gate_id'
    bytec 9 // "gate_id"
    // smart_contracts/poll/contract.algo.ts:113
    // this.gateID.value = gateID
    frame_dig -1
    app_global_put
    // smart_contracts/poll/constants.ts:5
    // export const PollGlobalStateKeyEndTime = 'end_time'
    bytec 8 // "end_time"
    // smart_contracts/poll/contract.algo.ts:114
    // this.endTime.value = endTime
    frame_dig -5
    app_global_put
    // smart_contracts/poll/constants.ts:9
    // export const PollGlobalStateKeyQuestion = 'question'
    pushbytes "question"
    // smart_contracts/poll/contract.algo.ts:115
    // this.question.value = question
    frame_dig -3
    app_global_put
    // smart_contracts/poll/contract.algo.ts:117
    // assert(options.length >= 2 && options.length <= 5, ERR_INVALID_OPTION_COUNT)
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    intc_2 // 2
    >=
    bz create_bool_false@3
    frame_dig 1
    pushint 5 // 5
    <=
    bz create_bool_false@3
    intc_1 // 1

create_bool_merge@4:
    // smart_contracts/poll/contract.algo.ts:117
    // assert(options.length >= 2 && options.length <= 5, ERR_INVALID_OPTION_COUNT)
    assert // Invalid number of options, must be between 2 and 5
    // smart_contracts/poll/contract.algo.ts:119
    // if (type === MultipleChoice || type === MultipleChoiceImpact) {
    frame_dig -6
    // smart_contracts/poll/types.ts:9
    // export const MultipleChoice: PollType = new UintN8(1)
    pushbytes 0x01
    // smart_contracts/poll/contract.algo.ts:119
    // if (type === MultipleChoice || type === MultipleChoiceImpact) {
    ==
    bnz create_if_body@6
    frame_dig -6
    // smart_contracts/poll/types.ts:11
    // export const MultipleChoiceImpact: PollType = new UintN8(3)
    pushbytes 0x03
    // smart_contracts/poll/contract.algo.ts:119
    // if (type === MultipleChoice || type === MultipleChoiceImpact) {
    ==
    bz create_after_if_else@11

create_if_body@6:
    // smart_contracts/poll/contract.algo.ts:120
    // assert(maxSelected >= 2 && maxSelected <= options.length - 1, ERR_INVALID_MAX_SELECTION)
    frame_dig -4
    intc_2 // 2
    >=
    bz create_bool_false@9
    frame_dig 1
    intc_1 // 1
    -
    frame_dig -4
    >=
    bz create_bool_false@9
    intc_1 // 1

create_bool_merge@10:
    // smart_contracts/poll/contract.algo.ts:120
    // assert(maxSelected >= 2 && maxSelected <= options.length - 1, ERR_INVALID_MAX_SELECTION)
    assert // Invalid maximum selection
    // smart_contracts/poll/constants.ts:7
    // export const PollGlobalStateKeyMaxSelected = 'max_selected'
    bytec 10 // "max_selected"
    // smart_contracts/poll/contract.algo.ts:121
    // this.maxSelected.value = maxSelected
    frame_dig -4
    app_global_put

create_after_if_else@11:
    // smart_contracts/poll/constants.ts:6
    // export const PollGlobalStateKeyOptionCount = 'option_count'
    bytec 11 // "option_count"
    // smart_contracts/poll/contract.algo.ts:124
    // this.optionCount.value = options.length
    frame_dig 1
    dup
    cover 2
    app_global_put
    // smart_contracts/poll/constants.ts:8
    // export const PollGlobalStateKeyBoxCount = 'box_count'
    bytec_2 // "box_count"
    // smart_contracts/poll/contract.algo.ts:125
    // this.boxCount.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/poll/contract.algo.ts:127
    // this.optionOne.value = options[0].native
    frame_dig -2
    extract 2 0
    dup
    frame_bury 0
    dig 1
    assert // Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    dig 2
    cover 2
    extract3
    extract 2 0
    // smart_contracts/poll/constants.ts:10
    // export const PollGlobalStateKeyOptionOne = 'option_one'
    pushbytes "option_one"
    // smart_contracts/poll/contract.algo.ts:127
    // this.optionOne.value = options[0].native
    swap
    app_global_put
    // smart_contracts/poll/contract.algo.ts:128
    // this.optionTwo.value = options[1].native
    intc_1 // 1
    dig 2
    <
    assert // Index access is out of bounds
    dup
    intc_2 // 2
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/poll/constants.ts:12
    // export const PollGlobalStateKeyOptionTwo = 'option_two'
    pushbytes "option_two"
    // smart_contracts/poll/contract.algo.ts:128
    // this.optionTwo.value = options[1].native
    swap
    app_global_put
    // smart_contracts/poll/contract.algo.ts:130
    // if (options.length >= 3) {
    pushint 3 // 3
    >=
    bz create_after_if_else@13
    // smart_contracts/poll/contract.algo.ts:131
    // this.optionThree.value = options[2].native
    intc_2 // 2
    frame_dig 1
    <
    assert // Index access is out of bounds
    frame_dig 0
    dup
    intc_3 // 4
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/poll/constants.ts:14
    // export const PollGlobalStateKeyOptionThree = 'option_three'
    pushbytes "option_three"
    // smart_contracts/poll/contract.algo.ts:131
    // this.optionThree.value = options[2].native
    swap
    app_global_put

create_after_if_else@13:
    // smart_contracts/poll/contract.algo.ts:134
    // if (options.length >= 4) {
    frame_dig 1
    intc_3 // 4
    >=
    bz create_after_if_else@15
    // smart_contracts/poll/contract.algo.ts:135
    // this.optionFour.value = options[3].native
    pushint 3 // 3
    frame_dig 1
    <
    assert // Index access is out of bounds
    frame_dig 0
    dup
    pushint 6 // 6
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/poll/constants.ts:16
    // export const PollGlobalStateKeyOptionFour = 'option_four'
    pushbytes "option_four"
    // smart_contracts/poll/contract.algo.ts:135
    // this.optionFour.value = options[3].native
    swap
    app_global_put

create_after_if_else@15:
    // smart_contracts/poll/contract.algo.ts:138
    // if (options.length >= 5) {
    frame_dig 1
    pushint 5 // 5
    >=
    bz create_after_if_else@17
    // smart_contracts/poll/contract.algo.ts:139
    // this.optionFive.value = options[4].native
    intc_3 // 4
    frame_dig 1
    <
    assert // Index access is out of bounds
    frame_dig 0
    dup
    pushint 8 // 8
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/poll/constants.ts:18
    // export const PollGlobalStateKeyOptionFive = 'option_five'
    pushbytes "option_five"
    // smart_contracts/poll/contract.algo.ts:139
    // this.optionFive.value = options[4].native
    swap
    app_global_put

create_after_if_else@17:
    retsub

create_bool_false@9:
    intc_0 // 0
    b create_bool_merge@10

create_bool_false@3:
    intc_0 // 0
    b create_bool_merge@4


// smart_contracts/poll/contract.algo.ts::Poll.deleteBoxes(address: bytes) -> void:
deleteBoxes:
    // smart_contracts/poll/contract.algo.ts:143
    // deleteBoxes(address: Address): void {
    proto 1 0
    // smart_contracts/poll/contract.algo.ts:144
    // assert(Global.latestTimestamp > this.endTime.value, ERR_POLL_ACTIVE)
    global LatestTimestamp
    // smart_contracts/poll/constants.ts:5
    // export const PollGlobalStateKeyEndTime = 'end_time'
    intc_0 // 0
    bytec 8 // "end_time"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:144
    // assert(Global.latestTimestamp > this.endTime.value, ERR_POLL_ACTIVE)
    >
    assert // Poll is still active
    // smart_contracts/poll/contract.algo.ts:146
    // this.votes(address.native).delete()
    frame_dig -1
    box_del
    pop
    // smart_contracts/poll/contract.algo.ts:148-152
    // itxn.payment({
    //   receiver: address.native,
    //   amount: this.mbr(),
    //   note: 'MBR refund for poll vote',
    // }).submit()
    itxn_begin
    // smart_contracts/poll/contract.algo.ts:151
    // note: 'MBR refund for poll vote',
    pushbytes "MBR refund for poll vote"
    itxn_field Note
    // smart_contracts/poll/contract.algo.ts:92
    // return 15_300
    pushint 15300 // 15300
    itxn_field Amount
    frame_dig -1
    itxn_field Receiver
    // smart_contracts/poll/contract.algo.ts:148-152
    // itxn.payment({
    //   receiver: address.native,
    //   amount: this.mbr(),
    //   note: 'MBR refund for poll vote',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/poll/constants.ts:8
    // export const PollGlobalStateKeyBoxCount = 'box_count'
    intc_0 // 0
    bytec_2 // "box_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:154
    // this.boxCount.value -= 1
    intc_1 // 1
    -
    // smart_contracts/poll/constants.ts:8
    // export const PollGlobalStateKeyBoxCount = 'box_count'
    bytec_2 // "box_count"
    // smart_contracts/poll/contract.algo.ts:154
    // this.boxCount.value -= 1
    swap
    app_global_put
    retsub


// smart_contracts/poll/contract.algo.ts::Poll.vote(payment: uint64, votes: bytes, args: bytes) -> void:
vote:
    // smart_contracts/poll/contract.algo.ts:159
    // vote(payment: gtxn.PaymentTxn, votes: uint64[], args: GateArgs): void {
    proto 3 0
    pushbytes ""
    dupn 5
    // smart_contracts/poll/contract.algo.ts:160
    // assert(Global.latestTimestamp <= this.endTime.value, ERR_POLL_ENDED)
    global LatestTimestamp
    // smart_contracts/poll/constants.ts:5
    // export const PollGlobalStateKeyEndTime = 'end_time'
    intc_0 // 0
    bytec 8 // "end_time"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:160
    // assert(Global.latestTimestamp <= this.endTime.value, ERR_POLL_ENDED)
    <=
    assert // Poll has ended
    // smart_contracts/poll/contract.algo.ts:161
    // const arc4Sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/poll/contract.algo.ts:162
    // assert(!this.votes(Txn.sender).exists, ERR_ALREADY_VOTED)
    dup
    box_len
    bury 1
    !
    assert // User has already voted
    // smart_contracts/poll/contract.algo.ts:163
    // assert(votes.length <= 5 && votes.length >= 1, ERR_INVALID_VOTE)
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    pushint 5 // 5
    <=
    bz vote_bool_false@3
    frame_dig 7
    bz vote_bool_false@3
    intc_1 // 1

vote_bool_merge@4:
    // smart_contracts/poll/contract.algo.ts:163
    // assert(votes.length <= 5 && votes.length >= 1, ERR_INVALID_VOTE)
    assert // Invalid vote args
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    swap
    frame_bury 0
    assert // check GlobalState exists
    // smart_contracts/poll/constants.ts:4
    // export const PollGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 9 // "gate_id"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 2
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:131
    // if (id === 0) {
    bnz vote_after_if_else@47
    // smart_contracts/utils/functions.ts:132
    // return true
    intc_1 // 1

vote_after_inlined_smart_contracts/utils/functions.ts::gateCheck@48:
    // smart_contracts/poll/contract.algo.ts:164
    // assert(gateCheck(this.akitaDAO.value, arc4Sender, this.gateID.value, args), ERR_FAILED_GATE)
    assert // Gate check failed
    // smart_contracts/poll/contract.algo.ts:166
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/poll/contract.algo.ts:167
    // assert(payment.amount === this.mbr(), ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -3
    gtxns Amount
    // smart_contracts/poll/contract.algo.ts:92
    // return 15_300
    pushint 15300 // 15300
    // smart_contracts/poll/contract.algo.ts:167
    // assert(payment.amount === this.mbr(), ERR_INVALID_PAYMENT_AMOUNT)
    ==
    assert // Invalid payment amount
    // smart_contracts/poll/contract.algo.ts:169
    // let impact: uint64 = 1
    intc_1 // 1
    frame_bury 3
    // smart_contracts/poll/constants.ts:3
    // export const PollGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec_1 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/types.ts:10
    // export const SingleChoiceImpact: PollType = new UintN8(2)
    pushbytes 0x02
    // smart_contracts/poll/contract.algo.ts:170
    // if (this.type.value === SingleChoiceImpact || this.type.value === MultipleChoiceImpact) {
    ==
    bnz vote_if_body@6
    // smart_contracts/poll/constants.ts:3
    // export const PollGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec_1 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/types.ts:11
    // export const MultipleChoiceImpact: PollType = new UintN8(3)
    pushbytes 0x03
    // smart_contracts/poll/contract.algo.ts:170
    // if (this.type.value === SingleChoiceImpact || this.type.value === MultipleChoiceImpact) {
    ==
    bz vote_after_if_else@7

vote_if_body@6:
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:171
    // impact = getUserImpact(this.akitaDAO.value, Txn.sender)
    txn Sender
    // smart_contracts/utils/functions.ts:91-98
    // return abiCall(
    //   AkitaSocialImpactInterface.prototype.getUserImpact,
    //   {
    //     appId: getPluginAppList(akitaDAO).impact,
    //     args: [new Address(account)],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    swap
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    pushbytes "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    pushint 16 // 16
    extract_uint64
    // smart_contracts/utils/functions.ts:91-98
    // return abiCall(
    //   AkitaSocialImpactInterface.prototype.getUserImpact,
    //   {
    //     appId: getPluginAppList(akitaDAO).impact,
    //     args: [new Address(account)],
    //     fee: 0,
    //   }
    // ).returnValue
    pushbytes 0xd574bb10 // method "getUserImpact(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:96
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:91-98
    // return abiCall(
    //   AkitaSocialImpactInterface.prototype.getUserImpact,
    //   {
    //     appId: getPluginAppList(akitaDAO).impact,
    //     args: [new Address(account)],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 12 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    frame_bury 3

vote_after_if_else@7:
    // smart_contracts/poll/constants.ts:3
    // export const PollGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec_1 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/types.ts:8
    // export const SingleChoice: PollType = new UintN8(0)
    pushbytes 0x00
    // smart_contracts/poll/contract.algo.ts:174
    // if (this.type.value === SingleChoice || this.type.value === SingleChoiceImpact) {
    ==
    bnz vote_if_body@9
    // smart_contracts/poll/constants.ts:3
    // export const PollGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec_1 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/types.ts:10
    // export const SingleChoiceImpact: PollType = new UintN8(2)
    pushbytes 0x02
    // smart_contracts/poll/contract.algo.ts:174
    // if (this.type.value === SingleChoice || this.type.value === SingleChoiceImpact) {
    ==
    bz vote_else_body@24

vote_if_body@9:
    // smart_contracts/poll/contract.algo.ts:175
    // assert(votes.length === 1, ERR_INVALID_VOTE_COUNT)
    frame_dig 7
    intc_1 // 1
    ==
    assert // Invalid number of vote args
    // smart_contracts/poll/contract.algo.ts:177
    // if (votes[0] === 0) {
    frame_dig -2
    intc_2 // 2
    extract_uint64
    dup
    frame_bury 4
    bnz vote_else_body@11
    // smart_contracts/poll/constants.ts:11
    // export const PollGlobalStateKeyVotesOne = 'votes_one'
    intc_0 // 0
    bytec_3 // "votes_one"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:178
    // this.votesOne.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:11
    // export const PollGlobalStateKeyVotesOne = 'votes_one'
    bytec_3 // "votes_one"
    // smart_contracts/poll/contract.algo.ts:178
    // this.votesOne.value += 1
    swap
    app_global_put

vote_after_if_else@42:
    // smart_contracts/poll/contract.algo.ts:208
    // this.votes(Txn.sender).value = new arc4.StaticBytes<0>()
    txn Sender
    pushbytes 0x
    box_put
    // smart_contracts/poll/constants.ts:8
    // export const PollGlobalStateKeyBoxCount = 'box_count'
    intc_0 // 0
    bytec_2 // "box_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:209
    // this.boxCount.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:8
    // export const PollGlobalStateKeyBoxCount = 'box_count'
    bytec_2 // "box_count"
    // smart_contracts/poll/contract.algo.ts:209
    // this.boxCount.value += 1
    swap
    app_global_put
    retsub

vote_else_body@11:
    // smart_contracts/poll/contract.algo.ts:179
    // } else if (votes[0] === 1) {
    frame_dig 4
    intc_1 // 1
    ==
    bz vote_else_body@13
    // smart_contracts/poll/constants.ts:13
    // export const PollGlobalStateKeyVotesTwo = 'votes_two'
    intc_0 // 0
    bytec 4 // "votes_two"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:180
    // this.votesTwo.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:13
    // export const PollGlobalStateKeyVotesTwo = 'votes_two'
    bytec 4 // "votes_two"
    // smart_contracts/poll/contract.algo.ts:180
    // this.votesTwo.value += 1
    swap
    app_global_put
    b vote_after_if_else@42

vote_else_body@13:
    // smart_contracts/poll/contract.algo.ts:181
    // } else if (votes[0] === 2) {
    frame_dig 4
    intc_2 // 2
    ==
    bz vote_else_body@15
    // smart_contracts/poll/constants.ts:15
    // export const PollGlobalStateKeyVotesThree = 'votes_three'
    intc_0 // 0
    bytec 5 // "votes_three"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:182
    // this.votesThree.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:15
    // export const PollGlobalStateKeyVotesThree = 'votes_three'
    bytec 5 // "votes_three"
    // smart_contracts/poll/contract.algo.ts:182
    // this.votesThree.value += 1
    swap
    app_global_put
    b vote_after_if_else@42

vote_else_body@15:
    // smart_contracts/poll/contract.algo.ts:183
    // } else if (votes[0] === 3) {
    frame_dig 4
    pushint 3 // 3
    ==
    bz vote_else_body@17
    // smart_contracts/poll/constants.ts:17
    // export const PollGlobalStateKeyVotesFour = 'votes_four'
    intc_0 // 0
    bytec 6 // "votes_four"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:184
    // this.votesFour.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:17
    // export const PollGlobalStateKeyVotesFour = 'votes_four'
    bytec 6 // "votes_four"
    // smart_contracts/poll/contract.algo.ts:184
    // this.votesFour.value += 1
    swap
    app_global_put
    b vote_after_if_else@42

vote_else_body@17:
    // smart_contracts/poll/contract.algo.ts:185
    // } else if (votes[0] === 4) {
    frame_dig 4
    intc_3 // 4
    ==
    bz vote_after_if_else@42
    // smart_contracts/poll/constants.ts:19
    // export const PollGlobalStateKeyVotesFive = 'votes_five'
    intc_0 // 0
    bytec 7 // "votes_five"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:186
    // this.votesFive.value += 1
    intc_1 // 1
    +
    // smart_contracts/poll/constants.ts:19
    // export const PollGlobalStateKeyVotesFive = 'votes_five'
    bytec 7 // "votes_five"
    // smart_contracts/poll/contract.algo.ts:186
    // this.votesFive.value += 1
    swap
    app_global_put
    b vote_after_if_else@42

vote_else_body@24:
    // smart_contracts/poll/constants.ts:7
    // export const PollGlobalStateKeyMaxSelected = 'max_selected'
    intc_0 // 0
    bytec 10 // "max_selected"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:189
    // assert(votes.length <= this.maxSelected.value, ERR_INVALID_VOTE_COUNT)
    frame_dig 7
    >=
    assert // Invalid number of vote args
    // smart_contracts/poll/contract.algo.ts:191
    // for (let i: uint64 = 0; i < votes.length; i += 1) {
    intc_0 // 0
    frame_bury 1

vote_while_top@25:
    // smart_contracts/poll/contract.algo.ts:191
    // for (let i: uint64 = 0; i < votes.length; i += 1) {
    frame_dig 1
    frame_dig 7
    <
    bz vote_after_if_else@42
    // smart_contracts/poll/contract.algo.ts:192
    // assert(votes[i] <= this.optionCount.value - 1, ERR_INVALID_VOTE_OPTION)
    frame_dig -2
    extract 2 0
    frame_dig 1
    pushint 8 // 8
    *
    extract_uint64
    dup
    frame_bury 5
    // smart_contracts/poll/constants.ts:6
    // export const PollGlobalStateKeyOptionCount = 'option_count'
    intc_0 // 0
    bytec 11 // "option_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:192
    // assert(votes[i] <= this.optionCount.value - 1, ERR_INVALID_VOTE_OPTION)
    intc_1 // 1
    -
    dig 1
    >=
    assert // Invalid vote option
    // smart_contracts/poll/contract.algo.ts:194
    // if (votes[i] === 0) {
    bnz vote_else_body@28
    // smart_contracts/poll/constants.ts:11
    // export const PollGlobalStateKeyVotesOne = 'votes_one'
    intc_0 // 0
    bytec_3 // "votes_one"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:195
    // this.votesOne.value += impact
    frame_dig 3
    +
    // smart_contracts/poll/constants.ts:11
    // export const PollGlobalStateKeyVotesOne = 'votes_one'
    bytec_3 // "votes_one"
    // smart_contracts/poll/contract.algo.ts:195
    // this.votesOne.value += impact
    swap
    app_global_put

vote_after_if_else@40:
    // smart_contracts/poll/contract.algo.ts:191
    // for (let i: uint64 = 0; i < votes.length; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b vote_while_top@25

vote_else_body@28:
    // smart_contracts/poll/contract.algo.ts:196
    // } else if (votes[i] === 1) {
    frame_dig 5
    intc_1 // 1
    ==
    bz vote_else_body@30
    // smart_contracts/poll/constants.ts:13
    // export const PollGlobalStateKeyVotesTwo = 'votes_two'
    intc_0 // 0
    bytec 4 // "votes_two"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:197
    // this.votesTwo.value += impact
    frame_dig 3
    +
    // smart_contracts/poll/constants.ts:13
    // export const PollGlobalStateKeyVotesTwo = 'votes_two'
    bytec 4 // "votes_two"
    // smart_contracts/poll/contract.algo.ts:197
    // this.votesTwo.value += impact
    swap
    app_global_put
    b vote_after_if_else@40

vote_else_body@30:
    // smart_contracts/poll/contract.algo.ts:198
    // } else if (votes[i] === 2) {
    frame_dig 5
    intc_2 // 2
    ==
    bz vote_else_body@32
    // smart_contracts/poll/constants.ts:15
    // export const PollGlobalStateKeyVotesThree = 'votes_three'
    intc_0 // 0
    bytec 5 // "votes_three"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:199
    // this.votesThree.value += impact
    frame_dig 3
    +
    // smart_contracts/poll/constants.ts:15
    // export const PollGlobalStateKeyVotesThree = 'votes_three'
    bytec 5 // "votes_three"
    // smart_contracts/poll/contract.algo.ts:199
    // this.votesThree.value += impact
    swap
    app_global_put
    b vote_after_if_else@40

vote_else_body@32:
    // smart_contracts/poll/contract.algo.ts:200
    // } else if (votes[i] === 3) {
    frame_dig 5
    pushint 3 // 3
    ==
    bz vote_else_body@34
    // smart_contracts/poll/constants.ts:17
    // export const PollGlobalStateKeyVotesFour = 'votes_four'
    intc_0 // 0
    bytec 6 // "votes_four"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:201
    // this.votesFour.value += impact
    frame_dig 3
    +
    // smart_contracts/poll/constants.ts:17
    // export const PollGlobalStateKeyVotesFour = 'votes_four'
    bytec 6 // "votes_four"
    // smart_contracts/poll/contract.algo.ts:201
    // this.votesFour.value += impact
    swap
    app_global_put
    b vote_after_if_else@40

vote_else_body@34:
    // smart_contracts/poll/contract.algo.ts:202
    // } else if (votes[i] === 4) {
    frame_dig 5
    intc_3 // 4
    ==
    bz vote_after_if_else@40
    // smart_contracts/poll/constants.ts:19
    // export const PollGlobalStateKeyVotesFive = 'votes_five'
    intc_0 // 0
    bytec 7 // "votes_five"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/poll/contract.algo.ts:203
    // this.votesFive.value += impact
    frame_dig 3
    +
    // smart_contracts/poll/constants.ts:19
    // export const PollGlobalStateKeyVotesFive = 'votes_five'
    bytec 7 // "votes_five"
    // smart_contracts/poll/contract.algo.ts:203
    // this.votesFive.value += impact
    swap
    app_global_put
    b vote_after_if_else@40

vote_after_if_else@47:
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig 0
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    pushbytes "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 40 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:137
    // args: [caller, id, args],
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:138
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 12 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/poll/contract.algo.ts:164
    // assert(gateCheck(this.akitaDAO.value, arc4Sender, this.gateID.value, args), ERR_FAILED_GATE)
    b vote_after_inlined_smart_contracts/utils/functions.ts::gateCheck@48

vote_bool_false@3:
    intc_0 // 0
    b vote_bool_merge@4


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:19-20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:21
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:21
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:22
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:29
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
