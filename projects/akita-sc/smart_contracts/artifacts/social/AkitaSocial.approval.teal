#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 100000 392 31700 63072000 86400 60600
    bytecblock "akita_dao" "controlled_address" "" 0x151f7c75 "p" "m" 0x14 0x00 "akita_al" "akita_escrow" "b" "wallet" "d" "akita_assets" "social_fees" "a" "r" 0x80 0x0a "o" "w" 0x0000 "paywall_id" "f" "n" 0x27e3bb4f 0x0001 "version" 0x000000000000000000 "other_al" "plugn_al" 0x6835e3bc 0x003c
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/social/contract.algo.ts:32
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 22 // "paywall_id"
    intc_1 // 1
    app_global_put

main_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:28
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/social/contract.algo.ts:28
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@60
    pushbytess 0xc6ae2b28 0xba4bf794 0x16ba2de3 0xc0d29149 0xd62be255 0xef34221e 0x58307cdd 0xd811e839 0x72724f96 0x1c99fe9e 0x890dbb5b 0xeeeb21b1 0x40798af2 0x88eff637 0x84fa4b5e 0x5b4e6e2c 0x56536f3e 0x125903c0 0x6c8b5642 0x1b06bdbc 0x8b559657 0x6e5b7702 0x86675494 0x4b6f907f 0x0aea5a8a 0xb59c8a54 0xaeebb378 0x77662c8e 0x03e3ab22 0x8ebc19b5 0x61dcd2ef 0x7960ea76 0xa0d2321d 0xd90671b6 0xf1492bf4 0x856433ea 0xd09f3de8 0x69a4ef97 0xe869934d 0x70e5c48b 0x1f3c618c 0x739ea70b 0xbb32bb70 0x81b7159e 0xa2efa6fe 0x88afd211 0x1cc0c897 0xf4ea50e4 0x603f9fc2 0x1ead20a9 0x33e92c94 0x854dede0 // method "post(pay,axfer,byte[36],uint64,bool,uint64)void", method "editPost(pay,axfer,byte[36],byte[32])void", method "gatedReplyPost(pay,axfer,appl,byte[36],byte[32],uint64,bool,uint64)void", method "replyPost(pay,axfer,byte[36],byte[32],uint64,bool,uint64)void", method "replyAsset(pay,axfer,byte[36],uint64,uint64,bool,uint64)void", method "gatedReplyAddress(pay,axfer,appl,byte[36],address,uint64,bool,uint64)void", method "replyAddress(pay,axfer,byte[36],address,uint64,bool,uint64)void", method "replyApp(pay,axfer,byte[36],uint64,uint64,bool,uint64)void", method "gatedEditReply(pay,axfer,appl,byte[36],byte[32])void", method "editReply(pay,axfer,byte[36],byte[32])void", method "votePost(pay,axfer,byte[32],bool)void", method "voteAsset(pay,axfer,uint64,bool)void", method "voteAddress(pay,axfer,address,bool)void", method "voteApp(pay,axfer,uint64,bool)void", method "editVote(pay,axfer,byte[32],bool)void", method "gatedReactPost(pay,axfer,appl,byte[32],uint64)void", method "reactPost(pay,axfer,byte[32],uint64)void", method "reactAsset(pay,axfer,uint64,uint64)void", method "gatedReactAddress(pay,axfer,appl,address,uint64)void", method "reactAddress(pay,axfer,address,uint64)void", method "reactApp(pay,axfer,uint64,uint64)void", method "deleteReaction(byte[32],uint64)void", method "gatedFollow(pay,appl,address)void", method "follow(pay,address)void", method "unfollow(address,uint64)void", method "block(pay,address)void", method "unblock(address)void", method "addModerator(pay,address)void", method "removeModerator(address)void", method "ban(pay,address,uint64)void", method "flagPost(byte[32])void", method "unflagPost(byte[32])void", method "unban(address)void", method "addAction(pay,uint64,byte[36])void", method "removeAction(uint64)void", method "initMeta(pay,address,bool,uint64,uint64,uint64)uint64", method "createPayWall(pay,((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", method "updateMeta(uint64,uint64,uint64,uint64,uint64,uint64)void", method "getUserSocialImpact(address)uint64", method "isFollower(address,uint64,address)bool", method "moderatorMeta(address)(bool,uint64)", method "getMeta(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,uint64)", method "getMetaWallet(address)uint64", method "postExists(byte[])bool", method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)", method "getPost(byte[32])(address,uint64,uint64,bool,uint64,bool,bool,byte[])", method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,uint64))", method "getVote(byte[32])(uint64,bool)", method "getPostMeta(byte[32],uint64)((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64),bool)", method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match post editPost gatedReplyPost replyPost replyAsset gatedReplyAddress replyAddress replyApp gatedEditReply editReply votePost voteAsset voteAddress voteApp editVote gatedReactPost reactPost reactAsset gatedReactAddress reactAddress reactApp deleteReaction gatedFollow follow unfollow block unblock addModerator removeModerator ban flagPost unflagPost unban addAction removeAction initMeta createPayWall updateMeta getUserSocialImpact isFollower moderatorMeta getMeta getMetaWallet postExists reactionMeta getPost getPostAndCreatorMeta getVote getPostMeta updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@58
    err

main_opUp_route@58:
    // smart_contracts/utils/base-contracts/base.ts:41
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@60:
    // smart_contracts/social/contract.algo.ts:28
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0x88c940f8 // method "create(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:114
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:115
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:116
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    pushint 1000 // 1000
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:115
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::referrerOrZeroAddress(walletID: uint64) -> bytes:
referrerOrZeroAddress:
    // smart_contracts/utils/functions.ts:144
    // export function referrerOrZeroAddress(walletID: Application): Account {
    proto 1 1
    // smart_contracts/utils/functions.ts:145
    // return referrerOr(walletID, Global.zeroAddress)
    global ZeroAddress
    // smart_contracts/utils/functions.ts:138
    // if (walletID.id === 0) {
    frame_dig -1
    bnz referrerOrZeroAddress_after_if_else@3
    frame_dig 0

referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4:
    // smart_contracts/utils/functions.ts:145
    // return referrerOr(walletID, Global.zeroAddress)
    swap
    retsub

referrerOrZeroAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:157-160
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:159
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:157-160
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:145
    // return referrerOr(walletID, Global.zeroAddress)
    b referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:164
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:53
    // return op.AppGlobal.getExUint64(akitaDAO, Bytes(AbstractAccountGlobalStateKeysEscrowFactory))[0]
    frame_dig -2
    pushbytes "escrow_factory"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:170-173
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:175
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:176
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:179
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:203
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:205
    // gateTxn.sender === Txn.sender &&
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    // smart_contracts/utils/functions.ts:205-206
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:206
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:206
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:205-206
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:207
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:205-207
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:208
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    pushint 4 // 4
    ==
    // smart_contracts/utils/functions.ts:205-208
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:210
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x00b6e80e // method "mustCheck(address,uint64,byte[])"
    ==
    // smart_contracts/utils/functions.ts:205-210
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:211
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:205-211
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:212
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:205-212
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@8
    intc_1 // 1
    // smart_contracts/utils/functions.ts:204-213
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    //   gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@8:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:204-213
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    //   gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/utils/functions.ts::sendReferralPayment(akitaDAO: uint64, asset: uint64, amount: uint64) -> bytes:
sendReferralPayment:
    // smart_contracts/utils/functions.ts:524
    // export function sendReferralPayment(akitaDAO: Application, asset: uint64, amount: uint64): ReferralPaymentInfo {
    proto 3 1
    intc_0 // 0
    bytec_2 // ""
    dupn 4
    // smart_contracts/utils/functions.ts:525
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    frame_dig -3
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:526
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    // smart_contracts/utils/functions.ts:529
    // if (amount > 0 && referrer !== Global.zeroAddress) {
    frame_dig -1
    bz sendReferralPayment_after_if_else@6
    frame_dig 6
    global ZeroAddress
    !=
    bz sendReferralPayment_after_if_else@6
    // smart_contracts/utils/functions.ts:57
    // const [walletFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysWalletFees))
    frame_dig -3
    pushbytes "wallet_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:531
    // const { referrerPercentage } = getWalletFees(akitaDAO)
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 3
    // smart_contracts/utils/functions.ts:534
    // if (referralFee === 0 && amount > 0) {
    bnz sendReferralPayment_after_if_else@5
    frame_dig -1
    bz sendReferralPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:535
    // referralFee = 1
    intc_1 // 1
    frame_bury 3

sendReferralPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:541
    // Global.latestTimestamp,
    global LatestTimestamp
    frame_bury 5
    // smart_contracts/utils/functions.ts:542
    // (Global.latestTimestamp + ONE_WEEK),
    global LatestTimestamp
    pushint 604800 // 604800
    +
    frame_bury 2
    // smart_contracts/utils/functions.ts:543
    // [{ address: referrer, amount: referralFee }],
    frame_dig 3
    itob
    frame_dig 6
    swap
    concat
    bytec 26 // 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:459
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 4
    // smart_contracts/utils/functions.ts:462
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc_0 // 0
    extract_uint16
    pushint 25300 // 25300
    *
    pushint 35300 // 35300
    +
    frame_bury 1
    // smart_contracts/utils/functions.ts:463
    // if (asset === 0) {
    frame_dig -2
    bnz sendReferralPayment_else_body@9
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:468
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:469
    // amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    frame_dig 1
    frame_dig 3
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:467-470
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:471
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:472
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0x7b7dc5fc // method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi

sendReferralPayment_after_if_else@12:
    // smart_contracts/utils/functions.ts:510
    // return { id, cost }
    itob
    frame_dig 1
    itob
    concat
    // smart_contracts/utils/functions.ts:538-545
    // const { cost: referralMbr } = createInstantDisbursement(
    //   akitaDAO,
    //   asset,
    //   Global.latestTimestamp,
    //   (Global.latestTimestamp + ONE_WEEK),
    //   [{ address: referrer, amount: referralFee }],
    //   referralFee
    // )
    extract 8 8
    // smart_contracts/utils/functions.ts:547
    // return { leftover: (amount - referralFee), referralMbr }
    frame_dig -1
    frame_dig 3
    -
    itob
    swap
    concat
    frame_bury 0
    retsub

sendReferralPayment_else_body@9:
    // smart_contracts/utils/functions.ts:477
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 4
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bz sendReferralPayment_if_body@10
    frame_dig 1

sendReferralPayment_after_if_else@11:
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:495
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:494-497
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:498-502
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/utils/functions.ts:499
    // assetReceiver: Application(rewardsApp).address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/functions.ts:498-502
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:503
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:504
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0xaf1a14f2 // method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 2 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    frame_bury 1
    b sendReferralPayment_after_if_else@12

sendReferralPayment_if_body@10:
    // smart_contracts/utils/functions.ts:478
    // cost += Global.assetOptInMinBalance
    frame_dig 1
    global AssetOptInMinBalance
    +
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    itxn_begin
    // smart_contracts/utils/functions.ts:483
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:484
    // amount: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:482-485
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: Global.assetOptInMinBalance
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/functions.ts:486
    // asset
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b sendReferralPayment_after_if_else@11

sendReferralPayment_after_if_else@6:
    // smart_contracts/utils/functions.ts:550
    // return { leftover: amount, referralMbr: 0 }
    frame_dig -1
    itob
    intc_0 // 0
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.create[routing]() -> void:
create:
    // smart_contracts/social/contract.algo.ts:687
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 27 // "version"
    // smart_contracts/social/contract.algo.ts:689
    // this.version.value = version
    uncover 3
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:690
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:691
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:687
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.post[routing]() -> void:
post:
    // smart_contracts/social/contract.algo.ts:696-703
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:704
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:704
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz post_after_if_else@3
    dup

post_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:707
    // this.validateTip(tip, TipActionPost)
    dig 7
    bytec 18 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:708
    // this.createPost(origin, mbrPayment, cid, gateID, usePayWall, payWallID, false)
    dig 8
    dig 7
    dig 7
    dig 7
    dig 7
    intc_0 // 0
    callsub createPost
    // smart_contracts/social/contract.algo.ts:696-703
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

post_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b post_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editPost[routing]() -> void:
editPost:
    // smart_contracts/social/contract.algo.ts:711-716
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:717
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:717
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz editPost_after_if_else@3
    dup

editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 4
    concat
    // smart_contracts/social/contract.algo.ts:720
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:721
    // const { creator, ref, gateID, usePayWall, payWallID } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 58 // 58
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 8
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:65
    // return creator === origin
    uncover 5
    ==
    // smart_contracts/social/contract.algo.ts:722
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:723
    // assert(!this.isReply(ref), ERR_IS_A_REPLY)
    dig 3
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/social/contract.algo.ts:724
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dig 3
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:726
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 15 // "a"
    txn TxID
    concat
    uncover 4
    swap
    concat
    dig 4
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 58 // 58
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 4
    box_del
    pop
    uncover 4
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:728
    // this.validateTip(tip, TipActionPost)
    dig 8
    bytec 18 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:729
    // this.createPost(origin, mbrPayment, cid, gateID, usePayWall, payWallID, true)
    uncover 3
    dig 9
    dig 8
    uncover 5
    uncover 5
    uncover 5
    intc_1 // 1
    callsub createPost
    // smart_contracts/social/contract.algo.ts:711-716
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return

editPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReplyPost[routing]() -> void:
gatedReplyPost:
    // smart_contracts/social/contract.algo.ts:732-741
    // gatedReplyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:742
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:742
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedReplyPost_after_if_else@3
    dup

gatedReplyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:744
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 8
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:746
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:747
    // const { gateID: postGateID } = this.posts(ref).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:748
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:748
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 12
    swap
    uncover 5
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:750
    // this.validateTip(tip, TipActionReact)
    dig 11
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:751
    // this.createReply(origin, referrer, mbrPayment, 0, cid, ref, gateID, usePayWall, payWallID, false)
    swap
    dig 12
    intc_0 // 0
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:732-741
    // gatedReplyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

gatedReplyPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedReplyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyPost[routing]() -> void:
replyPost:
    // smart_contracts/social/contract.algo.ts:754-762
    // replyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:763
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:763
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz replyPost_after_if_else@3
    dup

replyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:765
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 8
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:767
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:768
    // const { gateID: postGateID } = this.posts(ref).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:769
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:771
    // this.validateTip(tip, TipActionReact)
    dig 10
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:772
    // this.createReply(origin, referrer, mbrPayment, 0, cid, ref, gateID, usePayWall, payWallID, false)
    uncover 2
    swap
    dig 11
    intc_0 // 0
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:754-762
    // replyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

replyPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b replyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyAsset[routing]() -> void:
replyAsset:
    // smart_contracts/social/contract.algo.ts:775-783
    // replyAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:784
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:784
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz replyAsset_after_if_else@3
    dup

replyAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:786
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:788
    // assert(ref !== 0, ERR_INVALID_ASSET)
    dig 7
    dup
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:789
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    dup
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:790
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:791
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    swap
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:793
    // this.validateTip(tip, TipActionReact)
    dig 11
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:794
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, paddedRef, gateID, usePayWall, payWallID, false)
    uncover 3
    uncover 3
    dig 12
    uncover 3
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:775-783
    // replyAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

replyAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b replyAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReplyAddress[routing]() -> void:
gatedReplyAddress:
    // smart_contracts/social/contract.algo.ts:797-806
    // gatedReplyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: Account,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:807
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:807
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedReplyAddress_after_if_else@3
    dup

gatedReplyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:809
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 8
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:812
    // assert(this.meta(ref).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:813
    // const { addressGateID } = this.meta(ref).value
    box_get
    pop
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:814
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:814
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 12
    swap
    uncover 5
    dup
    cover 4
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:817
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref)
    dig 1
    dig 2
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:819
    // this.validateTip(tip, TipActionReact)
    dig 12
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:820
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, r, gateID, usePayWall, payWallID, false)
    swap
    uncover 3
    dig 13
    uncover 3
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:797-806
    // gatedReplyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: Account,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

gatedReplyAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedReplyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyAddress[routing]() -> void:
replyAddress:
    intc_0 // 0
    dupn 2
    // smart_contracts/social/contract.algo.ts:823-831
    // replyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: Account,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:832
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:832
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz replyAddress_after_if_else@6
    dup
    bury 11

replyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7:
    // smart_contracts/social/contract.algo.ts:834
    // const referrer = referrerOrZeroAddress(wallet)
    dig 1
    callsub referrerOrZeroAddress
    bury 10
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 6
    concat
    dup
    bury 13
    // smart_contracts/social/contract.algo.ts:836
    // if (this.meta(ref).exists) {
    box_len
    bury 1
    bz replyAddress_after_if_else@3
    // smart_contracts/social/contract.algo.ts:837
    // const { addressGateID } = this.meta(ref).value
    dig 11
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:838
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

replyAddress_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:842
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref)
    dig 5
    dup
    dig 1
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:844
    // this.validateTip(tip, TipActionReact)
    dig 9
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:845
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, r, gateID, usePayWall, payWallID, false)
    dig 12
    dig 12
    dig 12
    uncover 3
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:823-831
    // replyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: Account,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

replyAddress_after_if_else@6:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 11
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b replyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyApp[routing]() -> void:
replyApp:
    // smart_contracts/social/contract.algo.ts:848-856
    // replyApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:857
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:857
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz replyApp_after_if_else@3
    dup

replyApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:859
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:861
    // assert(ref !== 0, ERR_INVALID_APP)
    dig 7
    dup
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:862
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    dup
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:863
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:864
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    swap
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:866
    // this.validateTip(tip, TipActionReact)
    dig 11
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:867
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, paddedRef, gateID, usePayWall, payWallID, false)
    uncover 3
    uncover 3
    dig 12
    uncover 3
    dig 11
    uncover 5
    dig 10
    dig 10
    dig 10
    intc_0 // 0
    callsub createReply
    // smart_contracts/social/contract.algo.ts:848-856
    // replyApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

replyApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b replyApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedEditReply[routing]() -> void:
gatedEditReply:
    // smart_contracts/social/contract.algo.ts:870-876
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:877
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:877
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedEditReply_after_if_else@3
    dup

gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:879
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    dup
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 6
    concat
    // smart_contracts/social/contract.algo.ts:881
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:882
    // const { creator, ref, gateID, usePayWall, payWallID } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 58 // 58
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    uncover 7
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:65
    // return creator === origin
    uncover 5
    ==
    // smart_contracts/social/contract.algo.ts:883
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:884
    // assert(this.isReply(ref), ERR_NOT_A_REPLY)
    dig 3
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:885
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dig 3
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:887
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 15 // "a"
    txn TxID
    concat
    dig 4
    swap
    concat
    dig 5
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 58 // 58
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 5
    box_del
    pop
    uncover 5
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:889
    // const originalPostRef = ref.slice(0, 32).toFixed({ length: 32 })
    dig 3
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_3 // 32
    dig 2
    >=
    intc_3 // 32
    uncover 3
    uncover 2
    select
    uncover 5
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:890
    // const { gateID: ogPostGateID } = this.posts(originalPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:891
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:891
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 12
    swap
    uncover 8
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:893
    // this.validateTip(tip, TipActionReact)
    dig 11
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:894
    // this.createReply(origin, referrer, mbrPayment, 0, cid, originalPostRef, gateID, usePayWall, payWallID, true)
    uncover 5
    dig 12
    intc_0 // 0
    dig 11
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    intc_1 // 1
    callsub createReply
    // smart_contracts/social/contract.algo.ts:870-876
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    intc_1 // 1
    return

gatedEditReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editReply[routing]() -> void:
editReply:
    // smart_contracts/social/contract.algo.ts:897-902
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:903
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:903
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz editReply_after_if_else@3
    dup

editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:905
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    dup
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 6
    concat
    // smart_contracts/social/contract.algo.ts:907
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:908
    // const { creator, ref, gateID, usePayWall, payWallID } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 58 // 58
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    uncover 7
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:65
    // return creator === origin
    uncover 5
    ==
    // smart_contracts/social/contract.algo.ts:909
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:910
    // assert(this.isReply(ref), ERR_NOT_A_REPLY)
    dig 3
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:911
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dig 3
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:913
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 15 // "a"
    txn TxID
    concat
    dig 4
    swap
    concat
    dig 5
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 58 // 58
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 5
    box_del
    pop
    uncover 5
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:915
    // const originalPostRef = ref.slice(0, 32).toFixed({ length: 32 })
    dig 3
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_3 // 32
    dig 2
    >=
    intc_3 // 32
    uncover 3
    uncover 2
    select
    uncover 5
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:916
    // const { gateID: ogPostGateID } = this.posts(originalPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:917
    // assert(ogPostGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:919
    // this.validateTip(tip, TipActionReact)
    dig 10
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:920
    // this.createReply(origin, referrer, mbrPayment, 0, cid, originalPostRef, gateID, usePayWall, payWallID, true)
    uncover 5
    uncover 5
    dig 11
    intc_0 // 0
    dig 11
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    intc_1 // 1
    callsub createReply
    // smart_contracts/social/contract.algo.ts:897-902
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return

editReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.votePost[routing]() -> void:
votePost:
    // smart_contracts/social/contract.algo.ts:923-928
    // votePost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:929
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:929
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz votePost_after_if_else@3
    dup

votePost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:931
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:933
    // this.validateTip(tip, TipActionReact)
    dig 6
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:934
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:935
    // this.createVote(origin, referrer, mbrPayment, mbrNeeded, ref, isUp)
    cover 2
    dig 8
    uncover 3
    dig 7
    dig 7
    callsub createVote
    // smart_contracts/social/contract.algo.ts:923-928
    // votePost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return

votePost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b votePost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteAsset[routing]() -> void:
voteAsset:
    // smart_contracts/social/contract.algo.ts:938-943
    // voteAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:944
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:944
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz voteAsset_after_if_else@3
    dup

voteAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:946
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:948
    // assert(ref !== 0, ERR_INVALID_ASSET)
    dig 5
    dup
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:949
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    dup
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:950
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:951
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:952
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    uncover 2
    asset_params_get AssetCreator
    assert // asset exists
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:954
    // this.validateTip(tip, TipActionReact)
    dig 9
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:955
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), paddedRef, isUp)
    +
    uncover 3
    uncover 3
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createVote
    // smart_contracts/social/contract.algo.ts:938-943
    // voteAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return

voteAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b voteAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteAddress[routing]() -> void:
voteAddress:
    // smart_contracts/social/contract.algo.ts:958-963
    // voteAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Account,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:964
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:964
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz voteAddress_after_if_else@3
    dup

voteAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:966
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:969
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:970
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref)
    dig 6
    dup
    dig 1
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:972
    // this.validateTip(tip, TipActionReact)
    dig 9
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:973
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), r, isUp)
    uncover 2
    +
    uncover 3
    uncover 3
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createVote
    // smart_contracts/social/contract.algo.ts:958-963
    // voteAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Account,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return

voteAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b voteAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteApp[routing]() -> void:
voteApp:
    // smart_contracts/social/contract.algo.ts:976-981
    // voteApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:982
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:982
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz voteApp_after_if_else@3
    dup

voteApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:984
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:986
    // assert(ref !== 0, ERR_INVALID_APP)
    dig 5
    dup
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:987
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    dup
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:988
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:989
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:990
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    uncover 2
    app_params_get AppCreator
    assert // application exists
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:992
    // this.validateTip(tip, TipActionReact)
    dig 9
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:993
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), paddedRef, isUp)
    +
    uncover 3
    uncover 3
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createVote
    // smart_contracts/social/contract.algo.ts:976-981
    // voteApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return

voteApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b voteApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editVote[routing]() -> void:
editVote:
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    // smart_contracts/social/contract.algo.ts:996-1001
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1002
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1002
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz editVote_after_if_else@8
    dup
    bury 9

editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@9:
    // smart_contracts/social/contract.algo.ts:1004
    // const referrer = referrerOrZeroAddress(wallet)
    dig 1
    callsub referrerOrZeroAddress
    bury 8
    // smart_contracts/social/contract.algo.ts:1006
    // const voteListKey = this.vlk(origin, ref)
    dig 8
    dig 4
    dup
    cover 2
    callsub vlk
    // smart_contracts/social/contract.algo.ts:47
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    dup
    bury 12
    // smart_contracts/social/contract.algo.ts:1007
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1009
    // const { impact, isUp } = this.votelist(voteListKey).value
    box_get
    pop
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:1012
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    bury 10
    swap
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:1015
    // if (!flip) {
    dig 2
    bnz editVote_after_if_else@4
    // smart_contracts/social/contract.algo.ts:1017
    // this.votelist(voteListKey).delete()
    dig 9
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1019-1024
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1022
    // amount: this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_3 // 32
    extract_uint64
    itxn_field Amount
    dig 8
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1019-1023
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1019-1024
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_submit

editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5:
    // smart_contracts/social/contract.algo.ts:996-1001
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    intc_1 // 1
    return

editVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:1030
    // this.validateTip(tip, TipActionReact)
    dig 4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1031
    // this.createVote(origin, referrer, mbrPayment, 0, ref, !isUp)
    dig 8
    dig 8
    dig 7
    intc_0 // 0
    dig 7
    dig 11
    callsub createVote
    // smart_contracts/social/contract.algo.ts:996-1001
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    b editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5

editVote_after_if_else@8:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 9
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReactPost[routing]() -> void:
gatedReactPost:
    // smart_contracts/social/contract.algo.ts:1034-1040
    // gatedReactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1041
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1041
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedReactPost_after_if_else@3
    dup

gatedReactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1043
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 6
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:1045
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1046
    // const { gateID } = this.posts(ref).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:1047
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1047
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 9
    swap
    uncover 5
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:1049
    // this.validateTip(tip, TipActionReact)
    dig 8
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1050
    // this.createReaction(origin, referrer, mbrPayment, 0, ref, NFT)
    swap
    dig 9
    intc_0 // 0
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1034-1040
    // gatedReactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

gatedReactPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedReactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactPost[routing]() -> void:
reactPost:
    // smart_contracts/social/contract.algo.ts:1053-1058
    // reactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1059
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1059
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz reactPost_after_if_else@3
    dup

reactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1061
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 6
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:1063
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1064
    // const { gateID: postGateID } = this.posts(ref).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:1065
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:1067
    // this.validateTip(tip, TipActionReact)
    dig 7
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1068
    // this.createReaction(origin, referrer, mbrPayment, 0, ref, NFT)
    uncover 2
    swap
    dig 8
    intc_0 // 0
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1053-1058
    // reactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

reactPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b reactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactAsset[routing]() -> void:
reactAsset:
    // smart_contracts/social/contract.algo.ts:1071-1076
    // reactAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1077
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1077
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz reactAsset_after_if_else@3
    dup

reactAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1079
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:1081
    // assert(ref !== 0, ERR_INVALID_ASSET)
    dig 5
    dup
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:1082
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    dup
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:1083
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1084
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    swap
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1086
    // this.validateTip(tip, TipActionReact)
    dig 8
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1087
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, paddedRef, NFT)
    uncover 3
    uncover 3
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1071-1076
    // reactAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

reactAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b reactAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReactAddress[routing]() -> void:
gatedReactAddress:
    intc_0 // 0
    dupn 2
    // smart_contracts/social/contract.algo.ts:1090-1096
    // gatedReactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: Account,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1097
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1097
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedReactAddress_after_if_else@6
    dup
    bury 9

gatedReactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7:
    // smart_contracts/social/contract.algo.ts:1099
    // const referrer = referrerOrZeroAddress(wallet)
    dig 1
    callsub referrerOrZeroAddress
    bury 8
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 4
    concat
    dup
    bury 11
    // smart_contracts/social/contract.algo.ts:1101
    // if (this.meta(ref).exists) {
    box_len
    bury 1
    bz gatedReactAddress_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1102
    // const { addressGateID } = this.meta(ref).value
    dig 9
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1103
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1103
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    swap
    dig 11
    uncover 3
    callsub gateCheck
    assert // Gate check failed

gatedReactAddress_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1107
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref)
    dig 3
    dup
    dig 1
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1109
    // this.validateTip(tip, TipActionReact)
    dig 7
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1110
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, r, NFT)
    dig 10
    dig 10
    dig 10
    uncover 3
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1090-1096
    // gatedReactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: Account,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

gatedReactAddress_after_if_else@6:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 9
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedReactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactAddress[routing]() -> void:
reactAddress:
    intc_0 // 0
    dupn 2
    // smart_contracts/social/contract.algo.ts:1113-1118
    // reactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Account,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1119
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1119
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz reactAddress_after_if_else@6
    dup
    bury 8

reactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7:
    // smart_contracts/social/contract.algo.ts:1121
    // const referrer = referrerOrZeroAddress(wallet)
    dig 1
    callsub referrerOrZeroAddress
    bury 7
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 4
    concat
    dup
    bury 10
    // smart_contracts/social/contract.algo.ts:1123
    // if (this.meta(ref).exists) {
    box_len
    bury 1
    bz reactAddress_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1124
    // const { addressGateID } = this.meta(ref).value
    dig 8
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1125
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

reactAddress_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1129
    // let addedMbr = this.createEmptyPostIfNecessary(r, ref)
    dig 3
    dup
    dig 1
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1131
    // this.validateTip(tip, TipActionReact)
    dig 6
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1132
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, r, NFT)
    dig 9
    dig 9
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1113-1118
    // reactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Account,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

reactAddress_after_if_else@6:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 8
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b reactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactApp[routing]() -> void:
reactApp:
    // smart_contracts/social/contract.algo.ts:1135-1140
    // reactApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1141
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1141
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz reactApp_after_if_else@3
    dup

reactApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1143
    // const referrer = referrerOrZeroAddress(wallet)
    dig 2
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:1145
    // assert(ref !== 0, ERR_INVALID_APP)
    dig 5
    dup
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:1146
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    dup
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:1147
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    dup
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1148
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    swap
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1150
    // this.validateTip(tip, TipActionReact)
    dig 8
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1151
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, paddedRef, NFT)
    uncover 3
    uncover 3
    dig 9
    uncover 3
    uncover 4
    dig 7
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:1135-1140
    // reactApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

reactApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b reactApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.deleteReaction[routing]() -> void:
deleteReaction:
    // smart_contracts/social/contract.algo.ts:1154
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1155
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1155
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz deleteReaction_after_if_else@3
    dup

deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1158
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 5
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:1159
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1160
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:113
    // const blocksKey = this.blk(user, blocked)
    dig 1
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:114
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:1161
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:1163
    // const reactionListKey = this.rlk(origin, ref, NFT)
    dup
    dig 2
    dig 6
    dup
    cover 3
    callsub rlk
    // smart_contracts/social/contract.algo.ts:51
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1164
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:1166
    // this.reactions({ ref, NFT }).value -= 1
    swap
    itob
    uncover 3
    swap
    concat
    // smart_contracts/social/contract.algo.ts:49
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 16 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1166
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1167
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1169-1175
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1172
    // amount: this.mbr(Bytes('')).reactionlist,
    bytec_2 // ""
    callsub mbr
    pushint 48 // 48
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1169-1174
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1169-1175
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1154
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    intc_1 // 1
    return

deleteReaction_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedFollow[routing]() -> void:
gatedFollow:
    // smart_contracts/social/contract.algo.ts:1178-1182
    // gatedFollow(
    //   mbrPayment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   address: Account
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1183
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1183
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz gatedFollow_after_if_else@3
    dup

gatedFollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 4
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:1186
    // assert(this.meta(address).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1187
    // const { followGateID } = this.meta(address).value
    box_get
    pop
    pushint 50 // 50
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1188
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, followGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1188
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, followGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 7
    swap
    uncover 4
    dup
    cover 4
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:1190
    // const { follows } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1191-1198
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 7
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1194
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1191-1198
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1200
    // this.createFollow(origin, address)
    swap
    callsub createFollow
    // smart_contracts/social/contract.algo.ts:1178-1182
    // gatedFollow(
    //   mbrPayment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   address: Account
    // ): void {
    intc_1 // 1
    return

gatedFollow_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b gatedFollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.follow[routing]() -> void:
follow:
    // smart_contracts/social/contract.algo.ts:1203
    // follow(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1204
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1204
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz follow_after_if_else@3
    dup

follow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 4
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:1207
    // assert(this.meta(address).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1208
    // const { followGateID } = this.meta(address).value
    box_get
    pop
    pushint 50 // 50
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1209
    // assert(followGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:1211
    // const { follows } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1212-1219
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 6
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1215
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1212-1219
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1221
    // this.createFollow(origin, address)
    callsub createFollow
    // smart_contracts/social/contract.algo.ts:1203
    // follow(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    intc_1 // 1
    return

follow_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b follow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unfollow[routing]() -> void:
unfollow:
    // smart_contracts/social/contract.algo.ts:1224
    // unfollow(address: Account, index: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1225
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1225
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz unfollow_after_if_else@3
    dup

unfollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1228
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1230
    // const followsKey = { user: address, index }
    dig 3
    itob
    dig 5
    dup
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:1231
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/social/contract.algo.ts:37
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1231
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    box_get
    assert // Box must have value
    dig 3
    ==
    assert // Wrong follower key
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:1233
    // this.meta(address).value.followerCount -= 1
    dup
    box_get
    assert // Box must have value
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    -
    itob
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1235
    // this.follows(followsKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1237-1242
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1240
    // amount: this.mbr(Bytes('')).follows
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1237-1241
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1237-1242
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1224
    // unfollow(address: Account, index: uint64): void {
    intc_1 // 1
    return

unfollow_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b unfollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.block[routing]() -> void:
block:
    // smart_contracts/social/contract.algo.ts:1247
    // block(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1248
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1248
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz block_after_if_else@3
    dup

block_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1251
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1253-1260
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 4
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1256
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1253-1260
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1257
    // amount: this.mbr(Bytes('')).blocks
    bytec_2 // ""
    callsub mbr
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1253-1260
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1262
    // const blocksKey = this.blk(origin, address)
    dig 3
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1263
    // this.blocks(blocksKey).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/social/contract.algo.ts:1247
    // block(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    intc_1 // 1
    return

block_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b block_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unblock[routing]() -> void:
unblock:
    // smart_contracts/social/contract.algo.ts:1266
    // unblock(address: Account): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1267
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1267
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz unblock_after_if_else@3
    dup

unblock_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1270
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1272
    // const blocksKey = this.blk(origin, address)
    dup
    dig 4
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1273
    // this.blocks(blocksKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1275-1280
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1278
    // amount: this.mbr(Bytes('')).blocks
    bytec_2 // ""
    callsub mbr
    intc_2 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1275-1279
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1275-1280
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1266
    // unblock(address: Account): void {
    intc_1 // 1
    return

unblock_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b unblock_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.addModerator[routing]() -> void:
addModerator:
    // smart_contracts/social/contract.algo.ts:1283
    // addModerator(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1284
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1284
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1285
    // assert(!this.moderators(address).exists, ERR_ALREADY_A_MODERATOR)
    dup
    box_len
    bury 1
    !
    assert // Already a moderator
    // smart_contracts/social/contract.algo.ts:1287-1294
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1290
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1287-1294
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1291
    // amount: this.mbr(Bytes('')).moderators
    bytec_2 // ""
    callsub mbr
    pushint 64 // 64
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1287-1294
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1296
    // this.moderators(address).create()
    intc_2 // 8
    box_create
    pop
    // smart_contracts/social/contract.algo.ts:1283
    // addModerator(mbrPayment: gtxn.PaymentTxn, address: Account): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.removeModerator[routing]() -> void:
removeModerator:
    // smart_contracts/social/contract.algo.ts:1299
    // removeModerator(address: Account): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1300
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1300
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1301
    // assert(this.moderators(address).exists, ERR_NOT_A_MODERATOR)
    dup
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:1303
    // this.moderators(address).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1305-1310
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1307
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1308
    // amount: this.mbr(Bytes('')).moderators
    bytec_2 // ""
    callsub mbr
    pushint 64 // 64
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1305-1309
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1305-1310
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1299
    // removeModerator(address: Account): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.ban[routing]() -> void:
ban:
    // smart_contracts/social/contract.algo.ts:1313
    // ban(mbrPayment: gtxn.PaymentTxn, address: Account, expiration: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1314
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1314
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz ban_after_if_else@3
    dup

ban_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1317
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:57
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 24 // "n"
    dig 4
    concat
    // smart_contracts/social/contract.algo.ts:1318
    // assert(!this.banned(address).exists, ERR_ALREADY_BANNED)
    dup
    box_len
    bury 1
    !
    assert // This account is already banned
    // smart_contracts/social/contract.algo.ts:1320-1327
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 5
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1323
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1320-1327
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1324
    // amount: this.mbr(Bytes('')).banned
    bytec_2 // ""
    callsub mbr
    pushint 72 // 72
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1320-1327
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1329
    // this.banned(address).value = expiration
    dig 3
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1313
    // ban(mbrPayment: gtxn.PaymentTxn, address: Account, expiration: uint64): void {
    intc_1 // 1
    return

ban_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b ban_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.flagPost[routing]() -> void:
flagPost:
    // smart_contracts/social/contract.algo.ts:1332
    // flagPost(ref: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1333
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1333
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz flagPost_after_if_else@3
    dup

flagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1336
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 3
    concat
    // smart_contracts/social/contract.algo.ts:1337
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1338
    // const { againstContentPolicy } = this.posts(ref).value
    dup
    pushint 57 // 57
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1339
    // assert(!againstContentPolicy, ERR_ALREADY_FLAGGED)
    !
    assert // Already flagged
    // smart_contracts/social/contract.algo.ts:1341
    // this.posts(ref).value.againstContentPolicy = true
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 57 // 57
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1332
    // flagPost(ref: bytes<32>): void {
    intc_1 // 1
    return

flagPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b flagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unflagPost[routing]() -> void:
unflagPost:
    // smart_contracts/social/contract.algo.ts:1344
    // unflagPost(ref: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1345
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1345
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz unflagPost_after_if_else@3
    dup

unflagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1348
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 3
    concat
    // smart_contracts/social/contract.algo.ts:1349
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1350
    // const { againstContentPolicy } = this.posts(ref).value
    dup
    pushint 57 // 57
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1351
    // assert(againstContentPolicy, ERR_NOT_FLAGGED)
    assert // Not flagged
    // smart_contracts/social/contract.algo.ts:1352
    // this.posts(ref).value.againstContentPolicy = false
    intc_0 // 0
    dup
    setbit
    pushint 57 // 57
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1344
    // unflagPost(ref: bytes<32>): void {
    intc_1 // 1
    return

unflagPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b unflagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unban[routing]() -> void:
unban:
    // smart_contracts/social/contract.algo.ts:1355
    // unban(address: Account): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1356
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1356
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz unban_after_if_else@3
    dup

unban_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1359
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:57
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 24 // "n"
    dig 4
    concat
    // smart_contracts/social/contract.algo.ts:1360
    // this.banned(address).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1362-1367
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1365
    // amount: this.mbr(Bytes('')).banned
    bytec_2 // ""
    callsub mbr
    pushint 72 // 72
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1362-1366
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1362-1367
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1355
    // unban(address: Account): void {
    intc_1 // 1
    return

unban_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b unban_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.addAction[routing]() -> void:
addAction:
    // smart_contracts/social/contract.algo.ts:1370
    // addAction(mbrPayment: gtxn.PaymentTxn, actionAppID: uint64, content: CID) {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    // smart_contracts/social/contract.algo.ts:1371
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1371
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/social/contract.algo.ts:1372
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    swap
    itob
    // smart_contracts/social/contract.algo.ts:59
    // actions = BoxMap<uint64, Action>({ keyPrefix: AkitaSocialBoxPrefixActions })
    bytec 15 // "a"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1372
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    !
    assert // Already an action
    // smart_contracts/social/contract.algo.ts:1374-1381
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1377
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1374-1381
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 3
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1378
    // amount: this.mbr(Bytes('')).actions
    bytec_2 // ""
    callsub mbr
    pushint 80 // 80
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1374-1381
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1383
    // this.actions(actionAppID).value = { content }
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1370
    // addAction(mbrPayment: gtxn.PaymentTxn, actionAppID: uint64, content: CID) {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.removeAction[routing]() -> void:
removeAction:
    // smart_contracts/social/contract.algo.ts:1386
    // removeAction(actionAppID: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1387
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1387
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/social/contract.algo.ts:1388
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    itob
    // smart_contracts/social/contract.algo.ts:59
    // actions = BoxMap<uint64, Action>({ keyPrefix: AkitaSocialBoxPrefixActions })
    bytec 15 // "a"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1388
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    assert // Already an action
    // smart_contracts/social/contract.algo.ts:1390
    // this.actions(actionAppID).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1392-1397
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1394
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1395
    // amount: this.mbr(Bytes('')).actions
    bytec_2 // ""
    callsub mbr
    pushint 80 // 80
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1392-1396
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1392-1397
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1386
    // removeAction(actionAppID: uint64) {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta[routing]() -> void:
initMeta:
    intc_0 // 0
    dup
    bytec_2 // ""
    // smart_contracts/social/contract.algo.ts:1400-1407
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1408
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1408
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz initMeta_after_if_else@12
    dig 5
    bury 9

initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@13:
    // smart_contracts/social/contract.algo.ts:1410
    // const userIsSender = (Txn.sender === user)
    txn Sender
    dig 6
    ==
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 10
    concat
    dup
    bury 12
    // smart_contracts/social/contract.algo.ts:1412
    // assert(!this.meta(origin).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/social/contract.algo.ts:1414-1421
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 7
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1417
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1414-1421
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1418
    // amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    bytec_2 // ""
    callsub mbr
    pushint 56 // 56
    extract_uint64
    intc 6 // 31700
    +
    // smart_contracts/social/contract.algo.ts:1414-1421
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1423
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1423
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1423
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    pushint 104 // 104
    extract_uint64
    dup
    bury 10
    // smart_contracts/social/contract.algo.ts:1425-1430
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1427
    // receiver: Application(impact).address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:1428
    // amount: ImpactMetaMBR
    intc 6 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1425-1429
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1425-1430
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1432
    // if (automated) {
    dig 5
    bz initMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1437
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:1438
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:1433-1445
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    dig 3
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1436
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:1433-1445
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1439
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1433-1445
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec 17 // 0x80
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    dig 11
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1447-1455
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     origin,
    //     0,
    //     0,
    //     0
    //   ]
    // })
    itxn_begin
    bytec 25 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1457
    // return 0
    intc_0 // 0

initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7:
    // smart_contracts/social/contract.algo.ts:1400-1407
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

initMeta_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1464
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:1465
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:1460-1472
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    dig 3
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1463
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:1460-1472
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1466
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1460-1472
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec 7 // 0x00
    concat
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    dig 10
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1474-1482
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaAppList(this.akitaDAO.value).impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1474-1482
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaAppList(this.akitaDAO.value).impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    bytec 25 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dig 9
    dup
    cover 2
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1484
    // return impactScore + this.getSocialImpactScore(origin)
    swap
    callsub getSocialImpactScore
    +
    // smart_contracts/social/contract.algo.ts:1400-1407
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    b initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7

initMeta_after_if_else@12:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dup
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 9
    // smart_contracts/social/contract.algo.ts:1409
    // const origin = originOr(wallet, user)
    b initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@13


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPayWall[routing]() -> void:
createPayWall:
    // smart_contracts/social/contract.algo.ts:1487
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1489-1497
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1492
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1489-1497
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/social/base.ts:34
    // PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    dig 2
    pushint 2 // 2
    extract_uint16
    dig 3
    len
    dig 4
    dig 2
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16
    dig 4
    intc_0 // 0
    extract_uint16
    dig 5
    swap
    uncover 3
    substring3
    intc_0 // 0
    extract_uint16
    +
    // smart_contracts/social/base.ts:33-35
    // BoxCostPerByte * (
    //   PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    // )
    pushint 6800 // 6800
    *
    // smart_contracts/social/base.ts:32
    // return MinPayWallMBR + (
    pushint 5200 // 5200
    // smart_contracts/social/base.ts:32-36
    // return MinPayWallMBR + (
    //   BoxCostPerByte * (
    //     PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    //   )
    // )
    +
    // smart_contracts/social/contract.algo.ts:1489-1497
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    >=
    &&
    assert // assert target is match for conditions
    // smart_contracts/social/contract.algo.ts:1499
    // const id = this.payWallId.value
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:32
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 22 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1499
    // const id = this.payWallId.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/social/contract.algo.ts:1500
    // this.payWallId.value++
    dup
    intc_1 // 1
    +
    // smart_contracts/social/contract.algo.ts:32
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 22 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1500
    // this.payWallId.value++
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:1502
    // this.paywall(id).value = clone(payWall)
    itob
    // smart_contracts/social/contract.algo.ts:43
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 20 // "w"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1502
    // this.paywall(id).value = clone(payWall)
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/social/contract.algo.ts:1487
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateMeta[routing]() -> void:
updateMeta:
    // smart_contracts/social/contract.algo.ts:1507-1514
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1515
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1515
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz updateMeta_after_if_else@3
    dup

updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1518
    // assert(this.meta(origin).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1520
    // this.meta(origin).value.followGateID = followGateID
    dup
    pushint 50 // 50
    dig 12
    box_replace
    // smart_contracts/social/contract.algo.ts:1521
    // this.meta(origin).value.addressGateID = addressGateID
    dup
    pushint 58 // 58
    dig 11
    box_replace
    // smart_contracts/social/contract.algo.ts:1522
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    dig 4
    itob
    // smart_contracts/social/contract.algo.ts:43
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 20 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1522
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    box_len
    bury 1
    assert // ERR:NOPAYWALL
    // smart_contracts/social/contract.algo.ts:1523
    // this.meta(origin).value.defaultPayWallID = defaultPayWallID
    pushint 66 // 66
    dig 6
    box_replace
    // smart_contracts/social/contract.algo.ts:1525
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1525
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1525
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1526-1534
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // })
    itxn_begin
    bytec 25 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    // smart_contracts/social/contract.algo.ts:1507-1514
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    return // on error: invalid number of bytes for uint64

updateMeta_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserSocialImpact[routing]() -> void:
getUserSocialImpact:
    // smart_contracts/social/contract.algo.ts:1539
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1541
    // return this.getSocialImpactScore(user)
    callsub getSocialImpactScore
    // smart_contracts/social/contract.algo.ts:1539
    // @abimethod({ readonly: true })
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isFollower[routing]() -> void:
isFollower:
    // smart_contracts/social/contract.algo.ts:1544
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1546
    // return this.follows({ user, index }).value === follower
    swap
    itob
    uncover 2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:37
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1546
    // return this.follows({ user, index }).value === follower
    box_get
    assert // Box must have value
    ==
    // smart_contracts/social/contract.algo.ts:1544
    // @abimethod({ readonly: true })
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.moderatorMeta[routing]() -> void:
moderatorMeta:
    // smart_contracts/social/contract.algo.ts:1549
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:55
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 12 // "d"
    swap
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1551
    // if (this.moderators(user).exists) {
    box_len
    bury 1
    bz moderatorMeta_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1554
    // lastActive: this.moderators(user).value
    dup
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/social/contract.algo.ts:1552-1555
    // return {
    //   exists: true,
    //   lastActive: this.moderators(user).value
    // }
    itob
    bytec 17 // 0x80
    swap
    concat

moderatorMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.moderatorMeta@4:
    // smart_contracts/social/contract.algo.ts:1549
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

moderatorMeta_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1557
    // return { exists: false, lastActive: 0 }
    bytec 28 // 0x000000000000000000
    // smart_contracts/social/contract.algo.ts:1549
    // @abimethod({ readonly: true })
    b moderatorMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.moderatorMeta@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMeta[routing]() -> void:
getMeta:
    // smart_contracts/social/contract.algo.ts:1560
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1562
    // return this.meta(user).value
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1560
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMetaWallet[routing]() -> void:
getMetaWallet:
    // smart_contracts/social/contract.algo.ts:1565
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1567
    // if (this.meta(user).exists) {
    box_len
    bury 1
    bz getMetaWallet_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1568
    // return this.meta(user).value.wallet
    dup
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64

getMetaWallet_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getMetaWallet@4:
    // smart_contracts/social/contract.algo.ts:1565
    // @abimethod({ readonly: true })
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMetaWallet_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1570
    // return 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1565
    // @abimethod({ readonly: true })
    b getMetaWallet_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getMetaWallet@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.postExists[routing]() -> void:
postExists:
    // smart_contracts/social/contract.algo.ts:1573
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.postExists
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactionMeta[routing]() -> void:
reactionMeta:
    intc_0 // 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:1585
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1587
    // const postExists = this.postExists(ref)
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.postExists
    dup
    // smart_contracts/social/contract.algo.ts:1588
    // let reactionExists: boolean = false
    intc_0 // 0
    swap
    // smart_contracts/social/contract.algo.ts:1589
    // if (postExists) {
    bz reactionMeta_after_if_else@6
    // smart_contracts/social/contract.algo.ts:1590
    // if (ref.length === 8) {
    dig 4
    len
    dup
    bury 7
    intc_2 // 8
    ==
    bz reactionMeta_else_body@4
    // smart_contracts/social/contract.algo.ts:1591
    // const paddedRef = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    dig 5
    swap
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1592
    // reactionExists = this.reactions({ ref: paddedRef, NFT }).exists
    dig 4
    itob
    concat
    // smart_contracts/social/contract.algo.ts:49
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 16 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1592
    // reactionExists = this.reactions({ ref: paddedRef, NFT }).exists
    box_len
    bury 2
    pop

reactionMeta_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:1598
    // let creatorWallet: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/social/contract.algo.ts:1599
    // let addressGateID: uint64 = 0
    intc_0 // 0
    bury 8
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 3
    concat
    dup
    bury 10
    // smart_contracts/social/contract.algo.ts:1600
    // if (this.meta(user).exists) {
    box_len
    bury 1
    bz reactionMeta_after_if_else@8
    // smart_contracts/social/contract.algo.ts:1601
    // const { wallet, addressGateID: metaAddressGateID } = this.meta(user).value
    dig 8
    box_get
    assert // Box must have value
    dup
    intc_1 // 1
    extract_uint64
    swap
    pushint 58 // 58
    extract_uint64
    bury 9
    bury 7

reactionMeta_after_if_else@8:
    // smart_contracts/social/contract.algo.ts:1606-1611
    // return {
    //   postExists,
    //   reactionExists,
    //   creatorWallet,
    //   addressGateID
    // }
    bytec 7 // 0x00
    intc_0 // 0
    dig 3
    setbit
    intc_1 // 1
    dig 2
    setbit
    dig 7
    itob
    concat
    dig 8
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1585
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

reactionMeta_else_body@4:
    // smart_contracts/social/contract.algo.ts:1594
    // reactionExists = this.reactions({ ref: ref.toFixed({ length: 32 }), NFT }).exists
    dig 5
    intc_3 // 32
    ==
    assert // Length must be 32
    dig 3
    itob
    dig 5
    swap
    concat
    // smart_contracts/social/contract.algo.ts:49
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 16 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1594
    // reactionExists = this.reactions({ ref: ref.toFixed({ length: 32 }), NFT }).exists
    box_len
    bury 2
    pop
    b reactionMeta_after_if_else@6


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPost[routing]() -> void:
getPost:
    // smart_contracts/social/contract.algo.ts:1614
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1616
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1617
    // return this.posts(ref).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1614
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostAndCreatorMeta[routing]() -> void:
getPostAndCreatorMeta:
    // smart_contracts/social/contract.algo.ts:1620
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1622
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1623
    // const post = clone(this.posts(ref).value)
    dup
    box_get
    pop
    swap
    // smart_contracts/social/contract.algo.ts:1623-1624
    // const post = clone(this.posts(ref).value)
    // const meta = clone(this.meta(post.creator).value)
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1624
    // const meta = clone(this.meta(post.creator).value)
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1625
    // return { post, meta }
    pushbytes 0x004c
    swap
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1620
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getVote[routing]() -> void:
getVote:
    // smart_contracts/social/contract.algo.ts:1628
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1630
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1630
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz getVote_after_if_else@3
    dup

getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1633
    // const voteListKey = this.vlk(origin, ref)
    dig 3
    callsub vlk
    // smart_contracts/social/contract.algo.ts:47
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1634
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1636
    // return this.votelist(voteListKey).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1628
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getVote_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostMeta[routing]() -> void:
getPostMeta:
    // smart_contracts/social/contract.algo.ts:1639
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:1641
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1642
    // const post = clone(this.posts(ref).value)
    dup
    box_get
    pop
    cover 3
    // smart_contracts/social/contract.algo.ts:1642-1643
    // const post = clone(this.posts(ref).value)
    // const meta = clone(this.meta(post.creator).value)
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1643
    // const meta = clone(this.meta(post.creator).value)
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1644
    // const reactionExists = this.reactions({ ref, NFT }).exists
    uncover 3
    itob
    uncover 4
    swap
    concat
    // smart_contracts/social/contract.algo.ts:49
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 16 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1644
    // const reactionExists = this.reactions({ ref, NFT }).exists
    box_len
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:1645
    // return { post, meta, reactionExists }
    dig 2
    intc_3 // 32
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    uncover 4
    pushint 57 // 57
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    dig 6
    pushint 58 // 58
    extract_uint16
    dig 7
    len
    uncover 8
    cover 2
    substring3
    extract 2 0
    uncover 4
    itob
    uncover 6
    swap
    concat
    uncover 4
    itob
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_1 // 1
    uncover 4
    setbit
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    pushbytes 0x0033
    concat
    swap
    concat
    dig 1
    intc_0 // 0
    getbit
    dig 2
    extract 1 8
    dig 3
    extract 9 8
    dig 4
    extract 17 8
    dig 5
    extract 25 8
    dig 6
    extract 33 8
    dig 7
    extract 41 8
    dig 8
    intc 5 // 392
    getbit
    dig 9
    extract 50 8
    uncover 10
    extract 58 8
    bytec 7 // 0x00
    intc_0 // 0
    uncover 11
    setbit
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    concat
    uncover 2
    concat
    swap
    concat
    pushbytes 0x0045
    swap
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1639
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:113
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:52
    // args: [Txn.lease, Global.currentApplicationId.id],
    txn Lease
    global CurrentApplicationID
    itob
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    pushbytes 0x2c2f51c3 // method "isValidUpgrade(byte[32],uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/base-contracts/base.ts:55
    // assert(valid, ERR_INVALID_UPGRADE)
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 27 // "version"
    // smart_contracts/utils/base-contracts/base.ts:57
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:38
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isReply(ref: bytes) -> uint64:
isReply:
    // smart_contracts/social/contract.algo.ts:68
    // private isReply(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:69
    // return ref.length === 68 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 68 // 68
    ==
    bnz isReply_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1

isReply_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:69
    // return ref.length === 68 || ref.length === 101
    swap
    retsub

isReply_bool_false@3:
    intc_0 // 0
    b isReply_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.isAmended(ref: bytes) -> uint64:
isAmended:
    // smart_contracts/social/contract.algo.ts:72
    // private isAmended(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:73
    // return ref.length === 69 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 69 // 69
    ==
    bnz isAmended_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isAmended_bool_false@3

isAmended_bool_true@2:
    intc_1 // 1

isAmended_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:73
    // return ref.length === 69 || ref.length === 101
    swap
    retsub

isAmended_bool_false@3:
    intc_0 // 0
    b isAmended_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned(account: bytes) -> uint64:
isBanned:
    // smart_contracts/social/contract.algo.ts:76
    // private isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:57
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 24 // "n"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:77
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    box_len
    bury 1
    bz isBanned_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    global LatestTimestamp
    >
    bz isBanned_bool_false@3
    intc_1 // 1

isBanned_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:77
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    swap
    retsub

isBanned_bool_false@3:
    intc_0 // 0
    b isBanned_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.blk(userAddress: bytes, blockedAddress: bytes) -> bytes:
blk:
    // smart_contracts/social/contract.algo.ts:81
    // private blk(userAddress: Account, blockedAddress: Account): BlockListKey {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:82
    // const user = userAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:83
    // const blocked = blockedAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:84
    // return { user, blocked }
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.rlk(user: bytes, ref: bytes, NFT: uint64) -> bytes:
rlk:
    // smart_contracts/social/contract.algo.ts:88
    // private rlk(user: Account, ref: bytes<32>, NFT: uint64): ReactionListKey {
    proto 3 1
    // smart_contracts/social/contract.algo.ts:89
    // const userKey = user.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -3
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -3
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:90
    // const refKey = ref.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:91
    // return { user: userKey, ref: refKey, NFT }
    concat
    frame_dig -1
    itob
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.vlk(account: bytes, r: bytes) -> bytes:
vlk:
    // smart_contracts/social/contract.algo.ts:95
    // private vlk(account: Account, r: bytes<32>): VoteListKey {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:96
    // const user = account.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:97
    // const ref = r.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:98
    // return { user, ref }
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/social/contract.algo.ts:117
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:119
    // const { streak, startDate } = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    pushint 9 // 9
    extract_uint64
    dup
    uncover 2
    pushint 17 // 17
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:122
    // if (streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@2
    // smart_contracts/social/contract.algo.ts:123
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:131
    // const accountAge: uint64 = Global.latestTimestamp - startDate
    global LatestTimestamp
    frame_dig 6
    -
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:133
    // if (accountAge >= TWO_YEARS) {
    intc 7 // 63072000
    >=
    bz getSocialImpactScore_else_body@5
    // smart_contracts/social/contract.algo.ts:134
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:45
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:141
    // if (this.votes(account.bytes).exists) {
    box_len
    bury 1
    bz getSocialImpactScore_after_if_else@16
    // smart_contracts/social/contract.algo.ts:142
    // const { voteCount, isNegative } = this.votes(account.bytes).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:144
    // let impact: uint64 = (voteCount * 75) / 100_000
    pushint 75 // 75
    *
    intc 4 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:145
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@9
    // smart_contracts/social/contract.algo.ts:146
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@9:
    // smart_contracts/social/contract.algo.ts:149
    // if (isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@14
    // smart_contracts/social/contract.algo.ts:151
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@12
    // smart_contracts/social/contract.algo.ts:152
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:162
    // return socialImpact
    frame_dig 4
    frame_bury 0
    retsub

getSocialImpactScore_else_body@12:
    // smart_contracts/social/contract.algo.ts:154
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@16

getSocialImpactScore_else_body@14:
    // smart_contracts/social/contract.algo.ts:158
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@16

getSocialImpactScore_else_body@5:
    // smart_contracts/social/contract.algo.ts:137
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    intc 7 // 63072000
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@6

getSocialImpactScore_else_body@2:
    // smart_contracts/social/contract.algo.ts:126
    // socialImpact += (streak * 100) / 60
    frame_dig 5
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@3


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:165
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:166-169
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:167
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:167
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:167
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:166-169
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:171
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.sendReactionPayments(receiver: bytes, wallet: uint64, preReferralTax: uint64) -> uint64:
sendReactionPayments:
    // smart_contracts/social/contract.algo.ts:299
    // private sendReactionPayments(receiver: Account, wallet: Application, preReferralTax: uint64): uint64 {
    proto 3 1
    intc_0 // 0
    dupn 4
    bytec_2 // ""
    dupn 8
    // smart_contracts/social/contract.algo.ts:300
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:300
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:53
    // const akta = Asset(getAkitaAssets(akitaDAO).akta)
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/base.ts:55
    // if (creator.isOptedIn(akta)) {
    frame_dig -3
    swap
    asset_holding_get AssetBalance
    bury 1
    bz sendReactionPayments_after_if_else@27
    // smart_contracts/social/base.ts:56-66
    // return {
    //   type: TipSendTypeDirect,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: 0
    // }
    pushbytes 0x0a000000000000000000000000000000000000000000000000000000000000000000
    frame_bury 2

sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@33:
    // smart_contracts/social/contract.algo.ts:300
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    frame_dig 2
    dup
    extract 0 1
    dup
    cover 2
    frame_bury 4
    pushint 26 // 26
    extract_uint64
    frame_bury 6
    // smart_contracts/social/contract.algo.ts:301
    // let extraAmount: uint64 = 0
    intc_0 // 0
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:303
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:303
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:303
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    dup
    extract 0 8
    frame_bury 1
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:304
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, preReferralTax)
    frame_dig -1
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    frame_bury 9
    // smart_contracts/social/contract.algo.ts:305
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:305
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:305
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    frame_bury 10
    // smart_contracts/social/contract.algo.ts:308
    // case TipSendTypeDirect: {
    bytec 18 // 0x0a
    ==
    // smart_contracts/social/contract.algo.ts:308-311
    // case TipSendTypeDirect: {
    //   this.sendDirectReactionPayments(receiver, akta, leftover, (reactFee - preReferralTax))
    //   break
    // }
    bz sendReactionPayments_after_if_else@4
    // smart_contracts/social/contract.algo.ts:309
    // this.sendDirectReactionPayments(receiver, akta, leftover, (reactFee - preReferralTax))
    frame_dig 10
    frame_dig -1
    -
    // smart_contracts/social/contract.algo.ts:285
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:285
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:296
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_begin
    frame_dig 5
    dup
    cover 2
    itxn_field XferAsset
    frame_dig 9
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:284-288
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:296
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_next
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:290-294
    // const xferTxn = itxn.assetTransfer({
    //   assetReceiver: creator,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:296
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_submit

sendReactionPayments_block@13:
    // smart_contracts/social/contract.algo.ts:324
    // return extraAmount
    frame_dig 8
    frame_bury 0
    retsub

sendReactionPayments_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:312
    // case TipSendTypeARC59: {
    frame_dig 4
    bytec 6 // 0x14
    ==
    // smart_contracts/social/contract.algo.ts:312-316
    // case TipSendTypeARC59: {
    //   extraAmount = (arc59.mbr + arc59.receiverAlgoNeededForClaim)
    //   this.arc59SendReactionPayments(receiver, akta, leftover, (reactFee - preReferralTax), arc59)
    //   break
    // }
    bz sendReactionPayments_after_if_else@8
    // smart_contracts/social/contract.algo.ts:313
    // extraAmount = (arc59.mbr + arc59.receiverAlgoNeededForClaim)
    frame_dig 2
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    dig 1
    extract 17 8
    frame_bury 0
    dig 1
    pushint 17 // 17
    extract_uint64
    dup
    frame_bury 11
    dig 1
    +
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:314
    // this.arc59SendReactionPayments(receiver, akta, leftover, (reactFee - preReferralTax), arc59)
    frame_dig 10
    frame_dig -1
    -
    frame_bury 12
    // smart_contracts/social/contract.algo.ts:240
    // const { routerOptedIn, mbr, receiverAlgoNeededForClaim } = arc59
    swap
    pushint 128 // 128
    getbit
    frame_bury 13
    // smart_contracts/social/contract.algo.ts:241
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:241
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:48
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 29 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:241
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:242
    // const inboxAddress = Application(assetInbox).address
    app_params_get AppAddress
    swap
    frame_bury 3
    assert // application exists
    // smart_contracts/social/contract.algo.ts:244
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz sendReactionPayments_if_body@18
    frame_dig 11
    bz sendReactionPayments_after_if_else@19

sendReactionPayments_if_body@18:
    // smart_contracts/social/contract.algo.ts:245-250
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    //   .submit()
    itxn_begin
    frame_dig 8
    itxn_field Amount
    frame_dig 3
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:245-249
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:245-250
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    //   .submit()
    itxn_submit

sendReactionPayments_after_if_else@19:
    // smart_contracts/social/contract.algo.ts:253
    // if (!routerOptedIn) {
    frame_dig 13
    bnz sendReactionPayments_after_if_else@21
    // smart_contracts/social/contract.algo.ts:254-257
    // abiCall<typeof AssetInbox.prototype.arc59_optRouterIn>({
    //   appId: assetInbox,
    //   args: [asset]
    // })
    itxn_begin
    pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

sendReactionPayments_after_if_else@21:
    // smart_contracts/social/contract.algo.ts:260-266
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:262
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:262
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 5
    dup
    cover 2
    itxn_field XferAsset
    frame_dig 9
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:260-265
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:260-266
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:268-279
    // abiCall<typeof AssetInbox.prototype.arc59_sendAsset>({
    //   appId: assetInbox,
    //   args: [
    //     itxn.assetTransfer({
    //       assetReceiver: inboxAddress,
    //       assetAmount: remainder,
    //       xferAsset: asset
    //     }),
    //     creator,
    //     receiverAlgoNeededForClaim
    //   ]
    // })
    itxn_begin
    itxn_field XferAsset
    frame_dig 12
    itxn_field AssetAmount
    frame_dig 3
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:271-275
    // itxn.assetTransfer({
    //   assetReceiver: inboxAddress,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:268-279
    // abiCall<typeof AssetInbox.prototype.arc59_sendAsset>({
    //   appId: assetInbox,
    //   args: [
    //     itxn.assetTransfer({
    //       assetReceiver: inboxAddress,
    //       assetAmount: remainder,
    //       xferAsset: asset
    //     }),
    //     creator,
    //     receiverAlgoNeededForClaim
    //   ]
    // })
    itxn_next
    pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:315
    // break
    b sendReactionPayments_block@13

sendReactionPayments_after_if_else@8:
    // smart_contracts/social/contract.algo.ts:317
    // case TipSendTypeARC58: {
    frame_dig 4
    pushbytes 0x1e
    ==
    // smart_contracts/social/contract.algo.ts:317-321
    // case TipSendTypeARC58: {
    //   extraAmount = arc58
    //   this.arc58SendReactionPayments(wallet, akta, leftover, (reactFee - preReferralTax))
    //   break
    // }
    bz sendReactionPayments_block@13
    // smart_contracts/social/contract.algo.ts:319
    // this.arc58SendReactionPayments(wallet, akta, leftover, (reactFee - preReferralTax))
    frame_dig 10
    frame_dig -1
    -
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -2
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:190
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:190
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:43
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 30 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:190
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:192-201
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    itxn_begin
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:196
    // true, // global
    bytec 17 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:197
    // '', // default account
    bytec 21 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:198
    // [], // no method offsets
    bytec 21 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:199
    // [] // no funds request
    bytec 21 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:192-201
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:203-214
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:210
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    dig 2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/social/contract.algo.ts:209-212
    // itxn.payment({
    //   amount: Global.assetOptInMinBalance,
    //   receiver: origin
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:203-214
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:206
    // wallet,
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:208
    // [asset],
    frame_dig 5
    dup
    cover 2
    itob
    bytec 26 // 0x0001
    swap
    concat
    // smart_contracts/social/contract.algo.ts:203-214
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    bytec 31 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:196
    // true, // global
    bytec 17 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:203-214
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:216-218
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({
    //   appId: wallet
    // })
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:220-226
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    // smart_contracts/social/contract.algo.ts:222
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:222
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 1
    itxn_field XferAsset
    frame_dig 9
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:221-225
    // itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:228-234
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: origin,
    //     assetAmount: remainder,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:229-233
    // itxn.assetTransfer({
    //   assetReceiver: origin,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:236
    // itxnCompose.submit()
    itxn_submit
    frame_dig 6
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:320
    // break
    b sendReactionPayments_block@13

sendReactionPayments_after_if_else@27:
    // smart_contracts/social/base.ts:69
    // if (wallet.id !== 0) {
    frame_dig -2
    bz sendReactionPayments_after_if_else@31
    // smart_contracts/social/base.ts:40-49
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:43
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    frame_dig 14
    bytec 30 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:43
    // getPluginAppList(akitaDAO).optin,
    extract 0 8
    // smart_contracts/social/base.ts:45
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/social/base.ts:40-49
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:44
    // true,
    bytec 17 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:46
    // '',
    bytec 21 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:47
    // methodSelector<typeof OptInPlugin.prototype.optIn>()
    bytec 31 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    // smart_contracts/social/base.ts:40-49
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/base.ts:71
    // if (canCallArc58OptIn) {
    bz sendReactionPayments_after_if_else@31
    // smart_contracts/social/base.ts:81
    // arc58: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    // smart_contracts/social/base.ts:72-82
    // return {
    //   type: TipSendTypeARC58,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: Global.assetOptInMinBalance
    // }
    itob
    pushbytes 0x1e00000000000000000000000000000000000000000000000000
    swap
    concat
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:300
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    b sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@33

sendReactionPayments_after_if_else@31:
    // smart_contracts/utils/functions.ts:48
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig 14
    bytec 29 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:86
    // const assetInbox = getOtherAppList(akitaDAO).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/base.ts:88-94
    // const arc59 = abiCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo>({
    //   appId: assetInbox,
    //   args: [
    //     creator,
    //     akta.id,
    //   ]
    // }).returnValue
    itxn_begin
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    frame_dig 15
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 25 // 25
    ==
    assert // invalid number of bytes for (uint64,uint64,bool1,bool1,uint64)
    // smart_contracts/social/base.ts:97
    // type: TipSendTypeARC59,
    bytec 6 // 0x14
    // smart_contracts/social/base.ts:96-100
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    swap
    concat
    // smart_contracts/social/base.ts:99
    // arc58: 0
    intc_0 // 0
    // smart_contracts/social/base.ts:96-100
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    itob
    concat
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:300
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    b sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@33


// smart_contracts/social/contract.algo.ts::AkitaSocial.createEmptyPostIfNecessary(key: bytes, creator: bytes) -> uint64:
createEmptyPostIfNecessary:
    // smart_contracts/social/contract.algo.ts:327
    // private createEmptyPostIfNecessary(key: bytes<32>, creator: Account): uint64 {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:328
    // if (!this.posts(key).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/social/contract.algo.ts:339
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:329-345
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:340
    // gateID: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:329-345
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    itob
    swap
    dig 1
    concat
    bytec 7 // 0x00
    concat
    swap
    concat
    pushbytes 0x00003c0000
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:347
    // return this.mbr(Bytes('')).posts
    bytec_2 // ""
    callsub mbr
    pushint 16 // 16
    extract_uint64
    swap
    retsub

createEmptyPostIfNecessary_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:349
    // return 0
    intc_0 // 0
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/social/contract.algo.ts:352
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/social/contract.algo.ts:353
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:355
    // const { startDate, lastActive } = this.meta(account).value
    dup
    box_get
    pop
    dup
    pushint 17 // 17
    extract_uint64
    swap
    pushint 25 // 25
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/social/contract.algo.ts:357
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    intc 8 // 86400
    %
    -
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:358
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    intc 8 // 86400
    -
    // smart_contracts/social/contract.algo.ts:360
    // this.meta(account).value.lastActive = Global.latestTimestamp
    global LatestTimestamp
    itob
    uncover 3
    pushint 25 // 25
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:363
    // if (lastWindowStart > lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/social/contract.algo.ts:364
    // this.meta(account).value.streak = 1
    intc_1 // 1
    itob
    frame_dig 0
    pushint 9 // 9
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:365
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:370
    // if (lastActive < thisWindowStart) {
    frame_dig 1
    frame_dig 2
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/social/contract.algo.ts:371
    // this.meta(account).value.streak += 1
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    pushint 9 // 9
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 9 // 9
    swap
    box_replace

updateStreak_after_if_else@4:
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/social/contract.algo.ts:407
    // private updateVotes(ref: bytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:45
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/social/contract.algo.ts:378
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/social/contract.algo.ts:379
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat

updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20:
    // smart_contracts/social/contract.algo.ts:408
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    dup
    extract 0 8
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:409
    // this.votes(ref).value = { voteCount, isNegative }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:382
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    pushint 64 // 64
    getbit
    frame_bury 1
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:385
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/social/contract.algo.ts:385
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:387
    // if (voteCount === 0) {
    frame_dig 2
    bnz updateVotes_after_if_else@11
    // smart_contracts/social/contract.algo.ts:388
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:408
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:391
    // if (impact === voteCount && differingDirections) {
    frame_dig -1
    frame_dig 2
    ==
    bz updateVotes_after_if_else@14
    frame_dig 0
    bz updateVotes_after_if_else@14
    // smart_contracts/social/contract.algo.ts:392
    // return { newCount: 0, isNegative: false }
    bytec 28 // 0x000000000000000000
    // smart_contracts/social/contract.algo.ts:408
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:397
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/social/contract.algo.ts:398
    // if (flip) {
    bz updateVotes_after_if_else@16
    // smart_contracts/social/contract.algo.ts:399
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/social/contract.algo.ts:400
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    swap
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:408
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:403
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@18
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@19:
    // smart_contracts/social/contract.algo.ts:404
    // return { newCount, isNegative }
    itob
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:408
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_ternary_false@18:
    // smart_contracts/social/contract.algo.ts:403
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@19

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/social/contract.algo.ts:412
    // private createVoteList(ref: bytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:413
    // const voteListKey = this.vlk(account, ref)
    frame_dig -2
    frame_dig -4
    callsub vlk
    // smart_contracts/social/contract.algo.ts:414
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:47
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:414
    // this.votelist(voteListKey).value = { impact, isUp }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPost(origin: bytes, mbrPayment: uint64, cid: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, isAmendment: uint64) -> void:
createPost:
    // smart_contracts/social/contract.algo.ts:417-425
    // private createPost(
    //   origin: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   isAmendment: boolean,
    // ): void {
    proto 7 0
    // smart_contracts/social/contract.algo.ts:426
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -7
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:103
    // (usePayWall || (!usePayWall && payWallID === 0)) && (
    frame_dig -3
    bnz createPost_and_contd@4
    frame_dig -3
    bnz createPost_bool_false@10
    frame_dig -2
    bnz createPost_bool_false@10

createPost_and_contd@4:
    // smart_contracts/social/contract.algo.ts:104-107
    // usePayWall && (
    //   payWallID !== 0 && this.paywall(payWallID).exists ||
    //   payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    // )
    frame_dig -3
    bz createPost_bool_false@10
    // smart_contracts/social/contract.algo.ts:105
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    frame_dig -2
    bz createPost_or_contd@7
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:43
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 20 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:105
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    box_len
    bury 1
    bnz createPost_bool_true@9

createPost_or_contd@7:
    // smart_contracts/social/contract.algo.ts:106
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    frame_dig -2
    bnz createPost_bool_false@10
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -7
    concat
    // smart_contracts/social/contract.algo.ts:106
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    box_get
    assert // Box must have value
    extract 66 8
    // smart_contracts/social/contract.algo.ts:43
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 20 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:106
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    box_len
    bury 1
    bz createPost_bool_false@10

createPost_bool_true@9:
    intc_1 // 1

createPost_bool_merge@11:
    // smart_contracts/social/contract.algo.ts:427
    // assert(this.validPayWall(usePayWall, payWallID, origin))
    assert
    // smart_contracts/social/contract.algo.ts:429
    // this.validatePostPayment(mbrPayment, cid, isAmendment, 0)
    frame_dig -6
    frame_dig -5
    frame_dig -1
    intc_0 // 0
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:433
    // this.updateStreak(origin)
    frame_dig -7
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:435
    // const impact = this.getUserImpact(origin)
    frame_dig -7
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:437
    // const postID = Txn.txId
    txn TxID
    // smart_contracts/social/contract.algo.ts:441
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:438-447
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    itob
    frame_dig -7
    swap
    concat
    frame_dig -4
    itob
    concat
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    frame_dig -2
    itob
    concat
    bytec 7 // 0x00
    intc_1 // 1
    frame_dig -1
    setbit
    concat
    frame_dig -5
    len
    itob
    extract 6 2
    frame_dig -5
    concat
    swap
    bytec 32 // 0x003c
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:438-447
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:448
    // this.updateVotes(postID, true, impact)
    dup
    intc_1 // 1
    dig 3
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:449
    // this.createVoteList(postID, true, origin, impact)
    intc_1 // 1
    frame_dig -7
    uncover 3
    callsub createVoteList
    // smart_contracts/social/contract.algo.ts:175
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:175
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:175
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    dig 1
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:176
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:177
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, postFee)
    uncover 2
    dig 2
    uncover 2
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:179-185
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:181
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:181
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:179-184
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:179-185
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    retsub

createPost_bool_false@10:
    intc_0 // 0
    b createPost_bool_merge@11


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReply(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, cid: bytes, ref: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, isAmendment: uint64) -> void:
createReply:
    // smart_contracts/social/contract.algo.ts:453-464
    // private createReply(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   isAmendment: boolean
    // ): void {
    proto 10 0
    // smart_contracts/social/contract.algo.ts:465
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -10
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    frame_dig -5
    concat
    // smart_contracts/social/contract.algo.ts:466
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:113
    // const blocksKey = this.blk(user, blocked)
    dup
    frame_dig -10
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:114
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:467
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:471
    // this.updateStreak(origin)
    frame_dig -10
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:473
    // const replyRef = cid.concat(ref)
    frame_dig -6
    frame_dig -5
    concat
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:474
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:475
    // const creatorImpact = this.getUserImpact(creator)
    dig 2
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:476
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:476
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:109
    // const { impactTaxMin, impactTaxMax } = getSocialFees(akitaDAO)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:110
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:479
    // extra += this.sendReactionPayments(creator, Application(wallet), tax)
    uncover 3
    cover 2
    callsub sendReactionPayments
    frame_dig -7
    +
    // smart_contracts/social/contract.algo.ts:481
    // this.validatePostPayment(mbrPayment, cid, isAmendment, extra)
    frame_dig -8
    frame_dig -6
    frame_dig -1
    uncover 3
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:483
    // const replyPostID = Txn.txId
    txn TxID
    // smart_contracts/social/contract.algo.ts:488
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:485-494
    // this.posts(replyPostID).value = {
    //   ref: replyRef,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    itob
    frame_dig -10
    swap
    concat
    frame_dig -4
    itob
    concat
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    frame_dig -2
    itob
    concat
    bytec 7 // 0x00
    intc_1 // 1
    frame_dig -1
    setbit
    concat
    dig 2
    len
    itob
    extract 6 2
    uncover 3
    concat
    swap
    bytec 32 // 0x003c
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:485-494
    // this.posts(replyPostID).value = {
    //   ref: replyRef,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:496
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -10
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:497
    // this.updateVotes(replyPostID, true, senderImpact)
    dig 1
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:498
    // this.createVoteList(replyPostID, true, origin, senderImpact)
    swap
    intc_1 // 1
    frame_dig -10
    uncover 3
    callsub createVoteList
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVote(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/social/contract.algo.ts:501-508
    // private createVote(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:509
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -6
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:510
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:512
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    dupn 2
    // smart_contracts/social/contract.algo.ts:113
    // const blocksKey = this.blk(user, blocked)
    frame_dig -6
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:114
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:513
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:515
    // const voteListKey = this.vlk(origin, ref)
    frame_dig -6
    frame_dig -2
    callsub vlk
    // smart_contracts/social/contract.algo.ts:47
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:516
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/social/contract.algo.ts:517
    // assert(origin !== creator, ERR_NO_SELF_VOTE)
    frame_dig -6
    !=
    assert // Cannot vote on your own content
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -6
    concat
    // smart_contracts/social/contract.algo.ts:519
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:520
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:522
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:522
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:522
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:526
    // this.updateStreak(origin)
    frame_dig -6
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:527
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:527
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:527
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    intc_2 // 8
    extract_uint64
    swap
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:529
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@2
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig 0
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:530
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:532
    // const recipientImpact = this.getUserImpact(creator)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:533
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 3
    frame_dig 4
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:535
    // const extra = this.sendReactionPayments(creator, Application(wallet), tax)
    callsub sendReactionPayments
    // smart_contracts/social/contract.algo.ts:537-544
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:540
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:537-544
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:541
    // amount: mbrNeeded + extra
    frame_dig -3
    uncover 3
    +
    // smart_contracts/social/contract.algo.ts:537-544
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment

createVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:565
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -6
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:566
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:567
    // this.createVoteList(ref, isUp, origin, senderImpact)
    frame_dig -2
    frame_dig -1
    frame_dig -6
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@2:
    // smart_contracts/social/contract.algo.ts:546-553
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:549
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:546-553
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    frame_dig -3
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:556
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 9 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:556
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:561
    // itxn.submitGroup(taxTxn)
    itxn_begin
    frame_dig 1
    itxn_field XferAsset
    frame_dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:555-559
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: reactFee,
    //   xferAsset: akta
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:561
    // itxn.submitGroup(taxTxn)
    itxn_submit
    b createVote_after_if_else@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReaction(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, NFT: uint64) -> void:
createReaction:
    // smart_contracts/social/contract.algo.ts:570-577
    // private createReaction(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:578
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -6
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:579
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:580
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:113
    // const blocksKey = this.blk(user, blocked)
    dup
    frame_dig -6
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:114
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:581
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:583
    // assert(AssetHolding.assetBalance(origin, NFT)[0] > 0, ERR_USER_DOES_NOT_OWN_NFT)
    frame_dig -6
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    assert // User does not own this NFT
    // smart_contracts/social/contract.algo.ts:585
    // const reactionListKey = this.rlk(origin, ref, NFT)
    frame_dig -6
    frame_dig -2
    frame_dig -1
    callsub rlk
    // smart_contracts/social/contract.algo.ts:51
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    dup
    cover 2
    // smart_contracts/social/contract.algo.ts:586
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:590
    // this.updateStreak(origin)
    frame_dig -6
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:592
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:593
    // const recipientImpact = this.getUserImpact(creator)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:594
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:594
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:594
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:595
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:597
    // const reactionKey: ReactionsKey = { ref, NFT }
    frame_dig -2
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:49
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 16 // "r"
    swap
    concat
    dup
    cover 4
    // smart_contracts/social/contract.algo.ts:598
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:601
    // extra += this.sendReactionPayments(creator, Application(wallet), tax)
    cover 3
    callsub sendReactionPayments
    frame_dig -3
    +
    swap
    // smart_contracts/social/contract.algo.ts:670
    // const { reactionlist, reactions } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    dup
    pushint 48 // 48
    extract_uint64
    cover 2
    pushint 40 // 40
    extract_uint64
    cover 2
    // smart_contracts/social/contract.algo.ts:671-673
    // const mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz createReaction_ternary_false@6

createReaction_ternary_merge@7:
    // smart_contracts/social/contract.algo.ts:675-682
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:678
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:675-682
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:679
    // amount: mbrAmount + extra
    uncover 2
    frame_dig 3
    +
    // smart_contracts/social/contract.algo.ts:675-682
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:605
    // if (reactionExists) {
    frame_dig 2
    bz createReaction_else_body@2
    // smart_contracts/social/contract.algo.ts:606
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:611
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    retsub

createReaction_else_body@2:
    // smart_contracts/social/contract.algo.ts:608
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@3

createReaction_ternary_false@6:
    // smart_contracts/social/contract.algo.ts:673
    // : reactions + reactionlist
    frame_dig 4
    +
    b createReaction_ternary_merge@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.createFollow(origin: bytes, address: bytes) -> void:
createFollow:
    // smart_contracts/social/contract.algo.ts:614
    // private createFollow(origin: Account, address: Account): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:615
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -2
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:113
    // const blocksKey = this.blk(user, blocked)
    frame_dig -1
    frame_dig -2
    callsub blk
    // smart_contracts/social/contract.algo.ts:39
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 10 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:114
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:616
    // assert(!this.isBlocked(address, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:618
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:619
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:53
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:621
    // const { followerIndex } = this.meta(address).value
    dup
    box_get
    assert // Box must have value
    pushint 33 // 33
    extract_uint64
    // smart_contracts/social/contract.algo.ts:623
    // const followsKey: FollowsKey = { user: address, index: (followerIndex + 1) }
    intc_1 // 1
    +
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:37
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:624
    // this.follows(followsKey).value = origin
    frame_dig -2
    box_put
    // smart_contracts/social/contract.algo.ts:626
    // this.meta(address).value.followerIndex += 1
    dup
    box_get
    pop
    pushint 33 // 33
    extract_uint64
    intc_1 // 1
    +
    itob
    dig 1
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:627
    // this.meta(address).value.followerCount += 1
    dup
    box_get
    pop
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 41 // 41
    swap
    box_replace
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validateTip(tip: uint64, action: bytes) -> void:
validateTip:
    // smart_contracts/social/contract.algo.ts:630
    // private validateTip(tip: gtxn.AssetTransferTxn, action: TipAction) {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:631
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:631
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:631
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:62
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 14 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:632
    // const { postFee, reactFee } = getSocialFees(this.akitaDAO.value)
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:634-642
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/social/contract.algo.ts:637
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:634-642
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    frame_dig -2
    gtxns XferAsset
    uncover 4
    ==
    &&
    frame_dig -2
    gtxns AssetAmount
    // smart_contracts/social/contract.algo.ts:639
    // assetAmount: (action === TipActionPost) ? postFee : reactFee,
    frame_dig -1
    bytec 18 // 0x0a
    ==
    uncover 3
    uncover 4
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:634-642
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    assert // Invalid transfer
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validatePostPayment(mbrPayment: uint64, cid: bytes, isAmendment: uint64, extraAmount: uint64) -> void:
validatePostPayment:
    // smart_contracts/social/contract.algo.ts:645-650
    // private validatePostPayment(
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   isAmendment: boolean,
    //   extraAmount: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:651
    // const { posts, votes, votelist } = this.mbr(cid)
    frame_dig -3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    swap
    dup
    pushint 24 // 24
    extract_uint64
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:652
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:652
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:87
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:652
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:514
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    dig 1
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:515
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    cover 2
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec 8 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:516
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:517
    // let cost: uint64 = MinDisbursementsMBR + UserAllocationMBR
    intc 9 // 60600
    cover 2
    // smart_contracts/utils/functions.ts:518
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz validatePostPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:517
    // let cost: uint64 = MinDisbursementsMBR + UserAllocationMBR
    intc 9 // 60600
    // smart_contracts/utils/functions.ts:519
    // cost += Global.assetOptInMinBalance
    global AssetOptInMinBalance
    +
    frame_bury 4

validatePostPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:521
    // return referrer !== Global.zeroAddress ? cost : 0
    frame_dig 3
    global ZeroAddress
    !=
    intc_0 // 0
    frame_dig 4
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:654
    // let amount: uint64 = posts + votes + votelist + referralFeeAmount + extraAmount
    frame_dig 0
    frame_dig 1
    +
    frame_dig 2
    +
    +
    frame_dig -1
    +
    // smart_contracts/social/contract.algo.ts:655
    // if (isAmendment) {
    frame_dig -2
    bz validatePostPayment_after_if_else@2
    // smart_contracts/social/contract.algo.ts:656
    // amount += AmendmentMBR
    pushint 13200 // 13200
    +

validatePostPayment_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:659-666
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:662
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:659-666
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.postExists(ref: bytes) -> uint64:
smart_contracts/social/contract.algo.ts::AkitaSocial.postExists:
    // smart_contracts/social/contract.algo.ts:1573-1574
    // @abimethod({ readonly: true })
    // postExists(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1575
    // assert(ref.length === 32 || ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    dup
    intc_3 // 32
    ==
    dup
    bnz smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_true@2
    frame_dig 0
    intc_2 // 8
    ==
    bz smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_false@3

smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_true@2:
    intc_1 // 1

smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:1575
    // assert(ref.length === 32 || ref.length === 8, ERR_INVALID_REF_LENGTH)
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:1577
    // if (ref.length === 8) {
    frame_dig 0
    intc_2 // 8
    ==
    bz smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_after_if_else@6
    // smart_contracts/social/contract.algo.ts:1578
    // const paddedRef = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1579
    // return this.posts(paddedRef).exists
    box_len
    frame_bury 0
    pop
    retsub

smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:1582
    // return this.posts(ref.toFixed({ length: 32 })).exists
    frame_dig 1
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:41
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec 4 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1582
    // return this.posts(ref.toFixed({ length: 32 })).exists
    box_len
    frame_bury 0
    pop
    retsub

smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_false@3:
    intc_0 // 0
    b smart_contracts/social/contract.algo.ts::AkitaSocial.postExists_bool_merge@4


// smart_contracts/social/base.ts::BaseSocial.mbr(ref: bytes) -> bytes:
mbr:
    // smart_contracts/social/base.ts:15
    // protected mbr(ref: bytes): AkitaSocialMBRData {
    proto 1 1
    // smart_contracts/social/base.ts:19
    // posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    frame_dig -1
    len
    pushint 400 // 400
    *
    pushint 40100 // 40100
    +
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    pushbytes 0x0000000000007bd40000000000003d54
    swap
    concat
    // smart_contracts/social/base.ts:20
    // votes: VotesMBR,
    pushint 19300 // 19300
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:22
    // reactions: ReactionsMBR,
    pushint 22100 // 22100
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    // smart_contracts/social/base.ts:23
    // reactionlist: ReactionlistMBR,
    pushint 18900 // 18900
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/base.ts:24
    // meta: MetaMBR,
    pushint 45300 // 45300
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:27
    // actions: ActionsMBR
    pushint 29700 // 29700
    // smart_contracts/social/base.ts:16-28
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    retsub
