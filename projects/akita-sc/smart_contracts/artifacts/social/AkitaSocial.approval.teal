#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 100000 13200 31700 63072000 86400 60600
    bytecblock "akita_dao" 0x151f7c75 0x00 "p" "controlled_address" "m" 0x14 "akita_escrow" "sal" "akita_assets" "social_fees" "wallet" 0x80 0x0000 0x03 "pal" 0x0a 0x01 "o" "w" "paywall_id" "aal" 0x0001 0x6835e3bc "a" 0x02 "r" 0x27e3bb4f 0x84269c78 "version" 0x582ff382 0x6cc3f606 0x003d
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 20 // "paywall_id"
    intc_1 // 1
    app_global_put

main_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@37
    pushbytess 0x83f14748 0x7105bbad 0xba4bf794 0xd5c8e7b8 0x2ffc3123 0x72724f96 0x1c99fe9e 0x02e92631 0x84fa4b5e 0x6e7d42c2 0xd0e5b18d 0x6e5b7702 0xeac6d922 0x856433ea 0xd09f3de8 0x69a4ef97 0x3306b32a // method "init()void", method "post(pay,axfer,uint64,byte[24],byte[36],uint64,bool,uint64)void", method "editPost(pay,axfer,byte[36],byte[32])void", method "gatedReply(pay,axfer,appl,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void", method "reply(pay,axfer,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void", method "gatedEditReply(pay,axfer,appl,byte[36],byte[32])void", method "editReply(pay,axfer,byte[36],byte[32])void", method "vote(pay,axfer,byte[],uint8,bool)void", method "editVote(pay,axfer,byte[32],bool)void", method "gatedReact(pay,axfer,appl,byte[],uint8,uint64)void", method "react(pay,axfer,byte[],uint8,uint64)void", method "deleteReaction(byte[32],uint64)void", method "setPostFlag(byte[32],bool)void", method "initMeta(pay,address,bool,uint64,uint64,uint64)uint64", method "createPayWall(pay,((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", method "updateMeta(uint64,uint64,uint64,uint64,uint64,uint64)void", method "updateFollowerMeta(address,uint64,uint64)void"
    bytec 28 // method "isBanned(address)bool"
    pushbytess 0xe869934d 0x739ea70b 0x984baef5 0xf4ea50e4 0x35752cf0 0x92e6dd3b 0xa134a278 0x344175f0 0x1ead20a9 0x33e92c94 0x854dede0 // method "getUserSocialImpact(address)uint64", method "getMeta(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,uint64)", method "getPost(byte[32])(address,uint64,uint64,bool,uint64,bool,uint8,byte[])", method "getVote(byte[32])(uint64,bool)", method "getPostMeta(byte[32],uint64)((address,uint64,uint64,bool,uint8,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64),bool)", method "mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", method "checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)", method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match init post editPost gatedReply reply gatedEditReply editReply vote editVote gatedReact react deleteReaction setPostFlag initMeta createPayWall updateMeta updateFollowerMeta isBanned getUserSocialImpact getMeta getPost getVote getPostMeta mbr payWallMbr checkTipMbrRequirements updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@35
    err

main_opUp_route@35:
    // smart_contracts/utils/base-contracts/base.ts:43
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@37:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0x88c940f8 // method "create(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/social/contract.algo.ts::b16(b: bytes) -> bytes:
b16:
    // smart_contracts/social/contract.algo.ts:23
    // export function b16(b: bytes): bytes<16> {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:24
    // return b.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    retsub


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:126
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:128
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    pushint 1000 // 1000
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::referrerOrZeroAddress(walletID: uint64) -> bytes:
referrerOrZeroAddress:
    // smart_contracts/utils/functions.ts:156
    // export function referrerOrZeroAddress(walletID: Application): Account {
    proto 1 1
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    global ZeroAddress
    // smart_contracts/utils/functions.ts:150
    // if (walletID.id === 0) {
    frame_dig -1
    bnz referrerOrZeroAddress_after_if_else@3
    frame_dig 0

referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4:
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    swap
    retsub

referrerOrZeroAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:169-172
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:171
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:169-172
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    b referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:176
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:55
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig -2
    pushbytes "oal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:60
    // return getOtherAppList(akitaDAO).escrow
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:182-185
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:187
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:188
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:191
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:227
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 21 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:230
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:231
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    pushint 4 // 4
    ==
    // smart_contracts/utils/functions.ts:229-231
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:232
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x43922655 // method "mustCheck(address,uint64,byte[][])void"
    ==
    // smart_contracts/utils/functions.ts:229-232
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:233
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:229-233
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:234
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:229-234
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@7
    intc_1 // 1
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@7:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/utils/functions.ts::sendReferralPayment(akitaDAO: uint64, asset: uint64, amount: uint64) -> bytes:
sendReferralPayment:
    // smart_contracts/utils/functions.ts:558
    // export function sendReferralPayment(akitaDAO: Application, asset: uint64, amount: uint64): ReferralPaymentInfo {
    proto 3 1
    intc_0 // 0
    pushbytes ""
    dupn 4
    // smart_contracts/utils/functions.ts:559
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    frame_dig -3
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:560
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    // smart_contracts/utils/functions.ts:563
    // if (amount > 0 && referrer !== Global.zeroAddress) {
    frame_dig -1
    bz sendReferralPayment_after_if_else@6
    frame_dig 6
    global ZeroAddress
    !=
    bz sendReferralPayment_after_if_else@6
    // smart_contracts/utils/functions.ts:64
    // const [walletFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysWalletFees))
    frame_dig -3
    pushbytes "wallet_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:565
    // const { referrerPercentage } = getWalletFees(akitaDAO)
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 3
    // smart_contracts/utils/functions.ts:568
    // if (referralFee === 0 && amount > 0) {
    bnz sendReferralPayment_after_if_else@5
    frame_dig -1
    bz sendReferralPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:569
    // referralFee = 1
    intc_1 // 1
    frame_bury 3

sendReferralPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:575
    // Global.latestTimestamp,
    global LatestTimestamp
    frame_bury 5
    // smart_contracts/utils/functions.ts:576
    // (Global.latestTimestamp + ONE_WEEK),
    global LatestTimestamp
    pushint 604800 // 604800
    +
    frame_bury 2
    // smart_contracts/utils/functions.ts:577
    // [{ address: referrer, amount: referralFee }],
    frame_dig 3
    itob
    frame_dig 6
    swap
    concat
    bytec 22 // 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 21 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:493
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 4
    // smart_contracts/utils/functions.ts:496
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc_0 // 0
    extract_uint16
    pushint 25300 // 25300
    *
    pushint 35300 // 35300
    +
    frame_bury 1
    // smart_contracts/utils/functions.ts:497
    // if (asset === 0) {
    frame_dig -2
    bnz sendReferralPayment_else_body@9
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:502
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:503
    // amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    frame_dig 1
    frame_dig 3
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:501-504
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:505
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:506
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0x7b7dc5fc // method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi

sendReferralPayment_after_if_else@12:
    // smart_contracts/utils/functions.ts:544
    // return { id, cost }
    itob
    frame_dig 1
    itob
    concat
    // smart_contracts/utils/functions.ts:572-579
    // const { cost: referralMbr } = createInstantDisbursement(
    //   akitaDAO,
    //   asset,
    //   Global.latestTimestamp,
    //   (Global.latestTimestamp + ONE_WEEK),
    //   [{ address: referrer, amount: referralFee }],
    //   referralFee
    // )
    extract 8 8
    // smart_contracts/utils/functions.ts:581
    // return { leftover: (amount - referralFee), referralMbr }
    frame_dig -1
    frame_dig 3
    -
    itob
    swap
    concat
    frame_bury 0
    retsub

sendReferralPayment_else_body@9:
    // smart_contracts/utils/functions.ts:511
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 4
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bz sendReferralPayment_if_body@10
    frame_dig 1

sendReferralPayment_after_if_else@11:
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:529
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:528-531
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:532-536
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/utils/functions.ts:533
    // assetReceiver: Application(rewardsApp).address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/functions.ts:532-536
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:537
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:538
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0xaf1a14f2 // method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 2 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    frame_bury 1
    b sendReferralPayment_after_if_else@12

sendReferralPayment_if_body@10:
    // smart_contracts/utils/functions.ts:512
    // cost += Global.assetOptInMinBalance
    frame_dig 1
    global AssetOptInMinBalance
    +
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    itxn_begin
    // smart_contracts/utils/functions.ts:517
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:518
    // amount: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:516-519
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: Global.assetOptInMinBalance
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/functions.ts:520
    // Asset(asset)
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    pushbytes 0x394eaeb2 // method "optIn(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b sendReferralPayment_after_if_else@11

sendReferralPayment_after_if_else@6:
    // smart_contracts/utils/functions.ts:584
    // return { leftover: amount, referralMbr: 0 }
    frame_dig -1
    itob
    intc_0 // 0
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.create[routing]() -> void:
create:
    // smart_contracts/social/contract.algo.ts:696
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 29 // "version"
    // smart_contracts/social/contract.algo.ts:698
    // this.version.value = version
    uncover 3
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:699
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:700
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:696
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.init[routing]() -> void:
init:
    pushbytes ""
    dupn 3
    // smart_contracts/social/contract.algo.ts:704
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:704
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:704
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    dup
    // smart_contracts/social/contract.algo.ts:705
    // assert(!Global.currentApplicationAddress.isOptedIn(akta), ERR_ALREADY_OPTED_IN)
    global CurrentApplicationAddress
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // already opted in
    // smart_contracts/social/contract.algo.ts:707-713
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:709
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 1
    itxn_field XferAsset
    // smart_contracts/social/contract.algo.ts:710
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:707-712
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:707-713
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:715
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(akta)) {
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:715
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(akta)) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz init_after_if_else@4
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check GlobalState exists
    dup
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    dup
    cover 2
    bury 4
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dup
    bytec 15 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:78
    // const { revenueManager } = getPluginAppList(this.akitaDAO.value)
    dup
    extract 8 8
    swap
    intc_2 // 8
    extract_uint64
    bury 6
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    swap
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:65-68
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    itxn_begin
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:67
    // args: [[name]],
    pushbytes 0x00010002000a7265765f736f6369616c
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:65-68
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/utils/base-contracts/base.ts:70
    // assert(escrow.id !== 0, ERR_ESCROW_DOES_NOT_EXIST)
    extract 6 9
    intc_0 // 0
    extract_uint64
    dup
    assert // Escrow does not exist
    // smart_contracts/utils/base-contracts/base.ts:81
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:81
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Wrong escrow for this operation
    // smart_contracts/utils/base-contracts/base.ts:83-92
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    itxn_begin
    bytec 30 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:87
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:88
    // name,
    pushbytes 0x000a7265765f736f6369616c
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:89
    // [0], // all the akita escrows have method restrictions with optin being index 0
    pushbytes 0x00010000000000000000
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:90
    // []
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:83-92
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:96
    // this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:588
    // let count: uint64 = 0
    intc_0 // 0
    bury 5
    // smart_contracts/utils/functions.ts:590
    // if (!escrow.isOptedIn(asset)) {
    dig 1
    asset_holding_get AssetBalance
    bury 1
    bnz init_after_if_else@7
    // smart_contracts/utils/functions.ts:99
    // const [splitsBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysRevenueSplits))
    dig 4
    pushbytes "revenue_splits"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    intc_0 // 0
    extract_uint16
    // smart_contracts/utils/functions.ts:591
    // count += 1
    intc_1 // 1
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    +
    bury 4

init_after_if_else@7:
    // smart_contracts/utils/base-contracts/base.ts:100
    // const mbrAmount: uint64 = Global.assetOptInMinBalance * optInCount
    global AssetOptInMinBalance
    dig 4
    *
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:109
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:109
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/utils/base-contracts/base.ts:108-111
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:105
    // wallet,
    dig 1
    dup
    itob
    // smart_contracts/utils/base-contracts/base.ts:107
    // [asset.id],
    dig 2
    itob
    bytec 22 // 0x0001
    swap
    concat
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    bytec 23 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:87
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:115
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({ appId: wallet })
    itxn_next
    bytec 31 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:127
    // itxnCompose.submit()
    itxn_submit

init_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:703
    // init(): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.post[routing]() -> void:
post:
    // smart_contracts/social/contract.algo.ts:726-735
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:736
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:736
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz post_after_if_else@3
    dup

post_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:740
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 9
    dup
    cover 2
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:743
    // const postKey = op.sha256(origin.bytes.concat(itob(timestamp)).concat(nonce))
    itob
    dig 1
    swap
    concat
    dig 8
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:745
    // this.validateTip(tip, TipActionPost)
    dig 10
    bytec 16 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:746
    // this.createPost(postKey, origin, mbrPayment, cid, gateID, usePayWall, payWallID, PostTypePost, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    uncover 2
    dig 12
    dig 9
    dig 9
    dig 9
    dig 9
    bytec_2 // 0x00
    uncover 8
    callsub createPost
    // smart_contracts/social/contract.algo.ts:726-735
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

post_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b post_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editPost[routing]() -> void:
editPost:
    // smart_contracts/social/contract.algo.ts:749-754
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:755
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:755
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz editPost_after_if_else@3
    dup

editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 4
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:758
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:759
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 10
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:54
    // return creator === origin
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:760
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:761
    // assert(!this.isReply(postType), ERR_IS_A_REPLY)
    dup
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/social/contract.algo.ts:762
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:766
    // const editKey = op.sha256(origin.bytes.concat(amendment).concat(Bytes(cid)))
    uncover 6
    dup
    cover 3
    dig 7
    concat
    dig 11
    dup
    cover 4
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:769
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 24 // "a"
    dig 1
    concat
    uncover 7
    swap
    concat
    dig 7
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 7
    box_del
    pop
    uncover 7
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:771
    // this.validateTip(tip, TipActionPost)
    dig 11
    bytec 16 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:772
    // this.createPost(editKey, origin, mbrPayment, cid, gateID, usePayWall, payWallID, PostTypeEditPost, amendment)
    uncover 4
    dig 12
    uncover 5
    uncover 6
    uncover 6
    uncover 6
    bytec 25 // 0x02
    uncover 8
    callsub createPost
    // smart_contracts/social/contract.algo.ts:749-754
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return

editPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReply[routing]() -> void:
gatedReply:
    // smart_contracts/social/contract.algo.ts:775-787
    // gatedReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:788
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:788
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz gatedReply_after_if_else@3
    dup

gatedReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:790
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    dig 6
    dig 8
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:793
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 13
    dup
    cover 4
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:795
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:796
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:797
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:797
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 17
    swap
    uncover 7
    dup
    cover 4
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:799
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 2
    global ZeroAddress
    ==
    uncover 3
    uncover 3
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:800
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:803
    // const replyKey = op.sha256(origin.bytes.concat(itob(timestamp)).concat(nonce))
    uncover 3
    itob
    dig 2
    swap
    concat
    dig 12
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:805
    // this.validateTip(tip, TipActionReact)
    dig 15
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:806
    // this.createReply(replyKey, origin, mbrPayment, addedMbr, cid, refBytes, gateID, usePayWall, payWallID, PostTypeReply, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    uncover 3
    dig 17
    uncover 4
    dig 13
    uncover 6
    dig 11
    dig 11
    dig 11
    bytec 17 // 0x01
    uncover 10
    callsub createReply
    // smart_contracts/social/contract.algo.ts:775-787
    // gatedReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

gatedReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b gatedReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reply[routing]() -> void:
reply:
    // smart_contracts/social/contract.algo.ts:809-820
    // reply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:821
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:821
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz reply_after_if_else@3
    dup

reply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:823
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    dig 6
    dig 8
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:826
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 13
    dup
    cover 4
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:828
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:829
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:830
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:832
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:833
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:836
    // const replyKey = op.sha256(origin.bytes.concat(itob(timestamp)).concat(nonce))
    uncover 2
    itob
    uncover 3
    dup
    uncover 2
    concat
    dig 12
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:838
    // this.validateTip(tip, TipActionReact)
    dig 14
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:839
    // this.createReply(replyKey, origin, mbrPayment, addedMbr, cid, refBytes, gateID, usePayWall, payWallID, PostTypeReply, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    uncover 2
    dig 16
    uncover 4
    dig 13
    uncover 6
    dig 11
    dig 11
    dig 11
    bytec 17 // 0x01
    uncover 10
    callsub createReply
    // smart_contracts/social/contract.algo.ts:809-820
    // reply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return

reply_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b reply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedEditReply[routing]() -> void:
gatedEditReply:
    // smart_contracts/social/contract.algo.ts:842-848
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:849
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:849
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz gatedEditReply_after_if_else@3
    dup

gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 4
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:852
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:853
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 10
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:54
    // return creator === origin
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:854
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:855
    // assert(this.isReply(postType), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:856
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:859
    // const editKey = op.sha256(origin.bytes.concat(amendment).concat(Bytes(cid)))
    uncover 6
    dup
    cover 4
    dig 7
    concat
    dig 11
    dup
    cover 5
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:862
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 24 // "a"
    dig 1
    concat
    dig 7
    swap
    concat
    dig 8
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 8
    box_del
    pop
    uncover 8
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:865
    // const parentPostRef = ref.slice(36, 68).toFixed({ length: 32 })
    dig 6
    len
    pushint 36 // 36
    dig 1
    >=
    pushint 36 // 36
    dig 2
    uncover 2
    select
    pushint 68 // 68
    dig 2
    >=
    pushint 68 // 68
    uncover 3
    uncover 2
    select
    uncover 8
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:866
    // const { gateID: ogPostGateID } = this.posts(parentPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:867
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:867
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 14
    swap
    dig 9
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:869
    // this.validateTip(tip, TipActionReact)
    dig 13
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:870
    // this.createReply(editKey, origin, mbrPayment, 0, cid, parentPostRef, gateID, usePayWall, payWallID, PostTypeEditReply, amendment)
    swap
    uncover 6
    dig 14
    intc_0 // 0
    uncover 8
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    bytec 14 // 0x03
    uncover 10
    callsub createReply
    // smart_contracts/social/contract.algo.ts:842-848
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    intc_1 // 1
    return

gatedEditReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editReply[routing]() -> void:
editReply:
    // smart_contracts/social/contract.algo.ts:873-878
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:879
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:879
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz editReply_after_if_else@3
    dup

editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 4
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:882
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:883
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 10
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:54
    // return creator === origin
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:884
    // assert(this.isCreator(creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:885
    // assert(this.isReply(postType), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:886
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:889
    // const editKey = op.sha256(origin.bytes.concat(amendment).concat(Bytes(cid)))
    uncover 6
    dup
    cover 4
    dig 7
    concat
    dig 11
    dup
    cover 4
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:892
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 24 // "a"
    dig 1
    concat
    dig 7
    swap
    concat
    dig 8
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 8
    box_del
    pop
    uncover 8
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:895
    // const parentPostRef = ref.slice(36, 68).toFixed({ length: 32 })
    dig 6
    len
    pushint 36 // 36
    dig 1
    >=
    pushint 36 // 36
    dig 2
    uncover 2
    select
    pushint 68 // 68
    dig 2
    >=
    pushint 68 // 68
    uncover 3
    uncover 2
    select
    uncover 8
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:896
    // const { gateID: ogPostGateID } = this.posts(parentPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:897
    // assert(ogPostGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:899
    // this.validateTip(tip, TipActionReact)
    dig 12
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:900
    // this.createReply(editKey, origin, mbrPayment, 0, cid, parentPostRef, gateID, usePayWall, payWallID, PostTypeEditReply, amendment)
    swap
    uncover 6
    dig 13
    intc_0 // 0
    uncover 7
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    bytec 14 // 0x03
    uncover 10
    callsub createReply
    // smart_contracts/social/contract.algo.ts:873-878
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return

editReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.vote[routing]() -> void:
vote:
    // smart_contracts/social/contract.algo.ts:903-909
    // vote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:910
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:910
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz vote_after_if_else@3
    dup

vote_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:913
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    dig 4
    dig 6
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:914
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:915
    // const { creator } = this.posts(refBytes).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:917
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:918
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:920
    // this.validateTip(tip, TipActionReact)
    dig 8
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:921
    // const mbrNeeded: uint64 = this.mbr(Bytes('')).votelist + addedMbr
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    intc_3 // 32
    extract_uint64
    +
    // smart_contracts/social/contract.algo.ts:922
    // this.createVote(origin, mbrPayment, mbrNeeded, refBytes, isUp)
    uncover 2
    dig 9
    uncover 2
    uncover 3
    dig 6
    callsub createVote
    // smart_contracts/social/contract.algo.ts:903-909
    // vote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return

vote_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b vote_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editVote[routing]() -> void:
editVote:
    intc_0 // 0
    pushbytes ""
    // smart_contracts/social/contract.algo.ts:925-930
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:931
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:931
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz editVote_after_if_else@8
    dup
    bury 8

editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@9:
    // smart_contracts/social/contract.algo.ts:934
    // const voteListKey: VoteListKey = { user: b16(origin.bytes), ref: b16(ref) }
    dig 7
    callsub b16
    dig 4
    dup
    cover 2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:935
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:937
    // const { impact, isUp } = this.votelist(voteListKey).value
    dup
    box_get
    pop
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:940
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    bury 11
    uncover 3
    swap
    uncover 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:943
    // this.votelist(voteListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:946
    // if (!flip) {
    dig 2
    bnz editVote_after_if_else@4
    // smart_contracts/social/contract.algo.ts:948-953
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:951
    // amount: this.mbr(Bytes('')).votelist
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    intc_3 // 32
    extract_uint64
    itxn_field Amount
    dig 7
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:948-952
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:948-953
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_submit

editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5:
    // smart_contracts/social/contract.algo.ts:925-930
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    intc_1 // 1
    return

editVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:959
    // this.validateTip(tip, TipActionReact)
    dig 4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:960
    // this.createVote(origin, mbrPayment, 0, ref, !isUp)
    dig 7
    dig 6
    intc_0 // 0
    dig 6
    dig 10
    callsub createVote
    // smart_contracts/social/contract.algo.ts:925-930
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    b editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5

editVote_after_if_else@8:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 8
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReact[routing]() -> void:
gatedReact:
    // smart_contracts/social/contract.algo.ts:963-970
    // gatedReact(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:971
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:971
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz gatedReact_after_if_else@3
    dup

gatedReact_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:973
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    dig 4
    dig 6
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:975
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:976
    // const { creator, gateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:977
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:977
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 11
    swap
    uncover 6
    dup
    cover 4
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:979
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 2
    global ZeroAddress
    ==
    uncover 3
    uncover 3
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:980
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:982
    // this.validateTip(tip, TipActionReact)
    dig 9
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:983
    // this.createReaction(origin, mbrPayment, addedMbr, refBytes, NFT)
    dig 10
    swap
    uncover 3
    dig 6
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:963-970
    // gatedReact(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

gatedReact_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b gatedReact_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.react[routing]() -> void:
react:
    // smart_contracts/social/contract.algo.ts:986-992
    // react(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:993
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:993
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz react_after_if_else@3
    dup

react_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:995
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    dig 4
    dig 6
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:997
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:998
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:999
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:1001
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:1002
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1004
    // this.validateTip(tip, TipActionReact)
    dig 8
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1005
    // this.createReaction(origin, mbrPayment, addedMbr, refBytes, NFT)
    uncover 2
    dig 9
    uncover 2
    uncover 3
    dig 6
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:986-992
    // react(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

react_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b react_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.deleteReaction[routing]() -> void:
deleteReaction:
    // smart_contracts/social/contract.algo.ts:1008
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1009
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1009
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz deleteReaction_after_if_else@3
    dup

deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1012
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 5
    dup
    cover 3
    concat
    // smart_contracts/social/contract.algo.ts:1013
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1014
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:1015
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    dig 1
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:1017
    // const reactionListKey: ReactionListKey = { user: b16(origin.bytes), ref: b16(ref), NFT }
    dup
    callsub b16
    dig 2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    dig 5
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:46
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1019
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:1021
    // this.reactions({ ref, NFT }).value -= 1
    uncover 3
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 26 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1021
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1022
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1024-1030
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1027
    // amount: this.mbr(Bytes('')).reactionlist,
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 48 // 48
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1024-1029
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1024-1030
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1008
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    intc_1 // 1
    return

deleteReaction_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.setPostFlag[routing]() -> void:
setPostFlag:
    // smart_contracts/social/contract.algo.ts:1033
    // setPostFlag(ref: bytes<32>, flagged: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1035
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1035
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1035
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    pushint 24 // 24
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // ERR:NOT_MODERATION
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:1036
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1037
    // this.posts(ref).value.againstContentPolicy = flagged
    dup
    pushint 57 // 57
    intc_1 // 1
    box_extract
    intc_0 // 0
    uncover 3
    setbit
    pushint 57 // 57
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1033
    // setPostFlag(ref: bytes<32>, flagged: boolean): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta[routing]() -> void:
initMeta:
    intc_0 // 0
    pushbytes ""
    // smart_contracts/social/contract.algo.ts:1040-1047
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1048
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1048
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz initMeta_after_if_else@12
    dig 5
    bury 9

initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@13:
    // smart_contracts/social/contract.algo.ts:1050
    // const userIsSender = (Txn.sender === user)
    txn Sender
    dig 6
    ==
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 10
    concat
    // smart_contracts/social/contract.algo.ts:1052
    // assert(!this.meta(origin).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/social/contract.algo.ts:1054-1061
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 7
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1057
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1054-1061
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1058
    // amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 56 // 56
    extract_uint64
    intc 6 // 31700
    +
    // smart_contracts/social/contract.algo.ts:1054-1061
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1063
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1063
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1063
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    pushint 16 // 16
    extract_uint64
    dup
    bury 10
    // smart_contracts/social/contract.algo.ts:1065-1070
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1067
    // receiver: Application(impact).address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:1068
    // amount: ImpactMetaMBR
    intc 6 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1065-1069
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1065-1070
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1072
    // if (automated) {
    dig 5
    bz initMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1073
    // this.createDefaultMeta(origin, userIsSender, wallet.id, true)
    dig 9
    dup
    uncover 2
    dig 3
    intc_1 // 1
    callsub createDefaultMeta
    // smart_contracts/social/contract.algo.ts:1075-1083
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     origin,
    //     0,
    //     0,
    //     0
    //   ]
    // })
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1079
    // 0,
    intc_0 // 0
    itob
    // smart_contracts/social/contract.algo.ts:1075-1083
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     origin,
    //     0,
    //     0,
    //     0
    //   ]
    // })
    bytec 27 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1085
    // return 0
    intc_0 // 0

initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7:
    // smart_contracts/social/contract.algo.ts:1040-1047
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

initMeta_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1088
    // this.createDefaultMeta(origin, userIsSender, wallet.id, false)
    dig 9
    dup
    uncover 2
    dig 3
    intc_0 // 0
    callsub createDefaultMeta
    // smart_contracts/social/contract.algo.ts:1090-1098
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1091
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1091
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1091
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1090-1098
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    bytec 27 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1100
    // return impactScore + this.getSocialImpactScore(origin)
    swap
    callsub getSocialImpactScore
    +
    // smart_contracts/social/contract.algo.ts:1040-1047
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    b initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7

initMeta_after_if_else@12:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dup
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    bury 9
    // smart_contracts/social/contract.algo.ts:1049
    // const origin = originOr(wallet, user)
    b initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@13


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPayWall[routing]() -> void:
createPayWall:
    // smart_contracts/social/contract.algo.ts:1103
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1104-1112
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1107
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1104-1112
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1109
    // greaterThanEq: this.payWallMbr(payWall)
    uncover 2
    callsub smart_contracts/social/base.ts::BaseSocial.payWallMbr
    // smart_contracts/social/contract.algo.ts:1104-1112
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    cover 2
    >=
    uncover 2
    &&
    assert // assert target is match for conditions
    // smart_contracts/social/contract.algo.ts:1114
    // const id = this.payWallId.value
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 20 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1114
    // const id = this.payWallId.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/social/contract.algo.ts:1115
    // this.payWallId.value++
    dup
    intc_1 // 1
    +
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 20 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1115
    // this.payWallId.value++
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:1117
    // this.paywall(id).value = clone(payWall)
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 19 // "w"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1117
    // this.paywall(id).value = clone(payWall)
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/social/contract.algo.ts:1103
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateMeta[routing]() -> void:
updateMeta:
    // smart_contracts/social/contract.algo.ts:1122-1129
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1130
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1130
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz updateMeta_after_if_else@3
    dup

updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1133
    // assert(this.meta(origin).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1135
    // this.meta(origin).value.followGateID = followGateID
    dup
    pushint 50 // 50
    dig 12
    box_replace
    // smart_contracts/social/contract.algo.ts:1136
    // this.meta(origin).value.addressGateID = addressGateID
    dup
    pushint 58 // 58
    dig 11
    box_replace
    // smart_contracts/social/contract.algo.ts:1137
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    dig 4
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 19 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1137
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    box_len
    bury 1
    assert // ERR:NOPAYWALL
    // smart_contracts/social/contract.algo.ts:1138
    // this.meta(origin).value.defaultPayWallID = defaultPayWallID
    pushint 66 // 66
    dig 6
    box_replace
    // smart_contracts/social/contract.algo.ts:1140
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1140
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1140
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1141-1149
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     origin,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // })
    itxn_begin
    bytec 27 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    // smart_contracts/social/contract.algo.ts:1122-1129
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    return // on error: invalid number of bytes for uint64

updateMeta_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateFollowerMeta[routing]() -> void:
updateFollowerMeta:
    // smart_contracts/social/contract.algo.ts:1152
    // updateFollowerMeta(address: Account, newFollowerIndex: uint64, newFollowerCount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1153
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1153
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1153
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    intc_2 // 8
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the social graph app
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    uncover 3
    concat
    // smart_contracts/social/contract.algo.ts:1154
    // this.meta(address).value.followerIndex = newFollowerIndex
    dup
    pushint 33 // 33
    uncover 4
    box_replace
    // smart_contracts/social/contract.algo.ts:1155
    // this.meta(address).value.followerCount = newFollowerCount
    pushint 41 // 41
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:1152
    // updateFollowerMeta(address: Account, newFollowerIndex: uint64, newFollowerCount: uint64): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned[routing]() -> void:
isBanned:
    // smart_contracts/social/contract.algo.ts:1160
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserSocialImpact[routing]() -> void:
getUserSocialImpact:
    // smart_contracts/social/contract.algo.ts:1168
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1170
    // return this.getSocialImpactScore(user)
    callsub getSocialImpactScore
    // smart_contracts/social/contract.algo.ts:1168
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMeta[routing]() -> void:
getMeta:
    // smart_contracts/social/contract.algo.ts:1173
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1175
    // return this.meta(user).value
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1173
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPost[routing]() -> void:
getPost:
    // smart_contracts/social/contract.algo.ts:1178
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1180
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1181
    // return this.posts(ref).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1178
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getVote[routing]() -> void:
getVote:
    // smart_contracts/social/contract.algo.ts:1184
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1186
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1186
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz getVote_after_if_else@3
    dup

getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1189
    // const voteListKey: VoteListKey = { user: b16(origin.bytes), ref: b16(ref) }
    callsub b16
    dig 3
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1190
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1192
    // return this.votelist(voteListKey).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1184
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getVote_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostMeta[routing]() -> void:
getPostMeta:
    // smart_contracts/social/contract.algo.ts:1195
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:1197
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1198
    // const post = clone(this.posts(ref).value)
    dup
    box_get
    pop
    cover 3
    // smart_contracts/social/contract.algo.ts:1198-1199
    // const post = clone(this.posts(ref).value)
    // const meta = clone(this.meta(post.creator).value)
    intc_0 // 0
    intc_3 // 32
    box_extract
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1199
    // const meta = clone(this.meta(post.creator).value)
    box_get
    swap
    cover 3
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1200
    // let reactionExists = false
    intc_0 // 0
    cover 2
    // smart_contracts/social/contract.algo.ts:1201
    // if (this.reactions({ ref, NFT }).exists) {
    itob
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 26 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1201
    // if (this.reactions({ ref, NFT }).exists) {
    box_len
    bury 1
    bz getPostMeta_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1202
    // reactionExists = true
    intc_1 // 1
    bury 1

getPostMeta_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1204
    // return { post, meta, reactionExists }
    dig 4
    dup
    intc_3 // 32
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 57 // 57
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    uncover 3
    pushint 58 // 58
    intc_1 // 1
    box_extract
    dig 7
    dup
    pushint 59 // 59
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    uncover 4
    itob
    dig 7
    swap
    concat
    uncover 4
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    concat
    uncover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    pushbytes 0x0034
    concat
    swap
    concat
    dig 2
    dup
    intc_0 // 0
    getbit
    dig 1
    extract 1 8
    dig 2
    extract 9 8
    dig 3
    extract 17 8
    dig 4
    extract 25 8
    dig 5
    extract 33 8
    dig 6
    extract 41 8
    dig 7
    pushint 392 // 392
    getbit
    dig 8
    extract 50 8
    uncover 9
    extract 58 8
    bytec_2 // 0x00
    intc_0 // 0
    uncover 11
    setbit
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    concat
    uncover 2
    concat
    swap
    concat
    pushbytes 0x0045
    swap
    concat
    bytec_2 // 0x00
    intc_0 // 0
    dig 4
    setbit
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1195
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.mbr[routing]() -> void:
mbr:
    // smart_contracts/social/base.ts:14
    // mbr(ref: bytes): AkitaSocialMBRData {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.payWallMbr[routing]() -> void:
payWallMbr:
    // smart_contracts/social/base.ts:30
    // payWallMbr(paywall: ViewPayWallValue): uint64 {
    txna ApplicationArgs 1
    callsub smart_contracts/social/base.ts::BaseSocial.payWallMbr
    pop
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements[routing]() -> void:
checkTipMbrRequirements:
    // smart_contracts/social/base.ts:51
    // checkTipMbrRequirements(akitaDAO: Application, creator: Account, wallet: Application): tipMBRInfo {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:132
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:133
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:133
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:134
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:132
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 15 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:51
    // const updatePlugin = getPluginAppList(this.akitaDAO.value).update
    pushint 16 // 16
    extract_uint64
    // smart_contracts/utils/base-contracts/base.ts:52
    // assert(Global.callerApplicationId === updatePlugin, ERR_INVALID_UPGRADE)
    global CallerApplicationID
    ==
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 29 // "version"
    // smart_contracts/utils/base-contracts/base.ts:53
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:40
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isReply(postType: bytes) -> uint64:
isReply:
    // smart_contracts/social/contract.algo.ts:57
    // private isReply(postType: PostType): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:58
    // return postType === PostTypeReply || postType === PostTypeEditReply
    frame_dig -1
    bytec 17 // 0x01
    ==
    bnz isReply_bool_true@2
    frame_dig -1
    bytec 14 // 0x03
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:58
    // return postType === PostTypeReply || postType === PostTypeEditReply
    retsub

isReply_bool_false@3:
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:58
    // return postType === PostTypeReply || postType === PostTypeEditReply
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isAmended(ref: bytes, postType: bytes) -> uint64:
isAmended:
    // smart_contracts/social/contract.algo.ts:81
    // private isAmended(ref: bytes, postType: PostType): boolean {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:68
    // case PostTypePost:
    frame_dig -1
    bytec_2 // 0x00
    ==
    // smart_contracts/social/contract.algo.ts:68-69
    // case PostTypePost:
    //   return 36
    bz isAmended_after_if_else@3
    // smart_contracts/social/contract.algo.ts:69
    // return 36
    pushint 36 // 36

isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10:
    // smart_contracts/social/contract.algo.ts:84
    // return ref.length > baseLength
    frame_dig -2
    len
    <
    retsub

isAmended_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:70
    // case PostTypeReply:
    frame_dig -1
    bytec 17 // 0x01
    ==
    // smart_contracts/social/contract.algo.ts:70-71
    // case PostTypeReply:
    //   return 68
    bz isAmended_after_if_else@5
    // smart_contracts/social/contract.algo.ts:71
    // return 68
    pushint 68 // 68
    // smart_contracts/social/contract.algo.ts:83
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:72
    // case PostTypeEditPost:
    frame_dig -1
    bytec 25 // 0x02
    ==
    // smart_contracts/social/contract.algo.ts:72-73
    // case PostTypeEditPost:
    //   return 68
    bz isAmended_after_if_else@7
    // smart_contracts/social/contract.algo.ts:73
    // return 68
    pushint 68 // 68
    // smart_contracts/social/contract.algo.ts:83
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:74
    // case PostTypeEditReply:
    frame_dig -1
    bytec 14 // 0x03
    ==
    // smart_contracts/social/contract.algo.ts:74-75
    // case PostTypeEditReply:
    //   return 100
    bz isAmended_after_if_else@9
    // smart_contracts/social/contract.algo.ts:75
    // return 100
    pushint 100 // 100
    // smart_contracts/social/contract.algo.ts:83
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@9:
    // smart_contracts/social/contract.algo.ts:77
    // return 36
    pushint 36 // 36
    // smart_contracts/social/contract.algo.ts:83
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10


// smart_contracts/social/contract.algo.ts::AkitaSocial.toBytes32(type: bytes, ref: bytes) -> bytes:
toBytes32:
    // smart_contracts/social/contract.algo.ts:87
    // private toBytes32(type: RefType, ref: bytes): { refBytes: bytes<32>, creator: Account } {
    proto 2 1
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:89
    // let creator: Account = Global.zeroAddress
    global ZeroAddress
    // smart_contracts/social/contract.algo.ts:91
    // case RefTypePost:
    frame_dig -2
    bytec 16 // 0x0a
    ==
    // smart_contracts/social/contract.algo.ts:91-94
    // case RefTypePost:
    //   assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    //   refBytes = ref.toFixed({ length: 32 })
    //   break
    bz toBytes32_after_if_else@3
    // smart_contracts/social/contract.algo.ts:92
    // assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_3 // 32
    ==
    assert // Invalid reference length, must be 32 bytes
    frame_dig -1

toBytes32_block@19:
    // smart_contracts/social/contract.algo.ts:129
    // return { refBytes, creator }
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig 1
    concat
    frame_bury 0
    retsub

toBytes32_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:95
    // case RefTypeAsset:
    frame_dig -2
    bytec 6 // 0x14
    ==
    // smart_contracts/social/contract.algo.ts:95-100
    // case RefTypeAsset:
    //   assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    //   assert(Asset(btoi(ref)).total > 0, ERR_INVALID_ASSET)
    //   refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    //   creator = Asset(btoi(ref)).creator
    //   break
    bz toBytes32_after_if_else@6
    // smart_contracts/social/contract.algo.ts:96
    // assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_2 // 8
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:97
    // assert(Asset(btoi(ref)).total > 0, ERR_INVALID_ASSET)
    frame_dig -1
    btoi
    dup
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:98
    // refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:99
    // creator = Asset(btoi(ref)).creator
    asset_params_get AssetCreator
    swap
    frame_bury 1
    assert // asset exists
    // smart_contracts/social/contract.algo.ts:100
    // break
    b toBytes32_block@19

toBytes32_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:101
    // case RefTypeAddress:
    frame_dig -2
    pushbytes 0x1e
    ==
    // smart_contracts/social/contract.algo.ts:101-111
    // case RefTypeAddress:
    //   assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    //   refBytes = ref.toFixed({ length: 32 })
    //   creator = Account(refBytes)
    // 
    //   if (this.meta(creator).exists) {
    //     const { addressGateID } = this.meta(creator).value
    //     assert(addressGateID === 0, ERR_HAS_GATE)
    //   }
    // 
    //   break
    bz toBytes32_after_if_else@11
    // smart_contracts/social/contract.algo.ts:102
    // assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_3 // 32
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:106
    // if (this.meta(creator).exists) {
    box_len
    bury 1
    bz toBytes32_after_if_else@10
    // smart_contracts/social/contract.algo.ts:107
    // const { addressGateID } = this.meta(creator).value
    frame_dig 0
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:108
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

toBytes32_after_if_else@10:
    frame_dig -1
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:111
    // break
    b toBytes32_block@19

toBytes32_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:112
    // case RefTypeApp:
    frame_dig -2
    pushbytes 0x28
    ==
    // smart_contracts/social/contract.algo.ts:112-117
    // case RefTypeApp:
    //   assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    //   assert(Application(btoi(ref)).approvalProgram.length > 0, ERR_INVALID_APP)
    //   refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    //   creator = Application(btoi(ref)).creator
    //   break
    bz toBytes32_after_if_else@14
    // smart_contracts/social/contract.algo.ts:113
    // assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_2 // 8
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:114
    // assert(Application(btoi(ref)).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -1
    btoi
    dup
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:115
    // refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:116
    // creator = Application(btoi(ref)).creator
    app_params_get AppCreator
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/social/contract.algo.ts:117
    // break
    b toBytes32_block@19

toBytes32_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:118
    // case RefTypeExternal:
    frame_dig -2
    pushbytes 0x32
    ==
    // smart_contracts/social/contract.algo.ts:118-124
    // case RefTypeExternal:
    //   // External refs (Twitter, Farcaster, etc.) - ref is the platform-prefixed identifier
    //   // Key is derived deterministically: sha256(ref) where ref = "platform:externalId"
    //   // Creator is zero address since external content has no Algorand creator
    //   refBytes = op.sha256(ref)
    //   creator = Global.zeroAddress
    //   break
    assert // Invalid reply type
    // smart_contracts/social/contract.algo.ts:122
    // refBytes = op.sha256(ref)
    frame_dig -1
    sha256
    // smart_contracts/social/contract.algo.ts:123
    // creator = Global.zeroAddress
    global ZeroAddress
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:124
    // break
    b toBytes32_block@19


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBlocked(user: bytes, blocked: bytes) -> uint64:
isBlocked:
    // smart_contracts/social/contract.algo.ts:132
    // private isBlocked(user: Account, blocked: Account): boolean {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:133-136
    // return abiCall<typeof AkitaSocialGraph.prototype.isBlocked>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    //   args: [user, blocked]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:134
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:134
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:134
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:133-136
    // return abiCall<typeof AkitaSocialGraph.prototype.isBlocked>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    //   args: [user, blocked]
    // }).returnValue
    pushbytes 0x4303668e // method "isBlocked(address,address)bool"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/social/contract.algo.ts:139
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    dupn 5
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:142
    // if (!this.meta(account).exists) {
    box_len
    bury 1
    bnz getSocialImpactScore_after_if_else@2
    // smart_contracts/social/contract.algo.ts:143
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getSocialImpactScore_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:146
    // const { streak, startDate } = clone(this.meta(account).value)
    frame_dig 7
    box_get
    assert // Box must have value
    dup
    pushint 9 // 9
    extract_uint64
    dup
    cover 2
    frame_bury 6
    pushint 17 // 17
    extract_uint64
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:149
    // if (streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@4
    // smart_contracts/social/contract.algo.ts:150
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:158
    // const accountAge: uint64 = Global.latestTimestamp - startDate
    global LatestTimestamp
    frame_dig 5
    -
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:160
    // if (accountAge >= TWO_YEARS) {
    intc 7 // 63072000
    >=
    bz getSocialImpactScore_else_body@7
    // smart_contracts/social/contract.algo.ts:161
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@8:
    // smart_contracts/social/contract.algo.ts:40
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:168
    // if (this.votes(account.bytes).exists) {
    box_len
    bury 1
    bz getSocialImpactScore_after_if_else@18
    // smart_contracts/social/contract.algo.ts:169
    // const { voteCount, isNegative } = this.votes(account.bytes).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:171
    // let impact: uint64 = (voteCount * 75) / 100_000
    pushint 75 // 75
    *
    intc 4 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:172
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@11
    // smart_contracts/social/contract.algo.ts:173
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:176
    // if (isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@16
    // smart_contracts/social/contract.algo.ts:178
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@14
    // smart_contracts/social/contract.algo.ts:179
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@18:
    // smart_contracts/social/contract.algo.ts:189
    // return socialImpact
    frame_dig 4
    frame_bury 0
    retsub

getSocialImpactScore_else_body@14:
    // smart_contracts/social/contract.algo.ts:181
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@18

getSocialImpactScore_else_body@16:
    // smart_contracts/social/contract.algo.ts:185
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@18

getSocialImpactScore_else_body@7:
    // smart_contracts/social/contract.algo.ts:164
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    intc 7 // 63072000
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@8

getSocialImpactScore_else_body@4:
    // smart_contracts/social/contract.algo.ts:153
    // socialImpact += (streak * 100) / 60
    frame_dig 6
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:192
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:193-196
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:194
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:194
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:194
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:193-196
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:198
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.sendReactionPayments(receiver: bytes, wallet: uint64, preReferralTax: uint64) -> uint64:
sendReactionPayments:
    // smart_contracts/social/contract.algo.ts:290
    // private sendReactionPayments(receiver: Account, wallet: Application, preReferralTax: uint64): uint64 {
    proto 3 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/social/contract.algo.ts:291
    // const { type, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:291
    // const { type, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -3
    frame_dig -2
    callsub smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements
    dup
    extract 0 1
    swap
    intc_1 // 1
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:292
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:292
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:292
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:293
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, preReferralTax)
    frame_dig -1
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:294
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:294
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:294
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:296
    // if (type === TipSendTypeARC58) {
    bytec 6 // 0x14
    ==
    bz sendReactionPayments_after_if_else@2
    // smart_contracts/social/contract.algo.ts:297
    // this.arc58SendReactionPayments(wallet, akta, leftover, (reactFee - preReferralTax))
    frame_dig -1
    -
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -2
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:217
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:217
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 15 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:217
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:219-228
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    itxn_begin
    bytec 30 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:223
    // true, // global
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:224
    // '', // default account
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:225
    // [], // no method offsets
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:226
    // [] // no funds request
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:219-228
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:230-241
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:237
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    dig 2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/social/contract.algo.ts:236-239
    // itxn.payment({
    //   amount: Global.assetOptInMinBalance,
    //   receiver: origin
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:230-241
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:233
    // wallet,
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:235
    // [asset],
    frame_dig 3
    dup
    cover 2
    itob
    bytec 22 // 0x0001
    swap
    concat
    // smart_contracts/social/contract.algo.ts:230-241
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    bytec 23 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:223
    // true, // global
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:230-241
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:243-245
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({
    //   appId: wallet
    // })
    itxn_next
    bytec 31 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:247-253
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    // smart_contracts/social/contract.algo.ts:249
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:249
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 1
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:248-252
    // itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:255-261
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: origin,
    //     assetAmount: remainder,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:256-260
    // itxn.assetTransfer({
    //   assetReceiver: origin,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:263
    // itxnCompose.submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:298
    // return arc58
    frame_dig 2
    frame_bury 0
    retsub

sendReactionPayments_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:301
    // this.sendDirectReactionPayments(receiver, akta, leftover, (reactFee - preReferralTax))
    frame_dig -1
    -
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:269
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:269
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    swap
    frame_bury 0
    assert // application exists
    // smart_contracts/social/contract.algo.ts:274
    // if (remainder > 0 && creator.isOptedIn(Asset(asset))) {
    bz sendReactionPayments_else_body@6
    frame_dig -3
    frame_dig 3
    asset_holding_get AssetBalance
    bury 1
    bz sendReactionPayments_else_body@6
    // smart_contracts/social/contract.algo.ts:281
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_begin
    frame_dig 3
    dup
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    frame_dig 0
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:268-272
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:281
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_next
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:275-279
    // const xferTxn = itxn.assetTransfer({
    //   assetReceiver: creator,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:281
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_submit

sendReactionPayments_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:302
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

sendReactionPayments_else_body@6:
    // smart_contracts/social/contract.algo.ts:284
    // assetAmount: tax + remainder
    frame_dig 4
    frame_dig 1
    +
    // smart_contracts/social/contract.algo.ts:286
    // taxTxn.submit()
    itxn_begin
    frame_dig 3
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig 0
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:268-272
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:286
    // taxTxn.submit()
    itxn_submit
    b sendReactionPayments_after_if_else@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.createEmptyPostIfNecessary(key: bytes, creator: bytes) -> uint64:
createEmptyPostIfNecessary:
    // smart_contracts/social/contract.algo.ts:305
    // private createEmptyPostIfNecessary(key: bytes<32>, creator: Account): uint64 {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:306
    // if (!this.posts(key).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/social/contract.algo.ts:317
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:307-323
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   postType: PostTypePost,
    // }
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:318
    // gateID: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:307-323
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   postType: PostTypePost,
    // }
    itob
    swap
    dig 1
    concat
    bytec_2 // 0x00
    concat
    swap
    concat
    pushbytes 0x0000003d0000
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:325
    // return this.mbr(Bytes('')).posts
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 16 // 16
    extract_uint64
    swap
    retsub

createEmptyPostIfNecessary_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:327
    // return 0
    intc_0 // 0
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/social/contract.algo.ts:330
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/social/contract.algo.ts:331
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:333
    // const { startDate, lastActive } = this.meta(account).value
    dup
    box_get
    pop
    dup
    pushint 17 // 17
    extract_uint64
    swap
    pushint 25 // 25
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/social/contract.algo.ts:335
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    intc 8 // 86400
    %
    -
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:336
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    intc 8 // 86400
    -
    // smart_contracts/social/contract.algo.ts:338
    // this.meta(account).value.lastActive = Global.latestTimestamp
    global LatestTimestamp
    itob
    uncover 3
    pushint 25 // 25
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:341
    // if (lastWindowStart > lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/social/contract.algo.ts:342
    // this.meta(account).value.streak = 1
    intc_1 // 1
    itob
    frame_dig 0
    pushint 9 // 9
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:343
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:348
    // if (lastActive < thisWindowStart) {
    frame_dig 1
    frame_dig 2
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/social/contract.algo.ts:349
    // this.meta(account).value.streak += 1
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    pushint 9 // 9
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 9 // 9
    swap
    box_replace

updateStreak_after_if_else@4:
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/social/contract.algo.ts:385
    // private updateVotes(ref: bytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    pushbytes ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:40
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/social/contract.algo.ts:356
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/social/contract.algo.ts:357
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat

updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20:
    // smart_contracts/social/contract.algo.ts:386
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    dup
    extract 0 8
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:387
    // this.votes(ref).value = { voteCount, isNegative }
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:360
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    pushint 64 // 64
    getbit
    frame_bury 1
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:363
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/social/contract.algo.ts:363
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:365
    // if (voteCount === 0) {
    frame_dig 2
    bnz updateVotes_after_if_else@11
    // smart_contracts/social/contract.algo.ts:366
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:386
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:369
    // if (impact === voteCount && differingDirections) {
    frame_dig -1
    frame_dig 2
    ==
    bz updateVotes_after_if_else@14
    frame_dig 0
    bz updateVotes_after_if_else@14
    // smart_contracts/social/contract.algo.ts:370
    // return { newCount: 0, isNegative: false }
    pushbytes 0x000000000000000000
    // smart_contracts/social/contract.algo.ts:386
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:375
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/social/contract.algo.ts:376
    // if (flip) {
    bz updateVotes_after_if_else@16
    // smart_contracts/social/contract.algo.ts:377
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/social/contract.algo.ts:378
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    swap
    itob
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:386
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:381
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@18
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@19:
    // smart_contracts/social/contract.algo.ts:382
    // return { newCount, isNegative }
    itob
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:386
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_ternary_false@18:
    // smart_contracts/social/contract.algo.ts:381
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@19

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/social/contract.algo.ts:390
    // private createVoteList(ref: bytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:391
    // const voteListKey: VoteListKey = { user: b16(account.bytes), ref: b16(ref) }
    frame_dig -2
    callsub b16
    frame_dig -4
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:392
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 18 // "o"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:392
    // this.votelist(voteListKey).value = { impact, isUp }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPost(postKey: bytes, origin: bytes, mbrPayment: uint64, cid: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, postType: bytes, amendmentOf: bytes) -> void:
createPost:
    // smart_contracts/social/contract.algo.ts:395-405
    // private createPost(
    //   postKey: bytes<32>,
    //   origin: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   postType: PostType,
    //   amendmentOf: bytes<32>,
    // ): void {
    proto 9 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/social/contract.algo.ts:406
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -8
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:408
    // (!usePayWall && payWallID === 0) || (
    frame_dig -4
    bnz createPost_or_contd@2
    frame_dig -3
    bz createPost_bool_true@7

createPost_or_contd@2:
    // smart_contracts/social/contract.algo.ts:409-412
    // usePayWall && (
    //   payWallID !== 0 && this.paywall(payWallID).exists ||
    //   payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    // )
    frame_dig -4
    bz createPost_bool_false@8
    // smart_contracts/social/contract.algo.ts:410
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    frame_dig -3
    bz createPost_or_contd@5
    frame_dig -3
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 19 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:410
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    box_len
    bury 1
    bnz createPost_bool_true@7

createPost_or_contd@5:
    // smart_contracts/social/contract.algo.ts:411
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    frame_dig -3
    bnz createPost_bool_false@8
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -8
    concat
    // smart_contracts/social/contract.algo.ts:411
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    box_get
    assert // Box must have value
    extract 66 8
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 19 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:411
    // payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    box_len
    bury 1
    bz createPost_bool_false@8

createPost_bool_true@7:
    intc_1 // 1

createPost_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:407-415
    // assert(
    //   (!usePayWall && payWallID === 0) || (
    //     usePayWall && (
    //       payWallID !== 0 && this.paywall(payWallID).exists ||
    //       payWallID === 0 && this.paywall(this.meta(origin).value.defaultPayWallID).exists
    //     )
    //   ),
    //   ERR_INVALID_PAYWALL
    // )
    assert // Invalid paywall
    // smart_contracts/social/contract.algo.ts:417
    // const isEditPost = postType === PostTypeEditPost
    frame_dig -2
    bytec 25 // 0x02
    ==
    // smart_contracts/social/contract.algo.ts:419
    // const editExtraMbr: uint64 = isEditPost ? EditBackRefMBR : 0
    dup
    intc 5 // 13200
    *
    // smart_contracts/social/contract.algo.ts:420
    // this.validatePostPayment(mbrPayment, cid, isEditPost, editExtraMbr)
    frame_dig -7
    frame_dig -6
    dig 3
    uncover 3
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:424
    // this.updateStreak(origin)
    frame_dig -8
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:426
    // const impact = this.getUserImpact(origin)
    frame_dig -8
    callsub getUserImpact
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -9
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:428
    // assert(!this.posts(postKey).exists, 'ERR:POST_EXISTS')
    box_len
    bury 1
    !
    assert // ERR:POST_EXISTS
    // smart_contracts/social/contract.algo.ts:433-435
    // const postRef: bytes = isEditPost
    //   ? Bytes(cid).concat(amendmentOf)
    //   : Bytes(cid)
    bz createPost_ternary_false@11
    // smart_contracts/social/contract.algo.ts:434
    // ? Bytes(cid).concat(amendmentOf)
    frame_dig -6
    frame_dig -1
    concat

createPost_ternary_merge@12:
    // smart_contracts/social/contract.algo.ts:440
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:437-446
    // this.posts(postKey).value = {
    //   ref: postRef,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   postType: postType,
    // }
    itob
    frame_dig -8
    swap
    concat
    frame_dig -5
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -4
    setbit
    concat
    frame_dig -3
    itob
    concat
    bytec_2 // 0x00
    concat
    frame_dig -2
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 32 // 0x003d
    concat
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:447
    // this.updateVotes(postKey, true, impact)
    frame_dig -9
    intc_1 // 1
    frame_dig 1
    dup
    cover 3
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:448
    // this.createVoteList(postKey, true, origin, impact)
    frame_dig -9
    intc_1 // 1
    frame_dig -8
    uncover 3
    callsub createVoteList
    // smart_contracts/social/contract.algo.ts:202
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:202
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:202
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    dig 1
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:203
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:204
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, postFee)
    uncover 2
    dig 2
    uncover 2
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:206-212
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:208
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:208
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:206-211
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:206-212
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    retsub

createPost_ternary_false@11:
    frame_dig -6
    b createPost_ternary_merge@12

createPost_bool_false@8:
    intc_0 // 0
    b createPost_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReply(replyKey: bytes, origin: bytes, mbrPayment: uint64, mbrNeeded: uint64, cid: bytes, parentRef: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, postType: bytes, amendmentOf: bytes) -> void:
createReply:
    // smart_contracts/social/contract.algo.ts:452-464
    // private createReply(
    //   replyKey: bytes<32>,
    //   origin: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   cid: CID,
    //   parentRef: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   postType: PostType,
    //   amendmentOf: bytes<32>,
    // ): void {
    proto 11 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:465
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -10
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -6
    concat
    // smart_contracts/social/contract.algo.ts:466
    // const { creator } = this.posts(parentRef).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:467
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    dup
    frame_dig -10
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:471
    // this.updateStreak(origin)
    frame_dig -10
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:473
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:474
    // const creatorImpact = this.getUserImpact(creator)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:475
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:475
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:121
    // const { impactTaxMin, impactTaxMax } = getSocialFees(akitaDAO)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:122
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:477
    // const isEditReply = postType === PostTypeEditReply
    frame_dig -2
    bytec 14 // 0x03
    ==
    dup
    cover 2
    cover 4
    // smart_contracts/social/contract.algo.ts:480
    // extra += this.sendReactionPayments(creator, Application(wallet), tax)
    uncover 3
    uncover 3
    uncover 2
    callsub sendReactionPayments
    frame_dig -8
    +
    swap
    // smart_contracts/social/contract.algo.ts:481
    // if (isEditReply) {
    bz createReply_after_if_else@2
    // smart_contracts/social/contract.algo.ts:482
    // extra += EditBackRefMBR
    intc 5 // 13200
    +

createReply_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:485
    // this.validatePostPayment(mbrPayment, cid, isEditReply, extra)
    frame_dig -9
    frame_dig -7
    frame_dig 1
    dup
    cover 3
    uncover 4
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -11
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:487
    // assert(!this.posts(replyKey).exists, 'ERR:POST_EXISTS')
    box_len
    bury 1
    !
    assert // ERR:POST_EXISTS
    // smart_contracts/social/contract.algo.ts:492-494
    // const replyRef: bytes = isEditReply
    //   ? Bytes(cid).concat(parentRef).concat(amendmentOf)
    //   : Bytes(cid).concat(parentRef)
    bz createReply_ternary_false@4
    // smart_contracts/social/contract.algo.ts:493
    // ? Bytes(cid).concat(parentRef).concat(amendmentOf)
    frame_dig -7
    frame_dig -6
    concat
    frame_dig -1
    concat

createReply_ternary_merge@5:
    // smart_contracts/social/contract.algo.ts:499
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:496-505
    // this.posts(replyKey).value = {
    //   ref: replyRef,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   postType: postType,
    // }
    itob
    frame_dig -10
    swap
    concat
    frame_dig -5
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -4
    setbit
    concat
    frame_dig -3
    itob
    concat
    bytec_2 // 0x00
    concat
    frame_dig -2
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 32 // 0x003d
    concat
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:507
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -10
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:508
    // this.updateVotes(replyKey, true, senderImpact)
    frame_dig -11
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:509
    // this.createVoteList(replyKey, true, origin, senderImpact)
    frame_dig -11
    intc_1 // 1
    frame_dig -10
    uncover 3
    callsub createVoteList
    retsub

createReply_ternary_false@4:
    // smart_contracts/social/contract.algo.ts:494
    // : Bytes(cid).concat(parentRef)
    frame_dig -7
    frame_dig -6
    concat
    b createReply_ternary_merge@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVote(origin: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/social/contract.algo.ts:512-518
    // private createVote(
    //   origin: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:519
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -5
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:520
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:522
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    dupn 2
    // smart_contracts/social/contract.algo.ts:523
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    frame_dig -5
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:525
    // const voteListKey: VoteListKey = { user: b16(origin.bytes), ref: b16(ref) }
    frame_dig -5
    callsub b16
    frame_dig -2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:526
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/social/contract.algo.ts:527
    // assert(origin !== creator, ERR_NO_SELF_VOTE)
    frame_dig -5
    !=
    assert // Cannot vote on your own content
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -5
    concat
    // smart_contracts/social/contract.algo.ts:529
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    pushint 392 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:530
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:532
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:532
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:532
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:536
    // this.updateStreak(origin)
    frame_dig -5
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:537
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:537
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:537
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    intc_2 // 8
    extract_uint64
    swap
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:539
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@2
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig 0
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:540
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:542
    // const recipientImpact = this.getUserImpact(creator)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:543
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 3
    frame_dig 4
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:545
    // const extra = this.sendReactionPayments(creator, Application(wallet), tax)
    callsub sendReactionPayments
    // smart_contracts/social/contract.algo.ts:547-554
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:550
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:547-554
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:551
    // amount: mbrNeeded + extra
    frame_dig -3
    uncover 3
    +
    // smart_contracts/social/contract.algo.ts:547-554
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment

createVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:575
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -5
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:576
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:577
    // this.createVoteList(ref, isUp, origin, senderImpact)
    frame_dig -2
    frame_dig -1
    frame_dig -5
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@2:
    // smart_contracts/social/contract.algo.ts:556-563
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:559
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:556-563
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    frame_dig -3
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:565-571
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:567
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 7 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:567
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field XferAsset
    frame_dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:565-570
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:565-571
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    b createVote_after_if_else@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReaction(origin: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, NFT: uint64) -> void:
createReaction:
    // smart_contracts/social/contract.algo.ts:580-586
    // private createReaction(
    //   origin: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:587
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -5
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:588
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:589
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:590
    // assert(!this.isBlocked(creator, origin), ERR_BLOCKED)
    dup
    frame_dig -5
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:592
    // assert(AssetHolding.assetBalance(origin, NFT)[0] > 0, ERR_USER_DOES_NOT_OWN_NFT)
    frame_dig -5
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    assert // User does not own this NFT
    // smart_contracts/social/contract.algo.ts:594
    // const reactionListKey: ReactionListKey = { user: b16(origin.bytes), ref: b16(ref), NFT }
    frame_dig -5
    callsub b16
    frame_dig -2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    frame_dig -1
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:46
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:596
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:600
    // this.updateStreak(origin)
    frame_dig -5
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:602
    // const { wallet } = this.meta(creator).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:603
    // const recipientImpact = this.getUserImpact(creator)
    dig 2
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:604
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:604
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:604
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:605
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:607
    // const reactionKey: ReactionsKey = { ref, NFT }
    frame_dig -2
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig -2
    uncover 3
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 26 // "r"
    swap
    concat
    dup
    cover 4
    // smart_contracts/social/contract.algo.ts:608
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:611
    // extra += this.sendReactionPayments(creator, Application(wallet), tax)
    cover 3
    callsub sendReactionPayments
    frame_dig -3
    +
    swap
    // smart_contracts/social/contract.algo.ts:663
    // const { reactionlist, reactions } = this.mbr(Bytes(''))
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    dup
    pushint 48 // 48
    extract_uint64
    cover 2
    pushint 40 // 40
    extract_uint64
    cover 2
    // smart_contracts/social/contract.algo.ts:664-666
    // const mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz createReaction_ternary_false@6

createReaction_ternary_merge@7:
    // smart_contracts/social/contract.algo.ts:668-675
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:671
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:668-675
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:672
    // amount: mbrAmount + extra
    uncover 2
    frame_dig 3
    +
    // smart_contracts/social/contract.algo.ts:668-675
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:615
    // if (reactionExists) {
    frame_dig 2
    bz createReaction_else_body@2
    // smart_contracts/social/contract.algo.ts:616
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:621
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    retsub

createReaction_else_body@2:
    // smart_contracts/social/contract.algo.ts:618
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@3

createReaction_ternary_false@6:
    // smart_contracts/social/contract.algo.ts:666
    // : reactions + reactionlist
    frame_dig 4
    +
    b createReaction_ternary_merge@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.validateTip(tip: uint64, action: bytes) -> void:
validateTip:
    // smart_contracts/social/contract.algo.ts:624
    // private validateTip(tip: gtxn.AssetTransferTxn, action: TipAction) {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:625
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:625
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:625
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 10 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:626
    // const { postFee, reactFee } = getSocialFees(this.akitaDAO.value)
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:627-635
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/social/contract.algo.ts:630
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:627-635
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    frame_dig -2
    gtxns XferAsset
    uncover 4
    ==
    &&
    frame_dig -2
    gtxns AssetAmount
    // smart_contracts/social/contract.algo.ts:632
    // assetAmount: (action === TipActionPost) ? postFee : reactFee
    frame_dig -1
    bytec 16 // 0x0a
    ==
    uncover 3
    uncover 4
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:627-635
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    assert // Invalid transfer
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validatePostPayment(mbrPayment: uint64, cid: bytes, isAmendment: uint64, extraAmount: uint64) -> void:
validatePostPayment:
    // smart_contracts/social/contract.algo.ts:638-643
    // private validatePostPayment(
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   isAmendment: boolean,
    //   extraAmount: uint64
    // ): void {
    proto 4 0
    pushbytes ""
    dup
    // smart_contracts/social/contract.algo.ts:644
    // const { posts, votes, votelist } = this.mbr(cid)
    frame_dig -3
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    dup
    pushint 16 // 16
    extract_uint64
    swap
    dup
    pushint 24 // 24
    extract_uint64
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:645
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:645
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:645
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    swap
    // smart_contracts/utils/functions.ts:548
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:549
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    // smart_contracts/utils/functions.ts:551
    // if (referrer === Global.zeroAddress) {
    global ZeroAddress
    ==
    bz validatePostPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:552
    // return 0
    intc_0 // 0

validatePostPayment_after_inlined_smart_contracts/utils/functions.ts::referralFee@9:
    // smart_contracts/social/contract.algo.ts:647
    // let amount: uint64 = posts + votes + votelist + referralFeeAmount + extraAmount
    frame_dig 2
    frame_dig 3
    +
    frame_dig 4
    +
    +
    frame_dig -1
    +
    // smart_contracts/social/contract.algo.ts:648
    // if (isAmendment) {
    frame_dig -2
    bz validatePostPayment_after_if_else@2
    // smart_contracts/social/contract.algo.ts:649
    // amount += AmendmentMBR
    intc 5 // 13200
    +

validatePostPayment_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:652-659
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:655
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:652-659
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    retsub

validatePostPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig 5
    bytec 21 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:482
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 1
    // smart_contracts/utils/functions.ts:483
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocationsLength)
    intc 9 // 60600
    frame_bury 0
    // smart_contracts/utils/functions.ts:485
    // if (asset !== 0 && !Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 6
    bz validatePostPayment_after_if_else@8
    frame_dig 1
    app_params_get AppAddress
    assert // application exists
    frame_dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz validatePostPayment_after_if_else@8
    // smart_contracts/utils/functions.ts:483
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocationsLength)
    intc 9 // 60600
    // smart_contracts/utils/functions.ts:486
    // cost += Global.assetOptInMinBalance
    global AssetOptInMinBalance
    +
    frame_bury 0

validatePostPayment_after_if_else@8:
    frame_dig 0
    // smart_contracts/social/contract.algo.ts:646
    // const referralFeeAmount = referralFee(this.akitaDAO.value, akta)
    b validatePostPayment_after_inlined_smart_contracts/utils/functions.ts::referralFee@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createDefaultMeta(origin: bytes, initialized: uint64, wallet: uint64, automated: uint64) -> void:
createDefaultMeta:
    // smart_contracts/social/contract.algo.ts:678
    // private createDefaultMeta(origin: Account, initialized: boolean, wallet: uint64, automated: boolean): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:683
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:684
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:679-691
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    frame_dig -2
    itob
    concat
    // smart_contracts/social/contract.algo.ts:682
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:679-691
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:685
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:679-691
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    concat
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -4
    concat
    // smart_contracts/social/contract.algo.ts:679-691
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned(account: bytes) -> uint64:
smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned:
    // smart_contracts/social/contract.algo.ts:1160-1161
    // @abimethod({ readonly: true })
    // isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1162-1165
    // return abiCall<typeof AkitaSocialModeration.prototype.isBanned>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1163
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1163
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1163
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1162-1165
    // return abiCall<typeof AkitaSocialModeration.prototype.isBanned>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    //   args: [account]
    // }).returnValue
    bytec 28 // method "isBanned(address)bool"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub


// smart_contracts/social/base.ts::BaseSocial.mbr(ref: bytes) -> bytes:
smart_contracts/social/base.ts::BaseSocial.mbr:
    // smart_contracts/social/base.ts:14
    // mbr(ref: bytes): AkitaSocialMBRData {
    proto 1 1
    // smart_contracts/social/base.ts:18
    // posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    frame_dig -1
    len
    pushint 400 // 400
    *
    pushint 40100 // 40100
    +
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    pushbytes 0x0000000000007bd40000000000003d54
    swap
    concat
    // smart_contracts/social/base.ts:19
    // votes: VotesMBR,
    pushint 19300 // 19300
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:21
    // reactions: ReactionsMBR,
    pushint 22100 // 22100
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    // smart_contracts/social/base.ts:22
    // reactionlist: ReactionlistMBR,
    pushint 18900 // 18900
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/base.ts:23
    // meta: MetaMBR,
    pushint 45300 // 45300
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:26
    // actions: ActionsMBR
    pushint 29700 // 29700
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    retsub


// smart_contracts/social/base.ts::BaseSocial.payWallMbr(paywall: bytes) -> uint64, bytes:
smart_contracts/social/base.ts::BaseSocial.payWallMbr:
    // smart_contracts/social/base.ts:30
    // payWallMbr(paywall: ViewPayWallValue): uint64 {
    proto 1 2
    // smart_contracts/social/base.ts:33
    // PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    frame_dig -1
    pushint 2 // 2
    extract_uint16
    frame_dig -1
    len
    frame_dig -1
    dig 2
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    swap
    uncover 3
    substring3
    intc_0 // 0
    extract_uint16
    +
    // smart_contracts/social/base.ts:32-34
    // BoxCostPerByte * (
    //   PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    // )
    pushint 6800 // 6800
    *
    // smart_contracts/social/base.ts:31
    // return MinPayWallMBR + (
    pushint 5200 // 5200
    // smart_contracts/social/base.ts:31-35
    // return MinPayWallMBR + (
    //   BoxCostPerByte * (
    //     PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    //   )
    // )
    +
    frame_dig -1
    retsub


// smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements(akitaDAO: uint64, creator: bytes, wallet: uint64) -> bytes:
smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements:
    // smart_contracts/social/base.ts:51
    // checkTipMbrRequirements(akitaDAO: Application, creator: Account, wallet: Application): tipMBRInfo {
    proto 3 1
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    frame_dig -3
    bytec 9 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:52
    // const akta = Asset(getAkitaAssets(akitaDAO).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/base.ts:54
    // if (!creator.isOptedIn(akta) && wallet.id !== 0) {
    frame_dig -2
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    frame_dig -1
    bz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    frame_dig -3
    bytec 15 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:42
    // getPluginAppList(akitaDAO).optin,
    extract 0 8
    // smart_contracts/social/base.ts:44
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:43
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:45
    // '',
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:46
    // methodSelector<typeof OptInPlugin.prototype.optIn>()
    bytec 23 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/base.ts:56
    // if (canCallArc58OptIn) {
    bz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    // smart_contracts/social/base.ts:59
    // arc58: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    // smart_contracts/social/base.ts:57-60
    // return {
    //   type: TipSendTypeARC58,
    //   arc58: Global.assetOptInMinBalance
    // }
    itob
    // smart_contracts/social/base.ts:58
    // type: TipSendTypeARC58,
    bytec 6 // 0x14
    // smart_contracts/social/base.ts:57-60
    // return {
    //   type: TipSendTypeARC58,
    //   arc58: Global.assetOptInMinBalance
    // }
    swap
    concat
    retsub

smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5:
    // smart_contracts/social/base.ts:64-67
    // return {
    //   type: TipSendTypeDirect,
    //   arc58: 0
    // }
    pushbytes 0x0a0000000000000000
    retsub
