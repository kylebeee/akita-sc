#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 32 4 392 63072000 100000 86400 31700
    bytecblock "akita_dao" "controlled_address" "" "p" 0x151f7c75 "m" 0x14 0x00 "akita_escrow" "b" "d" "akita_al" "social_fees" "akita_assets" 0x80 "r" "a" 0x0a 0x0000 "o" "n" "plugn_al" 0x0033 "f" 0x27e3bb4f 0x0001 "other_al" 0x000000000000000000 "version"
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn NumAppArgs
    bz main_after_if_else@62
    pushbytess 0x88c940f8 0x7f9a73c6 0x92bc9f09 0xb480e3a6 0x21e03db3 0x9e42e006 0xcb5cdec7 0x0bd6dbf6 0xbffa2948 0xbf3c2955 0x13ca77b5 0x890dbb5b 0xeeeb21b1 0x40798af2 0x88eff637 0x84fa4b5e 0x5b4e6e2c 0x56536f3e 0x125903c0 0x6c8b5642 0x1b06bdbc 0x8b559657 0x6e5b7702 0x86675494 0x4b6f907f 0x0aea5a8a 0xb59c8a54 0xaeebb378 0x77662c8e 0x03e3ab22 0x8ebc19b5 0x61dcd2ef 0x7960ea76 0xa0d2321d 0xd90671b6 0xf1492bf4 0x856433ea 0xbdf6879d 0xe869934d 0x70e5c48b 0x1f3c618c 0x6dc226b4 0xbb32bb70 0x81b7159e 0xa2efa6fe 0x1e4a6763 0x14641fbd 0xf4ea50e4 0x603f9fc2 0x854dede0 0x776e3a65 0xea9180dd 0x33e92c94 0x1ead20a9 // method "create(string,uint64,uint64)void", method "post(pay,axfer,byte[36],uint64)void", method "editPost(pay,axfer,byte[36],uint64,byte[32])void", method "gatedReplyPost(pay,axfer,appl,byte[36],byte[32],uint64)void", method "replyPost(pay,axfer,byte[36],byte[32],uint64)void", method "replyAsset(pay,axfer,byte[36],uint64,uint64)void", method "gatedReplyAddress(pay,axfer,appl,byte[36],address,uint64)void", method "replyAddress(pay,axfer,byte[36],address,uint64)void", method "replyApp(pay,axfer,byte[36],uint64,uint64)void", method "gatedEditReply(pay,axfer,appl,byte[36],uint64,byte[32])void", method "editReply(pay,axfer,byte[36],uint64,byte[32])void", method "votePost(pay,axfer,byte[32],bool)void", method "voteAsset(pay,axfer,uint64,bool)void", method "voteAddress(pay,axfer,address,bool)void", method "voteApp(pay,axfer,uint64,bool)void", method "editVote(pay,axfer,byte[32],bool)void", method "gatedReactPost(pay,axfer,appl,byte[32],uint64)void", method "reactPost(pay,axfer,byte[32],uint64)void", method "reactAsset(pay,axfer,uint64,uint64)void", method "gatedReactAddress(pay,axfer,appl,address,uint64)void", method "reactAddress(pay,axfer,address,uint64)void", method "reactApp(pay,axfer,uint64,uint64)void", method "deleteReaction(byte[32],uint64)void", method "gatedFollow(pay,appl,address)void", method "follow(pay,address)void", method "unfollow(address,uint64)void", method "block(pay,address)void", method "unblock(address)void", method "addModerator(pay,address)void", method "removeModerator(address)void", method "ban(pay,address,uint64)void", method "flagPost(byte[32])void", method "unflagPost(byte[32])void", method "unban(address)void", method "addAction(pay,uint64,byte[36])void", method "removeAction(uint64)void", method "initMeta(pay,address,bool,uint64,uint64,uint64)uint64", method "updateMeta(uint64,uint64,uint64,uint64,uint64)void", method "getUserSocialImpact(address)uint64", method "isFollower(address,uint64,address)bool", method "moderatorMeta(address)(bool,uint64)", method "getMeta(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)", method "getMetaWallet(address)uint64", method "postExists(byte[])bool", method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)", method "getPost(byte[32])(address,uint64,uint64,bool,bool,byte[])", method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))", method "getVote(byte[32])(uint64,bool)", method "getPostMeta(byte[32],uint64)((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64),bool)", method "opUp()void", method "optAkitaEscrowInAndSend(string,uint64,uint64)void", method "update(string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@5 main_post_route@6 main_editPost_route@7 main_gatedReplyPost_route@8 main_replyPost_route@9 main_replyAsset_route@10 main_gatedReplyAddress_route@11 main_replyAddress_route@12 main_replyApp_route@13 main_gatedEditReply_route@14 main_editReply_route@15 main_votePost_route@16 main_voteAsset_route@17 main_voteAddress_route@18 main_voteApp_route@19 main_editVote_route@20 main_gatedReactPost_route@21 main_reactPost_route@22 main_reactAsset_route@23 main_gatedReactAddress_route@24 main_reactAddress_route@25 main_reactApp_route@26 main_deleteReaction_route@27 main_gatedFollow_route@28 main_follow_route@29 main_unfollow_route@30 main_block_route@31 main_unblock_route@32 main_addModerator_route@33 main_removeModerator_route@34 main_ban_route@35 main_flagPost_route@36 main_unflagPost_route@37 main_unban_route@38 main_addAction_route@39 main_removeAction_route@40 main_initMeta_route@41 main_updateMeta_route@42 main_getUserSocialImpact_route@43 main_isFollower_route@44 main_moderatorMeta_route@45 main_getMeta_route@46 main_getMetaWallet_route@47 main_postExists_route@48 main_reactionMeta_route@49 main_getPost_route@50 main_getPostAndCreatorMeta_route@51 main_getVote_route@52 main_getPostMeta_route@53 main_opUp_route@54 main_optAkitaEscrowInAndSend_route@55 main_update_route@56 main_updateAkitaDAO_route@57 main_updateAkitaDAOEscrow_route@58

main_after_if_else@62:
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    intc_0 // 0
    return

main_updateAkitaDAOEscrow_route@58:
    // smart_contracts/utils/base-contracts/escrow.ts:62
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/escrow.ts:62
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_1 // 1
    return

main_updateAkitaDAO_route@57:
    // smart_contracts/utils/base-contracts/escrow.ts:57
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/escrow.ts:57
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@56:
    // smart_contracts/utils/base-contracts/escrow.ts:49
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/escrow.ts:49
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_optAkitaEscrowInAndSend_route@55:
    // smart_contracts/utils/base-contracts/escrow.ts:20
    // optAkitaEscrowInAndSend(name: string, asset: Asset, amount: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/utils/base-contracts/escrow.ts:20
    // optAkitaEscrowInAndSend(name: string, asset: Asset, amount: uint64): void {
    callsub optAkitaEscrowInAndSend
    intc_1 // 1
    return

main_opUp_route@54:
    // smart_contracts/social/contract.algo.ts:1630
    // opUp(): void { }
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_getPostMeta_route@53:
    // smart_contracts/social/contract.algo.ts:1620
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1620
    // @abimethod({ readonly: true })
    callsub getPostMeta
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getVote_route@52:
    // smart_contracts/social/contract.algo.ts:1609
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1609
    // @abimethod({ readonly: true })
    callsub getVote
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPostAndCreatorMeta_route@51:
    // smart_contracts/social/contract.algo.ts:1601
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1601
    // @abimethod({ readonly: true })
    callsub getPostAndCreatorMeta
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPost_route@50:
    // smart_contracts/social/contract.algo.ts:1595
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1595
    // @abimethod({ readonly: true })
    callsub getPost
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_reactionMeta_route@49:
    // smart_contracts/social/contract.algo.ts:1566
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/social/contract.algo.ts:1566
    // @abimethod({ readonly: true })
    callsub reactionMeta
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_postExists_route@48:
    // smart_contracts/social/contract.algo.ts:1554
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/social/contract.algo.ts:1554
    // @abimethod({ readonly: true })
    callsub postExists
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getMetaWallet_route@47:
    // smart_contracts/social/contract.algo.ts:1546
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1546
    // @abimethod({ readonly: true })
    callsub getMetaWallet
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getMeta_route@46:
    // smart_contracts/social/contract.algo.ts:1541
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1541
    // @abimethod({ readonly: true })
    callsub getMeta
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_moderatorMeta_route@45:
    // smart_contracts/social/contract.algo.ts:1530
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1530
    // @abimethod({ readonly: true })
    callsub moderatorMeta
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isFollower_route@44:
    // smart_contracts/social/contract.algo.ts:1525
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/social/contract.algo.ts:1525
    // @abimethod({ readonly: true })
    callsub isFollower
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserSocialImpact_route@43:
    // smart_contracts/social/contract.algo.ts:1520
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1520
    // @abimethod({ readonly: true })
    callsub getUserSocialImpact
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateMeta_route@42:
    // smart_contracts/social/contract.algo.ts:1488-1494
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/social/contract.algo.ts:1488-1494
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): void {
    callsub updateMeta
    intc_1 // 1
    return

main_initMeta_route@41:
    // smart_contracts/social/contract.algo.ts:1397-1404
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Address,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/social/contract.algo.ts:1397-1404
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Address,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    callsub initMeta
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeAction_route@40:
    // smart_contracts/social/contract.algo.ts:1383
    // removeAction(actionAppID: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/social/contract.algo.ts:1383
    // removeAction(actionAppID: uint64) {
    callsub removeAction
    intc_1 // 1
    return

main_addAction_route@39:
    // smart_contracts/social/contract.algo.ts:1367
    // addAction(mbrPayment: gtxn.PaymentTxn, actionAppID: uint64, content: CID) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/social/contract.algo.ts:1367
    // addAction(mbrPayment: gtxn.PaymentTxn, actionAppID: uint64, content: CID) {
    callsub addAction
    intc_1 // 1
    return

main_unban_route@38:
    // smart_contracts/social/contract.algo.ts:1352
    // unban(address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1352
    // unban(address: Address): void {
    callsub unban
    intc_1 // 1
    return

main_unflagPost_route@37:
    // smart_contracts/social/contract.algo.ts:1341
    // unflagPost(ref: bytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1341
    // unflagPost(ref: bytes<32>): void {
    callsub unflagPost
    intc_1 // 1
    return

main_flagPost_route@36:
    // smart_contracts/social/contract.algo.ts:1329
    // flagPost(ref: bytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1329
    // flagPost(ref: bytes<32>): void {
    callsub flagPost
    intc_1 // 1
    return

main_ban_route@35:
    // smart_contracts/social/contract.algo.ts:1310
    // ban(mbrPayment: gtxn.PaymentTxn, address: Address, expiration: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1310
    // ban(mbrPayment: gtxn.PaymentTxn, address: Address, expiration: uint64): void {
    callsub ban
    intc_1 // 1
    return

main_removeModerator_route@34:
    // smart_contracts/social/contract.algo.ts:1296
    // removeModerator(address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1296
    // removeModerator(address: Address): void {
    callsub removeModerator
    intc_1 // 1
    return

main_addModerator_route@33:
    // smart_contracts/social/contract.algo.ts:1280
    // addModerator(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1280
    // addModerator(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    callsub addModerator
    intc_1 // 1
    return

main_unblock_route@32:
    // smart_contracts/social/contract.algo.ts:1263
    // unblock(address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1263
    // unblock(address: Address): void {
    callsub unblock
    intc_1 // 1
    return

main_block_route@31:
    // smart_contracts/social/contract.algo.ts:1244
    // block(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1244
    // block(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    callsub block
    intc_1 // 1
    return

main_unfollow_route@30:
    // smart_contracts/social/contract.algo.ts:1221
    // unfollow(address: Address, index: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1221
    // unfollow(address: Address, index: uint64): void {
    callsub unfollow
    intc_1 // 1
    return

main_follow_route@29:
    // smart_contracts/social/contract.algo.ts:1200
    // follow(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1200
    // follow(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    callsub follow
    intc_1 // 1
    return

main_gatedFollow_route@28:
    // smart_contracts/social/contract.algo.ts:1175-1179
    // gatedFollow(
    //   mbrPayment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   address: Address
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1175-1179
    // gatedFollow(
    //   mbrPayment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   address: Address
    // ): void {
    callsub gatedFollow
    intc_1 // 1
    return

main_deleteReaction_route@27:
    // smart_contracts/social/contract.algo.ts:1151
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1151
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    callsub deleteReaction
    intc_1 // 1
    return

main_reactApp_route@26:
    // smart_contracts/social/contract.algo.ts:1132-1137
    // reactApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1132-1137
    // reactApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    callsub reactApp
    intc_1 // 1
    return

main_reactAddress_route@25:
    // smart_contracts/social/contract.algo.ts:1110-1115
    // reactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1110-1115
    // reactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    callsub reactAddress
    intc_1 // 1
    return

main_gatedReactAddress_route@24:
    // smart_contracts/social/contract.algo.ts:1087-1093
    // gatedReactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1087-1093
    // gatedReactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    callsub gatedReactAddress
    intc_1 // 1
    return

main_reactAsset_route@23:
    // smart_contracts/social/contract.algo.ts:1068-1073
    // reactAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1068-1073
    // reactAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    callsub reactAsset
    intc_1 // 1
    return

main_reactPost_route@22:
    // smart_contracts/social/contract.algo.ts:1050-1055
    // reactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1050-1055
    // reactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    callsub reactPost
    intc_1 // 1
    return

main_gatedReactPost_route@21:
    // smart_contracts/social/contract.algo.ts:1031-1037
    // gatedReactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1031-1037
    // gatedReactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    callsub gatedReactPost
    intc_1 // 1
    return

main_editVote_route@20:
    // smart_contracts/social/contract.algo.ts:993-998
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:993-998
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    callsub editVote
    intc_1 // 1
    return

main_voteApp_route@19:
    // smart_contracts/social/contract.algo.ts:973-978
    // voteApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:973-978
    // voteApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    callsub voteApp
    intc_1 // 1
    return

main_voteAddress_route@18:
    // smart_contracts/social/contract.algo.ts:955-960
    // voteAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   isUp: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:955-960
    // voteAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   isUp: boolean
    // ): void {
    callsub voteAddress
    intc_1 // 1
    return

main_voteAsset_route@17:
    // smart_contracts/social/contract.algo.ts:935-940
    // voteAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:935-940
    // voteAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    callsub voteAsset
    intc_1 // 1
    return

main_votePost_route@16:
    // smart_contracts/social/contract.algo.ts:920-925
    // votePost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:920-925
    // votePost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    callsub votePost
    intc_1 // 1
    return

main_editReply_route@15:
    // smart_contracts/social/contract.algo.ts:893-899
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/social/contract.algo.ts:893-899
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    callsub editReply
    intc_1 // 1
    return

main_gatedEditReply_route@14:
    // smart_contracts/social/contract.algo.ts:865-872
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/social/contract.algo.ts:865-872
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    callsub gatedEditReply
    intc_1 // 1
    return

main_replyApp_route@13:
    // smart_contracts/social/contract.algo.ts:845-851
    // replyApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:845-851
    // replyApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    callsub replyApp
    intc_1 // 1
    return

main_replyAddress_route@12:
    // smart_contracts/social/contract.algo.ts:822-828
    // replyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:822-828
    // replyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    callsub replyAddress
    intc_1 // 1
    return

main_gatedReplyAddress_route@11:
    // smart_contracts/social/contract.algo.ts:798-805
    // gatedReplyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:798-805
    // gatedReplyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    callsub gatedReplyAddress
    intc_1 // 1
    return

main_replyAsset_route@10:
    // smart_contracts/social/contract.algo.ts:778-784
    // replyAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:778-784
    // replyAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    callsub replyAsset
    intc_1 // 1
    return

main_replyPost_route@9:
    // smart_contracts/social/contract.algo.ts:759-765
    // replyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:759-765
    // replyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    callsub replyPost
    intc_1 // 1
    return

main_gatedReplyPost_route@8:
    // smart_contracts/social/contract.algo.ts:739-746
    // gatedReplyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:739-746
    // gatedReplyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    callsub gatedReplyPost
    intc_1 // 1
    return

main_editPost_route@7:
    // smart_contracts/social/contract.algo.ts:716-722
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/social/contract.algo.ts:716-722
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    callsub editPost
    intc_1 // 1
    return

main_post_route@6:
    // smart_contracts/social/contract.algo.ts:702-707
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:702-707
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64
    // ): void {
    callsub post
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/social/contract.algo.ts:693
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/social/contract.algo.ts:26
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseEscrow) implements AkitaSocialInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/social/contract.algo.ts:693
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:104
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:105
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:106
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    pushint 1000 // 1000
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:105
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::referrerOrZeroAddress(walletID: uint64) -> bytes:
referrerOrZeroAddress:
    // smart_contracts/utils/functions.ts:137
    // export function referrerOrZeroAddress(walletID: Application): Account {
    proto 1 1
    // smart_contracts/utils/functions.ts:138
    // return referrerOr(walletID, Global.zeroAddress)
    global ZeroAddress
    // smart_contracts/utils/functions.ts:131
    // if (walletID.id === 0) {
    frame_dig -1
    bnz referrerOrZeroAddress_after_if_else@3
    frame_dig 0

referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4:
    // smart_contracts/utils/functions.ts:138
    // return referrerOr(walletID, Global.zeroAddress)
    swap
    retsub

referrerOrZeroAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:150-153
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:152
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:150-153
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:138
    // return referrerOr(walletID, Global.zeroAddress)
    b referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:157
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:43
    // return op.AppGlobal.getExUint64(akitaDAO, Bytes(AbstractAccountGlobalStateKeysEscrowFactory))[0]
    frame_dig -2
    pushbytes "escrow_factory"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:163-169
    // const data = abiCall(
    //   EscrowFactoryInterface.prototype.get,
    //   {
    //     appId: escrowFactory,
    //     args: [new Address(address)]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:171
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    pushint 8 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:172
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:159
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:175
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:159
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:202
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:204
    // gateTxn.sender === Txn.sender &&
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    // smart_contracts/utils/functions.ts:204-205
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:205
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:205
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:204-205
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:206
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:204-206
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:207
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    intc_3 // 4
    ==
    // smart_contracts/utils/functions.ts:204-207
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:208
    // gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x43922655 // method "mustCheck(address,uint64,byte[][])void"
    ==
    // smart_contracts/utils/functions.ts:204-208
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:209
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:204-209
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:210
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:204-210
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@8
    intc_1 // 1
    // smart_contracts/utils/functions.ts:203-211
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@8:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:203-211
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector(GateInterface.prototype.mustCheck) &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isReply(ref: bytes) -> uint64:
isReply:
    // smart_contracts/social/contract.algo.ts:60
    // private isReply(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:61
    // return ref.length === 68 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 68 // 68
    ==
    bnz isReply_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1

isReply_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:61
    // return ref.length === 68 || ref.length === 101
    swap
    retsub

isReply_bool_false@3:
    intc_0 // 0
    b isReply_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.isAmended(ref: bytes) -> uint64:
isAmended:
    // smart_contracts/social/contract.algo.ts:64
    // private isAmended(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:65
    // return ref.length === 69 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 69 // 69
    ==
    bnz isAmended_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isAmended_bool_false@3

isAmended_bool_true@2:
    intc_1 // 1

isAmended_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:65
    // return ref.length === 69 || ref.length === 101
    swap
    retsub

isAmended_bool_false@3:
    intc_0 // 0
    b isAmended_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned(account: bytes) -> uint64:
isBanned:
    // smart_contracts/social/contract.algo.ts:68
    // private isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:49
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 20 // "n"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:69
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    box_len
    bury 1
    bz isBanned_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    global LatestTimestamp
    >
    bz isBanned_bool_false@3
    intc_1 // 1

isBanned_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:69
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    swap
    retsub

isBanned_bool_false@3:
    intc_0 // 0
    b isBanned_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.blk(userAddress: bytes, blockedAddress: bytes) -> bytes:
blk:
    // smart_contracts/social/contract.algo.ts:73
    // private blk(userAddress: Account, blockedAddress: Account): BlockListKey {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:74
    // const user = userAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:75
    // const blocked = blockedAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:76
    // return { user, blocked }
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.rlk(user: bytes, ref: bytes, NFT: uint64) -> bytes:
rlk:
    // smart_contracts/social/contract.algo.ts:80
    // private rlk(user: Account, ref: bytes<32>, NFT: uint64): ReactionListKey {
    proto 3 1
    // smart_contracts/social/contract.algo.ts:81
    // const userKey = user.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -3
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -3
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:82
    // const refKey = ref.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:83
    // return { user: userKey, ref: refKey, NFT }
    concat
    frame_dig -1
    itob
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.vlk(account: bytes, r: bytes) -> bytes:
vlk:
    // smart_contracts/social/contract.algo.ts:87
    // private vlk(account: Account, r: bytes<32>): VoteListKey {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:88
    // const user = account.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:89
    // const ref = r.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/social/contract.algo.ts:90
    // return { user, ref }
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/social/contract.algo.ts:98
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    bytec_2 // ""
    dupn 4
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:100
    // const { streak, startDate } = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    pushint 9 // 9
    extract_uint64
    dup
    uncover 2
    pushint 17 // 17
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:103
    // if (streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@2
    // smart_contracts/social/contract.algo.ts:104
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:112
    // const accountAge: uint64 = Global.latestTimestamp - startDate
    global LatestTimestamp
    frame_dig 7
    -
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:114
    // if (accountAge >= TWO_YEARS) {
    intc 5 // 63072000
    >=
    bz getSocialImpactScore_else_body@5
    // smart_contracts/social/contract.algo.ts:115
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:37
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:122
    // if (this.votes(account.bytes).exists) {
    box_len
    bury 1
    frame_dig 4
    frame_bury 5
    bz getSocialImpactScore_after_if_else@16
    // smart_contracts/social/contract.algo.ts:123
    // const { voteCount, isNegative } = this.votes(account.bytes).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:125
    // let impact: uint64 = (voteCount * 75) / 100_000
    pushint 75 // 75
    *
    intc 6 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:126
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@9
    // smart_contracts/social/contract.algo.ts:127
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@9:
    // smart_contracts/social/contract.algo.ts:130
    // if (isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@14
    // smart_contracts/social/contract.algo.ts:132
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@12
    // smart_contracts/social/contract.algo.ts:133
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@15:
    frame_dig 4
    frame_bury 5

getSocialImpactScore_after_if_else@16:
    frame_dig 5
    // smart_contracts/social/contract.algo.ts:143
    // return socialImpact
    frame_bury 0
    retsub

getSocialImpactScore_else_body@12:
    // smart_contracts/social/contract.algo.ts:135
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@14:
    // smart_contracts/social/contract.algo.ts:139
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@5:
    // smart_contracts/social/contract.algo.ts:118
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    intc 5 // 63072000
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@6

getSocialImpactScore_else_body@2:
    // smart_contracts/social/contract.algo.ts:107
    // socialImpact += (streak * 100) / 60
    frame_dig 6
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@3


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:146
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:147-153
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:150
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:150
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:150
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:147-153
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/social/contract.algo.ts:155
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.sendReferralPayment(referrer: bytes, asset: uint64, preReferralTax: uint64) -> bytes:
sendReferralPayment:
    // smart_contracts/social/contract.algo.ts:172
    // private sendReferralPayment(referrer: Account, asset: uint64, preReferralTax: uint64): { tax: uint64, cost: uint64 } {
    proto 3 1
    intc_0 // 0
    bytec_2 // ""
    dupn 6
    // smart_contracts/social/contract.algo.ts:174
    // if (referrer !== Global.zeroAddress && referrer.isOptedIn(Asset(asset))) {
    frame_dig -3
    global ZeroAddress
    !=
    bz sendReferralPayment_after_if_else@6
    frame_dig -3
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bz sendReferralPayment_after_if_else@6
    // smart_contracts/utils/functions.ts:83
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    // smart_contracts/social/contract.algo.ts:175
    // referralFee = calcPercent(preReferralTax, TWENTY_FIVE_PERCENT)
    pushint 25000 // 25000
    // smart_contracts/utils/functions.ts:83
    // return op.divw(...op.mulw(a, p), DIVISOR)
    mulw
    intc 6 // 100000
    divw
    dup
    frame_bury 4
    dup
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:176
    // if (referralFee === 0 && preReferralTax > 0) {
    bnz sendReferralPayment_after_if_else@5
    frame_dig 4
    frame_bury 5
    frame_dig -1
    bz sendReferralPayment_after_if_else@5
    // smart_contracts/social/contract.algo.ts:177
    // referralFee = 1
    intc_1 // 1
    frame_bury 5

sendReferralPayment_after_if_else@5:
    frame_dig 5
    dup
    frame_bury 4
    // smart_contracts/social/contract.algo.ts:181
    // this.akitaDAO.value,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:181
    // this.akitaDAO.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/social/contract.algo.ts:183
    // Global.latestTimestamp,
    global LatestTimestamp
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:184
    // (Global.latestTimestamp + ONE_WEEK),
    global LatestTimestamp
    pushint 604800 // 604800
    +
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:185
    // [{ address: new Address(referrer), amount: referralFee }],
    swap
    itob
    frame_dig -3
    swap
    concat
    bytec 25 // 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:469
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    pushint 8 // 8
    extract_uint64
    frame_bury 6
    // smart_contracts/utils/functions.ts:472
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc_0 // 0
    extract_uint16
    pushint 25300 // 25300
    *
    pushint 35300 // 35300
    +
    frame_bury 1
    // smart_contracts/utils/functions.ts:473
    // if (asset === 0) {
    frame_dig -2
    bnz sendReferralPayment_else_body@9
    // smart_contracts/utils/functions.ts:474-488
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:480
    // receiver: Application(rewardsApp).address,
    frame_dig 6
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:481
    // amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    frame_dig 1
    frame_dig 4
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:479-482
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:474-488
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:483
    // timeToUnlock,
    frame_dig 7
    itob
    // smart_contracts/utils/functions.ts:484
    // expiration,
    frame_dig 3
    itob
    // smart_contracts/utils/functions.ts:474-488
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x7b7dc5fc // method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi

sendReferralPayment_after_if_else@12:
    // smart_contracts/utils/functions.ts:529
    // return { id, cost }
    itob
    frame_dig 1
    itob
    concat
    // smart_contracts/social/contract.algo.ts:180-187
    // const { cost } = createInstantDisbursement(
    //   this.akitaDAO.value,
    //   asset,
    //   Global.latestTimestamp,
    //   (Global.latestTimestamp + ONE_WEEK),
    //   [{ address: new Address(referrer), amount: referralFee }],
    //   referralFee
    // )
    extract 8 8
    // smart_contracts/social/contract.algo.ts:189
    // return { tax: (preReferralTax - referralFee), cost }
    frame_dig -1
    frame_dig 4
    -
    itob
    swap
    concat
    frame_bury 0
    retsub

sendReferralPayment_else_body@9:
    // smart_contracts/utils/functions.ts:490
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 6
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    frame_dig 1
    frame_bury 2
    bnz sendReferralPayment_after_if_else@11
    // smart_contracts/utils/functions.ts:491
    // cost += Global.assetOptInMinBalance
    frame_dig 1
    global AssetOptInMinBalance
    +
    frame_bury 2
    // smart_contracts/utils/functions.ts:492-504
    // abiCall(
    //   RewardsInterface.prototype.optin,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: Global.assetOptInMinBalance
    //       }),
    //       asset
    //     ]
    //   }
    // )
    itxn_begin
    // smart_contracts/utils/functions.ts:498
    // receiver: Application(rewardsApp).address,
    frame_dig 6
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:499
    // amount: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:497-500
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: Global.assetOptInMinBalance
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:492-504
    // abiCall(
    //   RewardsInterface.prototype.optin,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: Global.assetOptInMinBalance
    //       }),
    //       asset
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:501
    // asset
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:492-504
    // abiCall(
    //   RewardsInterface.prototype.optin,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: Global.assetOptInMinBalance
    //       }),
    //       asset
    //     ]
    //   }
    // )
    pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

sendReferralPayment_after_if_else@11:
    // smart_contracts/utils/functions.ts:507-526
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantAsaDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: Application(rewardsApp).address,
    //         assetAmount: sum,
    //         xferAsset: asset
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:513
    // receiver: Application(rewardsApp).address,
    frame_dig 6
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:512-515
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:516-520
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/utils/functions.ts:517
    // assetReceiver: Application(rewardsApp).address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/functions.ts:516-520
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:507-526
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantAsaDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: Application(rewardsApp).address,
    //         assetAmount: sum,
    //         xferAsset: asset
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:521
    // timeToUnlock,
    frame_dig 7
    itob
    // smart_contracts/utils/functions.ts:522
    // expiration,
    frame_dig 3
    itob
    // smart_contracts/utils/functions.ts:507-526
    // id = abiCall(
    //   RewardsInterface.prototype.createInstantAsaDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: Application(rewardsApp).address,
    //         amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: Application(rewardsApp).address,
    //         assetAmount: sum,
    //         xferAsset: asset
    //       }),
    //       timeToUnlock,
    //       expiration,
    //       allocations
    //     ]
    //   }
    // ).returnValue
    pushbytes 0xaf1a14f2 // method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 2 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    frame_dig 2
    frame_bury 1
    b sendReferralPayment_after_if_else@12

sendReferralPayment_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:192
    // return { tax: preReferralTax, cost: 0 }
    frame_dig -1
    itob
    intc_0 // 0
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.sendReactionPayments(receiver: bytes, wallet: uint64, referrer: bytes, preReferralTax: uint64) -> uint64:
sendReactionPayments:
    // smart_contracts/social/contract.algo.ts:316
    // private sendReactionPayments(receiver: Account, wallet: uint64, referrer: Account, preReferralTax: uint64): uint64 {
    proto 4 1
    intc_0 // 0
    dupn 4
    bytec_2 // ""
    dupn 9
    // smart_contracts/social/contract.algo.ts:317
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:317
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:46
    // const akta = Asset(getAkitaAssets(akitaDAO).akta)
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/base.ts:48
    // if (creator.isOptedIn(akta)) {
    frame_dig -4
    swap
    asset_holding_get AssetBalance
    bury 1
    bz sendReactionPayments_after_if_else@24
    // smart_contracts/social/base.ts:49-59
    // return {
    //   type: TipSendTypeDirect,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: 0
    // }
    pushbytes 0x0a000000000000000000000000000000000000000000000000000000000000000000
    frame_bury 2

sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@30:
    // smart_contracts/social/contract.algo.ts:317
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    frame_dig 2
    dup
    extract 0 1
    dup
    cover 2
    frame_bury 4
    pushint 26 // 26
    extract_uint64
    frame_bury 6
    // smart_contracts/social/contract.algo.ts:320
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:320
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:320
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    dup
    extract 0 8
    frame_bury 1
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:321
    // const { tax, cost } = this.sendReferralPayment(referrer, akta, preReferralTax)
    frame_dig -2
    swap
    frame_dig -1
    callsub sendReferralPayment
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 14
    pushint 8 // 8
    extract_uint64
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:323
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:323
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:323
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    pushint 8 // 8
    extract_uint64
    frame_bury 10
    // smart_contracts/social/contract.algo.ts:326
    // case TipSendTypeDirect: {
    bytec 17 // 0x0a
    ==
    // smart_contracts/social/contract.algo.ts:326-329
    // case TipSendTypeDirect: {
    //   this.sendDirectReactionPayments(receiver, akta, tax, (reactFee - preReferralTax))
    //   break
    // }
    bz sendReactionPayments_after_if_else@3
    // smart_contracts/social/contract.algo.ts:327
    // this.sendDirectReactionPayments(receiver, akta, tax, (reactFee - preReferralTax))
    frame_dig 10
    frame_dig -1
    -
    // smart_contracts/social/contract.algo.ts:302
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:302
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:313
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_begin
    frame_dig 5
    dup
    cover 2
    itxn_field XferAsset
    frame_dig 14
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:301-305
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:313
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_next
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig -4
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:307-311
    // const xferTxn = itxn.assetTransfer({
    //   assetReceiver: creator,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:313
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_submit
    frame_dig 8
    frame_bury 9

sendReactionPayments_block@10:
    // smart_contracts/social/contract.algo.ts:342
    // return extraAmount
    frame_dig 9
    frame_bury 0
    retsub

sendReactionPayments_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:330
    // case TipSendTypeARC59: {
    frame_dig 4
    bytec 6 // 0x14
    ==
    // smart_contracts/social/contract.algo.ts:330-334
    // case TipSendTypeARC59: {
    //   extraAmount = (arc59.mbr + arc59.receiverAlgoNeededForClaim)
    //   this.arc59SendReactionPayments(receiver, akta, tax, (reactFee - preReferralTax), arc59)
    //   break
    // }
    bz sendReactionPayments_after_if_else@6
    // smart_contracts/social/contract.algo.ts:331
    // extraAmount = (arc59.mbr + arc59.receiverAlgoNeededForClaim)
    frame_dig 2
    extract 1 25
    dup
    pushint 8 // 8
    extract_uint64
    dig 1
    extract 17 8
    frame_bury 0
    dig 1
    pushint 17 // 17
    extract_uint64
    dup
    frame_bury 11
    dig 1
    +
    frame_bury 9
    // smart_contracts/social/contract.algo.ts:332
    // this.arc59SendReactionPayments(receiver, akta, tax, (reactFee - preReferralTax), arc59)
    frame_dig 10
    frame_dig -1
    -
    frame_bury 12
    // smart_contracts/social/contract.algo.ts:254
    // const { routerOptedIn, mbr, receiverAlgoNeededForClaim } = arc59
    swap
    pushint 128 // 128
    getbit
    frame_bury 13
    // smart_contracts/social/contract.algo.ts:255
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:255
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 26 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:255
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:256
    // const inboxAddress = Application(assetInbox).address
    app_params_get AppAddress
    swap
    frame_bury 3
    assert // application exists
    // smart_contracts/social/contract.algo.ts:258
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz sendReactionPayments_if_body@15
    frame_dig 11
    bz sendReactionPayments_after_if_else@16

sendReactionPayments_if_body@15:
    // smart_contracts/social/contract.algo.ts:259-264
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    //   .submit()
    itxn_begin
    frame_dig 9
    itxn_field Amount
    frame_dig 3
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:259-263
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:259-264
    // itxn
    //   .payment({
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim
    //   })
    //   .submit()
    itxn_submit

sendReactionPayments_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:267
    // if (!routerOptedIn) {
    frame_dig 13
    bnz sendReactionPayments_after_if_else@18
    // smart_contracts/social/contract.algo.ts:268-271
    // abiCall(AssetInbox.prototype.arc59_optRouterIn, {
    //   appId: assetInbox,
    //   args: [asset]
    // })
    itxn_begin
    pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

sendReactionPayments_after_if_else@18:
    // smart_contracts/social/contract.algo.ts:274-280
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:276
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:276
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 5
    dup
    cover 2
    itxn_field XferAsset
    frame_dig 14
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:274-279
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:274-280
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:282-296
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         assetReceiver: inboxAddress,
    //         assetAmount: remainder,
    //         xferAsset: asset
    //       }),
    //       new Address(creator),
    //       receiverAlgoNeededForClaim
    //     ]
    //   }
    // )
    itxn_begin
    itxn_field XferAsset
    frame_dig 12
    itxn_field AssetAmount
    frame_dig 3
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:287-291
    // itxn.assetTransfer({
    //   assetReceiver: inboxAddress,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // }),
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:282-296
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         assetReceiver: inboxAddress,
    //         assetAmount: remainder,
    //         xferAsset: asset
    //       }),
    //       new Address(creator),
    //       receiverAlgoNeededForClaim
    //     ]
    //   }
    // )
    itxn_next
    pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/contract.algo.ts:333
    // break
    b sendReactionPayments_block@10

sendReactionPayments_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:335
    // case TipSendTypeARC58: {
    frame_dig 4
    pushbytes 0x1e
    ==
    // smart_contracts/social/contract.algo.ts:335-339
    // case TipSendTypeARC58: {
    //   extraAmount = arc58
    //   this.arc58SendReactionPayments(wallet, akta, tax, (reactFee - preReferralTax))
    //   break
    // }
    bz sendReactionPayments_after_if_else@9
    // smart_contracts/social/contract.algo.ts:337
    // this.arc58SendReactionPayments(wallet, akta, tax, (reactFee - preReferralTax))
    frame_dig 10
    frame_dig -1
    -
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:199-211
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: wallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true, // global
    //       '', // default account
    //       [], // no method offsets
    //       [] // no funds request
    //     ]
    //   }
    // )
    itxn_begin
    // smart_contracts/social/contract.algo.ts:204
    // getPluginAppList(this.akitaDAO.value).optin,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:204
    // getPluginAppList(this.akitaDAO.value).optin,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:33
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dup
    bytec 21 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:204
    // getPluginAppList(this.akitaDAO.value).optin,
    extract 0 8
    // smart_contracts/social/contract.algo.ts:199-211
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: wallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true, // global
    //       '', // default account
    //       [], // no method offsets
    //       [] // no funds request
    //     ]
    //   }
    // )
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:205
    // true, // global
    bytec 14 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:206
    // '', // default account
    bytec 18 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:207
    // [], // no method offsets
    bytec 18 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:208
    // [] // no funds request
    bytec 18 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:199-211
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: wallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true, // global
    //       '', // default account
    //       [], // no method offsets
    //       [] // no funds request
    //     ]
    //   }
    // )
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:213-227
    // itxnCompose.next(
    //   OptInPlugin.prototype.optIn,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       walletID,
    //       true, // rekey back immediately
    //       [asset],
    //       itxn.payment({
    //         amount: Global.assetOptInMinBalance,
    //         receiver: origin
    //       })
    //     ],
    //   }
    // )
    itxn_next
    // smart_contracts/social/contract.algo.ts:222
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    dig 2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/social/contract.algo.ts:221-224
    // itxn.payment({
    //   amount: Global.assetOptInMinBalance,
    //   receiver: origin
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:213-227
    // itxnCompose.next(
    //   OptInPlugin.prototype.optIn,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       walletID,
    //       true, // rekey back immediately
    //       [asset],
    //       itxn.payment({
    //         amount: Global.assetOptInMinBalance,
    //         receiver: origin
    //       })
    //     ],
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:33
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 21 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:216
    // appId: getPluginAppList(this.akitaDAO.value).optin,
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:218
    // walletID,
    frame_dig -3
    itob
    // smart_contracts/social/contract.algo.ts:220
    // [asset],
    frame_dig 5
    dup
    cover 3
    itob
    bytec 25 // 0x0001
    swap
    concat
    // smart_contracts/social/contract.algo.ts:213-227
    // itxnCompose.next(
    //   OptInPlugin.prototype.optIn,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       walletID,
    //       true, // rekey back immediately
    //       [asset],
    //       itxn.payment({
    //         amount: Global.assetOptInMinBalance,
    //         receiver: origin
    //       })
    //     ],
    //   }
    // )
    pushbytes 0x6835e3bc // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:205
    // true, // global
    bytec 14 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:213-227
    // itxnCompose.next(
    //   OptInPlugin.prototype.optIn,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       walletID,
    //       true, // rekey back immediately
    //       [asset],
    //       itxn.payment({
    //         amount: Global.assetOptInMinBalance,
    //         receiver: origin
    //       })
    //     ],
    //   }
    // )
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:229-232
    // itxnCompose.next(
    //   AbstractedAccountInterface.prototype.arc58_verifyAuthAddress,
    //   { appId: wallet }
    // )
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:234-240
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    // smart_contracts/social/contract.algo.ts:236
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:236
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 1
    itxn_field XferAsset
    frame_dig 14
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:235-239
    // itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:242-248
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: origin,
    //     assetAmount: remainder,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:243-247
    // itxn.assetTransfer({
    //   assetReceiver: origin,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:250
    // itxnCompose.submit()
    itxn_submit
    frame_dig 6
    frame_bury 9
    // smart_contracts/social/contract.algo.ts:338
    // break
    b sendReactionPayments_block@10

sendReactionPayments_after_if_else@9:
    frame_dig 8
    frame_bury 9
    b sendReactionPayments_block@10

sendReactionPayments_after_if_else@24:
    // smart_contracts/social/base.ts:62
    // if (wallet !== 0) {
    frame_dig -3
    bz sendReactionPayments_after_if_else@28
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:33
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    frame_dig 15
    bytec 21 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:35
    // getPluginAppList(akitaDAO).optin,
    extract 0 8
    // smart_contracts/social/base.ts:37
    // new Address(Global.zeroAddress),
    global ZeroAddress
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:36
    // true,
    bytec 14 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:38
    // '',
    bytec 18 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:39
    // methodSelector(OptInPluginInterface.prototype.optInToAsset)
    pushbytes 0x27ece5e6 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/social/base.ts:64
    // if (canCallArc58OptIn) {
    bz sendReactionPayments_after_if_else@28
    // smart_contracts/social/base.ts:74
    // arc58: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    // smart_contracts/social/base.ts:65-75
    // return {
    //   type: TipSendTypeARC58,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: Global.assetOptInMinBalance
    // }
    itob
    pushbytes 0x1e00000000000000000000000000000000000000000000000000
    swap
    concat
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:317
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    b sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@30

sendReactionPayments_after_if_else@28:
    // smart_contracts/utils/functions.ts:38
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig 15
    bytec 26 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:79
    // const assetInbox = getOtherAppList(akitaDAO).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/base.ts:81-90
    // const arc59 = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [
    //       new Address(creator),
    //       akta.id,
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    frame_dig 16
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/base.ts:93
    // type: TipSendTypeARC59,
    bytec 6 // 0x14
    // smart_contracts/social/base.ts:92-96
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    swap
    concat
    // smart_contracts/social/base.ts:95
    // arc58: 0
    intc_0 // 0
    // smart_contracts/social/base.ts:92-96
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    itob
    concat
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:317
    // const { type, arc59, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, receiver, wallet)
    b sendReactionPayments_after_inlined_smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements@30


// smart_contracts/social/contract.algo.ts::AkitaSocial.createEmptyPostIfNecessary(key: bytes, creator: bytes) -> uint64:
createEmptyPostIfNecessary:
    // smart_contracts/social/contract.algo.ts:345
    // private createEmptyPostIfNecessary(key: bytes<32>, creator: Account): uint64 {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:346
    // if (!this.posts(key).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/social/contract.algo.ts:357
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:347-361
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: new Address(creator),
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:358
    // gateID: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:347-361
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: new Address(creator),
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    itob
    concat
    pushbytes 0x0000330000
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:363
    // return this.mbr(Bytes('')).posts
    bytec_2 // ""
    callsub mbr
    pushint 16 // 16
    extract_uint64
    swap
    retsub

createEmptyPostIfNecessary_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:365
    // return 0
    intc_0 // 0
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/social/contract.algo.ts:368
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/social/contract.algo.ts:369
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:371
    // const { startDate, lastActive } = this.meta(account).value
    dup
    box_get
    pop
    dup
    pushint 17 // 17
    extract_uint64
    swap
    pushint 25 // 25
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/social/contract.algo.ts:373
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    intc 7 // 86400
    %
    -
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:374
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    intc 7 // 86400
    -
    // smart_contracts/social/contract.algo.ts:376
    // this.meta(account).value.lastActive = Global.latestTimestamp
    global LatestTimestamp
    itob
    uncover 3
    pushint 25 // 25
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:379
    // if (lastWindowStart > lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/social/contract.algo.ts:380
    // this.meta(account).value.streak = 1
    intc_1 // 1
    itob
    frame_dig 0
    pushint 9 // 9
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:381
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:386
    // if (lastActive < thisWindowStart) {
    frame_dig 1
    frame_dig 2
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/social/contract.algo.ts:387
    // this.meta(account).value.streak += 1
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    pushint 9 // 9
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 9 // 9
    swap
    box_replace

updateStreak_after_if_else@4:
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/social/contract.algo.ts:423
    // private updateVotes(ref: bytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:37
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/social/contract.algo.ts:394
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/social/contract.algo.ts:395
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat

updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20:
    // smart_contracts/social/contract.algo.ts:424
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    dup
    extract 0 8
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:425
    // this.votes(ref).value = { voteCount, isNegative }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:398
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    pushint 64 // 64
    getbit
    frame_bury 1
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:401
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/social/contract.algo.ts:401
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:403
    // if (voteCount === 0) {
    frame_dig 2
    bnz updateVotes_after_if_else@11
    // smart_contracts/social/contract.algo.ts:404
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:424
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:407
    // if (impact === voteCount && differingDirections) {
    frame_dig -1
    frame_dig 2
    ==
    bz updateVotes_after_if_else@14
    frame_dig 0
    bz updateVotes_after_if_else@14
    // smart_contracts/social/contract.algo.ts:408
    // return { newCount: 0, isNegative: false }
    bytec 27 // 0x000000000000000000
    // smart_contracts/social/contract.algo.ts:424
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:413
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/social/contract.algo.ts:414
    // if (flip) {
    bz updateVotes_after_if_else@16
    // smart_contracts/social/contract.algo.ts:415
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/social/contract.algo.ts:416
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    swap
    itob
    bytec 7 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:424
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:419
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@18
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@19:
    // smart_contracts/social/contract.algo.ts:420
    // return { newCount, isNegative }
    itob
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:424
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_ternary_false@18:
    // smart_contracts/social/contract.algo.ts:419
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@19

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/social/contract.algo.ts:428
    // private createVoteList(ref: bytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:429
    // const voteListKey = this.vlk(account, ref)
    frame_dig -2
    frame_dig -4
    callsub vlk
    // smart_contracts/social/contract.algo.ts:430
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:39
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:430
    // this.votelist(voteListKey).value = { impact, isUp }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPost(origin: bytes, referrer: bytes, mbrPayment: uint64, cid: bytes, gateID: uint64, isAmendment: uint64) -> void:
createPost:
    // smart_contracts/social/contract.algo.ts:433-440
    // private createPost(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   isAmendment: boolean,
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:441
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -6
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:443
    // this.validatePostPayment(mbrPayment, cid, isAmendment, 0)
    frame_dig -4
    frame_dig -3
    frame_dig -1
    intc_0 // 0
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:447
    // this.updateStreak(origin)
    frame_dig -6
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:449
    // const impact = this.getUserImpact(origin)
    frame_dig -6
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:451
    // const postID = Txn.txId
    txn TxID
    // smart_contracts/social/contract.algo.ts:455
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:452-459
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: new Address(origin),
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    itob
    frame_dig -6
    swap
    concat
    frame_dig -2
    itob
    concat
    bytec 7 // 0x00
    intc_1 // 1
    frame_dig -1
    setbit
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    swap
    bytec 22 // 0x0033
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:452-459
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: new Address(origin),
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:460
    // this.updateVotes(postID, true, impact)
    dup
    intc_1 // 1
    dig 3
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:461
    // this.createVoteList(postID, true, origin, impact)
    intc_1 // 1
    frame_dig -6
    uncover 3
    callsub createVoteList
    // smart_contracts/social/contract.algo.ts:159
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:159
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:159
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:160
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:161
    // const { tax } = this.sendReferralPayment(referrer, akta, postFee)
    frame_dig -5
    dig 2
    uncover 2
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:163-169
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:165
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:165
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:163-168
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:163-169
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReply(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, cid: bytes, ref: bytes, gateID: uint64, isAmendment: uint64) -> void:
createReply:
    // smart_contracts/social/contract.algo.ts:465-474
    // private createReply(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   isAmendment: boolean
    // ): void {
    proto 8 0
    // smart_contracts/social/contract.algo.ts:475
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -8
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -3
    concat
    // smart_contracts/social/contract.algo.ts:476
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_2 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:94
    // const blocksKey = this.blk(user, blocked)
    dup
    frame_dig -8
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:95
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:477
    // assert(!this.isBlocked(creator.native, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:481
    // this.updateStreak(origin)
    frame_dig -8
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:483
    // const replyRef = cid.concat(ref)
    frame_dig -4
    frame_dig -3
    concat
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:484
    // const { wallet, } = this.meta(creator.native).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:485
    // const creatorImpact = this.getUserImpact(creator.native)
    dig 2
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:486
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:486
    // const tax = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:99
    // const { impactTaxMin, impactTaxMax } = getSocialFees(akitaDAO)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:100
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:489
    // extra += this.sendReactionPayments(creator.native, wallet, referrer, tax)
    uncover 3
    uncover 2
    frame_dig -7
    uncover 3
    callsub sendReactionPayments
    frame_dig -5
    +
    // smart_contracts/social/contract.algo.ts:491
    // this.validatePostPayment(mbrPayment, cid, isAmendment, extra)
    frame_dig -6
    frame_dig -4
    frame_dig -1
    uncover 3
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:493
    // const replyPostID = Txn.txId
    txn TxID
    // smart_contracts/social/contract.algo.ts:498
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:495-502
    // this.posts(replyPostID).value = {
    //   ref: replyRef,
    //   creator: new Address(origin),
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    itob
    frame_dig -8
    swap
    concat
    frame_dig -2
    itob
    concat
    bytec 7 // 0x00
    intc_1 // 1
    frame_dig -1
    setbit
    concat
    dig 2
    len
    itob
    extract 6 2
    uncover 3
    concat
    swap
    bytec 22 // 0x0033
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:495-502
    // this.posts(replyPostID).value = {
    //   ref: replyRef,
    //   creator: new Address(origin),
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:504
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -8
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:505
    // this.updateVotes(replyPostID, true, senderImpact)
    dig 1
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:506
    // this.createVoteList(replyPostID, true, origin, senderImpact)
    swap
    intc_1 // 1
    frame_dig -8
    uncover 3
    callsub createVoteList
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVote(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/social/contract.algo.ts:509-516
    // private createVote(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:517
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -6
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:518
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:520
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_2 // 32
    box_extract
    dupn 2
    // smart_contracts/social/contract.algo.ts:94
    // const blocksKey = this.blk(user, blocked)
    frame_dig -6
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:95
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:521
    // assert(!this.isBlocked(creator.native, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:523
    // const voteListKey = this.vlk(origin, ref)
    frame_dig -6
    frame_dig -2
    callsub vlk
    // smart_contracts/social/contract.algo.ts:39
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:524
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/social/contract.algo.ts:525
    // assert(origin !== creator.native, ERR_NO_SELF_VOTE)
    frame_dig -6
    !=
    assert // Cannot vote on your own content
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -6
    concat
    // smart_contracts/social/contract.algo.ts:527
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 4 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:528
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:530
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:530
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:530
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:534
    // this.updateStreak(origin)
    frame_dig -6
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:535
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:535
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:535
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    pushint 8 // 8
    extract_uint64
    swap
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:537
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@2
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig 0
    dup
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:538
    // const { wallet } = this.meta(creator.native).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:540
    // const recipientImpact = this.getUserImpact(creator.native)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:541
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 3
    frame_dig 4
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:543
    // const extra = this.sendReactionPayments(creator.native, wallet, referrer, tax)
    cover 2
    frame_dig -5
    uncover 3
    callsub sendReactionPayments
    // smart_contracts/social/contract.algo.ts:545-552
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:548
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:545-552
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:549
    // amount: mbrNeeded + extra
    frame_dig -3
    uncover 3
    +
    // smart_contracts/social/contract.algo.ts:545-552
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment

createVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:573
    // const senderImpact = this.getUserImpact(origin)
    frame_dig -6
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:574
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:575
    // this.createVoteList(ref, isUp, origin, senderImpact)
    frame_dig -2
    frame_dig -1
    frame_dig -6
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@2:
    // smart_contracts/social/contract.algo.ts:554-561
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:557
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:554-561
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    frame_dig -3
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:564
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:564
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:569
    // itxn.submitGroup(taxTxn)
    itxn_begin
    frame_dig 1
    itxn_field XferAsset
    frame_dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:563-567
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: reactFee,
    //   xferAsset: akta
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:569
    // itxn.submitGroup(taxTxn)
    itxn_submit
    b createVote_after_if_else@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReaction(origin: bytes, referrer: bytes, mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, NFT: uint64) -> void:
createReaction:
    // smart_contracts/social/contract.algo.ts:578-585
    // private createReaction(
    //   origin: Account,
    //   referrer: Account,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:586
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -6
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:587
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:588
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_2 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:94
    // const blocksKey = this.blk(user, blocked)
    dup
    frame_dig -6
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:95
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:589
    // assert(!this.isBlocked(creator.native, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:591
    // assert(AssetHolding.assetBalance(origin, NFT)[0] > 0, ERR_USER_DOES_NOT_OWN_NFT)
    frame_dig -6
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    assert // User does not own this NFT
    // smart_contracts/social/contract.algo.ts:593
    // const reactionListKey = this.rlk(origin, ref, NFT)
    frame_dig -6
    frame_dig -2
    frame_dig -1
    callsub rlk
    // smart_contracts/social/contract.algo.ts:43
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    dup
    cover 2
    // smart_contracts/social/contract.algo.ts:594
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:598
    // this.updateStreak(origin)
    frame_dig -6
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:600
    // const { wallet } = this.meta(creator.native).value
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/social/contract.algo.ts:601
    // const recipientImpact = this.getUserImpact(creator.native)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:602
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:602
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:602
    // const { impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:603
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:605
    // const reactionKey: ReactionsKey = { ref, NFT }
    frame_dig -2
    len
    intc_2 // 32
    ==
    assert // invalid size
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 15 // "r"
    swap
    concat
    dup
    cover 4
    // smart_contracts/social/contract.algo.ts:606
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:609
    // extra += this.sendReactionPayments(creator.native, wallet, referrer, tax)
    uncover 3
    uncover 3
    frame_dig -5
    uncover 4
    callsub sendReactionPayments
    frame_dig -3
    +
    swap
    // smart_contracts/social/contract.algo.ts:676
    // const { reactionlist, reactions } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    dup
    pushint 48 // 48
    extract_uint64
    cover 2
    pushint 40 // 40
    extract_uint64
    cover 2
    // smart_contracts/social/contract.algo.ts:677-679
    // const mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz createReaction_ternary_false@6

createReaction_ternary_merge@7:
    // smart_contracts/social/contract.algo.ts:681-688
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:684
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:681-688
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:685
    // amount: mbrAmount + extra
    uncover 2
    frame_dig 3
    +
    // smart_contracts/social/contract.algo.ts:681-688
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:613
    // if (reactionExists) {
    frame_dig 2
    bz createReaction_else_body@2
    // smart_contracts/social/contract.algo.ts:614
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:619
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    retsub

createReaction_else_body@2:
    // smart_contracts/social/contract.algo.ts:616
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@3

createReaction_ternary_false@6:
    // smart_contracts/social/contract.algo.ts:679
    // : reactions + reactionlist
    frame_dig 4
    +
    b createReaction_ternary_merge@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.createFollow(origin: bytes, address: bytes) -> void:
createFollow:
    // smart_contracts/social/contract.algo.ts:622
    // private createFollow(origin: Account, address: Address): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:623
    // assert(!this.isBanned(origin), ERR_BANNED)
    frame_dig -2
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:94
    // const blocksKey = this.blk(user, blocked)
    frame_dig -1
    frame_dig -2
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:95
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:624
    // assert(!this.isBlocked(address.native, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:626
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 4 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:627
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:629
    // const { followerIndex } = this.meta(address.native).value
    dup
    box_get
    assert // Box must have value
    pushint 33 // 33
    extract_uint64
    // smart_contracts/social/contract.algo.ts:631
    // const followsKey: FollowsKey = { user: address.native, index: (followerIndex + 1) }
    intc_1 // 1
    +
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:31
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:632
    // this.follows(followsKey).value = origin
    frame_dig -2
    box_put
    // smart_contracts/social/contract.algo.ts:634
    // this.meta(address.native).value.followerIndex += 1
    dup
    box_get
    pop
    pushint 33 // 33
    extract_uint64
    intc_1 // 1
    +
    itob
    dig 1
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:635
    // this.meta(address.native).value.followerCount += 1
    dup
    box_get
    pop
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 41 // 41
    swap
    box_replace
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validateTip(tip: uint64, action: bytes) -> void:
validateTip:
    // smart_contracts/social/contract.algo.ts:638
    // private validateTip(tip: gtxn.AssetTransferTxn, action: TipAction) {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 13 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:52
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 12 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:640
    // const { postFee, reactFee } = getSocialFees(this.akitaDAO.value)
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 8 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:642-650
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/social/contract.algo.ts:645
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:642-650
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    frame_dig -2
    gtxns XferAsset
    uncover 4
    ==
    &&
    frame_dig -2
    gtxns AssetAmount
    // smart_contracts/social/contract.algo.ts:647
    // assetAmount: (action === TipActionPost) ? postFee : reactFee,
    frame_dig -1
    bytec 17 // 0x0a
    ==
    uncover 3
    uncover 4
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:642-650
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee,
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    assert // Invalid transfer
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validatePostPayment(mbrPayment: uint64, cid: bytes, isAmendment: uint64, extraAmount: uint64) -> void:
validatePostPayment:
    // smart_contracts/social/contract.algo.ts:653-658
    // private validatePostPayment(
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   isAmendment: boolean,
    //   extraAmount: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:659
    // const { posts, votes, votelist } = this.mbr(cid)
    frame_dig -3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    intc_2 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:660
    // let amount: uint64 = posts + votes + votelist + extraAmount
    cover 2
    +
    +
    frame_dig -1
    +
    dup
    // smart_contracts/social/contract.algo.ts:661
    // if (isAmendment) {
    frame_dig -2
    bz validatePostPayment_after_if_else@2
    // smart_contracts/social/contract.algo.ts:662
    // amount += AmendmentMBR
    frame_dig 0
    pushint 13200 // 13200
    +
    frame_bury 1

validatePostPayment_after_if_else@2:
    frame_dig 1
    // smart_contracts/social/contract.algo.ts:665-672
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:668
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:665-672
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.create(version: bytes, akitaDAO: uint64, escrow: uint64) -> void:
create:
    // smart_contracts/social/contract.algo.ts:693-694
    // @abimethod({ onCreate: 'require' })
    // create(version: string, akitaDAO: uint64, escrow: uint64): void {
    proto 3 0
    // smart_contracts/utils/base-contracts/escrow.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 28 // "version"
    // smart_contracts/social/contract.algo.ts:695
    // this.version.value = version
    frame_dig -3
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:696
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -2
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:697
    // this.akitaDAOEscrow.value = Application(escrow)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.post(mbrPayment: uint64, tip: uint64, cid: bytes, gateID: uint64) -> void:
post:
    // smart_contracts/social/contract.algo.ts:702-707
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:708
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:708
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz post_after_if_else@3
    frame_dig 1

post_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:710
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:712
    // this.validateTip(tip, TipActionPost)
    frame_dig -3
    bytec 17 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:713
    // this.createPost(origin, referrer, mbrPayment, cid, gateID, false)
    frame_dig -4
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createPost
    retsub

post_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b post_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editPost(mbrPayment: uint64, tip: uint64, cid: bytes, gateID: uint64, amendment: bytes) -> void:
editPost:
    // smart_contracts/social/contract.algo.ts:716-722
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:723
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:723
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz editPost_after_if_else@3
    frame_dig 1

editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:725
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    dup
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:727
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:728
    // const { creator, ref } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_2 // 32
    box_extract
    dig 2
    pushint 49 // 49
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    uncover 4
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:57
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/social/contract.algo.ts:729
    // assert(this.isCreator(creator.native, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:730
    // assert(!this.isReply(ref), ERR_IS_A_REPLY)
    dup
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/social/contract.algo.ts:731
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:733
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 16 // "a"
    txn TxID
    concat
    concat
    dig 1
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 49 // 49
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/social/contract.algo.ts:735
    // this.validateTip(tip, TipActionPost)
    frame_dig -4
    bytec 17 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:736
    // this.createPost(origin, referrer, mbrPayment, cid, gateID, true)
    frame_dig -5
    frame_dig -3
    frame_dig -2
    intc_1 // 1
    callsub createPost
    retsub

editPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b editPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReplyPost(mbrPayment: uint64, tip: uint64, gateTxn: uint64, cid: bytes, ref: bytes, gateID: uint64) -> void:
gatedReplyPost:
    // smart_contracts/social/contract.algo.ts:739-746
    // gatedReplyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:747
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:747
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedReplyPost_after_if_else@3
    frame_dig 1

gatedReplyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:749
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:751
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:752
    // const { gateID: postGateID } = this.posts(ref).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:753
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:753
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, postGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -4
    swap
    uncover 4
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:755
    // this.validateTip(tip, TipActionReact)
    frame_dig -5
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:756
    // this.createReply(origin, referrer, mbrPayment, 0, cid, ref, gateID, false)
    swap
    frame_dig -6
    intc_0 // 0
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

gatedReplyPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedReplyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyPost(mbrPayment: uint64, tip: uint64, cid: bytes, ref: bytes, gateID: uint64) -> void:
replyPost:
    // smart_contracts/social/contract.algo.ts:759-765
    // replyPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:766
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:766
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz replyPost_after_if_else@3
    frame_dig 1

replyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:768
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:770
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:771
    // const { gateID: postGateID } = this.posts(ref).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:772
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:774
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:775
    // this.createReply(origin, referrer, mbrPayment, 0, cid, ref, gateID, false)
    frame_dig -5
    intc_0 // 0
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

replyPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b replyPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyAsset(mbrPayment: uint64, tip: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyAsset:
    // smart_contracts/social/contract.algo.ts:778-784
    // replyAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:785
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:785
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz replyAsset_after_if_else@3
    frame_dig 1

replyAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:787
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:789
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:790
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:791
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:792
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:794
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:795
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, paddedRef, gateID, false)
    uncover 3
    uncover 3
    frame_dig -5
    uncover 3
    frame_dig -3
    uncover 5
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

replyAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b replyAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReplyAddress(mbrPayment: uint64, tip: uint64, gateTxn: uint64, cid: bytes, ref: bytes, gateID: uint64) -> void:
gatedReplyAddress:
    // smart_contracts/social/contract.algo.ts:798-805
    // gatedReplyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:806
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:806
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedReplyAddress_after_if_else@3
    frame_dig 1

gatedReplyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:808
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:811
    // assert(this.meta(ref.native).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:812
    // const { addressGateID } = this.meta(ref.native).value
    box_get
    pop
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:813
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:813
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -4
    swap
    uncover 4
    dup
    cover 4
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:816
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:818
    // this.validateTip(tip, TipActionReact)
    frame_dig -5
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:819
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, r, gateID, false)
    swap
    uncover 2
    frame_dig -6
    uncover 3
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

gatedReplyAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedReplyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyAddress(mbrPayment: uint64, tip: uint64, cid: bytes, ref: bytes, gateID: uint64) -> void:
replyAddress:
    // smart_contracts/social/contract.algo.ts:822-828
    // replyAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64
    // ): void {
    proto 5 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:829
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    dupn 3
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:829
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz replyAddress_after_if_else@5
    frame_dig 4
    frame_bury 1

replyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6:
    // smart_contracts/social/contract.algo.ts:831
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 3
    callsub referrerOrZeroAddress
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:833
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz replyAddress_after_if_else@2
    // smart_contracts/social/contract.algo.ts:834
    // const { addressGateID } = this.meta(ref.native).value
    frame_dig 0
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:835
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

replyAddress_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:839
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:841
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:842
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, r, gateID, false)
    frame_dig 1
    frame_dig 2
    frame_dig -5
    uncover 3
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

replyAddress_after_if_else@5:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b replyAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6


// smart_contracts/social/contract.algo.ts::AkitaSocial.replyApp(mbrPayment: uint64, tip: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyApp:
    // smart_contracts/social/contract.algo.ts:845-851
    // replyApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:852
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:852
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz replyApp_after_if_else@3
    frame_dig 1

replyApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:854
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:856
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:857
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:858
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:859
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:861
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:862
    // this.createReply(origin, referrer, mbrPayment, addedMbr, cid, paddedRef, gateID, false)
    uncover 3
    uncover 3
    frame_dig -5
    uncover 3
    frame_dig -3
    uncover 5
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub

replyApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b replyApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedEditReply(mbrPayment: uint64, tip: uint64, gateTxn: uint64, cid: bytes, gateID: uint64, amendment: bytes) -> void:
gatedEditReply:
    // smart_contracts/social/contract.algo.ts:865-872
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    proto 6 0
    // smart_contracts/social/contract.algo.ts:873
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:873
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedEditReply_after_if_else@3
    frame_dig 1

gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:875
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    dup
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:877
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:878
    // const { creator, ref } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_2 // 32
    box_extract
    dig 2
    pushint 49 // 49
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    uncover 4
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:57
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/social/contract.algo.ts:879
    // assert(this.isCreator(creator.native, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:880
    // assert(this.isReply(ref), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:881
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:883
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 16 // "a"
    txn TxID
    concat
    dig 1
    swap
    concat
    dig 2
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 49 // 49
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 2
    box_del
    pop
    uncover 2
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:885
    // const originalPostRef = ref.slice(0, 32).toFixed({ length: 32 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 32
    dig 2
    >=
    intc_2 // 32
    uncover 3
    uncover 2
    select
    substring3
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:886
    // const { gateID: ogPostGateID } = this.posts(originalPostRef).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:887
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:887
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, ogPostGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -4
    swap
    uncover 5
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:889
    // this.validateTip(tip, TipActionReact)
    frame_dig -5
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:890
    // this.createReply(origin, referrer, mbrPayment, 0, cid, originalPostRef, gateID, true)
    uncover 2
    frame_dig -6
    intc_0 // 0
    frame_dig -3
    uncover 5
    frame_dig -2
    intc_1 // 1
    callsub createReply
    retsub

gatedEditReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedEditReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editReply(mbrPayment: uint64, tip: uint64, cid: bytes, gateID: uint64, amendment: bytes) -> void:
editReply:
    // smart_contracts/social/contract.algo.ts:893-899
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:900
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:900
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz editReply_after_if_else@3
    frame_dig 1

editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:902
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    dup
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:904
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:905
    // const { creator, ref } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_2 // 32
    box_extract
    dig 2
    pushint 49 // 49
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    uncover 4
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:57
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/social/contract.algo.ts:906
    // assert(this.isCreator(creator.native, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:907
    // assert(this.isReply(ref), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:908
    // assert(!this.isAmended(ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:910
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(Txn.txId))
    bytec 16 // "a"
    txn TxID
    concat
    dig 1
    swap
    concat
    dig 2
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 49 // 49
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 2
    box_del
    pop
    uncover 2
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:912
    // const originalPostRef = ref.slice(0, 32).toFixed({ length: 32 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 32
    dig 2
    >=
    intc_2 // 32
    uncover 3
    uncover 2
    select
    substring3
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:913
    // const { gateID: ogPostGateID } = this.posts(originalPostRef).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:914
    // assert(ogPostGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:916
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:917
    // this.createReply(origin, referrer, mbrPayment, 0, cid, originalPostRef, gateID, true)
    cover 2
    frame_dig -5
    intc_0 // 0
    frame_dig -3
    uncover 5
    frame_dig -2
    intc_1 // 1
    callsub createReply
    retsub

editReply_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b editReply_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.votePost(mbrPayment: uint64, tip: uint64, ref: bytes, isUp: uint64) -> void:
votePost:
    // smart_contracts/social/contract.algo.ts:920-925
    // votePost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:926
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:926
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz votePost_after_if_else@3
    frame_dig 1

votePost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:928
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:930
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:931
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_2 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:932
    // this.createVote(origin, referrer, mbrPayment, mbrNeeded, ref, isUp)
    cover 2
    frame_dig -4
    uncover 3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub

votePost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b votePost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteAsset(mbrPayment: uint64, tip: uint64, ref: uint64, isUp: uint64) -> void:
voteAsset:
    // smart_contracts/social/contract.algo.ts:935-940
    // voteAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:941
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:941
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz voteAsset_after_if_else@3
    frame_dig 1

voteAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:943
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:945
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:946
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:947
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:948
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_2 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:949
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:951
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:952
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), paddedRef, isUp)
    +
    uncover 3
    uncover 3
    frame_dig -4
    uncover 3
    uncover 4
    frame_dig -1
    callsub createVote
    retsub

voteAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b voteAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteAddress(mbrPayment: uint64, tip: uint64, ref: bytes, isUp: uint64) -> void:
voteAddress:
    // smart_contracts/social/contract.algo.ts:955-960
    // voteAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   isUp: boolean
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:961
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:961
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz voteAddress_after_if_else@3
    frame_dig 1

voteAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:963
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:966
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_2 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:967
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:969
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:970
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), r, isUp)
    +
    cover 2
    frame_dig -4
    uncover 3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub

voteAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b voteAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.voteApp(mbrPayment: uint64, tip: uint64, ref: uint64, isUp: uint64) -> void:
voteApp:
    // smart_contracts/social/contract.algo.ts:973-978
    // voteApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   isUp: boolean
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:979
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:979
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz voteApp_after_if_else@3
    frame_dig 1

voteApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:981
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:983
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:984
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:985
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:986
    // const mbrNeeded = this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_2 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:987
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 2
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:989
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:990
    // this.createVote(origin, referrer, mbrPayment, (mbrNeeded + addedMbr), paddedRef, isUp)
    +
    uncover 3
    uncover 3
    frame_dig -4
    uncover 3
    uncover 4
    frame_dig -1
    callsub createVote
    retsub

voteApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b voteApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.editVote(mbrPayment: uint64, tip: uint64, ref: bytes, flip: uint64) -> void:
editVote:
    // smart_contracts/social/contract.algo.ts:993-998
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    proto 4 0
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    // smart_contracts/social/contract.algo.ts:999
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:999
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz editVote_after_if_else@6
    frame_dig 5
    frame_bury 1

editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@7:
    // smart_contracts/social/contract.algo.ts:1001
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 4
    callsub referrerOrZeroAddress
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1003
    // const voteListKey = this.vlk(origin, ref)
    frame_dig 1
    frame_dig -2
    callsub vlk
    // smart_contracts/social/contract.algo.ts:39
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1004
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1006
    // const { impact, isUp } = this.votelist(voteListKey).value
    box_get
    pop
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:1009
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    frame_bury 3
    frame_dig -2
    swap
    uncover 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:1012
    // if (!flip) {
    frame_dig -1
    bnz editVote_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1014
    // this.votelist(voteListKey).delete()
    frame_dig 0
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1016-1021
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1019
    // amount: this.mbr(Bytes('')).votelist
    bytec_2 // ""
    callsub mbr
    intc_2 // 32
    extract_uint64
    itxn_field Amount
    frame_dig 1
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1016-1020
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1016-1021
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1023
    // return
    retsub

editVote_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1027
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1028
    // this.createVote(origin, referrer, mbrPayment, 0, ref, !isUp)
    frame_dig 1
    frame_dig 2
    frame_dig -4
    intc_0 // 0
    frame_dig -2
    frame_dig 3
    callsub createVote
    retsub

editVote_after_if_else@6:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 4
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b editVote_after_inlined_smart_contracts/utils/functions.ts::originOr@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReactPost(mbrPayment: uint64, tip: uint64, gateTxn: uint64, ref: bytes, NFT: uint64) -> void:
gatedReactPost:
    // smart_contracts/social/contract.algo.ts:1031-1037
    // gatedReactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:1038
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1038
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedReactPost_after_if_else@3
    frame_dig 1

gatedReactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1040
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1042
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1043
    // const { gateID } = this.posts(ref).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:1044
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1044
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -3
    swap
    uncover 4
    dup
    cover 3
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:1046
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1047
    // this.createReaction(origin, referrer, mbrPayment, 0, ref, NFT)
    swap
    frame_dig -5
    intc_0 // 0
    frame_dig -2
    frame_dig -1
    callsub createReaction
    retsub

gatedReactPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedReactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactPost(mbrPayment: uint64, tip: uint64, ref: bytes, NFT: uint64) -> void:
reactPost:
    // smart_contracts/social/contract.algo.ts:1050-1055
    // reactPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:1056
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1056
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz reactPost_after_if_else@3
    frame_dig 1

reactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1058
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1060
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1061
    // const { gateID: postGateID } = this.posts(ref).value
    pushints 40 8 // 40, 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:1062
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:1064
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1065
    // this.createReaction(origin, referrer, mbrPayment, 0, ref, NFT)
    frame_dig -4
    intc_0 // 0
    frame_dig -2
    frame_dig -1
    callsub createReaction
    retsub

reactPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b reactPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactAsset(mbrPayment: uint64, tip: uint64, ref: uint64, NFT: uint64) -> void:
reactAsset:
    // smart_contracts/social/contract.algo.ts:1068-1073
    // reactAsset(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:1074
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1074
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz reactAsset_after_if_else@3
    frame_dig 1

reactAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1076
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:1078
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:1079
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:1080
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1081
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1083
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1084
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, paddedRef, NFT)
    uncover 3
    uncover 3
    frame_dig -4
    uncover 3
    uncover 4
    frame_dig -1
    callsub createReaction
    retsub

reactAsset_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b reactAsset_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReactAddress(mbrPayment: uint64, tip: uint64, gateTxn: uint64, ref: bytes, NFT: uint64) -> void:
gatedReactAddress:
    // smart_contracts/social/contract.algo.ts:1087-1093
    // gatedReactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    proto 5 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1094
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    dupn 3
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1094
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedReactAddress_after_if_else@5
    frame_dig 4
    frame_bury 1

gatedReactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6:
    // smart_contracts/social/contract.algo.ts:1096
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 3
    callsub referrerOrZeroAddress
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1098
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz gatedReactAddress_after_if_else@2
    // smart_contracts/social/contract.algo.ts:1099
    // const { addressGateID } = this.meta(ref.native).value
    frame_dig 0
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1100
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1100
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, addressGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -3
    swap
    frame_dig 1
    uncover 3
    callsub gateCheck
    assert // Gate check failed

gatedReactAddress_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:1104
    // const addedMbr = this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1106
    // this.validateTip(tip, TipActionReact)
    frame_dig -4
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1107
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, r, NFT)
    frame_dig 1
    frame_dig 2
    frame_dig -5
    uncover 3
    frame_dig -2
    frame_dig -1
    callsub createReaction
    retsub

gatedReactAddress_after_if_else@5:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedReactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactAddress(mbrPayment: uint64, tip: uint64, ref: bytes, NFT: uint64) -> void:
reactAddress:
    // smart_contracts/social/contract.algo.ts:1110-1115
    // reactAddress(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: Address,
    //   NFT: uint64
    // ): void {
    proto 4 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1116
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    dupn 3
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1116
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz reactAddress_after_if_else@5
    frame_dig 4
    frame_bury 1

reactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6:
    // smart_contracts/social/contract.algo.ts:1118
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 3
    callsub referrerOrZeroAddress
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1120
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz reactAddress_after_if_else@2
    // smart_contracts/social/contract.algo.ts:1121
    // const { addressGateID } = this.meta(ref.native).value
    frame_dig 0
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1122
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

reactAddress_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:1126
    // let addedMbr = this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1128
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1129
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, r, NFT)
    frame_dig 1
    frame_dig 2
    frame_dig -4
    uncover 3
    frame_dig -2
    frame_dig -1
    callsub createReaction
    retsub

reactAddress_after_if_else@5:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b reactAddress_after_inlined_smart_contracts/utils/functions.ts::originOr@6


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactApp(mbrPayment: uint64, tip: uint64, ref: uint64, NFT: uint64) -> void:
reactApp:
    // smart_contracts/social/contract.algo.ts:1132-1137
    // reactApp(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:1138
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1138
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz reactApp_after_if_else@3
    frame_dig 1

reactApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1140
    // const referrer = referrerOrZeroAddress(wallet)
    frame_dig 0
    callsub referrerOrZeroAddress
    // smart_contracts/social/contract.algo.ts:1142
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:1143
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:1144
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1145
    // const addedMbr = this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:1147
    // this.validateTip(tip, TipActionReact)
    frame_dig -3
    bytec 6 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:1148
    // this.createReaction(origin, referrer, mbrPayment, addedMbr, paddedRef, NFT)
    uncover 3
    uncover 3
    frame_dig -4
    uncover 3
    uncover 4
    frame_dig -1
    callsub createReaction
    retsub

reactApp_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b reactApp_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.deleteReaction(ref: bytes, NFT: uint64) -> void:
deleteReaction:
    // smart_contracts/social/contract.algo.ts:1151
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:1152
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1152
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz deleteReaction_after_if_else@3
    frame_dig 1

deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1155
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1156
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1157
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_2 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:94
    // const blocksKey = this.blk(user, blocked)
    dig 1
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:95
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:1158
    // assert(!this.isBlocked(creator.native, origin), ERR_BLOCKED)
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:1160
    // const reactionListKey = this.rlk(origin, ref, NFT)
    dup
    frame_dig -2
    frame_dig -1
    callsub rlk
    // smart_contracts/social/contract.algo.ts:43
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1161
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:1163
    // this.reactions({ ref, NFT }).value -= 1
    frame_dig -2
    len
    intc_2 // 32
    ==
    assert // invalid size
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 15 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1163
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1164
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1166-1172
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1169
    // amount: this.mbr(Bytes('')).reactionlist,
    bytec_2 // ""
    callsub mbr
    pushint 48 // 48
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1166-1171
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1166-1172
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_submit
    retsub

deleteReaction_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b deleteReaction_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedFollow(mbrPayment: uint64, gateTxn: uint64, address: bytes) -> void:
gatedFollow:
    // smart_contracts/social/contract.algo.ts:1175-1179
    // gatedFollow(
    //   mbrPayment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   address: Address
    // ): void {
    proto 3 0
    // smart_contracts/social/contract.algo.ts:1180
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1180
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz gatedFollow_after_if_else@3
    frame_dig 1

gatedFollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1183
    // assert(this.meta(address.native).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1184
    // const { followGateID } = this.meta(address.native).value
    box_get
    pop
    pushint 50 // 50
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1185
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, followGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1185
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, followGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -2
    swap
    dig 3
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:1187
    // const { follows } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1188-1195
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1191
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1188-1195
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -3
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1197
    // this.createFollow(origin, address)
    frame_dig -1
    callsub createFollow
    retsub

gatedFollow_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b gatedFollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.follow(mbrPayment: uint64, address: bytes) -> void:
follow:
    // smart_contracts/social/contract.algo.ts:1200
    // follow(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:1201
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1201
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz follow_after_if_else@3
    frame_dig 1

follow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1204
    // assert(this.meta(address.native).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1205
    // const { followGateID } = this.meta(address.native).value
    box_get
    pop
    pushint 50 // 50
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1206
    // assert(followGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:1208
    // const { follows } = this.mbr(Bytes(''))
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1209-1216
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1212
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1209-1216
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: follows
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1218
    // this.createFollow(origin, address)
    frame_dig -1
    callsub createFollow
    retsub

follow_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b follow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unfollow(address: bytes, index: uint64) -> void:
unfollow:
    // smart_contracts/social/contract.algo.ts:1221
    // unfollow(address: Address, index: uint64): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:1222
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1222
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz unfollow_after_if_else@3
    frame_dig 1

unfollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1225
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1227
    // const followsKey = { user: address.native, index }
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1228
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/social/contract.algo.ts:31
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1228
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    box_get
    assert // Box must have value
    dig 2
    ==
    assert // Wrong follower key
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1230
    // this.meta(address.native).value.followerCount -= 1
    dup
    box_get
    assert // Box must have value
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    -
    itob
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1232
    // this.follows(followsKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1234-1239
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1237
    // amount: this.mbr(Bytes('')).follows
    bytec_2 // ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1234-1238
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1234-1239
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows
    //   })
    //   .submit()
    itxn_submit
    retsub

unfollow_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b unfollow_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.block(mbrPayment: uint64, address: bytes) -> void:
block:
    // smart_contracts/social/contract.algo.ts:1244
    // block(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:1245
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1245
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz block_after_if_else@3
    frame_dig 1

block_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1248
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1250-1257
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1253
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1250-1257
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1254
    // amount: this.mbr(Bytes('')).blocks
    bytec_2 // ""
    callsub mbr
    pushint 8 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1250-1257
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1259
    // const blocksKey = this.blk(origin, address.native)
    frame_dig -1
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1260
    // this.blocks(blocksKey).create()
    intc_0 // 0
    box_create
    pop
    retsub

block_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b block_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unblock(address: bytes) -> void:
unblock:
    // smart_contracts/social/contract.algo.ts:1263
    // unblock(address: Address): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1264
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1264
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz unblock_after_if_else@3
    frame_dig 1

unblock_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1267
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:1269
    // const blocksKey = this.blk(origin, address.native)
    dup
    frame_dig -1
    callsub blk
    // smart_contracts/social/contract.algo.ts:33
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixBlocks })
    bytec 9 // "b"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1270
    // this.blocks(blocksKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1272-1277
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1275
    // amount: this.mbr(Bytes('')).blocks
    bytec_2 // ""
    callsub mbr
    pushint 8 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1272-1276
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1272-1277
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks
    //   })
    //   .submit()
    itxn_submit
    retsub

unblock_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b unblock_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.addModerator(mbrPayment: uint64, address: bytes) -> void:
addModerator:
    // smart_contracts/social/contract.algo.ts:1280
    // addModerator(mbrPayment: gtxn.PaymentTxn, address: Address): void {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:1281
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1281
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the DAO
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1282
    // assert(!this.moderators(address.native).exists, ERR_ALREADY_A_MODERATOR)
    dup
    box_len
    bury 1
    !
    assert // Already a moderator
    // smart_contracts/social/contract.algo.ts:1284-1291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1287
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1284-1291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1288
    // amount: this.mbr(Bytes('')).moderators
    bytec_2 // ""
    callsub mbr
    pushint 64 // 64
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1284-1291
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1293
    // this.moderators(address.native).create()
    pushint 8 // 8
    box_create
    pop
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.removeModerator(address: bytes) -> void:
removeModerator:
    // smart_contracts/social/contract.algo.ts:1296
    // removeModerator(address: Address): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1297
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1297
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the DAO
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1298
    // assert(this.moderators(address.native).exists, ERR_NOT_A_MODERATOR)
    dup
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:1300
    // this.moderators(address.native).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1302-1307
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1304
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1305
    // amount: this.mbr(Bytes('')).moderators
    bytec_2 // ""
    callsub mbr
    pushint 64 // 64
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1302-1306
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1302-1307
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).moderators
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.ban(mbrPayment: uint64, address: bytes, expiration: uint64) -> void:
ban:
    // smart_contracts/social/contract.algo.ts:1310
    // ban(mbrPayment: gtxn.PaymentTxn, address: Address, expiration: uint64): void {
    proto 3 0
    // smart_contracts/social/contract.algo.ts:1311
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1311
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz ban_after_if_else@3
    frame_dig 1

ban_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1314
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:49
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 20 // "n"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1315
    // assert(!this.banned(address.native).exists, ERR_ALREADY_BANNED)
    dup
    box_len
    bury 1
    !
    assert // This account is already banned
    // smart_contracts/social/contract.algo.ts:1317-1324
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1320
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1317-1324
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -3
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1321
    // amount: this.mbr(Bytes('')).banned
    bytec_2 // ""
    callsub mbr
    pushint 72 // 72
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1317-1324
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1326
    // this.banned(address.native).value = expiration
    frame_dig -1
    itob
    box_put
    retsub

ban_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b ban_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.flagPost(ref: bytes) -> void:
flagPost:
    // smart_contracts/social/contract.algo.ts:1329
    // flagPost(ref: bytes<32>): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1330
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1330
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz flagPost_after_if_else@3
    frame_dig 1

flagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1333
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1334
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1335
    // const { againstContentPolicy } = this.posts(ref).value
    dup
    pushint 48 // 48
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1336
    // assert(!againstContentPolicy, ERR_ALREADY_FLAGGED)
    !
    assert // Already flagged
    // smart_contracts/social/contract.algo.ts:1338
    // this.posts(ref).value.againstContentPolicy = true
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 48 // 48
    swap
    box_replace
    retsub

flagPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b flagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unflagPost(ref: bytes) -> void:
unflagPost:
    // smart_contracts/social/contract.algo.ts:1341
    // unflagPost(ref: bytes<32>): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1342
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1342
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz unflagPost_after_if_else@3
    frame_dig 1

unflagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1345
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1346
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1347
    // const { againstContentPolicy } = this.posts(ref).value
    dup
    pushint 48 // 48
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1348
    // assert(againstContentPolicy, ERR_NOT_FLAGGED)
    assert // Not flagged
    // smart_contracts/social/contract.algo.ts:1349
    // this.posts(ref).value.againstContentPolicy = false
    intc_0 // 0
    dup
    setbit
    pushint 48 // 48
    swap
    box_replace
    retsub

unflagPost_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b unflagPost_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.unban(address: bytes) -> void:
unban:
    // smart_contracts/social/contract.algo.ts:1352
    // unban(address: Address): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1353
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1353
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz unban_after_if_else@3
    frame_dig 1

unban_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1356
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/social/contract.algo.ts:49
    // banned = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixBanned })
    bytec 20 // "n"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1357
    // this.banned(address.native).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1359-1364
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1362
    // amount: this.mbr(Bytes('')).banned
    bytec_2 // ""
    callsub mbr
    pushint 72 // 72
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1359-1363
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1359-1364
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned
    //   })
    //   .submit()
    itxn_submit
    retsub

unban_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b unban_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.addAction(mbrPayment: uint64, actionAppID: uint64, content: bytes) -> void:
addAction:
    // smart_contracts/social/contract.algo.ts:1367
    // addAction(mbrPayment: gtxn.PaymentTxn, actionAppID: uint64, content: CID) {
    proto 3 0
    // smart_contracts/social/contract.algo.ts:1368
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1368
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the DAO
    // smart_contracts/social/contract.algo.ts:1369
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:51
    // actions = BoxMap<uint64, Action>({ keyPrefix: AkitaSocialBoxPrefixActions })
    bytec 16 // "a"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1369
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    !
    assert // Already an action
    // smart_contracts/social/contract.algo.ts:1371-1378
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1374
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1371-1378
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -3
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1375
    // amount: this.mbr(Bytes('')).actions
    bytec_2 // ""
    callsub mbr
    pushint 80 // 80
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1371-1378
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1380
    // this.actions(actionAppID).value = { content }
    frame_dig -1
    len
    pushint 36 // 36
    ==
    assert // invalid size
    frame_dig -1
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.removeAction(actionAppID: uint64) -> void:
removeAction:
    // smart_contracts/social/contract.algo.ts:1383
    // removeAction(actionAppID: uint64) {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:1384
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1384
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the DAO
    // smart_contracts/social/contract.algo.ts:1385
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -1
    itob
    // smart_contracts/social/contract.algo.ts:51
    // actions = BoxMap<uint64, Action>({ keyPrefix: AkitaSocialBoxPrefixActions })
    bytec 16 // "a"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1385
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    assert // Already an action
    // smart_contracts/social/contract.algo.ts:1387
    // this.actions(actionAppID).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1389-1394
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1391
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1392
    // amount: this.mbr(Bytes('')).actions
    bytec_2 // ""
    callsub mbr
    pushint 80 // 80
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1389-1393
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1389-1394
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).actions
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta(mbrPayment: uint64, user: bytes, automated: uint64, subscriptionIndex: uint64, NFD: uint64, akitaNFT: uint64) -> uint64:
initMeta:
    // smart_contracts/social/contract.algo.ts:1397-1404
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Address,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    proto 6 1
    intc_0 // 0
    dup
    bytec_2 // ""
    // smart_contracts/social/contract.algo.ts:1405
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user.native)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1405
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user.native)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -5
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz initMeta_after_if_else@9
    frame_dig -5
    frame_bury 1

initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@10:
    // smart_contracts/social/contract.algo.ts:1407
    // const userIsSender = (Txn.sender === user.native)
    txn Sender
    frame_dig -5
    ==
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig 1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1409
    // assert(!this.meta(origin).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/social/contract.algo.ts:1411-1418
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -6
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1414
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1411-1418
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -6
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1415
    // amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    bytec_2 // ""
    callsub mbr
    pushint 56 // 56
    extract_uint64
    intc 8 // 31700
    +
    // smart_contracts/social/contract.algo.ts:1411-1418
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1420
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1420
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1420
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    pushint 104 // 104
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1422-1427
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1424
    // receiver: Application(impact).address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:1425
    // amount: ImpactMetaMBR
    intc 8 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1422-1426
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1422-1427
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1429
    // if (automated) {
    frame_dig -4
    bz initMeta_after_if_else@4
    // smart_contracts/social/contract.algo.ts:1434
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:1435
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:1430-1441
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    frame_dig 3
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1433
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:1430-1441
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1436
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1430-1441
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec 14 // 0x80
    concat
    dig 1
    concat
    dig 1
    concat
    frame_dig 0
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1443-1454
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     appId: impact,
    //     args: [
    //       new Address(origin),
    //       0,
    //       0,
    //       0
    //     ]
    //   }
    // )
    itxn_begin
    bytec 24 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/contract.algo.ts:1456
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

initMeta_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:1463
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:1464
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:1459-1470
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    frame_dig 3
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1462
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:1459-1470
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1465
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1459-1470
    // this.meta(origin).value = {
    //   initialized: userIsSender,
    //   wallet: wallet.id,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec 7 // 0x00
    concat
    dig 1
    concat
    swap
    concat
    frame_dig 0
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1472-1483
    // const impactScore = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).impact,
    //     args: [
    //       new Address(origin),
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1475
    // appId: getAkitaAppList(this.akitaDAO.value).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1478
    // subscriptionIndex,
    frame_dig -3
    itob
    // smart_contracts/social/contract.algo.ts:1479
    // NFD,
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:1480
    // akitaNFT
    frame_dig -1
    itob
    // smart_contracts/social/contract.algo.ts:1472-1483
    // const impactScore = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).impact,
    //     args: [
    //       new Address(origin),
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ]
    //   }
    // ).returnValue
    bytec 24 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    frame_dig 1
    dup
    cover 5
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/social/contract.algo.ts:1485
    // return impactScore + this.getSocialImpactScore(origin)
    swap
    callsub getSocialImpactScore
    +
    frame_bury 0
    retsub

initMeta_after_if_else@9:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:1406
    // const origin = originOr(wallet, user.native)
    b initMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@10


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateMeta(followGateID: uint64, addressGateID: uint64, subscriptionIndex: uint64, NFD: uint64, akitaNFT: uint64) -> void:
updateMeta:
    // smart_contracts/social/contract.algo.ts:1488-1494
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): void {
    proto 5 0
    // smart_contracts/social/contract.algo.ts:1495
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1495
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz updateMeta_after_if_else@3
    frame_dig 1

updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1498
    // assert(this.meta(origin).exists, ERR_META_DOESNT_EXIST)
    dup
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:1500
    // this.meta(origin).value.followGateID = followGateID
    frame_dig -5
    itob
    dig 1
    pushint 50 // 50
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:1501
    // this.meta(origin).value.addressGateID = addressGateID
    frame_dig -4
    itob
    pushint 58 // 58
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1503
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1503
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 11 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1503
    // const impact = getAkitaAppList(this.akitaDAO.value).impact
    pushint 104 // 104
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1504-1515
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     appId: impact,
    //     args: [
    //       new Address(origin),
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ]
    //   }
    // )
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1510
    // subscriptionIndex,
    frame_dig -3
    itob
    // smart_contracts/social/contract.algo.ts:1511
    // NFD,
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:1512
    // akitaNFT
    frame_dig -1
    itob
    // smart_contracts/social/contract.algo.ts:1504-1515
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     appId: impact,
    //     args: [
    //       new Address(origin),
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ]
    //   }
    // )
    bytec 24 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub

updateMeta_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b updateMeta_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserSocialImpact(user: bytes) -> uint64:
getUserSocialImpact:
    // smart_contracts/social/contract.algo.ts:1520-1521
    // @abimethod({ readonly: true })
    // getUserSocialImpact(user: Address): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1522
    // return this.getSocialImpactScore(user.native)
    frame_dig -1
    callsub getSocialImpactScore
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isFollower(user: bytes, index: uint64, follower: bytes) -> uint64:
isFollower:
    // smart_contracts/social/contract.algo.ts:1525-1526
    // @abimethod({ readonly: true })
    // isFollower(user: Address, index: uint64, follower: Address): boolean {
    proto 3 1
    // smart_contracts/social/contract.algo.ts:1527
    // return this.follows({ user: user.native, index }).value === follower.native
    frame_dig -2
    itob
    frame_dig -3
    swap
    concat
    // smart_contracts/social/contract.algo.ts:31
    // follows = BoxMap<FollowsKey, Account>({ keyPrefix: AkitaSocialBoxPrefixFollows })
    bytec 23 // "f"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1527
    // return this.follows({ user: user.native, index }).value === follower.native
    box_get
    assert // Box must have value
    frame_dig -1
    ==
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.moderatorMeta(user: bytes) -> bytes:
moderatorMeta:
    // smart_contracts/social/contract.algo.ts:1530-1531
    // @abimethod({ readonly: true })
    // moderatorMeta(user: Address): { exists: boolean; lastActive: uint64 } {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:47
    // moderators = BoxMap<Account, uint64>({ keyPrefix: AkitaSocialBoxPrefixModerators })
    bytec 10 // "d"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1532
    // if (this.moderators(user.native).exists) {
    box_len
    bury 1
    bz moderatorMeta_after_if_else@2
    // smart_contracts/social/contract.algo.ts:1535
    // lastActive: this.moderators(user.native).value
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/social/contract.algo.ts:1533-1536
    // return {
    //   exists: true,
    //   lastActive: this.moderators(user.native).value
    // }
    itob
    bytec 14 // 0x80
    swap
    concat
    swap
    retsub

moderatorMeta_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:1538
    // return { exists: false, lastActive: 0 }
    bytec 27 // 0x000000000000000000
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMeta(user: bytes) -> bytes:
getMeta:
    // smart_contracts/social/contract.algo.ts:1541-1542
    // @abimethod({ readonly: true })
    // getMeta(user: Address): MetaValue {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1543
    // return this.meta(user.native).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMetaWallet(user: bytes) -> uint64:
getMetaWallet:
    // smart_contracts/social/contract.algo.ts:1546-1547
    // @abimethod({ readonly: true })
    // getMetaWallet(user: Address): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1548
    // if (this.meta(user.native).exists) {
    box_len
    bury 1
    bz getMetaWallet_after_if_else@2
    // smart_contracts/social/contract.algo.ts:1549
    // return this.meta(user.native).value.wallet
    frame_dig 0
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    swap
    retsub

getMetaWallet_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:1551
    // return 0
    intc_0 // 0
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.postExists(ref: bytes) -> uint64:
postExists:
    // smart_contracts/social/contract.algo.ts:1554-1555
    // @abimethod({ readonly: true })
    // postExists(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1556
    // assert(ref.length === 32 || ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    dup
    intc_2 // 32
    ==
    dup
    bnz postExists_bool_true@2
    frame_dig 0
    pushint 8 // 8
    ==
    bz postExists_bool_false@3

postExists_bool_true@2:
    intc_1 // 1

postExists_bool_merge@4:
    // smart_contracts/social/contract.algo.ts:1556
    // assert(ref.length === 32 || ref.length === 8, ERR_INVALID_REF_LENGTH)
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:1558
    // if (ref.length === 8) {
    frame_dig 0
    pushint 8 // 8
    ==
    bz postExists_after_if_else@6
    // smart_contracts/social/contract.algo.ts:1559
    // const paddedRef = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1560
    // return this.posts(paddedRef).exists
    box_len
    frame_bury 0
    pop
    retsub

postExists_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:1563
    // return this.posts(ref.toFixed({ length: 32 })).exists
    frame_dig 1
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1563
    // return this.posts(ref.toFixed({ length: 32 })).exists
    box_len
    frame_bury 0
    pop
    retsub

postExists_bool_false@3:
    intc_0 // 0
    b postExists_bool_merge@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.reactionMeta(ref: bytes, NFT: uint64, user: bytes) -> bytes:
reactionMeta:
    // smart_contracts/social/contract.algo.ts:1566-1567
    // @abimethod({ readonly: true })
    // reactionMeta(ref: bytes, NFT: uint64, user: Address): ReactionMeta {
    proto 3 1
    intc_0 // 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:1568
    // const postExists = this.postExists(ref)
    frame_dig -3
    callsub postExists
    dup
    // smart_contracts/social/contract.algo.ts:1569
    // let reactionExists: boolean = false
    intc_0 // 0
    swap
    // smart_contracts/social/contract.algo.ts:1570
    // if (postExists) {
    bz reactionMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1571
    // if (ref.length === 8) {
    frame_dig -3
    len
    dup
    frame_bury 3
    pushint 8 // 8
    ==
    bz reactionMeta_else_body@3
    // smart_contracts/social/contract.algo.ts:1572
    // const paddedRef = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -3
    swap
    concat
    dup
    len
    intc_2 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:1573
    // reactionExists = this.reactions({ ref: paddedRef, NFT }).exists
    frame_dig -2
    itob
    concat
    // smart_contracts/social/contract.algo.ts:41
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 15 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1573
    // reactionExists = this.reactions({ ref: paddedRef, NFT }).exists
    box_len
    frame_bury 5
    pop

reactionMeta_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1579
    // let creatorWallet: uint64 = 0
    intc_0 // 0
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1580
    // let addressGateID: uint64 = 0
    intc_0 // 0
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1581
    // if (this.meta(user.native).exists) {
    box_len
    bury 1
    bz reactionMeta_after_if_else@7
    // smart_contracts/social/contract.algo.ts:1582
    // const { wallet, addressGateID: metaAddressGateID } = this.meta(user.native).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_1 // 1
    extract_uint64
    swap
    pushint 58 // 58
    extract_uint64
    frame_bury 1
    frame_bury 2

reactionMeta_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:1587-1592
    // return {
    //   postExists,
    //   reactionExists,
    //   creatorWallet,
    //   addressGateID
    // }
    bytec 7 // 0x00
    intc_0 // 0
    frame_dig 4
    setbit
    intc_1 // 1
    frame_dig 5
    setbit
    frame_dig 2
    itob
    concat
    frame_dig 1
    itob
    concat
    frame_bury 0
    retsub

reactionMeta_else_body@3:
    // smart_contracts/social/contract.algo.ts:1575
    // reactionExists = this.reactions({ ref: ref.toFixed({ length: 32 }), NFT }).exists
    frame_dig 3
    intc_2 // 32
    ==
    assert // Length must be 32
    frame_dig -2
    itob
    frame_dig -3
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 15 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1575
    // reactionExists = this.reactions({ ref: ref.toFixed({ length: 32 }), NFT }).exists
    box_len
    frame_bury 5
    pop
    b reactionMeta_after_if_else@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPost(ref: bytes) -> bytes:
getPost:
    // smart_contracts/social/contract.algo.ts:1595-1596
    // @abimethod({ readonly: true })
    // getPost(ref: bytes<32>): PostValue {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1597
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1598
    // return this.posts(ref).value
    box_get
    pop
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostAndCreatorMeta(ref: bytes) -> bytes:
getPostAndCreatorMeta:
    // smart_contracts/social/contract.algo.ts:1601-1602
    // @abimethod({ readonly: true })
    // getPostAndCreatorMeta(ref: bytes<32>): { post: PostValue; meta: MetaValue } {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1603
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1604
    // const post = clone(this.posts(ref).value)
    dup
    box_get
    pop
    swap
    // smart_contracts/social/contract.algo.ts:1604-1605
    // const post = clone(this.posts(ref).value)
    // const meta = clone(this.meta(post.creator.native).value)
    intc_0 // 0
    intc_2 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1605
    // const meta = clone(this.meta(post.creator.native).value)
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1606
    // return { post, meta }
    pushbytes 0x0044
    swap
    concat
    swap
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getVote(ref: bytes) -> bytes:
getVote:
    // smart_contracts/social/contract.algo.ts:1609-1610
    // @abimethod({ readonly: true })
    // getVote(ref: bytes<32>): VoteListValue {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1611
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1611
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:120
    // if (walletID.id === 0) {
    bnz getVote_after_if_else@3
    frame_dig 1

getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/social/contract.algo.ts:1614
    // const voteListKey = this.vlk(origin, ref)
    frame_dig -1
    callsub vlk
    // smart_contracts/social/contract.algo.ts:39
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 19 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1615
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1617
    // return this.votelist(voteListKey).value
    box_get
    pop
    frame_bury 0
    retsub

getVote_after_if_else@3:
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec_1 // "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:127
    // return originOr(walletID, Txn.sender)
    b getVote_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostMeta(ref: bytes, NFT: uint64) -> bytes:
getPostMeta:
    // smart_contracts/social/contract.algo.ts:1620-1621
    // @abimethod({ readonly: true })
    // getPostMeta(ref: bytes<32>, NFT: uint64): PostMeta {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:35
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:1622
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1623
    // const post = clone(this.posts(ref).value)
    dup
    box_get
    pop
    swap
    // smart_contracts/social/contract.algo.ts:1623-1624
    // const post = clone(this.posts(ref).value)
    // const meta = clone(this.meta(post.creator.native).value)
    dup
    intc_0 // 0
    intc_2 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:45
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 5 // "m"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1624
    // const meta = clone(this.meta(post.creator.native).value)
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1625
    // const reactionExists = this.reactions({ ref, NFT }).exists
    frame_dig -2
    len
    intc_2 // 32
    ==
    assert // invalid size
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/social/contract.algo.ts:41
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 15 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1625
    // const reactionExists = this.reactions({ ref, NFT }).exists
    box_len
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:1623
    // const post = clone(this.posts(ref).value)
    dig 2
    intc_2 // 32
    pushint 8 // 8
    box_extract
    // smart_contracts/social/contract.algo.ts:1626
    // return { post, meta, reactionExists }
    btoi
    // smart_contracts/social/contract.algo.ts:1623
    // const post = clone(this.posts(ref).value)
    dig 3
    pushints 40 8 // 40, 8
    box_extract
    // smart_contracts/social/contract.algo.ts:1626
    // return { post, meta, reactionExists }
    btoi
    // smart_contracts/social/contract.algo.ts:1623
    // const post = clone(this.posts(ref).value)
    uncover 4
    pushint 48 // 48
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    // smart_contracts/social/contract.algo.ts:1626
    // return { post, meta, reactionExists }
    dig 6
    pushint 49 // 49
    extract_uint16
    dig 7
    len
    uncover 8
    cover 2
    substring3
    extract 2 0
    uncover 4
    itob
    uncover 6
    swap
    concat
    uncover 4
    itob
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_1 // 1
    uncover 4
    setbit
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 22 // 0x0033
    concat
    swap
    concat
    dig 1
    intc_0 // 0
    getbit
    dig 2
    extract 1 8
    dig 3
    extract 9 8
    dig 4
    extract 17 8
    dig 5
    extract 25 8
    dig 6
    extract 33 8
    dig 7
    extract 41 8
    dig 8
    intc 4 // 392
    getbit
    dig 9
    extract 50 8
    uncover 10
    extract 58 8
    bytec 7 // 0x00
    intc_0 // 0
    uncover 11
    setbit
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    concat
    uncover 2
    concat
    swap
    concat
    pushbytes 0x0045
    swap
    concat
    bytec 7 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    concat
    swap
    concat
    retsub


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend(name: bytes, asset: uint64, amount: uint64) -> void:
optAkitaEscrowInAndSend:
    // smart_contracts/utils/base-contracts/escrow.ts:20
    // optAkitaEscrowInAndSend(name: string, asset: Asset, amount: uint64): void {
    proto 3 0
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    itxn_begin
    // smart_contracts/utils/base-contracts/escrow.ts:27
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:27
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/base-contracts/escrow.ts:28
    // amount: (Global.assetOptInMinBalance * 4),
    global AssetOptInMinBalance
    intc_3 // 4
    *
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/base-contracts/escrow.ts:26-29
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: (Global.assetOptInMinBalance * 4),
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    itxn_next
    // smart_contracts/utils/base-contracts/escrow.ts:24
    // appId: this.akitaDAO.value,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:24
    // appId: this.akitaDAO.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/escrow.ts:30
    // name,
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    // smart_contracts/utils/base-contracts/escrow.ts:31
    // asset.id
    frame_dig -2
    itob
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    pushbytes 0x3cc3d0a4 // method "optinReceiveEscrow(pay,string,uint64)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/utils/base-contracts/escrow.ts:36
    // if (amount > 0) {
    frame_dig -1
    bz optAkitaEscrowInAndSend_after_if_else@5
    // smart_contracts/utils/base-contracts/escrow.ts:37-43
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/escrow.ts:39
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:39
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/escrow.ts:37-42
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/escrow.ts:37-43
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit

optAkitaEscrowInAndSend_after_if_else@5:
    retsub


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/escrow.ts:49-50
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/escrow.ts:51
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:51
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 28 // "version"
    // smart_contracts/utils/base-contracts/escrow.ts:52
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/escrow.ts:57
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/escrow.ts:58
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:58
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:59
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/escrow.ts:62
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/escrow.ts:63
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:63
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 8 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:64
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/social/base.ts::BaseSocial.mbr(ref: bytes) -> bytes:
mbr:
    // smart_contracts/social/base.ts:13
    // protected mbr(ref: bytes): AkitaSocialMBRData {
    proto 1 1
    // smart_contracts/social/base.ts:17
    // posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    frame_dig -1
    len
    pushint 400 // 400
    *
    pushint 36500 // 36500
    +
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    pushbytes 0x0000000000007bd40000000000003d54
    swap
    concat
    // smart_contracts/social/base.ts:18
    // votes: VotesMBR,
    pushint 19300 // 19300
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:20
    // reactions: ReactionsMBR,
    pushint 22100 // 22100
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    // smart_contracts/social/base.ts:21
    // reactionlist: ReactionlistMBR,
    pushint 18900 // 18900
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/base.ts:22
    // meta: MetaMBR,
    pushint 42100 // 42100
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:25
    // actions: ActionsMBR
    pushint 29700 // 29700
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    retsub
