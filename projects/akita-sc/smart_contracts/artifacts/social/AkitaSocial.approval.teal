#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 100000 13200 31700 63072000 86400 60600
    bytecblock "akita_dao" 0x151f7c75 "p" 0x00 "m" 0x14 "akita_escrow" "akita_assets" "sal" "social_fees" 0x0000 "wallet" 0x80 0x0a 0x03 "o" "pal" 0x01 "w" "paywall_id" "aal" 0x0001 0x6835e3bc "a" 0x02 "r" 0x27e3bb4f 0x84269c78 "version" 0x582ff382 0x6cc3f606 0x000000000000000000 0x003d
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 19 // "paywall_id"
    intc_1 // 1
    app_global_put

main_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@40
    pushbytess 0x83f14748 0x7105bbad 0xba4bf794 0xd5c8e7b8 0x2ffc3123 0x72724f96 0x1c99fe9e 0x02e92631 0x84fa4b5e 0x6e7d42c2 0xd0e5b18d 0x6e5b7702 0xeac6d922 0x856433ea 0xd09f3de8 0x69a4ef97 0x3306b32a // method "init()void", method "post(pay,axfer,uint64,byte[24],byte[36],uint64,bool,uint64)void", method "editPost(pay,axfer,byte[36],byte[32])void", method "gatedReply(pay,axfer,appl,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void", method "reply(pay,axfer,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void", method "gatedEditReply(pay,axfer,appl,byte[36],byte[32])void", method "editReply(pay,axfer,byte[36],byte[32])void", method "vote(pay,axfer,byte[],uint8,bool)void", method "editVote(pay,axfer,byte[32],bool)void", method "gatedReact(pay,axfer,appl,byte[],uint8,uint64)void", method "react(pay,axfer,byte[],uint8,uint64)void", method "deleteReaction(byte[32],uint64)void", method "setPostFlag(byte[32],bool)void", method "initMeta(pay,address,bool,uint64,uint64,uint64)uint64", method "createPayWall(pay,((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", method "updateMeta(uint64,uint64,uint64,uint64,uint64,uint64)void", method "updateFollowerMeta(address,uint64,uint64)void"
    bytec 27 // method "isBanned(address)bool"
    pushbytess 0xe869934d 0xe6e67bdc 0x739ea70b 0xc022be89 0x984baef5 0x9e174bb6 0xa8912044 0xf13600d1 0x92e6dd3b 0xa134a278 0x344175f0 0x1ead20a9 0x33e92c94 0x854dede0 // method "getUserSocialImpact(address)uint64", method "getMetaExists(address)bool", method "getMeta(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64,uint64)", method "getPostExists(byte[32])bool", method "getPost(byte[32])(address,uint64,uint64,bool,uint64,bool,uint8,byte[])", method "getVote(address,byte[32])(uint64,bool)", method "getVotes((address,byte[32])[])(uint64,bool)[]", method "getReactionExists(byte[32],uint64)bool", method "mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", method "checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)", method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match init post editPost gatedReply reply gatedEditReply editReply vote editVote gatedReact react deleteReaction setPostFlag initMeta createPayWall updateMeta updateFollowerMeta isBanned getUserSocialImpact getMetaExists getMeta getPostExists getPost getVote getVotes getReactionExists mbr payWallMbr checkTipMbrRequirements updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@38
    err

main_opUp_route@38:
    // smart_contracts/utils/base-contracts/base.ts:43
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@40:
    // smart_contracts/social/contract.algo.ts:27
    // export class AkitaSocial extends classes(BaseSocial, AkitaBaseFeeGeneratorContract) {
    pushbytes 0x88c940f8 // method "create(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/social/contract.algo.ts::b16(b: bytes) -> bytes:
b16:
    // smart_contracts/social/contract.algo.ts:23
    // export function b16(b: bytes): bytes<16> {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:24
    // return b.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    retsub


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:126
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:128
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    pushint 1000 // 1000
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::referrerOrZeroAddress(walletID: uint64) -> bytes:
referrerOrZeroAddress:
    // smart_contracts/utils/functions.ts:156
    // export function referrerOrZeroAddress(walletID: Application): Account {
    proto 1 1
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    global ZeroAddress
    // smart_contracts/utils/functions.ts:150
    // if (walletID.id === 0) {
    frame_dig -1
    bnz referrerOrZeroAddress_after_if_else@3
    frame_dig 0

referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4:
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    swap
    retsub

referrerOrZeroAddress_after_if_else@3:
    // smart_contracts/utils/functions.ts:169-172
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:171
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:169-172
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157
    // return referrerOr(walletID, Global.zeroAddress)
    b referrerOrZeroAddress_after_inlined_smart_contracts/utils/functions.ts::referrerOr@4


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:176
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:55
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig -2
    pushbytes "oal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:60
    // return getOtherAppList(akitaDAO).escrow
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:182-185
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:187
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:188
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:191
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:227
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 20 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:230
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:231
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    pushint 4 // 4
    ==
    // smart_contracts/utils/functions.ts:229-231
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:232
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x43922655 // method "mustCheck(address,uint64,byte[][])void"
    ==
    // smart_contracts/utils/functions.ts:229-232
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:233
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:229-233
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:234
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:229-234
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@7
    intc_1 // 1
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@7:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/utils/functions.ts::sendReferralPayment(akitaDAO: uint64, asset: uint64, amount: uint64) -> bytes:
sendReferralPayment:
    // smart_contracts/utils/functions.ts:558
    // export function sendReferralPayment(akitaDAO: Application, asset: uint64, amount: uint64): ReferralPaymentInfo {
    proto 3 1
    intc_0 // 0
    pushbytes ""
    dupn 4
    // smart_contracts/utils/functions.ts:559
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    frame_dig -3
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:560
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    // smart_contracts/utils/functions.ts:563
    // if (amount > 0 && referrer !== Global.zeroAddress) {
    frame_dig -1
    bz sendReferralPayment_after_if_else@6
    frame_dig 6
    global ZeroAddress
    !=
    bz sendReferralPayment_after_if_else@6
    // smart_contracts/utils/functions.ts:64
    // const [walletFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysWalletFees))
    frame_dig -3
    pushbytes "wallet_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:565
    // const { referrerPercentage } = getWalletFees(akitaDAO)
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 3
    // smart_contracts/utils/functions.ts:568
    // if (referralFee === 0 && amount > 0) {
    bnz sendReferralPayment_after_if_else@5
    frame_dig -1
    bz sendReferralPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:569
    // referralFee = 1
    intc_1 // 1
    frame_bury 3

sendReferralPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:575
    // Global.latestTimestamp,
    global LatestTimestamp
    frame_bury 5
    // smart_contracts/utils/functions.ts:576
    // (Global.latestTimestamp + ONE_WEEK),
    global LatestTimestamp
    pushint 604800 // 604800
    +
    frame_bury 2
    // smart_contracts/utils/functions.ts:577
    // [{ address: referrer, amount: referralFee }],
    frame_dig 3
    itob
    frame_dig 6
    swap
    concat
    bytec 21 // 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 20 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:493
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 4
    // smart_contracts/utils/functions.ts:496
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc_0 // 0
    extract_uint16
    pushint 25300 // 25300
    *
    pushint 35300 // 35300
    +
    frame_bury 1
    // smart_contracts/utils/functions.ts:497
    // if (asset === 0) {
    frame_dig -2
    bnz sendReferralPayment_else_body@9
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:502
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:503
    // amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    frame_dig 1
    frame_dig 3
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:501-504
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:505
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:506
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:498-509
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0x7b7dc5fc // method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi

sendReferralPayment_after_if_else@12:
    // smart_contracts/utils/functions.ts:544
    // return { id, cost }
    itob
    frame_dig 1
    itob
    concat
    // smart_contracts/utils/functions.ts:572-579
    // const { cost: referralMbr } = createInstantDisbursement(
    //   akitaDAO,
    //   asset,
    //   Global.latestTimestamp,
    //   (Global.latestTimestamp + ONE_WEEK),
    //   [{ address: referrer, amount: referralFee }],
    //   referralFee
    // )
    extract 8 8
    // smart_contracts/utils/functions.ts:581
    // return { leftover: (amount - referralFee), referralMbr }
    frame_dig -1
    frame_dig 3
    -
    itob
    swap
    concat
    frame_bury 0
    retsub

sendReferralPayment_else_body@9:
    // smart_contracts/utils/functions.ts:511
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 4
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bz sendReferralPayment_if_body@10
    frame_dig 1

sendReferralPayment_after_if_else@11:
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:529
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:528-531
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:532-536
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/utils/functions.ts:533
    // assetReceiver: Application(rewardsApp).address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/functions.ts:532-536
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:537
    // timeToUnlock,
    frame_dig 5
    itob
    // smart_contracts/utils/functions.ts:538
    // expiration,
    frame_dig 2
    itob
    // smart_contracts/utils/functions.ts:525-541
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0xaf1a14f2 // method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 2 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    frame_bury 1
    b sendReferralPayment_after_if_else@12

sendReferralPayment_if_body@10:
    // smart_contracts/utils/functions.ts:512
    // cost += Global.assetOptInMinBalance
    frame_dig 1
    global AssetOptInMinBalance
    +
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    itxn_begin
    // smart_contracts/utils/functions.ts:517
    // receiver: Application(rewardsApp).address,
    frame_dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:518
    // amount: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:516-519
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: Global.assetOptInMinBalance
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/functions.ts:520
    // Asset(asset)
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:513-522
    // abiCall<typeof Rewards.prototype.optIn>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     Asset(asset)
    //   ]
    // })
    pushbytes 0x394eaeb2 // method "optIn(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b sendReferralPayment_after_if_else@11

sendReferralPayment_after_if_else@6:
    // smart_contracts/utils/functions.ts:584
    // return { leftover: amount, referralMbr: 0 }
    frame_dig -1
    itob
    intc_0 // 0
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.create[routing]() -> void:
create:
    // smart_contracts/social/contract.algo.ts:710
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 28 // "version"
    // smart_contracts/social/contract.algo.ts:712
    // this.version.value = version
    uncover 3
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:713
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:714
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:710
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.init[routing]() -> void:
init:
    pushbytes ""
    dupn 3
    // smart_contracts/social/contract.algo.ts:718
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:718
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:718
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    dup
    // smart_contracts/social/contract.algo.ts:719
    // assert(!Global.currentApplicationAddress.isOptedIn(akta), ERR_ALREADY_OPTED_IN)
    global CurrentApplicationAddress
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // already opted in
    // smart_contracts/social/contract.algo.ts:721-727
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:723
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 1
    itxn_field XferAsset
    // smart_contracts/social/contract.algo.ts:724
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:721-726
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:721-727
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:729
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(akta)) {
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:729
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(akta)) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz init_after_if_else@4
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check GlobalState exists
    dup
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    dup
    cover 2
    bury 4
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dup
    bytec 16 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:83
    // const { revenueManager } = getPluginAppList(this.akitaDAO.value)
    dup
    extract 8 8
    swap
    intc_2 // 8
    extract_uint64
    bury 6
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    swap
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:70-73
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    itxn_begin
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:72
    // args: [[name]],
    pushbytes 0x00010002000a7265765f736f6369616c
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:70-73
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/utils/base-contracts/base.ts:75
    // assert(escrow.id !== 0, ERR_ESCROW_DOES_NOT_EXIST)
    extract 6 9
    intc_0 // 0
    extract_uint64
    dup
    assert // Escrow does not exist
    // smart_contracts/utils/base-contracts/base.ts:86
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:86
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Wrong escrow for this operation
    // smart_contracts/utils/base-contracts/base.ts:88-97
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    itxn_begin
    bytec 29 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:92
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:93
    // name,
    pushbytes 0x000a7265765f736f6369616c
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:94
    // [0], // all the akita escrows have method restrictions with optin being index 0
    pushbytes 0x00010000000000000000
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:95
    // []
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:88-97
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:101
    // this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:588
    // let count: uint64 = 0
    intc_0 // 0
    bury 5
    // smart_contracts/utils/functions.ts:590
    // if (!escrow.isOptedIn(asset)) {
    dig 1
    asset_holding_get AssetBalance
    bury 1
    bnz init_after_if_else@7
    // smart_contracts/utils/functions.ts:99
    // const [splitsBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysRevenueSplits))
    dig 4
    pushbytes "revenue_splits"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    intc_0 // 0
    extract_uint16
    // smart_contracts/utils/functions.ts:591
    // count += 1
    intc_1 // 1
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    +
    bury 4

init_after_if_else@7:
    // smart_contracts/utils/base-contracts/base.ts:105
    // const mbrAmount: uint64 = Global.assetOptInMinBalance * optInCount
    global AssetOptInMinBalance
    dig 4
    *
    // smart_contracts/utils/base-contracts/base.ts:107-118
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:114
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:114
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/utils/base-contracts/base.ts:113-116
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:107-118
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:110
    // wallet,
    dig 1
    dup
    itob
    // smart_contracts/utils/base-contracts/base.ts:112
    // [asset.id],
    dig 2
    itob
    bytec 21 // 0x0001
    swap
    concat
    // smart_contracts/utils/base-contracts/base.ts:107-118
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    bytec 22 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:92
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:107-118
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:120
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({ appId: wallet })
    itxn_next
    bytec 30 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:132
    // itxnCompose.submit()
    itxn_submit

init_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:717
    // init(): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.post[routing]() -> void:
post:
    // smart_contracts/social/contract.algo.ts:740-749
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:751
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 6
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:754
    // const postKey = op.sha256(Txn.sender.bytes.concat(itob(timestamp)).concat(nonce))
    txn Sender
    uncover 6
    itob
    concat
    uncover 5
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:756
    // this.validateTip(tip, TipActionPost)
    uncover 5
    bytec 13 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:757
    // this.createPost(postKey, mbrPayment, cid, gateID, usePayWall, payWallID, PostTypePost, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    cover 6
    cover 6
    bytec_3 // 0x00
    uncover 7
    callsub createPost
    // smart_contracts/social/contract.algo.ts:740-749
    // post(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.editPost[routing]() -> void:
editPost:
    // smart_contracts/social/contract.algo.ts:760-765
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:766
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:767
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/social/contract.algo.ts:768
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    txn Sender
    // smart_contracts/social/contract.algo.ts:53
    // return creator === sender
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:768
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:769
    // assert(!this.isReply(postType), ERR_IS_A_REPLY)
    dup
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/social/contract.algo.ts:770
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:774
    // const editKey = op.sha256(Txn.sender.bytes.concat(amendment).concat(Bytes(cid)))
    txn Sender
    dig 6
    concat
    dig 7
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:777
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 23 // "a"
    dig 1
    concat
    uncover 5
    swap
    concat
    dig 5
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 5
    box_del
    pop
    uncover 5
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:779
    // this.validateTip(tip, TipActionPost)
    uncover 6
    bytec 13 // 0x0a
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:780
    // this.createPost(editKey, mbrPayment, cid, gateID, usePayWall, payWallID, PostTypeEditPost, amendment)
    uncover 6
    uncover 6
    uncover 5
    uncover 5
    uncover 5
    bytec 24 // 0x02
    uncover 7
    callsub createPost
    // smart_contracts/social/contract.algo.ts:760-765
    // editPost(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReply[routing]() -> void:
gatedReply:
    // smart_contracts/social/contract.algo.ts:783-795
    // gatedReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:796
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    uncover 3
    uncover 4
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:799
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 8
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:801
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:802
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:803
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, postGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:803
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, postGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    uncover 12
    cover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:805
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:806
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:809
    // const replyKey = op.sha256(Txn.sender.bytes.concat(itob(timestamp)).concat(nonce))
    txn Sender
    uncover 8
    itob
    concat
    uncover 7
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:811
    // this.validateTip(tip, TipActionReact)
    uncover 7
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:812
    // this.createReply(replyKey, mbrPayment, addedMbr, cid, refBytes, gateID, usePayWall, payWallID, PostTypeReply, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    uncover 8
    uncover 3
    uncover 8
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    bytec 17 // 0x01
    uncover 9
    callsub createReply
    // smart_contracts/social/contract.algo.ts:783-795
    // gatedReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.reply[routing]() -> void:
reply:
    // smart_contracts/social/contract.algo.ts:815-826
    // reply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for uint8[24]
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:827
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    uncover 3
    uncover 4
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:830
    // assert(Global.latestTimestamp - timestamp <= MAX_TIMESTAMP_DRIFT, ERR_TIMESTAMP_TOO_OLD)
    global LatestTimestamp
    dig 8
    -
    pushint 60 // 60
    <=
    assert // Provided timestamp is too far in the past
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:832
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:833
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:834
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:836
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:837
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:840
    // const replyKey = op.sha256(Txn.sender.bytes.concat(itob(timestamp)).concat(nonce))
    txn Sender
    uncover 8
    itob
    concat
    uncover 7
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:842
    // this.validateTip(tip, TipActionReact)
    uncover 7
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:843
    // this.createReply(replyKey, mbrPayment, addedMbr, cid, refBytes, gateID, usePayWall, payWallID, PostTypeReply, op.bzero(32) as bytes<32>)
    intc_3 // 32
    bzero
    swap
    uncover 8
    uncover 3
    uncover 8
    uncover 5
    uncover 8
    uncover 8
    uncover 8
    bytec 17 // 0x01
    uncover 9
    callsub createReply
    // smart_contracts/social/contract.algo.ts:815-826
    // reply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   timestamp: uint64,
    //   nonce: bytes<24>,
    //   cid: CID,
    //   ref: bytes,
    //   type: RefType,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedEditReply[routing]() -> void:
gatedEditReply:
    // smart_contracts/social/contract.algo.ts:846-852
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:853
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:853
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    pop
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:855
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:856
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/social/contract.algo.ts:857
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    txn Sender
    // smart_contracts/social/contract.algo.ts:53
    // return creator === sender
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:857
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:858
    // assert(this.isReply(postType), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:859
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:862
    // const editKey = op.sha256(Txn.sender.bytes.concat(amendment).concat(Bytes(cid)))
    txn Sender
    dig 6
    concat
    dig 7
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:865
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 23 // "a"
    dig 1
    concat
    dig 5
    swap
    concat
    dig 6
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 6
    box_del
    pop
    uncover 6
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:868
    // const parentPostRef = ref.slice(36, 68).toFixed({ length: 32 })
    dig 4
    len
    pushint 36 // 36
    dig 1
    >=
    pushint 36 // 36
    dig 2
    uncover 2
    select
    pushint 68 // 68
    dig 2
    >=
    pushint 68 // 68
    uncover 3
    uncover 2
    select
    uncover 6
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:869
    // const { gateID: ogPostGateID } = this.posts(parentPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:870
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, ogPostGateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:870
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, ogPostGateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    uncover 10
    cover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:872
    // this.validateTip(tip, TipActionReact)
    uncover 7
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:873
    // this.createReply(editKey, mbrPayment, 0, cid, parentPostRef, gateID, usePayWall, payWallID, PostTypeEditReply, amendment)
    swap
    uncover 7
    intc_0 // 0
    uncover 8
    uncover 4
    uncover 7
    uncover 7
    uncover 7
    bytec 14 // 0x03
    uncover 9
    callsub createReply
    // smart_contracts/social/contract.algo.ts:846-852
    // gatedEditReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   cid: CID,
    //   amendment: bytes<32>,
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.editReply[routing]() -> void:
editReply:
    // smart_contracts/social/contract.algo.ts:876-881
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:882
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/social/contract.algo.ts:883
    // const { creator, ref, gateID, usePayWall, payWallID, postType } = this.posts(amendment).value
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    dig 2
    pushint 59 // 59
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 2
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 48 // 48
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 4
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    dig 5
    pushint 58 // 58
    intc_1 // 1
    box_extract
    // smart_contracts/social/contract.algo.ts:884
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    txn Sender
    // smart_contracts/social/contract.algo.ts:53
    // return creator === sender
    uncover 6
    ==
    // smart_contracts/social/contract.algo.ts:884
    // assert(this.isCreator(creator, Txn.sender), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/social/contract.algo.ts:885
    // assert(this.isReply(postType), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/social/contract.algo.ts:886
    // assert(!this.isAmended(ref, postType), ERR_IS_ALREADY_AMENDED)
    dig 4
    swap
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/social/contract.algo.ts:889
    // const editKey = op.sha256(Txn.sender.bytes.concat(amendment).concat(Bytes(cid)))
    txn Sender
    dig 6
    concat
    dig 7
    concat
    sha256
    // smart_contracts/social/contract.algo.ts:892
    // this.posts(amendment).value.ref = ref.concat(Bytes('a').concat(editKey))
    bytec 23 // "a"
    dig 1
    concat
    dig 5
    swap
    concat
    dig 6
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 59 // 59
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 6
    box_del
    pop
    uncover 6
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:895
    // const parentPostRef = ref.slice(36, 68).toFixed({ length: 32 })
    dig 4
    len
    pushint 36 // 36
    dig 1
    >=
    pushint 36 // 36
    dig 2
    uncover 2
    select
    pushint 68 // 68
    dig 2
    >=
    pushint 68 // 68
    uncover 3
    uncover 2
    select
    uncover 6
    cover 2
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:896
    // const { gateID: ogPostGateID } = this.posts(parentPostRef).value
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:897
    // assert(ogPostGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:899
    // this.validateTip(tip, TipActionReact)
    uncover 7
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:900
    // this.createReply(editKey, mbrPayment, 0, cid, parentPostRef, gateID, usePayWall, payWallID, PostTypeEditReply, amendment)
    swap
    uncover 7
    intc_0 // 0
    uncover 8
    uncover 4
    uncover 7
    uncover 7
    uncover 7
    bytec 14 // 0x03
    uncover 9
    callsub createReply
    // smart_contracts/social/contract.algo.ts:876-881
    // editReply(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   cid: CID,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.vote[routing]() -> void:
vote:
    // smart_contracts/social/contract.algo.ts:903-909
    // vote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   isUp: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    // smart_contracts/social/contract.algo.ts:910
    // let { refBytes, creator } = this.toBytes32(type, ref)
    dup
    uncover 2
    callsub toBytes32
    dup
    extract 0 32
    cover 2
    extract 32 32
    swap
    // smart_contracts/social/contract.algo.ts:911
    // if (type === RefTypePost) {
    bytec 13 // 0x0a
    ==
    bz vote_after_if_else@3
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:912
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND);
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:913
    // ({ creator } = this.posts(refBytes).value);
    intc_0 // 0
    intc_3 // 32
    box_extract
    bury 1

vote_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:916
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, creator)
    dig 1
    dup
    dig 2
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:918
    // this.validateTip(tip, TipActionReact)
    dig 5
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:919
    // const mbrNeeded: uint64 = this.mbr(Bytes('')).votelist + addedMbr
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    intc_3 // 32
    extract_uint64
    +
    // smart_contracts/social/contract.algo.ts:920
    // this.createVote(mbrPayment, mbrNeeded, refBytes, isUp)
    dig 6
    swap
    uncover 2
    dig 5
    callsub createVote
    // smart_contracts/social/contract.algo.ts:903-909
    // vote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   isUp: boolean
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.editVote[routing]() -> void:
editVote:
    // smart_contracts/social/contract.algo.ts:923-928
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:929
    // const voteListKey: VoteListKey = { user: b16(Txn.sender.bytes), ref: b16(ref) }
    txn Sender
    callsub b16
    dig 2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 15 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:930
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:932
    // const { impact, isUp } = this.votelist(voteListKey).value
    dup
    box_get
    pop
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:935
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    cover 5
    uncover 4
    swap
    uncover 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:938
    // this.votelist(voteListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:941
    // if (!flip) {
    bnz editVote_after_if_else@4
    // smart_contracts/social/contract.algo.ts:943-948
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:945
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:946
    // amount: this.mbr(Bytes('')).votelist
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    intc_3 // 32
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:943-947
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:943-948
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).votelist
    //   })
    //   .submit()
    itxn_submit

editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5:
    // smart_contracts/social/contract.algo.ts:923-928
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    intc_1 // 1
    return

editVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:954
    // this.validateTip(tip, TipActionReact)
    dig 2
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:955
    // this.createVote(mbrPayment, 0, ref, !isUp)
    dig 3
    intc_0 // 0
    dig 3
    dig 3
    callsub createVote
    // smart_contracts/social/contract.algo.ts:923-928
    // editVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes<32>,
    //   flip: boolean
    // ): void {
    b editVote_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.editVote@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.gatedReact[routing]() -> void:
gatedReact:
    // smart_contracts/social/contract.algo.ts:958-965
    // gatedReact(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:966
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    swap
    uncover 2
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:968
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:969
    // const { creator, gateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:970
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:970
    // assert(gateCheck(gateTxn, this.akitaDAO.value, Txn.sender, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    uncover 7
    cover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/social/contract.algo.ts:972
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:973
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:975
    // this.validateTip(tip, TipActionReact)
    uncover 3
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:976
    // this.createReaction(mbrPayment, addedMbr, refBytes, NFT)
    uncover 3
    swap
    uncover 2
    uncover 3
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:958-965
    // gatedReact(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.react[routing]() -> void:
react:
    // smart_contracts/social/contract.algo.ts:979-985
    // react(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:986
    // const { refBytes, creator: fallback } = this.toBytes32(type, ref)
    swap
    uncover 2
    callsub toBytes32
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:988
    // assert(this.posts(refBytes).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:989
    // const { creator, gateID: postGateID } = this.posts(refBytes).value
    dup
    intc_0 // 0
    intc_3 // 32
    box_extract
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/social/contract.algo.ts:990
    // assert(postGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate
    // smart_contracts/social/contract.algo.ts:992
    // const c = (fallback === Global.zeroAddress) ? creator : fallback
    dig 1
    global ZeroAddress
    ==
    select
    // smart_contracts/social/contract.algo.ts:993
    // const addedMbr = this.createEmptyPostIfNecessary(refBytes, c)
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/social/contract.algo.ts:995
    // this.validateTip(tip, TipActionReact)
    uncover 3
    bytec 5 // 0x14
    callsub validateTip
    // smart_contracts/social/contract.algo.ts:996
    // this.createReaction(mbrPayment, addedMbr, refBytes, NFT)
    uncover 3
    swap
    uncover 2
    uncover 3
    callsub createReaction
    // smart_contracts/social/contract.algo.ts:979-985
    // react(
    //   mbrPayment: gtxn.PaymentTxn,
    //   tip: gtxn.AssetTransferTxn,
    //   ref: bytes,
    //   type: RefType,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.deleteReaction[routing]() -> void:
deleteReaction:
    // smart_contracts/social/contract.algo.ts:999
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1000
    // assert(!this.isBanned(Txn.sender), ERR_BANNED)
    txn Sender
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    dig 2
    concat
    // smart_contracts/social/contract.algo.ts:1001
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1002
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:1003
    // assert(!this.isBlocked(creator, Txn.sender), ERR_BLOCKED)
    txn Sender
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:1005
    // const reactionListKey: ReactionListKey = { user: b16(Txn.sender.bytes), ref: b16(ref), NFT }
    txn Sender
    callsub b16
    dig 2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    swap
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:46
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1007
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:1009
    // this.reactions({ ref, NFT }).value -= 1
    cover 2
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 25 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1009
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1010
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/social/contract.algo.ts:1012-1018
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1014
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1015
    // amount: this.mbr(Bytes('')).reactionlist,
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 48 // 48
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1012-1017
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1012-1018
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.mbr(Bytes('')).reactionlist,
    // 
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:999
    // deleteReaction(ref: bytes<32>, NFT: uint64): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.setPostFlag[routing]() -> void:
setPostFlag:
    // smart_contracts/social/contract.algo.ts:1021
    // setPostFlag(ref: bytes<32>, flagged: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1023
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1023
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1023
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).moderation).address, 'ERR:NOT_MODERATION')
    pushint 24 // 24
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // ERR:NOT_MODERATION
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:1024
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1025
    // this.posts(ref).value.againstContentPolicy = flagged
    dup
    pushint 57 // 57
    intc_1 // 1
    box_extract
    intc_0 // 0
    uncover 3
    setbit
    pushint 57 // 57
    swap
    box_replace
    // smart_contracts/social/contract.algo.ts:1021
    // setPostFlag(ref: bytes<32>, flagged: boolean): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta[routing]() -> void:
initMeta:
    // smart_contracts/social/contract.algo.ts:1028-1035
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1036
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1036
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, user)
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    callsub getWalletIDUsingAkitaDAO
    cover 3
    // smart_contracts/social/contract.algo.ts:1037
    // const userIsSender = (Txn.sender === user)
    txn Sender
    uncover 2
    ==
    cover 3
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:1039
    // assert(!this.meta(Txn.sender).exists, ERR_META_ALREADY_EXISTS)
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:1039
    // assert(!this.meta(Txn.sender).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/social/contract.algo.ts:1041-1048
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1044
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1041-1048
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1045
    // amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 56 // 56
    extract_uint64
    intc 6 // 31700
    +
    // smart_contracts/social/contract.algo.ts:1041-1048
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).meta + ImpactMetaMBR
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:1050
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1050
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1050
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    pushint 16 // 16
    extract_uint64
    dup
    cover 4
    // smart_contracts/social/contract.algo.ts:1052-1057
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1054
    // receiver: Application(impact).address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/social/contract.algo.ts:1055
    // amount: ImpactMetaMBR
    intc 6 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/social/contract.algo.ts:1052-1056
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:1052-1057
    // itxn
    //   .payment({
    //     receiver: Application(impact).address,
    //     amount: ImpactMetaMBR
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:1059
    // if (automated) {
    bz initMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1060
    // this.createDefaultMeta(Txn.sender, userIsSender, wallet.id, true)
    txn Sender
    cover 2
    intc_1 // 1
    callsub createDefaultMeta
    // smart_contracts/social/contract.algo.ts:1062-1070
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     Txn.sender,
    //     0,
    //     0,
    //     0
    //   ]
    // })
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1065
    // Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1066
    // 0,
    intc_0 // 0
    itob
    // smart_contracts/social/contract.algo.ts:1062-1070
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     Txn.sender,
    //     0,
    //     0,
    //     0
    //   ]
    // })
    bytec 26 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1072
    // return 0
    intc_0 // 0

initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7:
    // smart_contracts/social/contract.algo.ts:1028-1035
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

initMeta_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1075
    // this.createDefaultMeta(Txn.sender, userIsSender, wallet.id, false)
    txn Sender
    cover 2
    intc_0 // 0
    callsub createDefaultMeta
    // smart_contracts/social/contract.algo.ts:1077-1085
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [
    //     Txn.sender,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1078
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1078
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1078
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1080
    // Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1077-1085
    // const impactScore = abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [
    //     Txn.sender,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // }).returnValue
    bytec 26 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1087
    // return impactScore + this.getSocialImpactScore(Txn.sender)
    txn Sender
    callsub getSocialImpactScore
    +
    // smart_contracts/social/contract.algo.ts:1028-1035
    // initMeta(
    //   mbrPayment: gtxn.PaymentTxn,
    //   user: Account,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    // ): uint64 {
    b initMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.initMeta@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPayWall[routing]() -> void:
createPayWall:
    // smart_contracts/social/contract.algo.ts:1090
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1091-1099
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1094
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1091-1099
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1096
    // greaterThanEq: this.payWallMbr(payWall)
    uncover 2
    callsub smart_contracts/social/base.ts::BaseSocial.payWallMbr
    // smart_contracts/social/contract.algo.ts:1091-1099
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.payWallMbr(payWall)
    //     }
    //   }
    // )
    cover 2
    >=
    uncover 2
    &&
    assert // assert target is match for conditions
    // smart_contracts/social/contract.algo.ts:1101
    // const id = this.payWallId.value
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 19 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1101
    // const id = this.payWallId.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/social/contract.algo.ts:1102
    // this.payWallId.value++
    dup
    intc_1 // 1
    +
    // smart_contracts/social/contract.algo.ts:31
    // payWallId = GlobalState<uint64>({ key: AkitaSocialGlobalStateKeysPaywallID, initialValue: 1 })
    bytec 19 // "paywall_id"
    // smart_contracts/social/contract.algo.ts:1102
    // this.payWallId.value++
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:1104
    // this.paywall(id).value = clone(payWall)
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 18 // "w"
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:1104
    // this.paywall(id).value = clone(payWall)
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/social/contract.algo.ts:1090
    // createPayWall(mbrPayment: gtxn.PaymentTxn, payWall: ViewPayWallValue): uint64 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateMeta[routing]() -> void:
updateMeta:
    // smart_contracts/social/contract.algo.ts:1109-1116
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    dup
    btoi
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:1117
    // assert(this.meta(Txn.sender).exists, ERR_META_DOESNT_EXIST)
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:1117
    // assert(this.meta(Txn.sender).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:1119
    // this.meta(Txn.sender).value.followGateID = followGateID
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:1119
    // this.meta(Txn.sender).value.followGateID = followGateID
    pushint 50 // 50
    uncover 8
    box_replace
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:1120
    // this.meta(Txn.sender).value.addressGateID = addressGateID
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:1120
    // this.meta(Txn.sender).value.addressGateID = addressGateID
    pushint 58 // 58
    uncover 7
    box_replace
    // smart_contracts/social/contract.algo.ts:1121
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 18 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1121
    // assert(this.paywall(defaultPayWallID).exists, 'ERR:NOPAYWALL')
    box_len
    bury 1
    assert // ERR:NOPAYWALL
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:1122
    // this.meta(Txn.sender).value.defaultPayWallID = defaultPayWallID
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:1122
    // this.meta(Txn.sender).value.defaultPayWallID = defaultPayWallID
    pushint 66 // 66
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:1124
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1124
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1124
    // const impact = getAkitaSocialAppList(this.akitaDAO.value).impact
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1125-1133
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     Txn.sender,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // })
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1128
    // Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:1125-1133
    // abiCall<typeof AkitaSocialImpact.prototype.cacheMeta>({
    //   appId: impact,
    //   args: [
    //     Txn.sender,
    //     subscriptionIndex,
    //     NFD,
    //     akitaNFT
    //   ]
    // })
    bytec 26 // method "cacheMeta(address,uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    // smart_contracts/social/contract.algo.ts:1109-1116
    // updateMeta(
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64,
    //   defaultPayWallID: uint64
    // ): void {
    return // on error: invalid number of bytes for uint64


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateFollowerMeta[routing]() -> void:
updateFollowerMeta:
    // smart_contracts/social/contract.algo.ts:1136
    // updateFollowerMeta(address: Account, newFollowerIndex: uint64, newFollowerCount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/social/contract.algo.ts:1137
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1137
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1137
    // assert(Txn.sender === Application(getAkitaSocialAppList(this.akitaDAO.value).graph).address, ERR_NOT_GRAPH)
    intc_2 // 8
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the social graph app
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    uncover 3
    concat
    // smart_contracts/social/contract.algo.ts:1138
    // this.meta(address).value.followerIndex = newFollowerIndex
    dup
    pushint 33 // 33
    uncover 4
    box_replace
    // smart_contracts/social/contract.algo.ts:1139
    // this.meta(address).value.followerCount = newFollowerCount
    pushint 41 // 41
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:1136
    // updateFollowerMeta(address: Account, newFollowerIndex: uint64, newFollowerCount: uint64): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned[routing]() -> void:
isBanned:
    // smart_contracts/social/contract.algo.ts:1144
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserSocialImpact[routing]() -> void:
getUserSocialImpact:
    // smart_contracts/social/contract.algo.ts:1152
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1154
    // return this.getSocialImpactScore(user)
    callsub getSocialImpactScore
    // smart_contracts/social/contract.algo.ts:1152
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMetaExists[routing]() -> void:
getMetaExists:
    // smart_contracts/social/contract.algo.ts:1157
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1159
    // return this.meta(user).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:1157
    // @abimethod({ readonly: true })
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getMeta[routing]() -> void:
getMeta:
    // smart_contracts/social/contract.algo.ts:1162
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1164
    // return this.meta(user).value
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1162
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPostExists[routing]() -> void:
getPostExists:
    // smart_contracts/social/contract.algo.ts:1168
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1170
    // return this.posts(ref).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:1168
    // @abimethod({ readonly: true })
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getPost[routing]() -> void:
getPost:
    // smart_contracts/social/contract.algo.ts:1173
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1175
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:1176
    // return this.posts(ref).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1173
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getVote[routing]() -> void:
getVote:
    // smart_contracts/social/contract.algo.ts:1179
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1181
    // const voteListKey: VoteListKey = { user: b16(account.bytes), ref: b16(ref) }
    swap
    callsub b16
    swap
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 15 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1182
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/social/contract.algo.ts:1184
    // return this.votelist(voteListKey).value
    box_get
    pop
    // smart_contracts/social/contract.algo.ts:1179
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getVotes[routing]() -> void:
getVotes:
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1187
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 64 // 64
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[32],uint8[32])[])
    // smart_contracts/social/contract.algo.ts:1189
    // const votes: VoteListValue[] = []
    bytec 10 // 0x0000
    intc_0 // 0

getVotes_for_header@2:
    // smart_contracts/social/contract.algo.ts:1190
    // for (const { user, ref } of clone(keys)) {
    dup
    dig 3
    <
    bz getVotes_after_for@8
    dig 3
    extract 2 0
    dig 1
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    swap
    extract 32 32
    // smart_contracts/social/contract.algo.ts:1191
    // const voteListKey: VoteListKey = { user: b16(user.bytes), ref: b16(ref) }
    swap
    callsub b16
    swap
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 15 // "o"
    swap
    concat
    dup
    bury 6
    // smart_contracts/social/contract.algo.ts:1192
    // if (this.votelist(voteListKey).exists) {
    box_len
    bury 1
    bz getVotes_else_body@5
    // smart_contracts/social/contract.algo.ts:1193
    // votes.push(this.votelist(voteListKey).value)
    dig 4
    box_get
    assert // Box must have value
    dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2

getVotes_after_if_else@6:
    dup
    intc_1 // 1
    +
    bury 1
    b getVotes_for_header@2

getVotes_else_body@5:
    // smart_contracts/social/contract.algo.ts:1195
    // votes.push({ impact: 0, isUp: false })
    dig 1
    dup
    bytec 31 // 0x000000000000000000
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2
    b getVotes_after_if_else@6

getVotes_after_for@8:
    // smart_contracts/social/contract.algo.ts:1187
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.getReactionExists[routing]() -> void:
getReactionExists:
    // smart_contracts/social/contract.algo.ts:1202
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1204
    // return this.reactions({ ref, NFT }).exists
    itob
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 25 // "r"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1204
    // return this.reactions({ ref, NFT }).exists
    box_len
    bury 1
    // smart_contracts/social/contract.algo.ts:1202
    // @abimethod({ readonly: true })
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.mbr[routing]() -> void:
mbr:
    // smart_contracts/social/base.ts:14
    // mbr(ref: bytes): AkitaSocialMBRData {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.payWallMbr[routing]() -> void:
payWallMbr:
    // smart_contracts/social/base.ts:30
    // payWallMbr(paywall: ViewPayWallValue): uint64 {
    txna ApplicationArgs 1
    callsub smart_contracts/social/base.ts::BaseSocial.payWallMbr
    pop
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements[routing]() -> void:
checkTipMbrRequirements:
    // smart_contracts/social/base.ts:51
    // checkTipMbrRequirements(akitaDAO: Application, creator: Account, wallet: Application): tipMBRInfo {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:137
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:138
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:138
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:139
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:137
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 16 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:51
    // const updatePlugin = getPluginAppList(this.akitaDAO.value).update
    pushint 16 // 16
    extract_uint64
    // smart_contracts/utils/base-contracts/base.ts:52
    // assert(Global.callerApplicationId === updatePlugin, ERR_INVALID_UPGRADE)
    global CallerApplicationID
    ==
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 28 // "version"
    // smart_contracts/utils/base-contracts/base.ts:53
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:40
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocial.isReply(postType: bytes) -> uint64:
isReply:
    // smart_contracts/social/contract.algo.ts:56
    // private isReply(postType: PostType): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:57
    // return postType === PostTypeReply || postType === PostTypeEditReply
    frame_dig -1
    bytec 17 // 0x01
    ==
    bnz isReply_bool_true@2
    frame_dig -1
    bytec 14 // 0x03
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:57
    // return postType === PostTypeReply || postType === PostTypeEditReply
    retsub

isReply_bool_false@3:
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:57
    // return postType === PostTypeReply || postType === PostTypeEditReply
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isAmended(ref: bytes, postType: bytes) -> uint64:
isAmended:
    // smart_contracts/social/contract.algo.ts:80
    // private isAmended(ref: bytes, postType: PostType): boolean {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:67
    // case PostTypePost:
    frame_dig -1
    bytec_3 // 0x00
    ==
    // smart_contracts/social/contract.algo.ts:67-68
    // case PostTypePost:
    //   return 36
    bz isAmended_after_if_else@3
    // smart_contracts/social/contract.algo.ts:68
    // return 36
    pushint 36 // 36

isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10:
    // smart_contracts/social/contract.algo.ts:83
    // return ref.length > baseLength
    frame_dig -2
    len
    <
    retsub

isAmended_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:69
    // case PostTypeReply:
    frame_dig -1
    bytec 17 // 0x01
    ==
    // smart_contracts/social/contract.algo.ts:69-70
    // case PostTypeReply:
    //   return 68
    bz isAmended_after_if_else@5
    // smart_contracts/social/contract.algo.ts:70
    // return 68
    pushint 68 // 68
    // smart_contracts/social/contract.algo.ts:82
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:71
    // case PostTypeEditPost:
    frame_dig -1
    bytec 24 // 0x02
    ==
    // smart_contracts/social/contract.algo.ts:71-72
    // case PostTypeEditPost:
    //   return 68
    bz isAmended_after_if_else@7
    // smart_contracts/social/contract.algo.ts:72
    // return 68
    pushint 68 // 68
    // smart_contracts/social/contract.algo.ts:82
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:73
    // case PostTypeEditReply:
    frame_dig -1
    bytec 14 // 0x03
    ==
    // smart_contracts/social/contract.algo.ts:73-74
    // case PostTypeEditReply:
    //   return 100
    bz isAmended_after_if_else@9
    // smart_contracts/social/contract.algo.ts:74
    // return 100
    pushint 100 // 100
    // smart_contracts/social/contract.algo.ts:82
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10

isAmended_after_if_else@9:
    // smart_contracts/social/contract.algo.ts:76
    // return 36
    pushint 36 // 36
    // smart_contracts/social/contract.algo.ts:82
    // const baseLength = this.getBaseRefLength(postType)
    b isAmended_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.getBaseRefLength@10


// smart_contracts/social/contract.algo.ts::AkitaSocial.toBytes32(type: bytes, ref: bytes) -> bytes:
toBytes32:
    // smart_contracts/social/contract.algo.ts:86
    // private toBytes32(type: RefType, ref: bytes): { refBytes: bytes<32>, creator: Account } {
    proto 2 1
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:88
    // let creator: Account = Global.zeroAddress
    global ZeroAddress
    // smart_contracts/social/contract.algo.ts:90
    // case RefTypePost:
    frame_dig -2
    bytec 13 // 0x0a
    ==
    // smart_contracts/social/contract.algo.ts:90-93
    // case RefTypePost:
    //   assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    //   refBytes = ref.toFixed({ length: 32 })
    //   break
    bz toBytes32_after_if_else@3
    // smart_contracts/social/contract.algo.ts:91
    // assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_3 // 32
    ==
    assert // Invalid reference length, must be 32 bytes
    frame_dig -1

toBytes32_block@19:
    // smart_contracts/social/contract.algo.ts:128
    // return { refBytes, creator }
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig 1
    concat
    frame_bury 0
    retsub

toBytes32_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:94
    // case RefTypeAsset:
    frame_dig -2
    bytec 5 // 0x14
    ==
    // smart_contracts/social/contract.algo.ts:94-99
    // case RefTypeAsset:
    //   assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    //   assert(Asset(btoi(ref)).total > 0, ERR_INVALID_ASSET)
    //   refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    //   creator = Asset(btoi(ref)).creator
    //   break
    bz toBytes32_after_if_else@6
    // smart_contracts/social/contract.algo.ts:95
    // assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_2 // 8
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:96
    // assert(Asset(btoi(ref)).total > 0, ERR_INVALID_ASSET)
    frame_dig -1
    btoi
    dup
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/social/contract.algo.ts:97
    // refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:98
    // creator = Asset(btoi(ref)).creator
    asset_params_get AssetCreator
    swap
    frame_bury 1
    assert // asset exists
    // smart_contracts/social/contract.algo.ts:99
    // break
    b toBytes32_block@19

toBytes32_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:100
    // case RefTypeAddress:
    frame_dig -2
    pushbytes 0x1e
    ==
    // smart_contracts/social/contract.algo.ts:100-110
    // case RefTypeAddress:
    //   assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    //   refBytes = ref.toFixed({ length: 32 })
    //   creator = Account(refBytes)
    // 
    //   if (this.meta(creator).exists) {
    //     const { addressGateID } = this.meta(creator).value
    //     assert(addressGateID === 0, ERR_HAS_GATE)
    //   }
    // 
    //   break
    bz toBytes32_after_if_else@11
    // smart_contracts/social/contract.algo.ts:101
    // assert(ref.length === 32, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_3 // 32
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:105
    // if (this.meta(creator).exists) {
    box_len
    bury 1
    bz toBytes32_after_if_else@10
    // smart_contracts/social/contract.algo.ts:106
    // const { addressGateID } = this.meta(creator).value
    frame_dig 0
    box_get
    assert // Box must have value
    pushint 58 // 58
    extract_uint64
    // smart_contracts/social/contract.algo.ts:107
    // assert(addressGateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

toBytes32_after_if_else@10:
    frame_dig -1
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:110
    // break
    b toBytes32_block@19

toBytes32_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:111
    // case RefTypeApp:
    frame_dig -2
    pushbytes 0x28
    ==
    // smart_contracts/social/contract.algo.ts:111-116
    // case RefTypeApp:
    //   assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    //   assert(Application(btoi(ref)).approvalProgram.length > 0, ERR_INVALID_APP)
    //   refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    //   creator = Application(btoi(ref)).creator
    //   break
    bz toBytes32_after_if_else@14
    // smart_contracts/social/contract.algo.ts:112
    // assert(ref.length === 8, ERR_INVALID_REF_LENGTH)
    frame_dig -1
    len
    intc_2 // 8
    ==
    assert // Invalid reference length, must be 32 bytes
    // smart_contracts/social/contract.algo.ts:113
    // assert(Application(btoi(ref)).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -1
    btoi
    dup
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/social/contract.algo.ts:114
    // refBytes = ref.concat(op.bzero(24)).toFixed({ length: 32 })
    pushint 24 // 24
    bzero
    frame_dig -1
    swap
    concat
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/social/contract.algo.ts:115
    // creator = Application(btoi(ref)).creator
    app_params_get AppCreator
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/social/contract.algo.ts:116
    // break
    b toBytes32_block@19

toBytes32_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:117
    // case RefTypeExternal:
    frame_dig -2
    pushbytes 0x32
    ==
    // smart_contracts/social/contract.algo.ts:117-123
    // case RefTypeExternal:
    //   // External refs (Twitter, Farcaster, etc.) - ref is the platform-prefixed identifier
    //   // Key is derived deterministically: sha256(ref) where ref = "platform:externalId"
    //   // Creator is zero address since external content has no Algorand creator
    //   refBytes = op.sha256(ref)
    //   creator = Global.zeroAddress
    //   break
    assert // Invalid reply type
    // smart_contracts/social/contract.algo.ts:121
    // refBytes = op.sha256(ref)
    frame_dig -1
    sha256
    // smart_contracts/social/contract.algo.ts:122
    // creator = Global.zeroAddress
    global ZeroAddress
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:123
    // break
    b toBytes32_block@19


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBlocked(user: bytes, blocked: bytes) -> uint64:
isBlocked:
    // smart_contracts/social/contract.algo.ts:131
    // private isBlocked(user: Account, blocked: Account): boolean {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:132-135
    // return abiCall<typeof AkitaSocialGraph.prototype.isBlocked>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    //   args: [user, blocked]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:133
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:133
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:133
    // appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:132-135
    // return abiCall<typeof AkitaSocialGraph.prototype.isBlocked>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).graph,
    //   args: [user, blocked]
    // }).returnValue
    pushbytes 0x4303668e // method "isBlocked(address,address)bool"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/social/contract.algo.ts:138
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    dupn 5
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    frame_dig -1
    concat
    dup
    // smart_contracts/social/contract.algo.ts:141
    // if (!this.meta(account).exists) {
    box_len
    bury 1
    bnz getSocialImpactScore_after_if_else@2
    // smart_contracts/social/contract.algo.ts:142
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getSocialImpactScore_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:145
    // const { streak, startDate } = clone(this.meta(account).value)
    frame_dig 7
    box_get
    assert // Box must have value
    dup
    pushint 9 // 9
    extract_uint64
    dup
    cover 2
    frame_bury 6
    pushint 17 // 17
    extract_uint64
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:148
    // if (streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@4
    // smart_contracts/social/contract.algo.ts:149
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:157
    // const accountAge: uint64 = Global.latestTimestamp - startDate
    global LatestTimestamp
    frame_dig 5
    -
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:159
    // if (accountAge >= TWO_YEARS) {
    intc 7 // 63072000
    >=
    bz getSocialImpactScore_else_body@7
    // smart_contracts/social/contract.algo.ts:160
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@8:
    // smart_contracts/social/contract.algo.ts:40
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:167
    // if (this.votes(account.bytes).exists) {
    box_len
    bury 1
    bz getSocialImpactScore_after_if_else@18
    // smart_contracts/social/contract.algo.ts:168
    // const { voteCount, isNegative } = this.votes(account.bytes).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:170
    // let impact: uint64 = (voteCount * 75) / 100_000
    pushint 75 // 75
    *
    intc 4 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:171
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@11
    // smart_contracts/social/contract.algo.ts:172
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:175
    // if (isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@16
    // smart_contracts/social/contract.algo.ts:177
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@14
    // smart_contracts/social/contract.algo.ts:178
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@18:
    // smart_contracts/social/contract.algo.ts:188
    // return socialImpact
    frame_dig 4
    frame_bury 0
    retsub

getSocialImpactScore_else_body@14:
    // smart_contracts/social/contract.algo.ts:180
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@18

getSocialImpactScore_else_body@16:
    // smart_contracts/social/contract.algo.ts:184
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@18

getSocialImpactScore_else_body@7:
    // smart_contracts/social/contract.algo.ts:163
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    intc 7 // 63072000
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@8

getSocialImpactScore_else_body@4:
    // smart_contracts/social/contract.algo.ts:152
    // socialImpact += (streak * 100) / 60
    frame_dig 6
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:191
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:192-195
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:193
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:193
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:193
    // appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/contract.algo.ts:192-195
    // const impact = abiCall<typeof AkitaSocialImpact.prototype.getUserImpactWithoutSocial>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).impact,
    //   args: [account]
    // }).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:197
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.tipCreator(creator: bytes, fee: uint64, tax: uint64) -> uint64:
tipCreator:
    // smart_contracts/social/contract.algo.ts:289
    // private tipCreator(creator: Account, fee: uint64, tax: uint64): uint64 {
    proto 3 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 4
    // smart_contracts/social/contract.algo.ts:290
    // if (creator === Global.zeroAddress) {
    frame_dig -3
    global ZeroAddress
    ==
    bz tipCreator_after_if_else@3
    // smart_contracts/social/contract.algo.ts:291
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:291
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:291
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:292-298
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: fee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:294
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:294
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    swap
    itxn_field XferAsset
    frame_dig -2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:292-297
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: fee,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:292-298
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: fee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:299
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

tipCreator_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:302
    // let wallet: uint64 = 0
    intc_0 // 0
    frame_bury 6
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    frame_dig -3
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:303
    // if (this.meta(creator).exists) {
    box_len
    bury 1
    bz tipCreator_after_if_else@5
    // smart_contracts/social/contract.algo.ts:304
    // wallet = this.meta(creator).value.wallet
    frame_dig 0
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    frame_bury 6

tipCreator_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:307
    // const { type, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, creator, Application(wallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:307
    // const { type, arc58 } = this.checkTipMbrRequirements(this.akitaDAO.value, creator, Application(wallet))
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -3
    frame_dig 6
    callsub smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements
    dup
    extract 0 1
    swap
    intc_1 // 1
    extract_uint64
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:308
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:308
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:308
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:309
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, tax)
    frame_dig -1
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    frame_bury 4
    // smart_contracts/social/contract.algo.ts:310
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:310
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:310
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:312
    // if (type === TipSendTypeARC58) {
    bytec 5 // 0x14
    ==
    bz tipCreator_after_if_else@7
    // smart_contracts/social/contract.algo.ts:313
    // this.arc58SendReactionPayments(Application(wallet), akta, leftover, (reactFee - tax))
    frame_dig -1
    -
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 6
    dup
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/social/contract.algo.ts:216
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:216
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 16 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:216
    // const optin = getPluginAppList(this.akitaDAO.value).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:218-227
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    itxn_begin
    bytec 29 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:222
    // true, // global
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:223
    // '', // default account
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:224
    // [], // no method offsets
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:225
    // [] // no funds request
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:218-227
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     optin,
    //     true, // global
    //     '', // default account
    //     [], // no method offsets
    //     [] // no funds request
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:229-240
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:236
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    dig 3
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/social/contract.algo.ts:235-238
    // itxn.payment({
    //   amount: Global.assetOptInMinBalance,
    //   receiver: origin
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:229-240
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/social/contract.algo.ts:232
    // wallet,
    dig 1
    itob
    // smart_contracts/social/contract.algo.ts:234
    // [asset],
    frame_dig 2
    dup
    cover 3
    itob
    bytec 21 // 0x0001
    swap
    concat
    // smart_contracts/social/contract.algo.ts:229-240
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    bytec 22 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:222
    // true, // global
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:229-240
    // itxnCompose.next<typeof OptInPlugin.prototype.optIn>({
    //   appId: optin,
    //   args: [
    //     wallet,
    //     true, // rekey back immediately
    //     [asset],
    //     itxn.payment({
    //       amount: Global.assetOptInMinBalance,
    //       receiver: origin
    //     })
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:242-244
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({
    //   appId: wallet
    // })
    itxn_next
    bytec 30 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:246-252
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    // smart_contracts/social/contract.algo.ts:248
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:248
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 1
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:247-251
    // itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:254-260
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetReceiver: origin,
    //     assetAmount: remainder,
    //     xferAsset: asset
    //   })
    // )
    itxn_next
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:255-259
    // itxn.assetTransfer({
    //   assetReceiver: origin,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:262
    // itxnCompose.submit()
    itxn_submit
    // smart_contracts/social/contract.algo.ts:314
    // return arc58
    frame_dig 3
    frame_bury 0
    retsub

tipCreator_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:317
    // this.sendDirectReactionPayments(creator, akta, leftover, (reactFee - tax))
    frame_dig -1
    -
    dup
    frame_bury 5
    // smart_contracts/social/contract.algo.ts:268
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:268
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/social/contract.algo.ts:273
    // if (remainder > 0 && creator.isOptedIn(Asset(asset))) {
    bz tipCreator_else_body@11
    frame_dig -3
    frame_dig 2
    asset_holding_get AssetBalance
    bury 1
    bz tipCreator_else_body@11
    // smart_contracts/social/contract.algo.ts:280
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_begin
    frame_dig 2
    dup
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    frame_dig 1
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:267-271
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:280
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_next
    itxn_field XferAsset
    frame_dig 5
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:274-278
    // const xferTxn = itxn.assetTransfer({
    //   assetReceiver: creator,
    //   assetAmount: remainder,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:280
    // itxn.submitGroup(taxTxn, xferTxn)
    itxn_submit

tipCreator_after_if_else@12:
    // smart_contracts/social/contract.algo.ts:318
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

tipCreator_else_body@11:
    // smart_contracts/social/contract.algo.ts:283
    // assetAmount: tax + remainder
    frame_dig 4
    frame_dig 5
    +
    // smart_contracts/social/contract.algo.ts:285
    // taxTxn.submit()
    itxn_begin
    frame_dig 2
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig 1
    itxn_field AssetReceiver
    // smart_contracts/social/contract.algo.ts:267-271
    // const taxTxn = itxn.assetTransfer({
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:285
    // taxTxn.submit()
    itxn_submit
    b tipCreator_after_if_else@12


// smart_contracts/social/contract.algo.ts::AkitaSocial.createEmptyPostIfNecessary(key: bytes, creator: bytes) -> uint64:
createEmptyPostIfNecessary:
    // smart_contracts/social/contract.algo.ts:321
    // private createEmptyPostIfNecessary(key: bytes<32>, creator: Account): uint64 {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:322
    // if (!this.posts(key).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/social/contract.algo.ts:333
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:323-339
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   postType: PostTypePost,
    // }
    itob
    frame_dig -1
    swap
    concat
    // smart_contracts/social/contract.algo.ts:334
    // gateID: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:323-339
    // this.posts(key).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Account
    //    * -   AppID: Application Creator
    //    */
    //   creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   usePayWall: false,
    //   payWallID: 0,
    //   againstContentPolicy: false,
    //   postType: PostTypePost,
    // }
    itob
    swap
    dig 1
    concat
    bytec_3 // 0x00
    concat
    swap
    concat
    pushbytes 0x0000003d0000
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:341
    // return this.mbr(Bytes('')).posts
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    pushint 16 // 16
    extract_uint64
    swap
    retsub

createEmptyPostIfNecessary_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:343
    // return 0
    intc_0 // 0
    swap
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/social/contract.algo.ts:346
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/social/contract.algo.ts:347
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/social/contract.algo.ts:349
    // const { startDate, lastActive } = this.meta(account).value
    dup
    box_get
    pop
    dup
    pushint 17 // 17
    extract_uint64
    swap
    pushint 25 // 25
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/social/contract.algo.ts:351
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    intc 8 // 86400
    %
    -
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:352
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    intc 8 // 86400
    -
    // smart_contracts/social/contract.algo.ts:354
    // this.meta(account).value.lastActive = Global.latestTimestamp
    global LatestTimestamp
    itob
    uncover 3
    pushint 25 // 25
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:357
    // if (lastWindowStart > lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/social/contract.algo.ts:358
    // this.meta(account).value.streak = 1
    intc_1 // 1
    itob
    frame_dig 0
    pushint 9 // 9
    uncover 2
    box_replace
    // smart_contracts/social/contract.algo.ts:359
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:364
    // if (lastActive < thisWindowStart) {
    frame_dig 1
    frame_dig 2
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/social/contract.algo.ts:365
    // this.meta(account).value.streak += 1
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    pushint 9 // 9
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 9 // 9
    swap
    box_replace

updateStreak_after_if_else@4:
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/social/contract.algo.ts:401
    // private updateVotes(ref: bytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    pushbytes ""
    dupn 2
    // smart_contracts/social/contract.algo.ts:40
    // votes = BoxMap<bytes<32>, VotesValue>({ keyPrefix: AkitaSocialBoxPrefixVotes })
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/social/contract.algo.ts:372
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/social/contract.algo.ts:373
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat

updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20:
    // smart_contracts/social/contract.algo.ts:402
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    dup
    extract 0 8
    swap
    pushint 64 // 64
    getbit
    // smart_contracts/social/contract.algo.ts:403
    // this.votes(ref).value = { voteCount, isNegative }
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:376
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    pushint 64 // 64
    getbit
    frame_bury 1
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:379
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/social/contract.algo.ts:379
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:381
    // if (voteCount === 0) {
    frame_dig 2
    bnz updateVotes_after_if_else@11
    // smart_contracts/social/contract.algo.ts:382
    // return { newCount: impact, isNegative: !isUp }
    frame_dig -2
    !
    frame_dig -1
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:402
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@11:
    // smart_contracts/social/contract.algo.ts:385
    // if (impact === voteCount && differingDirections) {
    frame_dig -1
    frame_dig 2
    ==
    bz updateVotes_after_if_else@14
    frame_dig 0
    bz updateVotes_after_if_else@14
    // smart_contracts/social/contract.algo.ts:386
    // return { newCount: 0, isNegative: false }
    bytec 31 // 0x000000000000000000
    // smart_contracts/social/contract.algo.ts:402
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:391
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/social/contract.algo.ts:392
    // if (flip) {
    bz updateVotes_after_if_else@16
    // smart_contracts/social/contract.algo.ts:393
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/social/contract.algo.ts:394
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    swap
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:402
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:397
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@18
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@19:
    // smart_contracts/social/contract.algo.ts:398
    // return { newCount, isNegative }
    itob
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:402
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocial.calcVotes@20

updateVotes_ternary_false@18:
    // smart_contracts/social/contract.algo.ts:397
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@19

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/social/contract.algo.ts:406
    // private createVoteList(ref: bytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:407
    // const voteListKey: VoteListKey = { user: b16(account.bytes), ref: b16(ref) }
    frame_dig -2
    callsub b16
    frame_dig -4
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:408
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 15 // "o"
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:408
    // this.votelist(voteListKey).value = { impact, isUp }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.createPost(postKey: bytes, mbrPayment: uint64, cid: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, postType: bytes, amendmentOf: bytes) -> void:
createPost:
    // smart_contracts/social/contract.algo.ts:411-420
    // private createPost(
    //   postKey: bytes<32>,
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   postType: PostType,
    //   amendmentOf: bytes<32>,
    // ): void {
    proto 8 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/social/contract.algo.ts:421
    // assert(!this.isBanned(Txn.sender), ERR_BANNED)
    txn Sender
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:423
    // (!usePayWall && payWallID === 0) || (
    frame_dig -4
    bnz createPost_or_contd@2
    frame_dig -3
    bz createPost_bool_true@7

createPost_or_contd@2:
    // smart_contracts/social/contract.algo.ts:424-427
    // usePayWall && (
    //   payWallID !== 0 && this.paywall(payWallID).exists ||
    //   payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    // )
    frame_dig -4
    bz createPost_bool_false@8
    // smart_contracts/social/contract.algo.ts:425
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    frame_dig -3
    bz createPost_or_contd@5
    frame_dig -3
    itob
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 18 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:425
    // payWallID !== 0 && this.paywall(payWallID).exists ||
    box_len
    bury 1
    bnz createPost_bool_true@7

createPost_or_contd@5:
    // smart_contracts/social/contract.algo.ts:426
    // payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    frame_dig -3
    bnz createPost_bool_false@8
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:426
    // payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:426
    // payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    box_get
    assert // Box must have value
    extract 66 8
    // smart_contracts/social/contract.algo.ts:38
    // paywall = BoxMap<uint64, ViewPayWallValue>({ keyPrefix: AkitaSocialboxPrefixPayWall })
    bytec 18 // "w"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:426
    // payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    box_len
    bury 1
    bz createPost_bool_false@8

createPost_bool_true@7:
    intc_1 // 1

createPost_bool_merge@9:
    // smart_contracts/social/contract.algo.ts:422-430
    // assert(
    //   (!usePayWall && payWallID === 0) || (
    //     usePayWall && (
    //       payWallID !== 0 && this.paywall(payWallID).exists ||
    //       payWallID === 0 && this.paywall(this.meta(Txn.sender).value.defaultPayWallID).exists
    //     )
    //   ),
    //   ERR_INVALID_PAYWALL
    // )
    assert // Invalid paywall
    // smart_contracts/social/contract.algo.ts:432
    // const isEditPost = postType === PostTypeEditPost
    frame_dig -2
    bytec 24 // 0x02
    ==
    // smart_contracts/social/contract.algo.ts:434
    // const editExtraMbr: uint64 = isEditPost ? EditBackRefMBR : 0
    dup
    intc 5 // 13200
    *
    // smart_contracts/social/contract.algo.ts:435
    // this.validatePostPayment(mbrPayment, cid, isEditPost, editExtraMbr)
    frame_dig -7
    frame_dig -6
    dig 3
    uncover 3
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:439
    // this.updateStreak(Txn.sender)
    txn Sender
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:441
    // const impact = this.getUserImpact(Txn.sender)
    txn Sender
    callsub getUserImpact
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -8
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:443
    // assert(!this.posts(postKey).exists, 'ERR:POST_EXISTS')
    box_len
    bury 1
    !
    assert // ERR:POST_EXISTS
    // smart_contracts/social/contract.algo.ts:448-450
    // const postRef: bytes = isEditPost
    //   ? Bytes(cid).concat(amendmentOf)
    //   : Bytes(cid)
    bz createPost_ternary_false@11
    // smart_contracts/social/contract.algo.ts:449
    // ? Bytes(cid).concat(amendmentOf)
    frame_dig -6
    frame_dig -1
    concat

createPost_ternary_merge@12:
    // smart_contracts/social/contract.algo.ts:454
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:455
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:452-461
    // this.posts(postKey).value = {
    //   ref: postRef,
    //   creator: Txn.sender,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   postType: postType,
    // }
    itob
    concat
    frame_dig -5
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -4
    setbit
    concat
    frame_dig -3
    itob
    concat
    bytec_3 // 0x00
    concat
    frame_dig -2
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 32 // 0x003d
    concat
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:462
    // this.updateVotes(postKey, true, impact)
    frame_dig -8
    intc_1 // 1
    frame_dig 1
    dup
    cover 3
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:463
    // this.createVoteList(postKey, true, Txn.sender, impact)
    frame_dig -8
    intc_1 // 1
    txn Sender
    uncover 3
    callsub createVoteList
    // smart_contracts/social/contract.algo.ts:201
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:201
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:201
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    dig 1
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:202
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:203
    // const { leftover } = sendReferralPayment(this.akitaDAO.value, akta, postFee)
    uncover 2
    dig 2
    uncover 2
    callsub sendReferralPayment
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:205-211
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:207
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:207
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:205-210
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:205-211
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: leftover,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    retsub

createPost_ternary_false@11:
    frame_dig -6
    b createPost_ternary_merge@12

createPost_bool_false@8:
    intc_0 // 0
    b createPost_bool_merge@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReply(replyKey: bytes, mbrPayment: uint64, mbrNeeded: uint64, cid: bytes, parentRef: bytes, gateID: uint64, usePayWall: uint64, payWallID: uint64, postType: bytes, amendmentOf: bytes) -> void:
createReply:
    // smart_contracts/social/contract.algo.ts:467-478
    // private createReply(
    //   replyKey: bytes<32>,
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   cid: CID,
    //   parentRef: bytes<32>,
    //   gateID: uint64,
    //   usePayWall: boolean,
    //   payWallID: uint64,
    //   postType: PostType,
    //   amendmentOf: bytes<32>,
    // ): void {
    proto 10 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:479
    // assert(!this.isBanned(Txn.sender), ERR_BANNED)
    txn Sender
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -6
    concat
    // smart_contracts/social/contract.algo.ts:480
    // const { creator } = this.posts(parentRef).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:481
    // assert(!this.isBlocked(creator, Txn.sender), ERR_BLOCKED)
    dup
    txn Sender
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:485
    // this.updateStreak(Txn.sender)
    txn Sender
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:487
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:487
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:487
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:488
    // const creatorImpact = this.getUserImpact(creator)
    dig 1
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:489
    // const taxPercentage = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:489
    // const taxPercentage = akitaSocialFee(this.akitaDAO.value, creatorImpact)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:121
    // const { impactTaxMin, impactTaxMax } = getSocialFees(akitaDAO)
    dup
    pushint 16 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:122
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 1
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/social/contract.algo.ts:492
    // const isEditReply = postType === PostTypeEditReply
    frame_dig -2
    bytec 14 // 0x03
    ==
    dup
    cover 2
    cover 4
    // smart_contracts/social/contract.algo.ts:495
    // extra += this.tipCreator(creator, reactFee, tax)
    uncover 3
    uncover 3
    uncover 2
    callsub tipCreator
    frame_dig -8
    +
    swap
    // smart_contracts/social/contract.algo.ts:497
    // if (isEditReply) {
    bz createReply_after_if_else@2
    // smart_contracts/social/contract.algo.ts:498
    // extra += EditBackRefMBR
    intc 5 // 13200
    +

createReply_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:501
    // this.validatePostPayment(mbrPayment, cid, isEditReply, extra)
    frame_dig -9
    frame_dig -7
    frame_dig 1
    dup
    cover 3
    uncover 4
    callsub validatePostPayment
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -10
    concat
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:503
    // assert(!this.posts(replyKey).exists, 'ERR:POST_EXISTS')
    box_len
    bury 1
    !
    assert // ERR:POST_EXISTS
    // smart_contracts/social/contract.algo.ts:508-510
    // const replyRef: bytes = isEditReply
    //   ? Bytes(cid).concat(parentRef).concat(amendmentOf)
    //   : Bytes(cid).concat(parentRef)
    bz createReply_ternary_false@4
    // smart_contracts/social/contract.algo.ts:509
    // ? Bytes(cid).concat(parentRef).concat(amendmentOf)
    frame_dig -7
    frame_dig -6
    concat
    frame_dig -1
    concat

createReply_ternary_merge@5:
    // smart_contracts/social/contract.algo.ts:514
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/social/contract.algo.ts:515
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:512-521
    // this.posts(replyKey).value = {
    //   ref: replyRef,
    //   creator: Txn.sender,
    //   timestamp: Global.latestTimestamp,
    //   gateID,
    //   usePayWall,
    //   payWallID,
    //   againstContentPolicy: false,
    //   postType: postType,
    // }
    itob
    concat
    frame_dig -5
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -4
    setbit
    concat
    frame_dig -3
    itob
    concat
    bytec_3 // 0x00
    concat
    frame_dig -2
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 32 // 0x003d
    concat
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:523
    // const senderImpact = this.getUserImpact(Txn.sender)
    txn Sender
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:524
    // this.updateVotes(replyKey, true, senderImpact)
    frame_dig -10
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:525
    // this.createVoteList(replyKey, true, Txn.sender, senderImpact)
    frame_dig -10
    intc_1 // 1
    txn Sender
    uncover 3
    callsub createVoteList
    retsub

createReply_ternary_false@4:
    // smart_contracts/social/contract.algo.ts:510
    // : Bytes(cid).concat(parentRef)
    frame_dig -7
    frame_dig -6
    concat
    b createReply_ternary_merge@5


// smart_contracts/social/contract.algo.ts::AkitaSocial.createVote(mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/social/contract.algo.ts:528-533
    // private createVote(
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   isUp: boolean
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:534
    // assert(!this.isBanned(Txn.sender), ERR_BANNED)
    txn Sender
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:535
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:537
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    dupn 2
    // smart_contracts/social/contract.algo.ts:538
    // assert(!this.isBlocked(creator, Txn.sender), ERR_BLOCKED)
    txn Sender
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:540
    // const voteListKey: VoteListKey = { user: b16(Txn.sender.bytes), ref: b16(ref) }
    txn Sender
    callsub b16
    frame_dig -2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    // smart_contracts/social/contract.algo.ts:42
    // votelist = BoxMap<VoteListKey, VoteListValue>({ keyPrefix: AkitaSocialBoxPrefixVoteList })
    bytec 15 // "o"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:541
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/social/contract.algo.ts:542
    // assert(Txn.sender !== creator, ERR_NO_SELF_VOTE)
    txn Sender
    !=
    assert // Cannot vote on your own content
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    // smart_contracts/social/contract.algo.ts:544
    // const senderIsAutomated = this.meta(Txn.sender).value.automated
    txn Sender
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    concat
    // smart_contracts/social/contract.algo.ts:544
    // const senderIsAutomated = this.meta(Txn.sender).value.automated
    box_get
    assert // Box must have value
    pushint 392 // 392
    getbit
    // smart_contracts/social/contract.algo.ts:545
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/social/contract.algo.ts:547
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:547
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:547
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:551
    // this.updateStreak(Txn.sender)
    txn Sender
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:552
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:552
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:552
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    intc_2 // 8
    extract_uint64
    swap
    dup
    pushint 16 // 16
    extract_uint64
    cover 2
    pushint 24 // 24
    extract_uint64
    swap
    // smart_contracts/social/contract.algo.ts:554
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@2
    // smart_contracts/social/contract.algo.ts:556
    // const recipientImpact = this.getUserImpact(creator)
    frame_dig 0
    dup
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:557
    // const taxPercentage = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 2
    frame_dig 3
    callsub impactRange
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    uncover 2
    dup
    uncover 2
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/social/contract.algo.ts:560
    // const extra = this.tipCreator(creator, reactFee, tax)
    callsub tipCreator
    // smart_contracts/social/contract.algo.ts:562-569
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:565
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:562-569
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:566
    // amount: mbrNeeded + extra
    frame_dig -3
    uncover 3
    +
    // smart_contracts/social/contract.algo.ts:562-569
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment

createVote_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:590
    // const senderImpact = this.getUserImpact(Txn.sender)
    txn Sender
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:591
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/social/contract.algo.ts:592
    // this.createVoteList(ref, isUp, Txn.sender, senderImpact)
    frame_dig -2
    frame_dig -1
    txn Sender
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@2:
    // smart_contracts/social/contract.algo.ts:571-578
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:574
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:571-578
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrNeeded
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    frame_dig -3
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:580-586
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/social/contract.algo.ts:582
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:65
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 6 // "akita_escrow"
    // smart_contracts/social/contract.algo.ts:582
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 1
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/social/contract.algo.ts:580-585
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/social/contract.algo.ts:580-586
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: reactFee,
    //     xferAsset: akta
    //   })
    //   .submit()
    itxn_submit
    b createVote_after_if_else@4


// smart_contracts/social/contract.algo.ts::AkitaSocial.createReaction(mbrPayment: uint64, mbrNeeded: uint64, ref: bytes, NFT: uint64) -> void:
createReaction:
    // smart_contracts/social/contract.algo.ts:595-600
    // private createReaction(
    //   mbrPayment: gtxn.PaymentTxn,
    //   mbrNeeded: uint64,
    //   ref: bytes<32>,
    //   NFT: uint64
    // ): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:601
    // assert(!this.isBanned(Txn.sender), ERR_BANNED)
    txn Sender
    callsub smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned
    !
    assert // This account is banned
    // smart_contracts/social/contract.algo.ts:36
    // posts = BoxMap<bytes<32>, PostValue>({ keyPrefix: AkitaSocialBoxPrefixPosts })
    bytec_2 // "p"
    frame_dig -2
    concat
    // smart_contracts/social/contract.algo.ts:602
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/social/contract.algo.ts:603
    // const { creator } = this.posts(ref).value
    intc_0 // 0
    intc_3 // 32
    box_extract
    // smart_contracts/social/contract.algo.ts:604
    // assert(!this.isBlocked(creator, Txn.sender), ERR_BLOCKED)
    dup
    txn Sender
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/social/contract.algo.ts:606
    // assert(AssetHolding.assetBalance(Txn.sender, NFT)[0] > 0, ERR_USER_DOES_NOT_OWN_NFT)
    txn Sender
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    assert // User does not own this NFT
    // smart_contracts/social/contract.algo.ts:608
    // const reactionListKey: ReactionListKey = { user: b16(Txn.sender.bytes), ref: b16(ref), NFT }
    txn Sender
    callsub b16
    frame_dig -2
    callsub b16
    dig 1
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    concat
    frame_dig -1
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/contract.algo.ts:46
    // reactionlist = BoxMap<ReactionListKey, bytes<0>>({ keyPrefix: AkitaSocialBoxPrefixReactionList })
    pushbytes "e"
    swap
    concat
    dup
    cover 3
    // smart_contracts/social/contract.algo.ts:610
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/social/contract.algo.ts:614
    // this.updateStreak(Txn.sender)
    txn Sender
    callsub updateStreak
    // smart_contracts/social/contract.algo.ts:616
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:616
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:616
    // const { reactFee, impactTaxMin, impactTaxMax } = getSocialFees(this.akitaDAO.value)
    dup
    intc_2 // 8
    extract_uint64
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:617
    // const recipientImpact = this.getUserImpact(creator)
    dig 4
    callsub getUserImpact
    // smart_contracts/social/contract.algo.ts:618
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    cover 2
    callsub impactRange
    // smart_contracts/social/contract.algo.ts:620
    // const reactionKey: ReactionsKey = { ref, NFT }
    frame_dig -2
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig -2
    uncover 3
    concat
    // smart_contracts/social/contract.algo.ts:44
    // reactions = BoxMap<ReactionsKey, uint64>({ keyPrefix: AkitaSocialBoxPrefixReactions })
    bytec 25 // "r"
    swap
    concat
    dup
    cover 4
    // smart_contracts/social/contract.algo.ts:621
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    cover 5
    pop
    // smart_contracts/social/contract.algo.ts:624
    // extra += this.tipCreator(creator, reactFee, tax)
    cover 3
    callsub tipCreator
    frame_dig -3
    +
    swap
    // smart_contracts/social/contract.algo.ts:677
    // const { reactionlist, reactions } = this.mbr(Bytes(''))
    pushbytes ""
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    dup
    pushint 48 // 48
    extract_uint64
    cover 2
    pushint 40 // 40
    extract_uint64
    cover 2
    // smart_contracts/social/contract.algo.ts:678-680
    // const mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz createReaction_ternary_false@6

createReaction_ternary_merge@7:
    // smart_contracts/social/contract.algo.ts:682-689
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:685
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:682-689
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:686
    // amount: mbrAmount + extra
    uncover 2
    frame_dig 3
    +
    // smart_contracts/social/contract.algo.ts:682-689
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + extra
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/social/contract.algo.ts:629
    // if (reactionExists) {
    frame_dig 2
    bz createReaction_else_body@2
    // smart_contracts/social/contract.algo.ts:630
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:635
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    retsub

createReaction_else_body@2:
    // smart_contracts/social/contract.algo.ts:632
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@3

createReaction_ternary_false@6:
    // smart_contracts/social/contract.algo.ts:680
    // : reactions + reactionlist
    frame_dig 4
    +
    b createReaction_ternary_merge@7


// smart_contracts/social/contract.algo.ts::AkitaSocial.validateTip(tip: uint64, action: bytes) -> void:
validateTip:
    // smart_contracts/social/contract.algo.ts:638
    // private validateTip(tip: gtxn.AssetTransferTxn, action: TipAction) {
    proto 2 0
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:639
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:69
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 9 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:640
    // const { postFee, reactFee } = getSocialFees(this.akitaDAO.value)
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:641-649
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -2
    gtxns AssetReceiver
    // smart_contracts/social/contract.algo.ts:644
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:641-649
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    frame_dig -2
    gtxns XferAsset
    uncover 4
    ==
    &&
    frame_dig -2
    gtxns AssetAmount
    // smart_contracts/social/contract.algo.ts:646
    // assetAmount: (action === TipActionPost) ? postFee : reactFee
    frame_dig -1
    bytec 13 // 0x0a
    ==
    uncover 3
    uncover 4
    uncover 2
    select
    // smart_contracts/social/contract.algo.ts:641-649
    // assertMatch(
    //   tip,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: akta,
    //     assetAmount: (action === TipActionPost) ? postFee : reactFee
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    assert // Invalid transfer
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.validatePostPayment(mbrPayment: uint64, cid: bytes, isAmendment: uint64, extraAmount: uint64) -> void:
validatePostPayment:
    // smart_contracts/social/contract.algo.ts:652-657
    // private validatePostPayment(
    //   mbrPayment: gtxn.PaymentTxn,
    //   cid: CID,
    //   isAmendment: boolean,
    //   extraAmount: uint64
    // ): void {
    proto 4 0
    pushbytes ""
    dup
    // smart_contracts/social/contract.algo.ts:658
    // const { posts, votes, votelist } = this.mbr(cid)
    frame_dig -3
    callsub smart_contracts/social/base.ts::BaseSocial.mbr
    dup
    pushint 16 // 16
    extract_uint64
    swap
    dup
    pushint 24 // 24
    extract_uint64
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:659
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:659
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:659
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    swap
    // smart_contracts/utils/functions.ts:548
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/utils/functions.ts:549
    // const referrer = referrerOrZeroAddress(wallet)
    callsub referrerOrZeroAddress
    // smart_contracts/utils/functions.ts:551
    // if (referrer === Global.zeroAddress) {
    global ZeroAddress
    ==
    bz validatePostPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:552
    // return 0
    intc_0 // 0

validatePostPayment_after_inlined_smart_contracts/utils/functions.ts::referralFee@9:
    // smart_contracts/social/contract.algo.ts:661
    // let amount: uint64 = posts + votes + votelist + referralFeeAmount + extraAmount
    frame_dig 2
    frame_dig 3
    +
    frame_dig 4
    +
    +
    frame_dig -1
    +
    // smart_contracts/social/contract.algo.ts:662
    // if (isAmendment) {
    frame_dig -2
    bz validatePostPayment_after_if_else@2
    // smart_contracts/social/contract.algo.ts:663
    // amount += AmendmentMBR
    intc 5 // 13200
    +

validatePostPayment_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:666-673
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:669
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:666-673
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -4
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    retsub

validatePostPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig 5
    bytec 20 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:482
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 1
    // smart_contracts/utils/functions.ts:483
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocationsLength)
    intc 9 // 60600
    frame_bury 0
    // smart_contracts/utils/functions.ts:485
    // if (asset !== 0 && !Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 6
    bz validatePostPayment_after_if_else@8
    frame_dig 1
    app_params_get AppAddress
    assert // application exists
    frame_dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz validatePostPayment_after_if_else@8
    // smart_contracts/utils/functions.ts:483
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocationsLength)
    intc 9 // 60600
    // smart_contracts/utils/functions.ts:486
    // cost += Global.assetOptInMinBalance
    global AssetOptInMinBalance
    +
    frame_bury 0

validatePostPayment_after_if_else@8:
    frame_dig 0
    // smart_contracts/social/contract.algo.ts:660
    // const referralFeeAmount = referralFee(this.akitaDAO.value, akta)
    b validatePostPayment_after_inlined_smart_contracts/utils/functions.ts::referralFee@9


// smart_contracts/social/contract.algo.ts::AkitaSocial.createDefaultMeta(origin: bytes, initialized: uint64, wallet: uint64, automated: uint64) -> void:
createDefaultMeta:
    // smart_contracts/social/contract.algo.ts:692
    // private createDefaultMeta(origin: Account, initialized: boolean, wallet: uint64, automated: boolean): void {
    proto 4 0
    // smart_contracts/social/contract.algo.ts:697
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/social/contract.algo.ts:698
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/social/contract.algo.ts:693-705
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    frame_dig -2
    itob
    concat
    // smart_contracts/social/contract.algo.ts:696
    // streak: 1,
    intc_1 // 1
    // smart_contracts/social/contract.algo.ts:693-705
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/social/contract.algo.ts:699
    // followerIndex: 0,
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:693-705
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    itob
    swap
    dig 1
    concat
    dig 1
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    concat
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:48
    // meta = BoxMap<Account, MetaValue>({ keyPrefix: AkitaSocialBoxPrefixMeta })
    bytec 4 // "m"
    frame_dig -4
    concat
    // smart_contracts/social/contract.algo.ts:693-705
    // this.meta(origin).value = {
    //   initialized,
    //   wallet,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated,
    //   followGateID: 0,
    //   addressGateID: 0,
    //   defaultPayWallID: 0
    // }
    swap
    box_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned(account: bytes) -> uint64:
smart_contracts/social/contract.algo.ts::AkitaSocial.isBanned:
    // smart_contracts/social/contract.algo.ts:1144-1145
    // @abimethod({ readonly: true })
    // isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1146-1149
    // return abiCall<typeof AkitaSocialModeration.prototype.isBanned>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1147
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1147
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 8 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1147
    // appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    pushint 24 // 24
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1146-1149
    // return abiCall<typeof AkitaSocialModeration.prototype.isBanned>({
    //   appId: getAkitaSocialAppList(this.akitaDAO.value).moderation,
    //   args: [account]
    // }).returnValue
    bytec 27 // method "isBanned(address)bool"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub


// smart_contracts/social/base.ts::BaseSocial.mbr(ref: bytes) -> bytes:
smart_contracts/social/base.ts::BaseSocial.mbr:
    // smart_contracts/social/base.ts:14
    // mbr(ref: bytes): AkitaSocialMBRData {
    proto 1 1
    // smart_contracts/social/base.ts:18
    // posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    frame_dig -1
    len
    pushint 400 // 400
    *
    pushint 40100 // 40100
    +
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    pushbytes 0x0000000000007bd40000000000003d54
    swap
    concat
    // smart_contracts/social/base.ts:19
    // votes: VotesMBR,
    pushint 19300 // 19300
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:21
    // reactions: ReactionsMBR,
    pushint 22100 // 22100
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    // smart_contracts/social/base.ts:22
    // reactionlist: ReactionlistMBR,
    pushint 18900 // 18900
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/base.ts:23
    // meta: MetaMBR,
    pushint 45300 // 45300
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:26
    // actions: ActionsMBR
    pushint 29700 // 29700
    // smart_contracts/social/base.ts:15-27
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    retsub


// smart_contracts/social/base.ts::BaseSocial.payWallMbr(paywall: bytes) -> uint64, bytes:
smart_contracts/social/base.ts::BaseSocial.payWallMbr:
    // smart_contracts/social/base.ts:30
    // payWallMbr(paywall: ViewPayWallValue): uint64 {
    proto 1 2
    // smart_contracts/social/base.ts:33
    // PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    frame_dig -1
    pushint 2 // 2
    extract_uint16
    frame_dig -1
    len
    frame_dig -1
    dig 2
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    swap
    uncover 3
    substring3
    intc_0 // 0
    extract_uint16
    +
    // smart_contracts/social/base.ts:32-34
    // BoxCostPerByte * (
    //   PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    // )
    pushint 6800 // 6800
    *
    // smart_contracts/social/base.ts:31
    // return MinPayWallMBR + (
    pushint 5200 // 5200
    // smart_contracts/social/base.ts:31-35
    // return MinPayWallMBR + (
    //   BoxCostPerByte * (
    //     PayWallPayOptionSize * (paywall.agentPayInfo.length + paywall.userPayInfo.length)
    //   )
    // )
    +
    frame_dig -1
    retsub


// smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements(akitaDAO: uint64, creator: bytes, wallet: uint64) -> bytes:
smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements:
    // smart_contracts/social/base.ts:51
    // checkTipMbrRequirements(akitaDAO: Application, creator: Account, wallet: Application): tipMBRInfo {
    proto 3 1
    // smart_contracts/utils/functions.ts:94
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    frame_dig -3
    bytec 7 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:52
    // const akta = Asset(getAkitaAssets(akitaDAO).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/base.ts:54
    // if (!creator.isOptedIn(akta) && wallet.id !== 0) {
    frame_dig -2
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    frame_dig -1
    bz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    frame_dig -3
    bytec 16 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:42
    // getPluginAppList(akitaDAO).optin,
    extract 0 8
    // smart_contracts/social/base.ts:44
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:43
    // true,
    bytec 12 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:45
    // '',
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:46
    // methodSelector<typeof OptInPlugin.prototype.optIn>()
    bytec 22 // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    // smart_contracts/social/base.ts:39-48
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(akitaDAO).optin,
    //     true,
    //     Global.zeroAddress,
    //     '',
    //     methodSelector<typeof OptInPlugin.prototype.optIn>()
    //   ]
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/base.ts:56
    // if (canCallArc58OptIn) {
    bz smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5
    // smart_contracts/social/base.ts:59
    // arc58: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    // smart_contracts/social/base.ts:57-60
    // return {
    //   type: TipSendTypeARC58,
    //   arc58: Global.assetOptInMinBalance
    // }
    itob
    // smart_contracts/social/base.ts:58
    // type: TipSendTypeARC58,
    bytec 5 // 0x14
    // smart_contracts/social/base.ts:57-60
    // return {
    //   type: TipSendTypeARC58,
    //   arc58: Global.assetOptInMinBalance
    // }
    swap
    concat
    retsub

smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements_after_if_else@5:
    // smart_contracts/social/base.ts:64-67
    // return {
    //   type: TipSendTypeDirect,
    //   arc58: 0
    // }
    pushbytes 0x0a0000000000000000
    retsub
