#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 6 32 1000000000000 200000000000 31536000 10000000000
    bytecblock "akita_dao" 0x151f7c75 "akita_al" "m" "akita_assets" "i.timeChanged" base32(AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLQ) 0x6c13ede4 "version" "other_al"
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txn NumAppArgs
    bz main_after_if_else@14
    pushbytess 0x6f9817f6 0x27e3bb4f 0x9d74f5a1 0xf81c7b62 0xd574bb10 0xb6ec6a5d 0xea9180dd 0x33e92c94 // method "create(uint64,string)void", method "cacheMeta(address,uint64,uint64,uint64)uint64", method "updateSubscriptionStateModifier(pay,uint64,uint64)void", method "getUserImpactWithoutSocial(address)uint64", method "getUserImpact(address)uint64", method "getMeta(address)(uint64,uint64,uint64,uint64,uint64)", method "update(string)void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@3 main_cacheMeta_route@4 main_updateSubscriptionStateModifier_route@5 main_getUserImpactWithoutSocial_route@6 main_getUserImpact_route@7 main_getMeta_route@8 main_update_route@9 main_updateAkitaDAO_route@10

main_after_if_else@14:
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    intc_0 // 0
    return

main_updateAkitaDAO_route@10:
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@9:
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_getMeta_route@8:
    // smart_contracts/social/contract.algo.ts:1982
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1982
    // @abimethod({ readonly: true })
    callsub getMeta
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserImpact_route@7:
    // smart_contracts/social/contract.algo.ts:1977
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1977
    // @abimethod({ readonly: true })
    callsub getUserImpact
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserImpactWithoutSocial_route@6:
    // smart_contracts/social/contract.algo.ts:1972
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    // smart_contracts/social/contract.algo.ts:1972
    // @abimethod({ readonly: true })
    callsub getUserImpactWithoutSocial
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateSubscriptionStateModifier_route@5:
    // smart_contracts/social/contract.algo.ts:1954
    // updateSubscriptionStateModifier(payment: gtxn.PaymentTxn, subscriptionIndex: uint64, newModifier: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/social/contract.algo.ts:1954
    // updateSubscriptionStateModifier(payment: gtxn.PaymentTxn, subscriptionIndex: uint64, newModifier: uint64): void {
    callsub updateSubscriptionStateModifier
    intc_1 // 1
    return

main_cacheMeta_route@4:
    // smart_contracts/social/contract.algo.ts:1919
    // cacheMeta(address: Address, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/social/contract.algo.ts:1919
    // cacheMeta(address: Address, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64): uint64 {
    callsub cacheMeta
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_route@3:
    // smart_contracts/social/contract.algo.ts:1911
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/social/contract.algo.ts:1634
    // export class AkitaSocialImpact extends AkitaBaseContract implements AkitaSocialImpactInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/social/contract.algo.ts:1911
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.isSubscribed(account: bytes, index: uint64) -> bytes:
isSubscribed:
    // smart_contracts/social/contract.algo.ts:1656
    // private isSubscribed(account: Account, index: uint64): { active: boolean; serviceID: uint64; streak: uint64 } {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:1657-1663
    // const info = abiCall(
    //   Subscriptions.prototype.getSubscriptionInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    //     args: [new Address(account), index]
    //   },
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1660
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1660
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    dup
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1660
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1661
    // args: [new Address(account), index]
    frame_dig -1
    itob
    // smart_contracts/social/contract.algo.ts:1657-1663
    // const info = abiCall(
    //   Subscriptions.prototype.getSubscriptionInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    //     args: [new Address(account), index]
    //   },
    // ).returnValue
    pushbytes 0x4015b840 // method "getSubscriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/contract.algo.ts:1666
    // const toAkita = info.recipient.native === this.akitaDAO.value.address
    dup
    extract 4 32
    uncover 2
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/social/contract.algo.ts:1670
    // const notDonating = info.serviceID !== 0
    dig 1
    pushint 36 // 36
    extract_uint64
    dup
    intc_0 // 0
    !=
    // smart_contracts/social/contract.algo.ts:1672
    // const lastWindowStart: uint64 = Global.latestTimestamp - (((Global.latestTimestamp - info.startDate) % info.interval) + info.interval)
    global LatestTimestamp
    dup
    dig 5
    pushint 44 // 44
    extract_uint64
    -
    dig 5
    pushint 60 // 60
    extract_uint64
    swap
    dig 1
    %
    +
    -
    // smart_contracts/social/contract.algo.ts:1676
    // const notStale = info.lastPayment > lastWindowStart
    dig 4
    pushint 84 // 84
    extract_uint64
    <
    // smart_contracts/social/contract.algo.ts:1679
    // active: toAkita && notDonating && notStale,
    uncover 3
    uncover 2
    &&
    &&
    // smart_contracts/social/contract.algo.ts:1681
    // streak: info.streak,
    uncover 2
    extract 92 8
    // smart_contracts/social/contract.algo.ts:1678-1682
    // return {
    //   active: toAkita && notDonating && notStale,
    //   serviceID: info.serviceID,
    //   streak: info.streak,
    // }
    pushbytes 0x00
    intc_0 // 0
    uncover 3
    setbit
    uncover 2
    itob
    concat
    swap
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.userImpact(account: bytes, includeSocial: uint64) -> uint64:
userImpact:
    // smart_contracts/social/contract.algo.ts:1724
    // private userImpact(account: Account, includeSocial: boolean): uint64 {
    proto 2 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 7
    // smart_contracts/social/contract.algo.ts:1639
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1725
    // const { subscriptionIndex, NFD, akitaNFT } = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    pushint 8 // 8
    extract_uint64
    swap
    intc_3 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1744
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1744
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1744
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    extract 0 8
    // smart_contracts/social/contract.algo.ts:1746-1758
    // const info = abiCall(
    //   Staking.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).staking,
    //     args: [
    //       new Address(account),
    //       {
    //         asset: akta,
    //         type: STAKING_TYPE_SOFT,
    //       }
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1749
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1752-1755
    // {
    //   asset: akta,
    //   type: STAKING_TYPE_SOFT,
    // }
    swap
    // smart_contracts/social/contract.algo.ts:1754
    // type: STAKING_TYPE_SOFT,
    pushbytes 0x14
    // smart_contracts/social/contract.algo.ts:1752-1755
    // {
    //   asset: akta,
    //   type: STAKING_TYPE_SOFT,
    // }
    concat
    // smart_contracts/social/contract.algo.ts:1746-1758
    // const info = abiCall(
    //   Staking.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).staking,
    //     args: [
    //       new Address(account),
    //       {
    //         asset: akta,
    //         type: STAKING_TYPE_SOFT,
    //       }
    //     ]
    //   }
    // ).returnValue
    pushbytes 0xc9068809 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/contract.algo.ts:1760
    // const elapsed: uint64 = Global.latestTimestamp - info.lastUpdate
    global LatestTimestamp
    dig 1
    pushint 12 // 12
    extract_uint64
    -
    swap
    pushint 4 // 4
    // smart_contracts/social/contract.algo.ts:1763
    // if (info.amount < TEN_THOUSAND_AKITA || elapsed < THIRTY_DAYS) {
    extract_uint64
    dup
    intc 7 // 10000000000
    <
    bnz userImpact_if_body@27
    frame_dig 14
    pushint 2592000 // 2592000
    <
    bz userImpact_after_if_else@28

userImpact_if_body@27:
    // smart_contracts/social/contract.algo.ts:1764
    // return 0
    intc_0 // 0
    frame_bury 6

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getStakingImpactScore@32:
    // smart_contracts/social/contract.algo.ts:1793
    // let subscriberImpact: uint64 = 0
    intc_0 // 0
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1795
    // const subscriptionState = this.isSubscribed(account, subscriptionIndex)
    frame_dig -2
    frame_dig 11
    callsub isSubscribed
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:1797
    // if (!subscriptionState.active) {
    intc_0 // 0
    getbit
    bz userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39
    // smart_contracts/social/contract.algo.ts:1801
    // const modifier = this.subscriptionStateModifier(subscriptionState.serviceID).value
    frame_dig 1
    dup
    extract 1 8
    // smart_contracts/social/contract.algo.ts:1641
    // subscriptionStateModifier = BoxMap<uint64, uint64>({ keyPrefix: ImpactBoxPrefixSubscriptionStateModifier })
    pushbytes "s"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1801
    // const modifier = this.subscriptionStateModifier(subscriptionState.serviceID).value
    box_get
    assert // Box must have value
    btoi
    swap
    // smart_contracts/social/contract.algo.ts:1804
    // if (subscriptionState.streak >= 12) {
    pushint 9 // 9
    extract_uint64
    dup
    frame_bury 9
    pushint 12 // 12
    >=
    bz userImpact_else_body@37
    // smart_contracts/social/contract.algo.ts:1805
    // subscriberImpact += 250 / modifier
    pushint 250 // 250
    swap
    /
    frame_bury 7

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39:
    // smart_contracts/social/contract.algo.ts:1729
    // const socialImpact = includeSocial ? this.getSocialImpactScore(account) : Uint64(0) // Social Activity | up to 250
    frame_dig -1
    bz userImpact_ternary_false@2
    // smart_contracts/social/contract.algo.ts:1814-1820
    // return abiCall(
    //   AkitaSocial.prototype.getUserSocialImpact,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).social,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1817
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1817
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1817
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    pushint 96 // 96
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1814-1820
    // return abiCall(
    //   AkitaSocial.prototype.getUserSocialImpact,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).social,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    pushbytes 0xe869934d // method "getUserSocialImpact(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    frame_bury 5

userImpact_ternary_merge@3:
    // smart_contracts/social/contract.algo.ts:1886
    // const { NFD, nfdTimeChanged, nfdImpact } = this.meta(account).value
    frame_dig 10
    box_get
    assert // Box must have value
    dup
    pushint 8 // 8
    extract_uint64
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    frame_bury 4
    // smart_contracts/social/contract.algo.ts:1887
    // const timeChanged = btoi(op.AppGlobal.getExBytes(NFD, Bytes(NFDGlobalStateKeysTimeChanged))[0])
    dig 1
    bytec 5 // "i.timeChanged"
    app_global_get_ex
    pop
    btoi
    // smart_contracts/social/contract.algo.ts:1889
    // assert(NFDApp.id === Application(NFD).id, ERR_INVALID_NFD)
    frame_dig 12
    uncover 3
    ==
    assert // Invalid NFD
    // smart_contracts/social/contract.algo.ts:1890
    // assert(nfdTimeChanged === timeChanged, ERR_NFD_CHANGED)
    ==
    assert // NFD changed since impact last calculated
    // smart_contracts/social/contract.algo.ts:1780
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1780
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:77
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1780
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1781
    // const balance = AssetHolding.assetBalance(account, akta)[0]
    frame_dig -2
    swap
    asset_holding_get AssetBalance
    pop
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1784
    // if (balance < TEN_THOUSAND_AKITA) {
    intc 7 // 10000000000
    <
    bz userImpact_after_if_else@10
    // smart_contracts/social/contract.algo.ts:1785
    // return 0
    intc_0 // 0
    frame_bury 3

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getHeldAktaImpactScore@11:
    // smart_contracts/social/contract.algo.ts:1896
    // const prefix = asset.unitName.slice(0, 3)
    frame_dig 13
    dup
    asset_params_get AssetUnitName
    assert // asset exists
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 3 // 3
    dig 2
    >=
    pushint 3 // 3
    uncover 3
    uncover 2
    select
    substring3
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1897
    // const balance = AssetHolding.assetBalance(account, asset)[0]
    frame_dig -2
    dig 1
    asset_holding_get AssetBalance
    pop
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1898
    // if (asset.creator === Account(AkitaNFTCreatorAddress) && balance > 0) {
    asset_params_get AssetCreator
    assert // asset exists
    bytec 6 // addr AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLTRG3PFI
    ==
    bz userImpact_after_if_else@19
    frame_dig 2
    bz userImpact_after_if_else@19
    // smart_contracts/social/contract.algo.ts:1899
    // if (prefix === Bytes(AkitaCollectionsPrefixAKC)) {
    frame_dig 0
    pushbytes "AKC"
    ==
    bz userImpact_after_if_else@16
    // smart_contracts/social/contract.algo.ts:1900
    // return 50
    pushint 50 // 50

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20:
    // smart_contracts/social/contract.algo.ts:1734
    // const total: uint64 = stakedAktaImpact + subscriberImpact + socialImpact + nfdScore + heldAkitaImpact + nftImpact
    frame_dig 6
    frame_dig 7
    +
    frame_dig 5
    +
    frame_dig 4
    +
    frame_dig 3
    +
    +
    dup
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:1735
    // if (total === 0) {
    bnz userImpact_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1736
    // return 1
    intc_1 // 1
    frame_bury 0
    retsub

userImpact_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1739
    // return total
    frame_dig 8
    frame_bury 0
    retsub

userImpact_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:1902
    // if (prefix === Bytes(AkitaCollectionsPrefixAOG)) {
    frame_dig 0
    pushbytes "AOG"
    ==
    bz userImpact_after_if_else@19
    // smart_contracts/social/contract.algo.ts:1903
    // return 25
    pushint 25 // 25
    // smart_contracts/social/contract.algo.ts:1732
    // const nftImpact = this.getNFTImpactScore(account, Asset(akitaNFT)) // Holds AKC/Omnigem | 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20

userImpact_after_if_else@19:
    // smart_contracts/social/contract.algo.ts:1906
    // return 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1732
    // const nftImpact = this.getNFTImpactScore(account, Asset(akitaNFT)) // Holds AKC/Omnigem | 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20

userImpact_after_if_else@10:
    // smart_contracts/social/contract.algo.ts:1788
    // const capped = balance >= ONE_MILLION_AKITA ? ONE_MILLION_AKITA : balance
    frame_dig 2
    dup
    intc 4 // 1000000000000
    >=
    intc 4 // 1000000000000
    swap
    select
    // smart_contracts/social/contract.algo.ts:1789
    // return (capped * 50) / ONE_MILLION_AKITA
    pushint 50 // 50
    *
    intc 4 // 1000000000000
    /
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:1731
    // const heldAkitaImpact = this.getHeldAktaImpactScore(account) // Held AKTA | up to 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getHeldAktaImpactScore@11

userImpact_ternary_false@2:
    // smart_contracts/social/contract.algo.ts:1729
    // const socialImpact = includeSocial ? this.getSocialImpactScore(account) : Uint64(0) // Social Activity | up to 250
    intc_0 // 0
    frame_bury 5
    b userImpact_ternary_merge@3

userImpact_else_body@37:
    // smart_contracts/social/contract.algo.ts:1807
    // subscriberImpact += (subscriptionState.streak * 20) / modifier
    frame_dig 9
    pushint 20 // 20
    *
    swap
    /
    frame_bury 7
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39

userImpact_after_if_else@28:
    // smart_contracts/social/contract.algo.ts:1768
    // const amtCapped = info.amount >= TWO_HUNDRED_THOUSAND_AKITA ? TWO_HUNDRED_THOUSAND_AKITA : info.amount
    frame_dig 15
    intc 5 // 200000000000
    >=
    bz userImpact_ternary_false@30
    intc 5 // 200000000000

userImpact_ternary_merge@31:
    // smart_contracts/social/contract.algo.ts:1771
    // const maxScore: uint64 = (amtCapped * 250) / TWO_HUNDRED_THOUSAND_AKITA
    pushint 250 // 250
    *
    intc 5 // 200000000000
    /
    // smart_contracts/social/contract.algo.ts:1774
    // const timeCapped = elapsed >= ONE_YEAR ? ONE_YEAR : elapsed
    frame_dig 14
    dup
    intc 6 // 31536000
    >=
    intc 6 // 31536000
    swap
    select
    // smart_contracts/social/contract.algo.ts:1776
    // return (timeCapped * maxScore) / ONE_YEAR
    *
    intc 6 // 31536000
    /
    frame_bury 6
    // smart_contracts/social/contract.algo.ts:1727
    // const stakedAktaImpact = this.getStakingImpactScore(account) // Staked AKTA | up to 250
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getStakingImpactScore@32

userImpact_ternary_false@30:
    frame_dig 15
    b userImpact_ternary_merge@31


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.nfdReadField(NFDApp: uint64, field: bytes) -> bytes:
nfdReadField:
    // smart_contracts/social/contract.algo.ts:1823
    // private nfdReadField(NFDApp: Application, field: string): bytes {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:1824-1830
    // const fieldBytes = abiCall(
    //   NFD.prototype.readField,
    //   {
    //     appId: NFDApp.id,
    //     args: [Bytes(field)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1828
    // args: [Bytes(field)]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1824-1830
    // const fieldBytes = abiCall(
    //   NFD.prototype.readField,
    //   {
    //     appId: NFDApp.id,
    //     args: [Bytes(field)]
    //   }
    // ).returnValue
    bytec 7 // method "readField(byte[])byte[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    // smart_contracts/social/contract.algo.ts:1832
    // return fieldBytes
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.create(akitaDAO: uint64, version: bytes) -> void:
create:
    // smart_contracts/social/contract.algo.ts:1911-1912
    // @abimethod({ onCreate: 'require' })
    // create(akitaDAO: uint64, version: string): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/base.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 8 // "version"
    // smart_contracts/social/contract.algo.ts:1913
    // this.version.value = version
    frame_dig -1
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1914
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -2
    app_global_put
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.cacheMeta(address: bytes, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64) -> uint64:
cacheMeta:
    // smart_contracts/social/contract.algo.ts:1919
    // cacheMeta(address: Address, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64): uint64 {
    proto 4 1
    intc_0 // 0
    dupn 5
    pushbytes ""
    dupn 4
    // smart_contracts/social/contract.algo.ts:1920
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1920
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1920
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    pushint 96 // 96
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not a social plugin
    // smart_contracts/social/contract.algo.ts:1922
    // if (subscriptionIndex !== 0) {
    frame_dig -3
    bz cacheMeta_after_if_else@2
    // smart_contracts/social/contract.algo.ts:1923
    // assert(this.isSubscribed(address.native, subscriptionIndex).active, ERR_NOT_A_SUBSCRIPTION)
    frame_dig -4
    frame_dig -3
    callsub isSubscribed
    intc_0 // 0
    getbit
    assert // Not an akita subscription contract

cacheMeta_after_if_else@2:
    // smart_contracts/social/contract.algo.ts:1926
    // let nfdTimeChanged: uint64 = 0
    intc_0 // 0
    frame_bury 9
    // smart_contracts/social/contract.algo.ts:1927
    // let nfdImpact: uint64 = 0
    intc_0 // 0
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1928
    // if (NFDAppID !== 0) {
    frame_dig -2
    bz cacheMeta_after_if_else@4
    // smart_contracts/social/contract.algo.ts:1686
    // const [nfdNameBytes] = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysName))
    frame_dig -2
    pushbytes "i.name"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1688-1694
    // return abiCall(
    //   NFDRegistry.prototype.isValidNfdAppId,
    //   {
    //     appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    //     args: [String(nfdNameBytes), NFDApp.id]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1691
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1691
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 9 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1691
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    pushint 8 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1692
    // args: [String(nfdNameBytes), NFDApp.id]
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:1688-1694
    // return abiCall(
    //   NFDRegistry.prototype.isValidNfdAppId,
    //   {
    //     appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    //     args: [String(nfdNameBytes), NFDApp.id]
    //   }
    // ).returnValue
    pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1930
    // assert(this.isNFD(nfdApp), ERR_NOT_AN_NFD)
    assert // Not an NFD
    // smart_contracts/social/contract.algo.ts:1699-1708
    // const caAlgoData = abiCall(
    //   NFD.prototype.readField,
    //   {
    //     appId: NFDApp.id,
    //     args: [
    //       Bytes(NFDMetaKeyVerifiedAddresses)
    //     ],
    // 
    //   },
    // ).returnValue
    itxn_begin
    bytec 7 // method "readField(byte[])byte[]"
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:1704
    // Bytes(NFDMetaKeyVerifiedAddresses)
    pushbytes 0x000d762e6361416c676f2e302e6173
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:1699-1708
    // const caAlgoData = abiCall(
    //   NFD.prototype.readField,
    //   {
    //     appId: NFDApp.id,
    //     args: [
    //       Bytes(NFDMetaKeyVerifiedAddresses)
    //     ],
    // 
    //   },
    // ).returnValue
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:1710
    // for (let i: uint64 = 0; i < caAlgoData.length; i += 32) {
    intc_0 // 0
    frame_bury 6

cacheMeta_while_top@14:
    // smart_contracts/social/contract.algo.ts:1710
    // for (let i: uint64 = 0; i < caAlgoData.length; i += 32) {
    frame_dig 1
    len
    dup
    frame_bury 10
    frame_dig 6
    >
    bz cacheMeta_after_while@19
    // smart_contracts/social/contract.algo.ts:1711
    // const addr = caAlgoData.slice(i, i + 32)
    frame_dig 6
    dup
    frame_dig 10
    dup
    cover 3
    >=
    dig 1
    dig 3
    uncover 2
    select
    swap
    intc_3 // 32
    +
    dup
    frame_bury 6
    dup
    dig 3
    >=
    swap
    uncover 3
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    frame_dig 1
    cover 2
    substring3
    dup
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1712
    // if (addr !== Global.zeroAddress.bytes && addr === account.bytes) {
    global ZeroAddress
    !=
    bz cacheMeta_while_top@14
    frame_dig 0
    frame_dig -4
    ==
    bz cacheMeta_while_top@14
    // smart_contracts/social/contract.algo.ts:1713
    // return true
    intc_1 // 1

cacheMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.addressVerifiedOnNFD@20:
    // smart_contracts/social/contract.algo.ts:1931
    // assert(this.addressVerifiedOnNFD(address.native, nfdApp), ERR_USER_DOES_NOT_OWN_NFD)
    assert // User does not own this NFD
    // smart_contracts/social/contract.algo.ts:1932
    // const [timeChangedBytes] = op.AppGlobal.getExBytes(nfdApp, Bytes(NFDGlobalStateKeysTimeChanged))
    frame_dig -2
    bytec 5 // "i.timeChanged"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1933
    // nfdTimeChanged = btoi(timeChangedBytes)
    btoi
    frame_bury 9
    // smart_contracts/social/contract.algo.ts:1846
    // let nfdImpact: uint64 = 50
    pushint 50 // 50
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1848
    // const [parentAppIDBytes, parentAppIDBytesExist] = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysParentAppID))
    frame_dig -2
    pushbytes "i.parentAppID"
    app_global_get_ex
    swap
    frame_bury 3
    swap
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:1850
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    bz cacheMeta_after_if_else@24
    frame_dig 3
    btoi
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1850
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 9 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1850
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    intc_3 // 32
    extract_uint64
    ==
    frame_dig 7
    frame_bury 8
    bz cacheMeta_after_if_else@24
    // smart_contracts/social/contract.algo.ts:1851
    // nfdImpact += 50
    pushint 100 // 100
    frame_bury 8

cacheMeta_after_if_else@24:
    frame_dig 8
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1854
    // const version = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysVersion))[0].slice(0, 2)
    frame_dig -2
    pushbytes "i.ver"
    app_global_get_ex
    pop
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 2 // 2
    dig 2
    >=
    pushint 2 // 2
    uncover 3
    uncover 2
    select
    substring3
    // smart_contracts/social/contract.algo.ts:1856
    // if (version !== Bytes('3.')) {
    pushbytes "3."
    !=
    bnz cacheMeta_after_if_else@4
    // smart_contracts/social/contract.algo.ts:1836
    // const domain = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedDomain)
    frame_dig -2
    pushbytes "v.domain"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1837
    // const twitter = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedTwitter)
    frame_dig -2
    pushbytes "v.twitter"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1838
    // const discord = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedDiscord)
    frame_dig -2
    pushbytes "v.discord"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1839
    // const telegram = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedTelegram)
    frame_dig -2
    pushbytes "v.telegram"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1841
    // return { domain, twitter, discord, telegram }
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    dup
    len
    pushint 8 // 8
    +
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    dig 1
    itob
    extract 6 2
    pushbytes 0x0008
    swap
    concat
    dig 1
    len
    uncover 3
    +
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    dig 1
    itob
    extract 6 2
    uncover 3
    swap
    concat
    dig 1
    len
    uncover 3
    +
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1860
    // const { domain, twitter, discord, telegram } = this.getNFDSocialFields(NFDApp)
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    pushint 4 // 4
    extract_uint16
    dig 3
    uncover 3
    dig 2
    substring3
    extract 2 0
    frame_bury 5
    dig 2
    intc_2 // 6
    extract_uint16
    dig 3
    uncover 2
    dig 2
    substring3
    extract 2 0
    frame_bury 2
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    frame_bury 4
    // smart_contracts/social/contract.algo.ts:1863
    // if (domain.length > 0) {
    len
    frame_dig 7
    frame_bury 8
    bz cacheMeta_after_if_else@28
    // smart_contracts/social/contract.algo.ts:1864
    // nfdImpact += 10
    frame_dig 7
    pushint 10 // 10
    +
    frame_bury 8

cacheMeta_after_if_else@28:
    frame_dig 8
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1868
    // if (twitter.length > 0) {
    frame_dig 5
    len
    swap
    frame_bury 8
    bz cacheMeta_after_if_else@30
    // smart_contracts/social/contract.algo.ts:1869
    // nfdImpact += 20
    frame_dig 7
    pushint 20 // 20
    +
    frame_bury 8

cacheMeta_after_if_else@30:
    frame_dig 8
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1873
    // if (discord.length > 0) {
    frame_dig 2
    len
    swap
    frame_bury 8
    bz cacheMeta_after_if_else@32
    // smart_contracts/social/contract.algo.ts:1874
    // nfdImpact += 10
    frame_dig 7
    pushint 10 // 10
    +
    frame_bury 8

cacheMeta_after_if_else@32:
    frame_dig 8
    dup
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1878
    // if (telegram.length > 0) {
    frame_dig 4
    len
    swap
    frame_bury 8
    bz cacheMeta_after_if_else@34
    // smart_contracts/social/contract.algo.ts:1879
    // nfdImpact += 10
    frame_dig 7
    pushint 10 // 10
    +
    frame_bury 8

cacheMeta_after_if_else@34:
    frame_dig 8
    frame_bury 7

cacheMeta_after_if_else@4:
    // smart_contracts/social/contract.algo.ts:1937
    // if (akitaAssetID !== 0) {
    frame_dig -1
    bz cacheMeta_after_if_else@6
    // smart_contracts/social/contract.algo.ts:1721
    // return akitaNFT.creator === Account(AkitaNFTCreatorAddress)
    frame_dig -1
    asset_params_get AssetCreator
    assert // asset exists
    bytec 6 // addr AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLTRG3PFI
    ==
    // smart_contracts/social/contract.algo.ts:1939
    // assert(this.isAkitaNFT(akitaNFT), ERR_NOT_AN_AKITA_NFT)
    assert // Not an akita NFT
    // smart_contracts/social/contract.algo.ts:1653
    // return AssetHolding.assetBalance(account, NFT)[0] > 0
    frame_dig -4
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    // smart_contracts/social/contract.algo.ts:1940
    // assert(this.userHolds(address.native, akitaNFT), ERR_USER_DOES_NOT_OWN_NFT)
    assert // User does not own this NFT

cacheMeta_after_if_else@6:
    // smart_contracts/social/contract.algo.ts:1943-1949
    // this.meta(address.native).value = {
    //   subscriptionIndex,
    //   NFD: NFDAppID,
    //   nfdTimeChanged,
    //   nfdImpact,
    //   akitaNFT: akitaAssetID,
    // }
    frame_dig -3
    itob
    frame_dig -2
    itob
    concat
    frame_dig 9
    itob
    concat
    frame_dig 7
    dup
    cover 2
    itob
    concat
    frame_dig -1
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1639
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    frame_dig -4
    concat
    // smart_contracts/social/contract.algo.ts:1943-1949
    // this.meta(address.native).value = {
    //   subscriptionIndex,
    //   NFD: NFDAppID,
    //   nfdTimeChanged,
    //   nfdImpact,
    //   akitaNFT: akitaAssetID,
    // }
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1951
    // return nfdImpact
    frame_bury 0
    retsub

cacheMeta_after_while@19:
    // smart_contracts/social/contract.algo.ts:1717
    // return false
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1931
    // assert(this.addressVerifiedOnNFD(address.native, nfdApp), ERR_USER_DOES_NOT_OWN_NFD)
    b cacheMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.addressVerifiedOnNFD@20


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.updateSubscriptionStateModifier(payment: uint64, subscriptionIndex: uint64, newModifier: uint64) -> void:
updateSubscriptionStateModifier:
    // smart_contracts/social/contract.algo.ts:1954
    // updateSubscriptionStateModifier(payment: gtxn.PaymentTxn, subscriptionIndex: uint64, newModifier: uint64): void {
    proto 3 0
    // smart_contracts/social/contract.algo.ts:1955
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1955
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not the DAO
    // smart_contracts/social/contract.algo.ts:1957
    // this.subscriptionStateModifier(subscriptionIndex).value = newModifier
    frame_dig -2
    itob
    // smart_contracts/social/contract.algo.ts:1641
    // subscriptionStateModifier = BoxMap<uint64, uint64>({ keyPrefix: ImpactBoxPrefixSubscriptionStateModifier })
    pushbytes "s"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1957
    // this.subscriptionStateModifier(subscriptionIndex).value = newModifier
    frame_dig -1
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1959-1966
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1962
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1959-1966
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -3
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1963
    // amount: this.mbr().subscriptionStateModifier
    pushint 9300 // 9300
    // smart_contracts/social/contract.algo.ts:1959-1966
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getUserImpactWithoutSocial(address: bytes) -> uint64:
getUserImpactWithoutSocial:
    // smart_contracts/social/contract.algo.ts:1972-1973
    // @abimethod({ readonly: true })
    // getUserImpactWithoutSocial(address: Address): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1974
    // return this.userImpact(address.native, false)
    frame_dig -1
    intc_0 // 0
    callsub userImpact
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getUserImpact(address: bytes) -> uint64:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:1977-1978
    // @abimethod({ readonly: true })
    // getUserImpact(address: Address): uint64 {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1979
    // return this.userImpact(address.native, true)
    frame_dig -1
    intc_1 // 1
    callsub userImpact
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getMeta(user: bytes) -> bytes:
getMeta:
    // smart_contracts/social/contract.algo.ts:1982-1983
    // @abimethod({ readonly: true })
    // getMeta(user: Address): ImpactMetaValue {
    proto 1 1
    // smart_contracts/social/contract.algo.ts:1639
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1984
    // return this.meta(user.native).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:18-19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 8 // "version"
    // smart_contracts/utils/base-contracts/base.ts:21
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:28
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
