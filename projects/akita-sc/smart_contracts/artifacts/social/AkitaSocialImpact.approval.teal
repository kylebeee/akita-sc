#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 2 1000000000000 200000000000 31536000 10000000000
    bytecblock "akita_dao" 0x151f7c75 "akita_al" "m" "wallet" "version" "other_al" 0x6c13ede4 "i.timeChanged" base32(AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLQ) "akita_assets"
    // smart_contracts/social/contract.algo.ts:1658
    // export class AkitaSocialImpact extends AkitaBaseContract {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@2

main_switch_case_next@3:
    // smart_contracts/social/contract.algo.ts:1658
    // export class AkitaSocialImpact extends AkitaBaseContract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@13
    pushbytess 0x27e3bb4f 0x9d74f5a1 0xf81c7b62 0xd574bb10 0xb6ec6a5d 0x33e92c94 0x854dede0 // method "cacheMeta(address,uint64,uint64,uint64)uint64", method "updateSubscriptionStateModifier(pay,uint64,uint64)void", method "getUserImpactWithoutSocial(address)uint64", method "getUserImpact(address)uint64", method "getMeta(address)(uint64,uint64,uint64,uint64,uint64)", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match cacheMeta updateSubscriptionStateModifier getUserImpactWithoutSocial getUserImpact getMeta updateAkitaDAO main_opUp_route@11
    err

main_opUp_route@11:
    // smart_contracts/utils/base-contracts/base.ts:41
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@13:
    // smart_contracts/social/contract.algo.ts:1658
    // export class AkitaSocialImpact extends AkitaBaseContract {
    pushbytes 0x6f9817f6 // method "create(uint64,string)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@2:
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.create[routing]() -> void:
create:
    // smart_contracts/social/contract.algo.ts:1914
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:17
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 5 // "version"
    // smart_contracts/social/contract.algo.ts:1916
    // this.version.value = version
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1917
    // this.akitaDAO.value = Application(akitaDAO)
    swap
    app_global_put
    // smart_contracts/social/contract.algo.ts:1914
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.cacheMeta[routing]() -> void:
cacheMeta:
    intc_0 // 0
    dupn 5
    pushbytes ""
    dupn 3
    // smart_contracts/social/contract.algo.ts:1922
    // cacheMeta(address: Address, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64): uint64 {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/social/contract.algo.ts:1923
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1923
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1923
    // assert(Txn.sender === Application(getAkitaAppList(this.akitaDAO.value).social).address, ERR_NOT_SOCIAL)
    pushint 96 // 96
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Not a social plugin
    // smart_contracts/social/contract.algo.ts:1925
    // if (subscriptionIndex !== 0) {
    bz cacheMeta_after_if_else@3
    // smart_contracts/social/contract.algo.ts:1926
    // assert(this.isSubscribed(address.native, subscriptionIndex).active, ERR_NOT_A_SUBSCRIPTION)
    dig 4
    dig 4
    callsub isSubscribed
    intc_0 // 0
    getbit
    assert // Not an akita subscription contract

cacheMeta_after_if_else@3:
    // smart_contracts/social/contract.algo.ts:1929
    // let nfdTimeChanged: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/social/contract.algo.ts:1930
    // let nfdImpact: uint64 = 0
    intc_0 // 0
    bury 8
    // smart_contracts/social/contract.algo.ts:1931
    // if (NFDAppID !== 0) {
    dig 1
    bz cacheMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1707
    // const [nfdNameBytes] = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysName))
    dig 1
    dup
    pushbytes "i.name"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1709-1712
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1710
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1710
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:50
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 6 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1710
    // appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    intc_2 // 8
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1711
    // args: [String(nfdNameBytes), NFDApp.id]
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    // smart_contracts/social/contract.algo.ts:1709-1712
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: getOtherAppList(this.akitaDAO.value).nfdRegistry,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/social/contract.algo.ts:1933
    // assert(this.isNFD(nfdApp), ERR_NOT_AN_NFD)
    assert // Not an NFD
    // smart_contracts/social/contract.algo.ts:1717-1720
    // const caAlgoData = abiCall<typeof NFD.prototype.readField>({
    //   appId: NFDApp.id,
    //   args: [Bytes(NFDMetaKeyVerifiedAddresses)]
    // }).returnValue
    itxn_begin
    bytec 7 // method "readField(byte[])byte[]"
    itxn_field ApplicationArgs
    // smart_contracts/social/contract.algo.ts:1719
    // args: [Bytes(NFDMetaKeyVerifiedAddresses)]
    pushbytes 0x000d762e6361416c676f2e302e6173
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/social/contract.algo.ts:1717-1720
    // const caAlgoData = abiCall<typeof NFD.prototype.readField>({
    //   appId: NFDApp.id,
    //   args: [Bytes(NFDMetaKeyVerifiedAddresses)]
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    bury 14
    // smart_contracts/social/contract.algo.ts:1722
    // for (let i: uint64 = 0; i < caAlgoData.length; i += 32) {
    intc_0 // 0
    bury 9

cacheMeta_while_top@15:
    // smart_contracts/social/contract.algo.ts:1722
    // for (let i: uint64 = 0; i < caAlgoData.length; i += 32) {
    dig 13
    len
    dup
    bury 7
    dig 9
    >
    bz cacheMeta_after_while@20
    // smart_contracts/social/contract.algo.ts:1723
    // const addr = caAlgoData.slice(i, i + 32)
    dig 8
    dup
    dig 7
    dup
    cover 3
    >=
    dig 1
    dig 3
    uncover 2
    select
    swap
    pushint 32 // 32
    +
    dup
    bury 12
    dup
    dig 3
    >=
    swap
    uncover 3
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    dig 15
    cover 2
    substring3
    dup
    bury 16
    // smart_contracts/social/contract.algo.ts:1724
    // if (addr !== Global.zeroAddress.bytes && addr === account.bytes) {
    global ZeroAddress
    !=
    bz cacheMeta_while_top@15
    dig 14
    dig 5
    ==
    bz cacheMeta_while_top@15
    // smart_contracts/social/contract.algo.ts:1725
    // return true
    intc_1 // 1

cacheMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.addressVerifiedOnNFD@21:
    // smart_contracts/social/contract.algo.ts:1934
    // assert(this.addressVerifiedOnNFD(address.native, nfdApp), ERR_USER_DOES_NOT_OWN_NFD)
    assert // User does not own this NFD
    // smart_contracts/social/contract.algo.ts:1935
    // const [timeChangedBytes] = op.AppGlobal.getExBytes(nfdApp, Bytes(NFDGlobalStateKeysTimeChanged))
    dig 1
    dup
    bytec 8 // "i.timeChanged"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1936
    // nfdTimeChanged = btoi(timeChangedBytes)
    btoi
    bury 8
    // smart_contracts/social/contract.algo.ts:1849
    // let nfdImpact: uint64 = 50
    pushint 50 // 50
    bury 9
    // smart_contracts/social/contract.algo.ts:1851
    // const [parentAppIDBytes, parentAppIDBytesExist] = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysParentAppID))
    pushbytes "i.parentAppID"
    app_global_get_ex
    swap
    bury 13
    // smart_contracts/social/contract.algo.ts:1853
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    bz cacheMeta_after_if_else@25
    dig 11
    btoi
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1853
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:50
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 6 // "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1853
    // if (parentAppIDBytesExist && btoi(parentAppIDBytes) === getOtherAppList(this.akitaDAO.value).akitaNfd) {
    pushint 40 // 40
    extract_uint64
    ==
    bz cacheMeta_after_if_else@25
    // smart_contracts/social/contract.algo.ts:1854
    // nfdImpact += 50
    pushint 100 // 100
    bury 8

cacheMeta_after_if_else@25:
    // smart_contracts/social/contract.algo.ts:1857
    // const version = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysVersion))[0].slice(0, 2)
    dig 1
    pushbytes "i.ver"
    app_global_get_ex
    pop
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_3 // 2
    dig 2
    >=
    intc_3 // 2
    uncover 3
    uncover 2
    select
    substring3
    // smart_contracts/social/contract.algo.ts:1859
    // if (version !== Bytes('3.')) {
    pushbytes "3."
    !=
    bnz cacheMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1839
    // const domain = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedDomain)
    dig 1
    dup
    pushbytes "v.domain"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1840
    // const twitter = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedTwitter)
    dig 1
    pushbytes "v.twitter"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1841
    // const discord = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedDiscord)
    dig 2
    pushbytes "v.discord"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1842
    // const telegram = this.nfdReadField(NFDApp, NFDMetaKeyVerifiedTelegram)
    uncover 3
    pushbytes "v.telegram"
    callsub nfdReadField
    // smart_contracts/social/contract.algo.ts:1844
    // return { domain, twitter, discord, telegram }
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    dup
    len
    intc_2 // 8
    +
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    dig 1
    itob
    extract 6 2
    pushbytes 0x0008
    swap
    concat
    dig 1
    len
    uncover 3
    +
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    dig 1
    itob
    extract 6 2
    uncover 3
    swap
    concat
    dig 1
    len
    uncover 3
    +
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1863
    // const { domain, twitter, discord, telegram } = this.getNFDSocialFields(NFDApp)
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    pushint 4 // 4
    extract_uint16
    dig 3
    uncover 3
    dig 2
    substring3
    extract 2 0
    bury 13
    dig 2
    pushint 6 // 6
    extract_uint16
    dig 3
    uncover 2
    dig 2
    substring3
    extract 2 0
    bury 16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    bury 12
    // smart_contracts/social/contract.algo.ts:1866
    // if (domain.length > 0) {
    len
    bz cacheMeta_after_if_else@29
    // smart_contracts/social/contract.algo.ts:1867
    // nfdImpact += 10
    dig 7
    pushint 10 // 10
    +
    bury 8

cacheMeta_after_if_else@29:
    // smart_contracts/social/contract.algo.ts:1871
    // if (twitter.length > 0) {
    dig 9
    len
    bz cacheMeta_after_if_else@31
    // smart_contracts/social/contract.algo.ts:1872
    // nfdImpact += 20
    dig 7
    pushint 20 // 20
    +
    bury 8

cacheMeta_after_if_else@31:
    // smart_contracts/social/contract.algo.ts:1876
    // if (discord.length > 0) {
    dig 12
    len
    bz cacheMeta_after_if_else@33
    // smart_contracts/social/contract.algo.ts:1877
    // nfdImpact += 10
    dig 7
    pushint 10 // 10
    +
    bury 8

cacheMeta_after_if_else@33:
    // smart_contracts/social/contract.algo.ts:1881
    // if (telegram.length > 0) {
    dig 10
    len
    bz cacheMeta_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1882
    // nfdImpact += 10
    dig 7
    pushint 10 // 10
    +
    bury 8

cacheMeta_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1940
    // if (akitaAssetID !== 0) {
    dup
    bz cacheMeta_after_if_else@7
    // smart_contracts/social/contract.algo.ts:1733
    // return akitaNFT.creator === Account(AkitaNFTCreatorAddress)
    dupn 2
    asset_params_get AssetCreator
    assert // asset exists
    bytec 9 // addr AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLTRG3PFI
    ==
    // smart_contracts/social/contract.algo.ts:1942
    // assert(this.isAkitaNFT(akitaNFT), ERR_NOT_AN_AKITA_NFT)
    assert // Not an akita NFT
    // smart_contracts/social/contract.algo.ts:1677
    // return AssetHolding.assetBalance(account, NFT)[0] > 0
    dig 5
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/social/contract.algo.ts:1943
    // assert(this.userHolds(address.native, akitaNFT), ERR_USER_DOES_NOT_OWN_NFT)
    assert // User does not own this NFT

cacheMeta_after_if_else@7:
    // smart_contracts/social/contract.algo.ts:1946-1952
    // this.meta(address.native).value = {
    //   subscriptionIndex,
    //   NFD: NFDAppID,
    //   nfdTimeChanged,
    //   nfdImpact,
    //   akitaNFT: akitaAssetID,
    // }
    dig 3
    itob
    dig 2
    itob
    concat
    dig 7
    itob
    concat
    dig 8
    itob
    swap
    dig 1
    concat
    dig 2
    itob
    concat
    // smart_contracts/social/contract.algo.ts:1663
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    dig 7
    concat
    // smart_contracts/social/contract.algo.ts:1946-1952
    // this.meta(address.native).value = {
    //   subscriptionIndex,
    //   NFD: NFDAppID,
    //   nfdTimeChanged,
    //   nfdImpact,
    //   akitaNFT: akitaAssetID,
    // }
    swap
    box_put
    // smart_contracts/social/contract.algo.ts:1922
    // cacheMeta(address: Address, subscriptionIndex: uint64, NFDAppID: uint64, akitaAssetID: uint64): uint64 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

cacheMeta_after_while@20:
    // smart_contracts/social/contract.algo.ts:1729
    // return false
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1934
    // assert(this.addressVerifiedOnNFD(address.native, nfdApp), ERR_USER_DOES_NOT_OWN_NFD)
    b cacheMeta_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.addressVerifiedOnNFD@21


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.updateSubscriptionStateModifier[routing]() -> void:
updateSubscriptionStateModifier:
    // smart_contracts/social/contract.algo.ts:1957
    // updateSubscriptionStateModifier(payment: gtxn.PaymentTxn, subscriptionIndex: uint64, newModifier: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/social/contract.algo.ts:1958
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 4 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1958
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/social/contract.algo.ts:1960
    // this.subscriptionStateModifier(subscriptionIndex).value = newModifier
    swap
    itob
    // smart_contracts/social/contract.algo.ts:1665
    // subscriptionStateModifier = BoxMap<uint64, uint64>({ keyPrefix: ImpactBoxPrefixSubscriptionStateModifier })
    pushbytes "s"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1960
    // this.subscriptionStateModifier(subscriptionIndex).value = newModifier
    swap
    itob
    box_put
    // smart_contracts/social/contract.algo.ts:1962-1969
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dup
    gtxns Receiver
    // smart_contracts/social/contract.algo.ts:1965
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/social/contract.algo.ts:1962-1969
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/social/contract.algo.ts:1966
    // amount: this.mbr().subscriptionStateModifier
    pushint 9300 // 9300
    // smart_contracts/social/contract.algo.ts:1962-1969
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr().subscriptionStateModifier
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    // smart_contracts/social/contract.algo.ts:1957
    // updateSubscriptionStateModifier(payment: gtxn.PaymentTxn, subscriptionIndex: uint64, newModifier: uint64): void {
    return // on error: Invalid payment


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getUserImpactWithoutSocial[routing]() -> void:
getUserImpactWithoutSocial:
    // smart_contracts/social/contract.algo.ts:1975
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1977
    // return this.userImpact(address.native, false)
    intc_0 // 0
    callsub userImpact
    // smart_contracts/social/contract.algo.ts:1975
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getUserImpact[routing]() -> void:
getUserImpact:
    // smart_contracts/social/contract.algo.ts:1980
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1982
    // return this.userImpact(address.native, true)
    intc_1 // 1
    callsub userImpact
    // smart_contracts/social/contract.algo.ts:1980
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getMeta[routing]() -> void:
getMeta:
    // smart_contracts/social/contract.algo.ts:1985
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/social/contract.algo.ts:1663
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1987
    // return this.meta(user.native).value
    box_get
    assert // Box must have value
    // smart_contracts/social/contract.algo.ts:1985
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:25
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 4 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:25
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:17
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 5 // "version"
    // smart_contracts/utils/base-contracts/base.ts:26
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 4 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:38
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.isSubscribed(account: bytes, index: uint64) -> bytes:
isSubscribed:
    // smart_contracts/social/contract.algo.ts:1680
    // private isSubscribed(account: Account, index: uint64): { active: boolean; serviceID: uint64; streak: uint64 } {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:1681-1684
    // const info = abiCall<typeof Subscriptions.prototype.getSubscription>({
    //   appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    //   args: [new Address(account), index]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1682
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1682
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    dup
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1682
    // appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    pushint 32 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1683
    // args: [new Address(account), index]
    frame_dig -1
    itob
    // smart_contracts/social/contract.algo.ts:1681-1684
    // const info = abiCall<typeof Subscriptions.prototype.getSubscription>({
    //   appId: getAkitaAppList(this.akitaDAO.value).subscriptions,
    //   args: [new Address(account), index]
    // }).returnValue
    pushbytes 0xeb42af80 // method "getSubscription(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 104 // 104
    ==
    assert // invalid number of bytes for (uint8[32],uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
    // smart_contracts/social/contract.algo.ts:1687
    // const toAkita = info.recipient.native === this.akitaDAO.value.address
    dup
    extract 4 32
    uncover 2
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/social/contract.algo.ts:1691
    // const notDonating = info.serviceID !== 0
    dig 1
    pushint 36 // 36
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1693
    // const lastWindowStart: uint64 = Global.latestTimestamp - (((Global.latestTimestamp - info.startDate) % info.interval) + info.interval)
    global LatestTimestamp
    dup
    dig 4
    pushint 44 // 44
    extract_uint64
    -
    dig 4
    pushint 60 // 60
    extract_uint64
    swap
    dig 1
    %
    +
    -
    // smart_contracts/social/contract.algo.ts:1697
    // const notStale = info.lastPayment > lastWindowStart
    dig 3
    pushint 84 // 84
    extract_uint64
    <
    // smart_contracts/social/contract.algo.ts:1700
    // active: toAkita && notDonating && notStale,
    uncover 2
    dig 2
    &&
    &&
    // smart_contracts/social/contract.algo.ts:1702
    // streak: info.streak,
    uncover 2
    extract 92 8
    // smart_contracts/social/contract.algo.ts:1699-1703
    // return {
    //   active: toAkita && notDonating && notStale,
    //   serviceID: info.serviceID,
    //   streak: info.streak,
    // }
    pushbytes 0x00
    intc_0 // 0
    uncover 3
    setbit
    uncover 2
    itob
    concat
    swap
    concat
    retsub


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.userImpact(account: bytes, includeSocial: uint64) -> uint64:
userImpact:
    // smart_contracts/social/contract.algo.ts:1736
    // private userImpact(account: Account, includeSocial: boolean): uint64 {
    proto 2 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 7
    // smart_contracts/social/contract.algo.ts:1663
    // meta = BoxMap<Account, ImpactMetaValue>({ keyPrefix: ImpactBoxPrefixMeta })
    bytec_3 // "m"
    frame_dig -2
    concat
    dup
    // smart_contracts/social/contract.algo.ts:1737
    // const { subscriptionIndex, NFD, akitaNFT } = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 32 // 32
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1756
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1756
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:89
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 10 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1756
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    extract 0 8
    // smart_contracts/social/contract.algo.ts:1758-1767
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(account),
    //     {
    //       asset: akta,
    //       type: STAKING_TYPE_SOFT,
    //     }
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1759
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1762-1765
    // {
    //   asset: akta,
    //   type: STAKING_TYPE_SOFT,
    // }
    swap
    // smart_contracts/social/contract.algo.ts:1764
    // type: STAKING_TYPE_SOFT,
    pushbytes 0x14
    // smart_contracts/social/contract.algo.ts:1762-1765
    // {
    //   asset: akta,
    //   type: STAKING_TYPE_SOFT,
    // }
    concat
    // smart_contracts/social/contract.algo.ts:1758-1767
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(account),
    //     {
    //       asset: akta,
    //       type: STAKING_TYPE_SOFT,
    //     }
    //   ]
    // }).returnValue
    pushbytes 0xc9068809 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    // smart_contracts/social/contract.algo.ts:1769
    // const elapsed: uint64 = Global.latestTimestamp - info.lastUpdate
    global LatestTimestamp
    dig 1
    pushint 12 // 12
    extract_uint64
    -
    swap
    pushint 4 // 4
    // smart_contracts/social/contract.algo.ts:1772
    // if (info.amount < TEN_THOUSAND_AKITA || elapsed < THIRTY_DAYS) {
    extract_uint64
    dup
    intc 7 // 10000000000
    <
    bnz userImpact_if_body@27
    frame_dig 14
    pushint 2592000 // 2592000
    <
    bz userImpact_after_if_else@28

userImpact_if_body@27:
    // smart_contracts/social/contract.algo.ts:1773
    // return 0
    intc_0 // 0
    frame_bury 6

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getStakingImpactScore@32:
    // smart_contracts/social/contract.algo.ts:1802
    // let subscriberImpact: uint64 = 0
    intc_0 // 0
    frame_bury 7
    // smart_contracts/social/contract.algo.ts:1804
    // const subscriptionState = this.isSubscribed(account, subscriptionIndex)
    frame_dig -2
    frame_dig 11
    callsub isSubscribed
    dup
    frame_bury 1
    // smart_contracts/social/contract.algo.ts:1806
    // if (!subscriptionState.active) {
    intc_0 // 0
    getbit
    bz userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39
    // smart_contracts/social/contract.algo.ts:1810
    // const modifier = this.subscriptionStateModifier(subscriptionState.serviceID).value
    frame_dig 1
    dup
    extract 1 8
    // smart_contracts/social/contract.algo.ts:1665
    // subscriptionStateModifier = BoxMap<uint64, uint64>({ keyPrefix: ImpactBoxPrefixSubscriptionStateModifier })
    pushbytes "s"
    swap
    concat
    // smart_contracts/social/contract.algo.ts:1810
    // const modifier = this.subscriptionStateModifier(subscriptionState.serviceID).value
    box_get
    assert // Box must have value
    btoi
    swap
    // smart_contracts/social/contract.algo.ts:1813
    // if (subscriptionState.streak >= 12) {
    pushint 9 // 9
    extract_uint64
    dup
    frame_bury 9
    pushint 12 // 12
    >=
    bz userImpact_else_body@37
    // smart_contracts/social/contract.algo.ts:1814
    // subscriberImpact += 250 / modifier
    pushint 250 // 250
    swap
    /
    frame_bury 7

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39:
    // smart_contracts/social/contract.algo.ts:1741
    // const socialImpact = includeSocial ? this.getSocialImpactScore(account) : Uint64(0) // Social Activity | up to 250
    frame_dig -1
    bz userImpact_ternary_false@2
    // smart_contracts/social/contract.algo.ts:1823-1826
    // return abiCall<typeof AkitaSocial.prototype.getUserSocialImpact>({
    //   appId: getAkitaAppList(this.akitaDAO.value).social,
    //   args: [new Address(account)]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1824
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1824
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1824
    // appId: getAkitaAppList(this.akitaDAO.value).social,
    pushint 96 // 96
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1823-1826
    // return abiCall<typeof AkitaSocial.prototype.getUserSocialImpact>({
    //   appId: getAkitaAppList(this.akitaDAO.value).social,
    //   args: [new Address(account)]
    // }).returnValue
    pushbytes 0xe869934d // method "getUserSocialImpact(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    frame_bury 5

userImpact_ternary_merge@3:
    // smart_contracts/social/contract.algo.ts:1889
    // const { NFD, nfdTimeChanged, nfdImpact } = this.meta(account).value
    frame_dig 10
    box_get
    assert // Box must have value
    dup
    intc_2 // 8
    extract_uint64
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    frame_bury 4
    // smart_contracts/social/contract.algo.ts:1890
    // const timeChanged = btoi(op.AppGlobal.getExBytes(NFD, Bytes(NFDGlobalStateKeysTimeChanged))[0])
    dig 1
    bytec 8 // "i.timeChanged"
    app_global_get_ex
    pop
    btoi
    // smart_contracts/social/contract.algo.ts:1892
    // assert(NFDApp.id === Application(NFD).id, ERR_INVALID_NFD)
    frame_dig 12
    uncover 3
    ==
    assert // Invalid NFD
    // smart_contracts/social/contract.algo.ts:1893
    // assert(nfdTimeChanged === timeChanged, ERR_NFD_CHANGED)
    ==
    assert // NFD changed since impact last calculated
    // smart_contracts/social/contract.algo.ts:1789
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/social/contract.algo.ts:1789
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:89
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    bytec 10 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/contract.algo.ts:1789
    // const akta = getAkitaAssets(this.akitaDAO.value).akta
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/contract.algo.ts:1790
    // const balance = AssetHolding.assetBalance(account, akta)[0]
    frame_dig -2
    swap
    asset_holding_get AssetBalance
    pop
    dup
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1793
    // if (balance < TEN_THOUSAND_AKITA) {
    intc 7 // 10000000000
    <
    bz userImpact_after_if_else@10
    // smart_contracts/social/contract.algo.ts:1794
    // return 0
    intc_0 // 0
    frame_bury 3

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getHeldAktaImpactScore@11:
    // smart_contracts/social/contract.algo.ts:1899
    // const prefix = asset.unitName.slice(0, 3)
    frame_dig 13
    dup
    asset_params_get AssetUnitName
    assert // asset exists
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 3 // 3
    dig 2
    >=
    pushint 3 // 3
    uncover 3
    uncover 2
    select
    substring3
    frame_bury 0
    // smart_contracts/social/contract.algo.ts:1900
    // const balance = AssetHolding.assetBalance(account, asset)[0]
    frame_dig -2
    dig 1
    asset_holding_get AssetBalance
    pop
    frame_bury 2
    // smart_contracts/social/contract.algo.ts:1901
    // if (asset.creator === Account(AkitaNFTCreatorAddress) && balance > 0) {
    asset_params_get AssetCreator
    assert // asset exists
    bytec 9 // addr AKCTRDK4OWNWHTPH4XPKLNWNLZ333VE35SKQ4FGQK3ZJA4FIHCLTRG3PFI
    ==
    bz userImpact_after_if_else@19
    frame_dig 2
    bz userImpact_after_if_else@19
    // smart_contracts/social/contract.algo.ts:1902
    // if (prefix === Bytes(AkitaCollectionsPrefixAKC)) {
    frame_dig 0
    pushbytes "AKC"
    ==
    bz userImpact_after_if_else@16
    // smart_contracts/social/contract.algo.ts:1903
    // return 50
    pushint 50 // 50

userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20:
    // smart_contracts/social/contract.algo.ts:1746
    // const total: uint64 = stakedAktaImpact + subscriberImpact + socialImpact + nfdScore + heldAkitaImpact + nftImpact
    frame_dig 6
    frame_dig 7
    +
    frame_dig 5
    +
    frame_dig 4
    +
    frame_dig 3
    +
    +
    dup
    frame_bury 8
    // smart_contracts/social/contract.algo.ts:1747
    // if (total === 0) {
    bnz userImpact_after_if_else@5
    // smart_contracts/social/contract.algo.ts:1748
    // return 1
    intc_1 // 1
    frame_bury 0
    retsub

userImpact_after_if_else@5:
    // smart_contracts/social/contract.algo.ts:1751
    // return total
    frame_dig 8
    frame_bury 0
    retsub

userImpact_after_if_else@16:
    // smart_contracts/social/contract.algo.ts:1905
    // if (prefix === Bytes(AkitaCollectionsPrefixAOG)) {
    frame_dig 0
    pushbytes "AOG"
    ==
    bz userImpact_after_if_else@19
    // smart_contracts/social/contract.algo.ts:1906
    // return 25
    pushint 25 // 25
    // smart_contracts/social/contract.algo.ts:1744
    // const nftImpact = this.getNFTImpactScore(account, Asset(akitaNFT)) // Holds AKC/Omnigem | 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20

userImpact_after_if_else@19:
    // smart_contracts/social/contract.algo.ts:1909
    // return 0
    intc_0 // 0
    // smart_contracts/social/contract.algo.ts:1744
    // const nftImpact = this.getNFTImpactScore(account, Asset(akitaNFT)) // Holds AKC/Omnigem | 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getNFTImpactScore@20

userImpact_after_if_else@10:
    // smart_contracts/social/contract.algo.ts:1797
    // const capped = balance >= ONE_MILLION_AKITA ? ONE_MILLION_AKITA : balance
    frame_dig 2
    dup
    intc 4 // 1000000000000
    >=
    intc 4 // 1000000000000
    swap
    select
    // smart_contracts/social/contract.algo.ts:1798
    // return (capped * 50) / ONE_MILLION_AKITA
    pushint 50 // 50
    *
    intc 4 // 1000000000000
    /
    frame_bury 3
    // smart_contracts/social/contract.algo.ts:1743
    // const heldAkitaImpact = this.getHeldAktaImpactScore(account) // Held AKTA | up to 50
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getHeldAktaImpactScore@11

userImpact_ternary_false@2:
    // smart_contracts/social/contract.algo.ts:1741
    // const socialImpact = includeSocial ? this.getSocialImpactScore(account) : Uint64(0) // Social Activity | up to 250
    intc_0 // 0
    frame_bury 5
    b userImpact_ternary_merge@3

userImpact_else_body@37:
    // smart_contracts/social/contract.algo.ts:1816
    // subscriberImpact += (subscriptionState.streak * 20) / modifier
    frame_dig 9
    pushint 20 // 20
    *
    swap
    /
    frame_bury 7
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getSubscriberImpactScore@39

userImpact_after_if_else@28:
    // smart_contracts/social/contract.algo.ts:1777
    // const amtCapped = info.amount >= TWO_HUNDRED_THOUSAND_AKITA ? TWO_HUNDRED_THOUSAND_AKITA : info.amount
    frame_dig 15
    intc 5 // 200000000000
    >=
    bz userImpact_ternary_false@30
    intc 5 // 200000000000

userImpact_ternary_merge@31:
    // smart_contracts/social/contract.algo.ts:1780
    // const maxScore: uint64 = (amtCapped * 250) / TWO_HUNDRED_THOUSAND_AKITA
    pushint 250 // 250
    *
    intc 5 // 200000000000
    /
    // smart_contracts/social/contract.algo.ts:1783
    // const timeCapped = elapsed >= ONE_YEAR ? ONE_YEAR : elapsed
    frame_dig 14
    dup
    intc 6 // 31536000
    >=
    intc 6 // 31536000
    swap
    select
    // smart_contracts/social/contract.algo.ts:1785
    // return (timeCapped * maxScore) / ONE_YEAR
    *
    intc 6 // 31536000
    /
    frame_bury 6
    // smart_contracts/social/contract.algo.ts:1739
    // const stakedAktaImpact = this.getStakingImpactScore(account) // Staked AKTA | up to 250
    b userImpact_after_inlined_smart_contracts/social/contract.algo.ts::AkitaSocialImpact.getStakingImpactScore@32

userImpact_ternary_false@30:
    frame_dig 15
    b userImpact_ternary_merge@31


// smart_contracts/social/contract.algo.ts::AkitaSocialImpact.nfdReadField(NFDApp: uint64, field: bytes) -> bytes:
nfdReadField:
    // smart_contracts/social/contract.algo.ts:1829
    // private nfdReadField(NFDApp: Application, field: string): bytes {
    proto 2 1
    // smart_contracts/social/contract.algo.ts:1830-1833
    // const fieldBytes = abiCall<typeof NFD.prototype.readField>({
    //   appId: NFDApp.id,
    //   args: [Bytes(field)]
    // }).returnValue
    itxn_begin
    // smart_contracts/social/contract.algo.ts:1832
    // args: [Bytes(field)]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/social/contract.algo.ts:1830-1833
    // const fieldBytes = abiCall<typeof NFD.prototype.readField>({
    //   appId: NFDApp.id,
    //   args: [Bytes(field)]
    // }).returnValue
    bytec 7 // method "readField(byte[])byte[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    // smart_contracts/social/contract.algo.ts:1835
    // return fieldBytes
    retsub
