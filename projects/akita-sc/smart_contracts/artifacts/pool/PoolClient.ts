/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"Pool","structs":{"ObjectC3416591":[{"name":"valid","type":"bool"},{"name":"balance","type":"uint64"}],"RootKey":[{"name":"address","type":"address"},{"name":"name","type":"string"}],"EntryData":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"},{"name":"quantity","type":"uint64"},{"name":"gateArgs","type":"byte[][]"},{"name":"disqualified","type":"bool"}],"EntryKey":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"}],"PoolMBRData":[{"name":"entries","type":"uint64"},{"name":"uniques","type":"uint64"},{"name":"entriesByAddress","type":"uint64"},{"name":"rewards","type":"uint64"},{"name":"disbursements","type":"uint64"}],"PoolState":[{"name":"status","type":"uint8"},{"name":"title","type":"string"},{"name":"type","type":"uint8"},{"name":"signupTimestamp","type":"uint64"},{"name":"startTimestamp","type":"uint64"},{"name":"allowLateSignups","type":"bool"},{"name":"endTimestamp","type":"uint64"},{"name":"maxEntries","type":"uint64"},{"name":"entryCount","type":"uint64"},{"name":"rewardCount","type":"uint64"},{"name":"totalStaked","type":"uint64"},{"name":"stakeKey","type":"RootKey"},{"name":"minimumStakeAmount","type":"uint64"},{"name":"gateId","type":"uint64"},{"name":"creator","type":"address"}],"RaffleCursor":[{"name":"ticket","type":"uint64"},{"name":"stake","type":"uint64"},{"name":"disbursed","type":"uint64"}],"Reward":[{"name":"asset","type":"uint64"},{"name":"distribution","type":"uint8"},{"name":"rate","type":"uint64"},{"name":"expiration","type":"uint64"},{"name":"interval","type":"uint64"},{"name":"qualifiedStakers","type":"uint64"},{"name":"qualifiedStake","type":"uint64"},{"name":"winnerCount","type":"uint64"},{"name":"winningTickets","type":"uint64[]"},{"name":"raffleCursor","type":"RaffleCursor"},{"name":"vrfFailureCount","type":"uint64"},{"name":"phase","type":"uint8"},{"name":"disbursementCursor","type":"uint64"},{"name":"activeDisbursementId","type":"uint64"},{"name":"activeDisbursementRoundStart","type":"uint64"},{"name":"lastDisbursementTimestamp","type":"uint64"}]},"methods":[{"name":"create","args":[{"type":"string","name":"title"},{"type":"uint8","name":"type"},{"type":"address","name":"creator"},{"type":"address","name":"marketplace"},{"type":"(address,string)","struct":"RootKey","name":"stakeKey"},{"type":"uint64","name":"minimumStakeAmount"},{"type":"uint64","name":"gateID"},{"type":"uint64","name":"maxEntries"},{"type":"uint64","name":"akitaDAO"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"init","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"delete","args":[{"type":"address","name":"caller"}],"returns":{"type":"void"},"actions":{"create":[],"call":["DeleteApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"optin","args":[{"type":"pay","name":"payment","desc":"The payment transaction"},{"type":"uint64","name":"asset","desc":"The asset to be opted into"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in","events":[],"recommendations":{}},{"name":"addReward","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"addRewardAsa","args":[{"type":"pay","name":"payment"},{"type":"axfer","name":"assetXfer"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalize","args":[{"type":"uint64","name":"signupTimestamp"},{"type":"uint64","name":"startTimestamp"},{"type":"uint64","name":"endTimestamp"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"enter","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint64,byte[32][])[]","name":"entries"},{"type":"byte[][]","name":"args"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"startDisbursement","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"raffle","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"disburseRewards","args":[{"type":"uint64","name":"rewardID"},{"type":"uint64","name":"iterationAmount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalizeDistribution","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"check","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(bool,uint64)","struct":"ObjectC3416591"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"signUpsOpen","args":[],"returns":{"type":"bool","desc":"a boolean of whether sign ups are open"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isLive","args":[],"returns":{"type":"bool","desc":"a boolean of whether the pool is live"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isEntered","args":[{"type":"address","name":"address"}],"returns":{"type":"bool","desc":"a boolean indicating if the address has entered the staking pool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getState","args":[],"returns":{"type":"(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)","struct":"PoolState"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mbr","args":[{"type":"uint64","name":"winningTickets"}],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","struct":"PoolMBRData","desc":"the mbr created for each boxmap entry"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"optAkitaEscrowInAndSend","args":[{"type":"string","name":"name"},{"type":"asset","name":"asset"},{"type":"uint64","name":"amount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"update","args":[{"type":"string","name":"newVersion"}],"returns":{"type":"void"},"actions":{"create":[],"call":["UpdateApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateAkitaDAO","args":[{"type":"uint64","name":"app"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateAkitaDAOEscrow","args":[{"type":"uint64","name":"app"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":16,"bytes":8},"local":{"ints":0,"bytes":0}},"keys":{"global":{"status":{"keyType":"AVMString","valueType":"uint8","key":"c3RhdHVz","desc":"the status the pool is in"},"title":{"keyType":"AVMString","valueType":"AVMString","key":"dGl0bGU=","desc":"title of the staking pool"},"type":{"keyType":"AVMString","valueType":"uint8","key":"dHlwZQ==","desc":"the method of staking to be used for the pool"},"signupTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c2lnbnVwX3RpbWVzdGFtcA==","desc":"the timestamp when sign ups for the pool are allowed"},"allowLateSignups":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWxsb3dfbGF0ZV9zaWdudXBz","desc":"whether signups are allowed after the staking pool begins"},"startTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c3RhcnRfdGltZXN0YW1w","desc":"the timestamp when the pool starts"},"endTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW5kX3RpbWVzdGFtcA==","desc":"the timestamp when the pool ends"},"maxEntries":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWF4X2VudHJpZXM=","desc":"the maximum entries allowed for the pool"},"entryID":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW50cnlfY291bnQ=","desc":"the number of entries in a pool"},"rewardID":{"keyType":"AVMString","valueType":"AVMUint64","key":"cmV3YXJkX2NvdW50","desc":"the number of rewards for the pool"},"totalStaked":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxfc3Rha2Vk","desc":"the total amount staked in the pool"},"stakeKey":{"keyType":"AVMString","valueType":"RootKey","key":"c3Rha2Vfa2V5","desc":"the name for the meta merkle asset group to validate staking\nstake key can be empty if distribution !== DistributionTypePercentage"},"minimumStakeAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWluaW11bV9zdGFrZV9hbW91bnQ=","desc":"minimum stake amount"},"gateID":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9pZA==","desc":"the gate id of the pool"},"gateSize":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9zaXpl","desc":"the size of the gate were using"},"creator":{"keyType":"AVMString","valueType":"address","key":"Y3JlYXRvcg==","desc":"the address of the creator of the staking pool"},"marketplace":{"keyType":"AVMString","valueType":"address","key":"bWFya2V0cGxhY2U=","desc":"marketplace is pool creation side marketplace"},"marketplaceRoyalties":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWFya2V0cGxhY2Vfcm95YWx0aWVz","desc":"the amount the marketplaces will get for the sale"},"akitaRoyalty":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eQ==","desc":"the akita royalty for the pool"},"akitaRoyaltyAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eV9hbW91bnQ=","desc":"the amount of royalties that were paid in a disbursement"},"salt":{"keyType":"AVMString","valueType":"AVMBytes","key":"c2FsdA==","desc":"salt for randomness"},"version":{"keyType":"AVMString","valueType":"AVMString","key":"dmVyc2lvbg==","desc":"the current version of the contract"},"akitaDAO":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZGFv","desc":"the app ID of the Akita DAO"},"akitaDAOEscrow":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZXNjcm93","desc":"the escrow account to use when making payments to the Akita DAO"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"entries":{"keyType":"uint64","valueType":"EntryData","desc":"indexed entries for efficient iteration","prefix":"ZQ=="},"uniques":{"keyType":"address","valueType":"uint64","desc":"the number of unique asset entries by address","prefix":"dQ=="},"entriesByAddress":{"keyType":"EntryKey","valueType":"uint64","desc":"the entries in the pool","prefix":"YQ=="},"rewards":{"keyType":"uint64","valueType":"Reward","desc":"the rewards for this staking pool","prefix":"cg=="},"disbursements":{"keyType":"uint64","valueType":"AVMBytes","desc":"the disbursements this pool as created & finalized","prefix":"ZA=="}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[1261,1380,3137,3370,3719,3824,3899,4018,4076,4155,4201,4343,4371,4465,4556,4601,4633,4759,4825,4863,4895,5008,5068,5106,5150,5334,5525,5598,5649,5707,5957],"errorMessage":"Box must have value"},{"pc":[1130,1211,1353,1438,1765,1873,2735,2836,3132,3356,4133],"errorMessage":"Bytes has valid prefix"},{"pc":[4296],"errorMessage":"DAO not opted in to the asset"},{"pc":[5826],"errorMessage":"Disbursement not ready for finalization"},{"pc":[1946,2041],"errorMessage":"Forbidden"},{"pc":[3278],"errorMessage":"Invalid disbursement phase"},{"pc":[1984,2176,2556],"errorMessage":"Invalid payment"},{"pc":[4251,4327,4506,4686],"errorMessage":"Invalid percentage"},{"pc":[4495],"errorMessage":"Invalid percentage of args"},{"pc":[1249],"errorMessage":"Invalid pool type for check"},{"pc":[2244],"errorMessage":"Invalid transfer"},{"pc":[2148],"errorMessage":"Max entries cannot be greater than rate"},{"pc":[2047],"errorMessage":"Must be an Algo asset"},{"pc":[4707,4952,5227],"errorMessage":"Not enough funds"},{"pc":[3815],"errorMessage":"Not ready to disburse"},{"pc":[964],"errorMessage":"OnCompletion is not DeleteApplication"},{"pc":[548,564,600,628,648,664,688,709,730,753,769,789,805,821,849,873,910,936,979,991],"errorMessage":"OnCompletion is not NoOp"},{"pc":[582],"errorMessage":"OnCompletion is not UpdateApplication"},{"pc":[6395,6423,6444],"errorMessage":"Only the Akita DAO can call this function"},{"pc":[2116],"errorMessage":"Rate must be greater than winner count"},{"pc":[2154],"errorMessage":"Rate must be greater than zero"},{"pc":[2074],"errorMessage":"Stake key required"},{"pc":[3284],"errorMessage":"Winning tickets already exist"},{"pc":[1516,1567,1584,3058,6291,6361,6393,6421,6442],"errorMessage":"application exists"},{"pc":[1897],"errorMessage":"call must come from factory"},{"pc":[995],"errorMessage":"can only call when creating"},{"pc":[551,567,585,603,631,651,667,691,712,733,756,772,792,808,824,852,876,913,939,967,982],"errorMessage":"can only call when not creating"},{"pc":[1231,1241,1305,1469,1724,1823,1840,1902,1911,1923,1944,2039,2052,2129,2137,2181,2266,2273,2294,2333,2423,2455,2478,2485,2494,2561,2646,2743,2754,2850,2987,3014,3317,3862,3870,3939,3965,3990,4007,4066,4190,4246,4322,4409,4417,4427,4587,4675,4681,4714,4722,4854,4943,4959,4967,5097,5218,5234,5242,5967,5979,5990,5999,6011,6023,6034,6043,6068,6073,6078,6083,6088,6093,6098,6103,6107,6114,6133,6138,6143,6148,6153,6288,6312,6358,6390,6418,6439],"errorMessage":"check GlobalState exists"},{"pc":[3009],"errorMessage":"distribution window is not open"},{"pc":[2738],"errorMessage":"failed to verify stake requirements"},{"pc":[2338],"errorMessage":"if the starting round is zero, the signup round must be zero and allowLateSignups must be true"},{"pc":[2617],"errorMessage":"index access is out of bounds"},{"pc":[3660,4524,4786,5034,5473],"errorMessage":"max array length exceeded"},{"pc":[1906],"errorMessage":"only the creator can delete the pool"},{"pc":[2268],"errorMessage":"only the creator can finalize the pool"},{"pc":[1818],"errorMessage":"only the factory can init the pool"},{"pc":[1482],"errorMessage":"overflow"},{"pc":[2499],"errorMessage":"pool has reached maximum entries"},{"pc":[1473],"errorMessage":"pool staking type is not set"},{"pc":[2648],"errorMessage":"quantity is less than minimum stake amount"},{"pc":[2950,3236,3774,5803],"errorMessage":"reward does not exist"},{"pc":[2979],"errorMessage":"reward is already in a disbursement phase"},{"pc":[2367],"errorMessage":"the ending round must be zero or after the starting round + 10"},{"pc":[2418,2937],"errorMessage":"the pool is not live"},{"pc":[1929],"errorMessage":"the pool must be in draft or ended"},{"pc":[2276],"errorMessage":"the pool must be in draft state to finalize"},{"pc":[2299],"errorMessage":"the signup round must be zero and late sign ups allowed or in the future"},{"pc":[2314],"errorMessage":"the starting round must be zero or in the future"},{"pc":[898],"errorMessage":"transaction type is axfer"},{"pc":[834,887,923,949],"errorMessage":"transaction type is pay"},{"pc":[5133],"errorMessage":"unknown reward rate type"},{"pc":[2846],"errorMessage":"user does not have enough staked"},{"pc":[2784],"errorMessage":"user does not have min balance"},{"pc":[2466],"errorMessage":"user does not meet gate requirements"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDYgOCA0MDAgMTAwMDAwIDYzNjQxMzYyMjM4NDY3OTMwMDUgMTQ0MjY5NTA0MDg4ODk2MzQwNyAxNDQyNjk1MDQwODg4OTYzNDA5IDQyOTQ5NjcyOTUgMTg0NDY3NDQwNzM3MDk1NTE2MTUKICAgIGJ5dGVjYmxvY2sgImVudHJ5X2NvdW50IiAweDE1MWY3Yzc1IDB4MDAgImFraXRhX2FsIiAidHlwZSIgMHgwYSAiZ2F0ZV9pZCIgMHgwMDAwICJlIiAweDE0ICJzdGF0dXMiICJjcmVhdG9yIiAweDFlICJtYXhfZW50cmllcyIgImVuZF90aW1lc3RhbXAiICJyIiAic3RhcnRfdGltZXN0YW1wIiAiYWtpdGFfcm95YWx0eV9hbW91bnQiICJha2l0YV9kYW8iIDB4ODAgInN0YWtlX2tleSIgImFraXRhX3JveWFsdHkiICJhbGxvd19sYXRlX3NpZ251cHMiICJ0aXRsZSIgIm1pbmltdW1fc3Rha2VfYW1vdW50IiAicmV3YXJkX2NvdW50IiAic2lnbnVwX3RpbWVzdGFtcCIgImFraXRhX2VzY3JvdyIgMHgwMDAwMDAwMDAwMDAwMDAwMDAgMHg0MGU5MTRlNiAic2FsdCIgImNvbnRyb2xsZWRfYWRkcmVzcyIgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTctMTAwCiAgICAvLyBleHBvcnQgY2xhc3MgUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VQb29sLAogICAgLy8gICBBa2l0YUJhc2VFc2Nyb3cKICAgIC8vICkgewogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYWZ0ZXJfaWZfZWxzZUAzMAogICAgcHVzaGJ5dGVzcyAweGQ1ZjNjMDZhIDB4ODNmMTQ3NDggMHhhYjhiMjEzYSAweDNlYTExODMyIDB4NjQ1YTdiY2MgMHgwZjJmYzMxMiAweDE4MWU4MjkxIDB4Njg1NThjNzAgMHhhOTQxOGQzNyAweGZjNjk5Y2IzIDB4NmU3NmIyY2EgMHhjZGIwYWM2YSAweGIyMjNkMzVkIDB4NTkyZWUzNDEgMHg4ZmE0YTE2MCAweGUzMzc3MzQyIDB4NzE3MDQ2NDkgMHhhNGIzZTc4OSAweDg1ODc1ODQwIDB4ZWE5MTgwZGQgMHgzM2U5MmM5NCAweDFlYWQyMGE5IC8vIG1ldGhvZCAiY3JlYXRlKHN0cmluZyx1aW50OCxhZGRyZXNzLGFkZHJlc3MsKGFkZHJlc3Msc3RyaW5nKSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiaW5pdCgpdm9pZCIsIG1ldGhvZCAiZGVsZXRlKGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAib3B0aW4ocGF5LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJhZGRSZXdhcmQocGF5LCh1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0W10sKHVpbnQ2NCx1aW50NjQsdWludDY0KSx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIiwgbWV0aG9kICJhZGRSZXdhcmRBc2EocGF5LGF4ZmVyLCh1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0W10sKHVpbnQ2NCx1aW50NjQsdWludDY0KSx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIiwgbWV0aG9kICJmaW5hbGl6ZSh1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJlbnRlcihwYXksKHVpbnQ2NCx1aW50NjQsYnl0ZVszMl1bXSlbXSxieXRlW11bXSl2b2lkIiwgbWV0aG9kICJzdGFydERpc2J1cnNlbWVudCh1aW50NjQpdm9pZCIsIG1ldGhvZCAicmFmZmxlKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJkaXNidXJzZVJld2FyZHModWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJmaW5hbGl6ZURpc3RyaWJ1dGlvbih1aW50NjQpdm9pZCIsIG1ldGhvZCAiY2hlY2soYWRkcmVzcyx1aW50NjQpKGJvb2wsdWludDY0KSIsIG1ldGhvZCAic2lnblVwc09wZW4oKWJvb2wiLCBtZXRob2QgImlzTGl2ZSgpYm9vbCIsIG1ldGhvZCAiaXNFbnRlcmVkKGFkZHJlc3MpYm9vbCIsIG1ldGhvZCAiZ2V0U3RhdGUoKSh1aW50OCxzdHJpbmcsdWludDgsdWludDY0LHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsKGFkZHJlc3Msc3RyaW5nKSx1aW50NjQsdWludDY0LGFkZHJlc3MpIiwgbWV0aG9kICJtYnIodWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAib3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmQoc3RyaW5nLGFzc2V0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGUoc3RyaW5nKXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBT0VzY3Jvdyh1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY3JlYXRlX3JvdXRlQDUgbWFpbl9pbml0X3JvdXRlQDYgbWFpbl9kZWxldGVfcm91dGVANyBtYWluX29wdGluX3JvdXRlQDggbWFpbl9hZGRSZXdhcmRfcm91dGVAOSBtYWluX2FkZFJld2FyZEFzYV9yb3V0ZUAxMCBtYWluX2ZpbmFsaXplX3JvdXRlQDExIG1haW5fZW50ZXJfcm91dGVAMTIgbWFpbl9zdGFydERpc2J1cnNlbWVudF9yb3V0ZUAxMyBtYWluX3JhZmZsZV9yb3V0ZUAxNCBtYWluX2Rpc2J1cnNlUmV3YXJkc19yb3V0ZUAxNSBtYWluX2ZpbmFsaXplRGlzdHJpYnV0aW9uX3JvdXRlQDE2IG1haW5fY2hlY2tfcm91dGVAMTcgbWFpbl9zaWduVXBzT3Blbl9yb3V0ZUAxOCBtYWluX2lzTGl2ZV9yb3V0ZUAxOSBtYWluX2lzRW50ZXJlZF9yb3V0ZUAyMCBtYWluX2dldFN0YXRlX3JvdXRlQDIxIG1haW5fbWJyX3JvdXRlQDIyIG1haW5fb3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmRfcm91dGVAMjMgbWFpbl91cGRhdGVfcm91dGVAMjQgbWFpbl91cGRhdGVBa2l0YURBT19yb3V0ZUAyNSBtYWluX3VwZGF0ZUFraXRhREFPRXNjcm93X3JvdXRlQDI2CgptYWluX2FmdGVyX2lmX2Vsc2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fdXBkYXRlQWtpdGFEQU9Fc2Nyb3dfcm91dGVAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjYyCiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6NjIKICAgIC8vIHVwZGF0ZUFraXRhREFPRXNjcm93KGFwcDogdWludDY0KTogdm9pZCB7CiAgICBjYWxsc3ViIHVwZGF0ZUFraXRhREFPRXNjcm93CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3VwZGF0ZUFraXRhREFPX3JvdXRlQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czo1NwogICAgLy8gdXBkYXRlQWtpdGFEQU8oYXBwOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjU3CiAgICAvLyB1cGRhdGVBa2l0YURBTyhhcHA6IHVpbnQ2NCk6IHZvaWQgewogICAgY2FsbHN1YiB1cGRhdGVBa2l0YURBTwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfcm91dGVAMjQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjQ5CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IFVwZGF0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTctMTAwCiAgICAvLyBleHBvcnQgY2xhc3MgUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VQb29sLAogICAgLy8gICBBa2l0YUJhc2VFc2Nyb3cKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6NDkKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgY2FsbHN1YiB1cGRhdGUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fb3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmRfcm91dGVAMjM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjIwCiAgICAvLyBvcHRBa2l0YUVzY3Jvd0luQW5kU2VuZChuYW1lOiBzdHJpbmcsIGFzc2V0OiBBc3NldCwgYW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQXNzZXRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjIwCiAgICAvLyBvcHRBa2l0YUVzY3Jvd0luQW5kU2VuZChuYW1lOiBzdHJpbmcsIGFzc2V0OiBBc3NldCwgYW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIGNhbGxzdWIgb3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmQKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fbWJyX3JvdXRlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvYmFzZS50czoxMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTctMTAwCiAgICAvLyBleHBvcnQgY2xhc3MgUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VQb29sLAogICAgLy8gICBBa2l0YUJhc2VFc2Nyb3cKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvYmFzZS50czoxMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIG1icgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRTdGF0ZV9yb3V0ZUAyMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0U3RhdGUKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faXNFbnRlcmVkX3JvdXRlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDg2CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODYKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgY2FsbHN1YiBpc0VudGVyZWQKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2lzTGl2ZV9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3NgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgaXNMaXZlCiAgICBieXRlY18yIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zaWduVXBzT3Blbl9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2NgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgc2lnblVwc09wZW4KICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NoZWNrX3JvdXRlQDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDU3CiAgICAvLyBjaGVjayhhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogeyB2YWxpZDogYm9vbGVhbiwgYmFsYW5jZTogdWludDY0IH0gewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1NwogICAgLy8gY2hlY2soYWRkcmVzczogQWRkcmVzcywgYXNzZXQ6IHVpbnQ2NCk6IHsgdmFsaWQ6IGJvb2xlYW4sIGJhbGFuY2U6IHVpbnQ2NCB9IHsKICAgIGNhbGxzdWIgY2hlY2sKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZmluYWxpemVEaXN0cmlidXRpb25fcm91dGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDAKICAgIC8vIGZpbmFsaXplRGlzdHJpYnV0aW9uKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDAKICAgIC8vIGZpbmFsaXplRGlzdHJpYnV0aW9uKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIGNhbGxzdWIgZmluYWxpemVEaXN0cmlidXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGlzYnVyc2VSZXdhcmRzX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5OTcKICAgIC8vIGRpc2J1cnNlUmV3YXJkcyhyZXdhcmRJRDogdWludDY0LCBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTk3CiAgICAvLyBkaXNidXJzZVJld2FyZHMocmV3YXJkSUQ6IHVpbnQ2NCwgaXRlcmF0aW9uQW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIGNhbGxzdWIgZGlzYnVyc2VSZXdhcmRzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JhZmZsZV9yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU0CiAgICAvLyByYWZmbGUocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU0CiAgICAvLyByYWZmbGUocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgY2FsbHN1YiByYWZmbGUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc3RhcnREaXNidXJzZW1lbnRfcm91dGVAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzMAogICAgLy8gc3RhcnREaXNidXJzZW1lbnQocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTMwCiAgICAvLyBzdGFydERpc2J1cnNlbWVudChyZXdhcmRJRDogdWludDY0KTogdm9pZCB7CiAgICBjYWxsc3ViIHN0YXJ0RGlzYnVyc2VtZW50CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2VudGVyX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MjkKICAgIC8vIGVudGVyKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgZW50cmllczogU3Rha2VFbnRyeVtdLCBhcmdzOiBHYXRlQXJncyk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3LTEwMAogICAgLy8gZXhwb3J0IGNsYXNzIFBvb2wgZXh0ZW5kcyBjbGFzc2VzKAogICAgLy8gICBCYXNlUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRXNjcm93CiAgICAvLyApIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MjkKICAgIC8vIGVudGVyKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgZW50cmllczogU3Rha2VFbnRyeVtdLCBhcmdzOiBHYXRlQXJncyk6IHZvaWQgewogICAgY2FsbHN1YiBlbnRlcgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9maW5hbGl6ZV9yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzk5CiAgICAvLyBmaW5hbGl6ZShzaWdudXBUaW1lc3RhbXA6IHVpbnQ2NCwgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwgZW5kVGltZXN0YW1wOiB1aW50NjQpIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc5OQogICAgLy8gZmluYWxpemUoc2lnbnVwVGltZXN0YW1wOiB1aW50NjQsIHN0YXJ0VGltZXN0YW1wOiB1aW50NjQsIGVuZFRpbWVzdGFtcDogdWludDY0KSB7CiAgICBjYWxsc3ViIGZpbmFsaXplCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2FkZFJld2FyZEFzYV9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzgzCiAgICAvLyBhZGRSZXdhcmRBc2EocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldFhmZXI6IGd0eG4uQXNzZXRUcmFuc2ZlclR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgcHVzaGludCAyIC8vIDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgcHVzaGludCA0IC8vIGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgYXhmZXIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzgzCiAgICAvLyBhZGRSZXdhcmRBc2EocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldFhmZXI6IGd0eG4uQXNzZXRUcmFuc2ZlclR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIGNhbGxzdWIgYWRkUmV3YXJkQXNhCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2FkZFJld2FyZF9yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NjIKICAgIC8vIGFkZFJld2FyZChwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIHJld2FyZDogUmV3YXJkKTogdm9pZCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTctMTAwCiAgICAvLyBleHBvcnQgY2xhc3MgUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VQb29sLAogICAgLy8gICBBa2l0YUJhc2VFc2Nyb3cKICAgIC8vICkgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc2MgogICAgLy8gYWRkUmV3YXJkKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIGNhbGxzdWIgYWRkUmV3YXJkCiAgICBwb3AKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fb3B0aW5fcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzIyCiAgICAvLyBvcHRpbihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0OiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzIyCiAgICAvLyBvcHRpbihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0OiB1aW50NjQpOiB2b2lkIHsKICAgIGNhbGxzdWIgb3B0aW4KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVsZXRlX3JvdXRlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwOAogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5Ny0xMDAKICAgIC8vIGV4cG9ydCBjbGFzcyBQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVBvb2wsCiAgICAvLyAgIEFraXRhQmFzZUVzY3JvdwogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwOAogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgY2FsbHN1YiBkZWxldGUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdF9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTQKICAgIC8vIGluaXQoKSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgaW5pdAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY0CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTctMTAwCiAgICAvLyBleHBvcnQgY2xhc3MgUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VQb29sLAogICAgLy8gICBBa2l0YUJhc2VFc2Nyb3cKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY0CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgY2FsbHN1YiBjcmVhdGUKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjpfX3BjZzMyT3V0cHV0KHN0YXRlOiB1aW50NjQpIC0+IHVpbnQ2NDoKX19wY2czMk91dHB1dDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjMKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBfX3BjZzMyT3V0cHV0KHN0YXRlOiBQQ0czMlNUQVRFKTogdWludDY0IHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoyNAogICAgLy8gY29uc3QgeG9yc2hpZnRlZCA9IF9fbWFza1RvVWludDMyKG9wLnNocihvcC5zaHIoc3RhdGUsIDE4KSBeIHN0YXRlLCAyNykpCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgMTggLy8gMTgKICAgIHNocgogICAgZnJhbWVfZGlnIC0xCiAgICBeCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBzaHIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTMKICAgIC8vIHJldHVybiB2YWx1ZSAmIChvcC5zaGwoMSwgMzIpIC0gMSkKICAgIGludGMgOSAvLyA0Mjk0OTY3Mjk1CiAgICAmCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI1CiAgICAvLyBjb25zdCByb3QgPSBvcC5zaHIoc3RhdGUsIDU5KQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBzaHIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjYKICAgIC8vIHJldHVybiBvcC5zaHIoeG9yc2hpZnRlZCwgcm90KSB8IF9fbWFza1RvVWludDMyKG9wLnNobCh4b3JzaGlmdGVkLCBfX3VpbnQ2NFR3b3Mocm90KSAmIDMxKSkKICAgIGR1cDIKICAgIHNocgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyh+dmFsdWUsIDEpCiAgICBzd2FwCiAgICB+CiAgICBpbnRjXzEgLy8gMQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI2CiAgICAvLyByZXR1cm4gb3Auc2hyKHhvcnNoaWZ0ZWQsIHJvdCkgfCBfX21hc2tUb1VpbnQzMihvcC5zaGwoeG9yc2hpZnRlZCwgX191aW50NjRUd29zKHJvdCkgJiAzMSkpCiAgICBwdXNoaW50IDMxIC8vIDMxCiAgICAmCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIHNobAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxMwogICAgLy8gcmV0dXJuIHZhbHVlICYgKG9wLnNobCgxLCAzMikgLSAxKQogICAgaW50YyA5IC8vIDQyOTQ5NjcyOTUKICAgICYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjYKICAgIC8vIHJldHVybiBvcC5zaHIoeG9yc2hpZnRlZCwgcm90KSB8IF9fbWFza1RvVWludDMyKG9wLnNobCh4b3JzaGlmdGVkLCBfX3VpbnQ2NFR3b3Mocm90KSAmIDMxKSkKICAgIHwKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdldFdhbGxldElEVXNpbmdBa2l0YURBTyhha2l0YURBTzogdWludDY0LCBhZGRyZXNzOiBieXRlcykgLT4gdWludDY0OgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzMAogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIGdldFdhbGxldElEVXNpbmdBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24sIGFkZHJlc3M6IEFjY291bnQpOiBBcHBsaWNhdGlvbiB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIHJldHVybiBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQoYWtpdGFEQU8sIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0VzY3Jvd0ZhY3RvcnkpKVswXQogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoYnl0ZXMgImVzY3Jvd19mYWN0b3J5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMzYtMTQyCiAgICAvLyBjb25zdCBkYXRhID0gYWJpQ2FsbCgKICAgIC8vICAgRXNjcm93RmFjdG9yeUludGVyZmFjZS5wcm90b3R5cGUuZ2V0LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGVzY3Jvd0ZhY3RvcnksCiAgICAvLyAgICAgYXJnczogW25ldyBBZGRyZXNzKGFkZHJlc3MpXQogICAgLy8gICB9CiAgICAvLyApLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHg3OTM0NWFkYyAvLyBtZXRob2QgImdldChieXRlWzMyXSlieXRlW10iCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZXh0cmFjdCA2IDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNDQKICAgIC8vIGlmIChCeXRlcyhkYXRhKS5sZW5ndGggPT09IDAgfHwgQnl0ZXMoZGF0YSkubGVuZ3RoICE9PSA4KSB7CiAgICBsZW4KICAgIGR1cAogICAgYnogZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2lmX2JvZHlANgogICAgZnJhbWVfZGlnIDEKICAgIGludGNfMyAvLyA4CiAgICAhPQogICAgYnogZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2FmdGVyX2lmX2Vsc2VANwoKZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2lmX2JvZHlANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTQ1CiAgICAvLyByZXR1cm4gMAogICAgaW50Y18wIC8vIDAKCmdldFdhbGxldElEVXNpbmdBa2l0YURBT19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdldFdhbGxldElEQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzMgogICAgLy8gcmV0dXJuIEFwcGxpY2F0aW9uKGdldFdhbGxldElEKGVzY3Jvd0ZhY3RvcnksIGFkZHJlc3MpKQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmdldFdhbGxldElEVXNpbmdBa2l0YURBT19hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE0OAogICAgLy8gcmV0dXJuIGJ0b2koZGF0YSkKICAgIGZyYW1lX2RpZyAwCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzMgogICAgLy8gcmV0dXJuIEFwcGxpY2F0aW9uKGdldFdhbGxldElEKGVzY3Jvd0ZhY3RvcnksIGFkZHJlc3MpKQogICAgYiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJREA4CgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6Z2F0ZUNhbGwoYWtpdGFEQU86IHVpbnQ2NCwgY2FsbGVyOiBieXRlcywgaWQ6IHVpbnQ2NCwgYXJnczogYnl0ZXMpIC0+IHVpbnQ2NCwgYnl0ZXM6CmdhdGVDYWxsOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBnYXRlQ2FsbChha2l0YURBTzogQXBwbGljYXRpb24sIGNhbGxlcjogQWNjb3VudCwgaWQ6IHVpbnQ2NCwgYXJnczogR2F0ZUFyZ3MpOiBib29sZWFuIHsKICAgIHByb3RvIDQgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjItMTcyCiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgR2F0ZUludGVyZmFjZS5wcm90b3R5cGUuY2hlY2ssCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIG5ldyBBZGRyZXNzKGNhbGxlciksCiAgICAvLyAgICAgICBpZCwKICAgIC8vICAgICAgIGFyZ3MsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgZnJhbWVfZGlnIC00CiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY1CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY4CiAgICAvLyBpZCwKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjItMTcyCiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgR2F0ZUludGVyZmFjZS5wcm90b3R5cGUuY2hlY2ssCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIG5ldyBBZGRyZXNzKGNhbGxlciksCiAgICAvLyAgICAgICBpZCwKICAgIC8vICAgICAgIGFyZ3MsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4OWJiMWQwZGQgLy8gbWV0aG9kICJjaGVjayhieXRlWzMyXSx1aW50NjQsYnl0ZVtdW10pYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGZyYW1lX2RpZyAtMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5jaGVja0J5SUQoaWQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmNoZWNrQnlJRDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDY1CiAgICAvLyBwcml2YXRlIGNoZWNrQnlJRChpZDogdWludDY0KTogeyB2YWxpZDogYm9vbGVhbiwgYmFsYW5jZTogdWludDY0IH0gewogICAgcHJvdG8gMSAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAyCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDkKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAidHlwZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ2NwogICAgLy8gdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgYnl0ZWNfMiAvLyAweDAwCiAgICAhPQogICAgYm56IGNoZWNrQnlJRF9ib29sX3RydWVAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDkKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAidHlwZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ2NwogICAgLy8gdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgYnl0ZWMgNSAvLyAweDBhCiAgICAhPQogICAgYnogY2hlY2tCeUlEX2Jvb2xfZmFsc2VAMwoKY2hlY2tCeUlEX2Jvb2xfdHJ1ZUAyOgogICAgaW50Y18xIC8vIDEKCmNoZWNrQnlJRF9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ2Ni00NjkKICAgIC8vIGFzc2VydCgKICAgIC8vICAgdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgLy8gICBFUlJfSU5WQUxJRF9QT09MX1RZUEVfRk9SX0NIRUNLCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwb29sIHR5cGUgZm9yIGNoZWNrCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3MQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGFzc2V0LCBxdWFudGl0eSB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1MwogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyA4IC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NzEKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzLCBhc3NldCwgcXVhbnRpdHkgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGMgNCAvLyA0MDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCAzMgogICAgZnJhbWVfYnVyeSAwCiAgICBkaWcgMQogICAgZXh0cmFjdCAzMiA4CiAgICBmcmFtZV9idXJ5IDEKICAgIGRpZyAxCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAzCiAgICBzd2FwCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3MwogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYnogY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NzQKICAgIC8vIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgYmFsYW5jZTogMCB9CiAgICBieXRlYyAyOCAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOQogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFBvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJ0eXBlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDc3CiAgICAvLyBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUKSB7CiAgICBieXRlYyA5IC8vIDB4MTQKICAgID09CiAgICBieiBjaGVja0J5SURfZWxzZV9ib2R5QDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3OC00ODQKICAgIC8vIGNvbnN0IGNoZWNrID0gYWJpQ2FsbCgKICAgIC8vICAgU3Rha2luZ0ludGVyZmFjZS5wcm90b3R5cGUuc29mdENoZWNrLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICAvLyAgICAgYXJnczogW2FkZHJlc3MsIGFzc2V0XSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0ODEKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5zdGFraW5nLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDgxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NzgtNDg0CiAgICAvLyBjb25zdCBjaGVjayA9IGFiaUNhbGwoCiAgICAvLyAgIFN0YWtpbmdJbnRlcmZhY2UucHJvdG90eXBlLnNvZnRDaGVjaywKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5zdGFraW5nLAogICAgLy8gICAgIGFyZ3M6IFthZGRyZXNzLCBhc3NldF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDgzN2JlNDNlIC8vIG1ldGhvZCAic29mdENoZWNrKGJ5dGVbMzJdLHVpbnQ2NCkoYm9vbCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBwdXNoaW50IDUgLy8gNQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0ODYKICAgIC8vIGlmIChjaGVjay5iYWxhbmNlID49IHF1YW50aXR5KSB7CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2RpZyA0CiAgICA+PQogICAgYnogY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDg3CiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogY2hlY2suYmFsYW5jZSB9CiAgICBmcmFtZV9kaWcgNQogICAgaXRvYgogICAgYnl0ZWMgMTkgLy8gMHg4MAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjUwOQogICAgLy8gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZS5kaXNxdWFsaWZpZWQgPSB0cnVlCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50YyA0IC8vIDQwMAogICAgaW50Y18xIC8vIDEKICAgIHNldGJpdAogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgYmFsYW5jZTogMCB9CiAgICBieXRlYyAyOCAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNoZWNrQnlJRF9lbHNlX2JvZHlAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5MC01MDIKICAgIC8vIGNvbnN0IGluZm8gPSBhYmlDYWxsKAogICAgLy8gICBTdGFraW5nSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRJbmZvLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgYWRkcmVzcywKICAgIC8vICAgICAgIHsKICAgIC8vICAgICAgICAgYXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgICB9LAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDkzCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMyAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5MwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDk4CiAgICAvLyB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICBjYWxsc3ViIHN0YWtpbmdUeXBlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5Ni00OTkKICAgIC8vIHsKICAgIC8vICAgYXNzZXQ6IGFzc2V0LAogICAgLy8gICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyB9LAogICAgZnJhbWVfZGlnIDMKICAgIGl0b2IKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0OTAtNTAyCiAgICAvLyBjb25zdCBpbmZvID0gYWJpQ2FsbCgKICAgIC8vICAgU3Rha2luZ0ludGVyZmFjZS5wcm90b3R5cGUuZ2V0SW5mbywKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5zdGFraW5nLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIGFkZHJlc3MsCiAgICAvLyAgICAgICB7CiAgICAvLyAgICAgICAgIGFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgICAgdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgLy8gICAgICAgfSwKICAgIC8vICAgICBdLAogICAgLy8gICB9CiAgICAvLyApLnJldHVyblZhbHVlCiAgICBieXRlYyAyOSAvLyBtZXRob2QgImdldEluZm8oYnl0ZVszMl0sKHVpbnQ2NCx1aW50OCkpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBwdXNoaW50IDQgLy8gNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MDQKICAgIC8vIGlmIChpbmZvLmFtb3VudCA+PSBxdWFudGl0eSkgewogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBmcmFtZV9kaWcgNAogICAgPj0KICAgIGJ6IGNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjUwNQogICAgLy8gcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGJhbGFuY2U6IGluZm8uYW1vdW50IH0KICAgIGZyYW1lX2RpZyA2CiAgICBpdG9iCiAgICBieXRlYyAxOSAvLyAweDgwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjaGVja0J5SURfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgY2hlY2tCeUlEX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuc3Rha2luZ1R5cGUoKSAtPiBieXRlczoKc3Rha2luZ1R5cGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOQogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFBvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJ0eXBlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTIzCiAgICAvLyBhc3NlcnQodGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FLCAncG9vbCBzdGFraW5nIHR5cGUgaXMgbm90IHNldCcpCiAgICBkdXAKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgIT0KICAgIGFzc2VydCAvLyBwb29sIHN0YWtpbmcgdHlwZSBpcyBub3Qgc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjUyNAogICAgLy8gcmV0dXJuIG5ldyBVaW50OCh0aGlzLnR5cGUudmFsdWUubmF0aXZlIC0gMSkKICAgIGJ0b2kKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18zIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGRpc2J1cnNlbWVudElEOiB1aW50NjQsIGFzc2V0OiB1aW50NjQsIGFsbG9jYXRpb25zOiBieXRlcywgc3VtOiB1aW50NjQpIC0+IGJ5dGVzOgpjcmVhdGVSZXdhcmRBbGxvY2F0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTcyLTU3NwogICAgLy8gcHJpdmF0ZSBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucygKICAgIC8vICAgZGlzYnVyc2VtZW50SUQ6IHVpbnQ2NCwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwKICAgIC8vICAgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10sCiAgICAvLyAgIHN1bTogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHByb3RvIDQgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NzkKICAgIC8vIGNvbnN0IHJld2FyZHNBcHAgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5yZXdhcmRzKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTc5CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NTkKICAgIC8vIHJldHVybiAyNF85MDAgKiBhbGxvY2F0aW9ucy5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDI0OTAwIC8vIDI0OTAwCiAgICAqCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4MgogICAgLy8gaWYgKGFzc2V0ID09PSAwKSB7CiAgICBmcmFtZV9kaWcgLTMKICAgIGJueiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9uc19lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1ODQtNTk3CiAgICAvLyBhYmlDYWxsKAogICAgLy8gICBSZXdhcmRzSW50ZXJmYWNlLnByb3RvdHlwZS5jcmVhdGVVc2VyQWxsb2NhdGlvbnMsCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgICBhbW91bnQ6IG1ickFtb3VudCArIHN1bSwKICAgIC8vICAgICAgIH0pLAogICAgLy8gICAgICAgZGlzYnVyc2VtZW50SUQsCiAgICAvLyAgICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgICBdLAogICAgLy8gICB9CiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5MAogICAgLy8gcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1OTEKICAgIC8vIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTg5LTU5MgogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTg0LTU5NwogICAgLy8gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlVXNlckFsbG9jYXRpb25zLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5MwogICAgLy8gZGlzYnVyc2VtZW50SUQsCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTg0LTU5NwogICAgLy8gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlVXNlckFsbG9jYXRpb25zLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4MDk3OWE5MGMgLy8gbWV0aG9kICJjcmVhdGVVc2VyQWxsb2NhdGlvbnMocGF5LHVpbnQ2NCwoYnl0ZVszMl0sdWludDY0KVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIHJldHN1YgoKY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnNfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjYwMC02MTgKICAgIC8vIGFiaUNhbGwoCiAgICAvLyAgIFJld2FyZHNJbnRlcmZhY2UucHJvdG90eXBlLmNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucywKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgICAgfSksCiAgICAvLyAgICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2MDYKICAgIC8vIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2MDUtNjA4CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vIH0pLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2MDktNjEzCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2MTAKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjA5LTYxMwogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjYwMC02MTgKICAgIC8vIGFiaUNhbGwoCiAgICAvLyAgIFJld2FyZHNJbnRlcmZhY2UucHJvdG90eXBlLmNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucywKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgICAgfSksCiAgICAvLyAgICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjYxNAogICAgLy8gZGlzYnVyc2VtZW50SUQsCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjAwLTYxOAogICAgLy8gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vICAgICAgIH0pLAogICAgLy8gICAgICAgZGlzYnVyc2VtZW50SUQsCiAgICAvLyAgICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgICBdLAogICAgLy8gICB9CiAgICAvLyApCiAgICBwdXNoYnl0ZXMgMHg2ZjMxMzc5NiAvLyBtZXRob2QgImNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucyhwYXksYXhmZXIsdWludDY0LChieXRlWzMyXSx1aW50NjQpW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9uc19hZnRlcl9pZl9lbHNlQDEwCgoKLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5jcmVhdGUodGl0bGU6IGJ5dGVzLCB0eXBlOiBieXRlcywgY3JlYXRvcjogYnl0ZXMsIG1hcmtldHBsYWNlOiBieXRlcywgc3Rha2VLZXk6IGJ5dGVzLCBtaW5pbXVtU3Rha2VBbW91bnQ6IHVpbnQ2NCwgZ2F0ZUlEOiB1aW50NjQsIG1heEVudHJpZXM6IHVpbnQ2NCwgYWtpdGFEQU86IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NjQtNjc1CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgLy8gY3JlYXRlKAogICAgLy8gICB0aXRsZTogc3RyaW5nLAogICAgLy8gICB0eXBlOiBTdGFraW5nVHlwZSwKICAgIC8vICAgY3JlYXRvcjogQWRkcmVzcywKICAgIC8vICAgbWFya2V0cGxhY2U6IEFkZHJlc3MsCiAgICAvLyAgIHN0YWtlS2V5OiBSb290S2V5LAogICAgLy8gICBtaW5pbXVtU3Rha2VBbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIG1heEVudHJpZXM6IHVpbnQ2NCwKICAgIC8vICAgYWtpdGFEQU86IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBwcm90byA5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1CiAgICAvLyBzdGF0dXMgPSBHbG9iYWxTdGF0ZTxQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyAxMCAvLyAic3RhdHVzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NzYKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlID0gUG9vbFN0YXR1c0RyYWZ0CiAgICBieXRlY18yIC8vIDB4MDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNwogICAgLy8gdGl0bGUgPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUaXRsZSB9KQogICAgYnl0ZWMgMjMgLy8gInRpdGxlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NzcKICAgIC8vIHRoaXMudGl0bGUudmFsdWUgPSB0aXRsZQogICAgZnJhbWVfZGlnIC05CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDkKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA0IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NzgKICAgIC8vIHRoaXMudHlwZS52YWx1ZSA9IHR5cGUKICAgIGZyYW1lX2RpZyAtOAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGJ5dGVjIDExIC8vICJjcmVhdG9yIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NzkKICAgIC8vIHRoaXMuY3JlYXRvci52YWx1ZSA9IGNyZWF0b3IubmF0aXZlCiAgICBmcmFtZV9kaWcgLTcKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MAogICAgLy8gbWFya2V0cGxhY2UgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWFya2V0cGxhY2UgfSkKICAgIHB1c2hieXRlcyAibWFya2V0cGxhY2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4MAogICAgLy8gdGhpcy5tYXJrZXRwbGFjZS52YWx1ZSA9IG1hcmtldHBsYWNlLm5hdGl2ZQogICAgZnJhbWVfZGlnIC02CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzAKICAgIC8vIHN0YWtlS2V5ID0gR2xvYmFsU3RhdGU8Um9vdEtleT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YWtlS2V5IH0pCiAgICBieXRlYyAyMCAvLyAic3Rha2Vfa2V5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2ODIKICAgIC8vIHRoaXMuc3Rha2VLZXkudmFsdWUgPSBjbG9uZShzdGFrZUtleSkKICAgIGZyYW1lX2RpZyAtNQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBtaW5pbXVtU3Rha2VBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNaW5pbXVtU3Rha2VBbW91bnQgfSkKICAgIGJ5dGVjIDI0IC8vICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjgzCiAgICAvLyB0aGlzLm1pbmltdW1TdGFrZUFtb3VudC52YWx1ZSA9IG1pbmltdW1TdGFrZUFtb3VudAogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgNiAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg0CiAgICAvLyB0aGlzLmdhdGVJRC52YWx1ZSA9IGdhdGVJRAogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMyAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4NQogICAgLy8gdGhpcy5tYXhFbnRyaWVzLnZhbHVlID0gbWF4RW50cmllcwogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIHNhbHQgPSBHbG9iYWxTdGF0ZTxieXRlczwzMj4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTYWx0IH0pCiAgICBieXRlYyAzMCAvLyAic2FsdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg3CiAgICAvLyB0aGlzLnNhbHQudmFsdWUgPSBUeG4udHhJZAogICAgdHhuIFR4SUQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4OQogICAgLy8gY29uc3QgZmVlcyA9IGdldFN0YWtpbmdGZWVzKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgZHVwCiAgICBmcmFtZV9idXJ5IC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ5CiAgICAvLyBjb25zdCBbc3Rha2luZ0ZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNTdGFraW5nRmVlcykpCiAgICBwdXNoYnl0ZXMgInN0YWtpbmdfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjkwCiAgICAvLyBjb25zdCBpbXBhY3QgPSBnZXRVc2VySW1wYWN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgdGhpcy5jcmVhdG9yLnZhbHVlKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBmcmFtZV9idXJ5IC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gImNyZWF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMDItMTA4CiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgQWtpdGFTb2NpYWxJbXBhY3RJbnRlcmZhY2UucHJvdG90eXBlLmdldFVzZXJJbXBhY3QsCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5pbXBhY3QsCiAgICAvLyAgICAgYXJnczogW25ldyBBZGRyZXNzKGFjY291bnQpXQogICAgLy8gICB9CiAgICAvLyApLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGVjXzMgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMDUKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoYWtpdGFEQU8pLmltcGFjdCwKICAgIHB1c2hpbnQgMTA0IC8vIDEwNAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTAyLTEwOAogICAgLy8gcmV0dXJuIGFiaUNhbGwoCiAgICAvLyAgIEFraXRhU29jaWFsSW1wYWN0SW50ZXJmYWNlLnByb3RvdHlwZS5nZXRVc2VySW1wYWN0LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChha2l0YURBTykuaW1wYWN0LAogICAgLy8gICAgIGFyZ3M6IFtuZXcgQWRkcmVzcyhhY2NvdW50KV0KICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MGE1OTM3MGQgLy8gbWV0aG9kICJnZXRVc2VySW1wYWN0KGJ5dGVbMzJdKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTEKICAgIC8vIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlID0gaW1wYWN0UmFuZ2UoaW1wYWN0LCBmZWVzLmltcGFjdFRheE1pbiwgZmVlcy5pbXBhY3RUYXhNYXgpCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBjb3ZlciAyCiAgICBzd2FwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5NwogICAgLy8gY29uc3QgbWluSW1wYWN0OiB1aW50NjQgPSAoaW1wYWN0ID4gMSkgPyBpbXBhY3QgLSAxIDogMQogICAgaW50Y18xIC8vIDEKICAgID4KICAgIGJ6IGNyZWF0ZV90ZXJuYXJ5X2ZhbHNlQDcKICAgIGZyYW1lX2RpZyAwCiAgICBpbnRjXzEgLy8gMQogICAgLQoKY3JlYXRlX3Rlcm5hcnlfbWVyZ2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTgKICAgIC8vIHJldHVybiBtYXggLSAoKChtYXggLSBtaW4pICogbWluSW1wYWN0KSAvIElNUEFDVF9ESVZJU09SKQogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgZnJhbWVfZGlnIDEKICAgIC0KICAgIHVuY292ZXIgMgogICAgKgogICAgcHVzaGludCAxMDAwIC8vIDEwMDAKICAgIC8KICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ0CiAgICAvLyBha2l0YVJveWFsdHkgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHkgfSkKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTEKICAgIC8vIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlID0gaW1wYWN0UmFuZ2UoaW1wYWN0LCBmZWVzLmltcGFjdFRheE1pbiwgZmVlcy5pbXBhY3RUYXhNYXgpCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpjcmVhdGVfdGVybmFyeV9mYWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5NwogICAgLy8gY29uc3QgbWluSW1wYWN0OiB1aW50NjQgPSAoaW1wYWN0ID4gMSkgPyBpbXBhY3QgLSAxIDogMQogICAgaW50Y18xIC8vIDEKICAgIGIgY3JlYXRlX3Rlcm5hcnlfbWVyZ2VAOAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuaW5pdCgpIC0+IHZvaWQ6CmluaXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NQogICAgLy8gYXNzZXJ0KEdsb2JhbC5jYWxsZXJBcHBsaWNhdGlvbkFkZHJlc3MgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ29ubHkgdGhlIGZhY3RvcnkgY2FuIGluaXQgdGhlIHBvb2wnKQogICAgZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uQWRkcmVzcwogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGZhY3RvcnkgY2FuIGluaXQgdGhlIHBvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM0CiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJnYXRlX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk3CiAgICAvLyBpZiAodGhpcy5nYXRlSUQudmFsdWUgPiAwKSB7CiAgICBieiBpbml0X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTgtNzA0CiAgICAvLyB0aGlzLmdhdGVTaXplLnZhbHVlID0gYWJpQ2FsbCgKICAgIC8vICAgR2F0ZUludGVyZmFjZS5wcm90b3R5cGUuc2l6ZSwKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5nYXRlLAogICAgLy8gICAgIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzAxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuZ2F0ZSwKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMyAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwMQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLmdhdGUsCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImdhdGVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTgtNzA0CiAgICAvLyB0aGlzLmdhdGVTaXplLnZhbHVlID0gYWJpQ2FsbCgKICAgIC8vICAgR2F0ZUludGVyZmFjZS5wcm90b3R5cGUuc2l6ZSwKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5nYXRlLAogICAgLy8gICAgIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGRmNTZiMDFlIC8vIG1ldGhvZCAic2l6ZSh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzYKICAgIC8vIGdhdGVTaXplID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZVNpemUgfSkKICAgIHB1c2hieXRlcyAiZ2F0ZV9zaXplIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2OTgtNzA0CiAgICAvLyB0aGlzLmdhdGVTaXplLnZhbHVlID0gYWJpQ2FsbCgKICAgIC8vICAgR2F0ZUludGVyZmFjZS5wcm90b3R5cGUuc2l6ZSwKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5nYXRlLAogICAgLy8gICAgIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0Cgppbml0X2FmdGVyX2lmX2Vsc2VAMzoKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuZGVsZXRlKGNhbGxlcjogYnl0ZXMpIC0+IHZvaWQ6CmRlbGV0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA4LTcwOQogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgLy8gZGVsZXRlKGNhbGxlcjogQWRkcmVzcyk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcxMAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ2NhbGwgbXVzdCBjb21lIGZyb20gZmFjdG9yeScpCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gY2FsbCBtdXN0IGNvbWUgZnJvbSBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gImNyZWF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3MTEKICAgIC8vIGFzc2VydChjYWxsZXIubmF0aXZlID09PSB0aGlzLmNyZWF0b3IudmFsdWUsICdvbmx5IHRoZSBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHBvb2wnKQogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgcG9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDUKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFBvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAic3RhdHVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzEyCiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkJykKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgPT0KICAgIGJueiBkZWxldGVfYm9vbF90cnVlQDIKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyBlbmRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbmRUaW1lc3RhbXAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNCAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcxMgogICAgLy8gYXNzZXJ0KHRoaXMuc3RhdHVzLnZhbHVlID09PSBQb29sU3RhdHVzRHJhZnQgfHwgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBvciBlbmRlZCcpCiAgICA+CiAgICBieiBkZWxldGVfYm9vbF9mYWxzZUAzCgpkZWxldGVfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKZGVsZXRlX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzEyCiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkJykKICAgIGFzc2VydCAvLyB0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkCiAgICByZXRzdWIKCmRlbGV0ZV9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBkZWxldGVfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5vcHRpbihwYXltZW50OiB1aW50NjQsIGFzc2V0OiB1aW50NjQpIC0+IHZvaWQ6Cm9wdGluOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3MjIKICAgIC8vIG9wdGluKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXQ6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcyMwogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgRVJSX0ZPUkJJRERFTikKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiY3JlYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcyMwogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgRVJSX0ZPUkJJRERFTikKICAgID09CiAgICBhc3NlcnQgLy8gRm9yYmlkZGVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjcyNwogICAgLy8gY29uc3QgZGFvRXNjcm93TmVlZHNUb09wdEluID0gIUdsb2JhbC56ZXJvQWRkcmVzcy5pc09wdGVkSW4oQXNzZXQoYXNzZXQpKQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjczMQogICAgLy8gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogKAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjczMgogICAgLy8gZGFvRXNjcm93TmVlZHNUb09wdEluID8gNCA6IDEKICAgIGludGNfMSAvLyAxCiAgICBwdXNoaW50IDQgLy8gNAogICAgdW5jb3ZlciAzCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzMxLTczMwogICAgLy8gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogKAogICAgLy8gICBkYW9Fc2Nyb3dOZWVkc1RvT3B0SW4gPyA0IDogMQogICAgLy8gKQogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3MzgtNzQ1CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IG9wdGluTUJSICsgcmV3YXJkc01CUiwKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NDEKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjczOC03NDUKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzQyCiAgICAvLyBhbW91bnQ6IG9wdGluTUJSICsgcmV3YXJkc01CUiwKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3MzYKICAgIC8vIGNvbnN0IHJld2FyZHNNQlI6IHVpbnQ2NCA9IHRoaXMucmV3YXJkc01icihXaW5uZXJDb3VudENhcCkgKiAyCiAgICBwdXNoaW50IDgwMDAgLy8gODAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NDIKICAgIC8vIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3MzgtNzQ1CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IG9wdGluTUJSICsgcmV3YXJkc01CUiwKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0Ny03NTMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NDkKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzUwCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzQ3LTc1MgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzQ3LTc1MwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NTYKICAgIC8vIEFraXRhREFPRXNjcm93QWNjb3VudFN0YWtpbmdQb29scywKICAgIHB1c2hieXRlcyAic3Rha2luZ19wb29scyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzU1LTc1OQogICAgLy8gdGhpcy5vcHRBa2l0YUVzY3Jvd0luQW5kU2VuZCgKICAgIC8vICAgQWtpdGFEQU9Fc2Nyb3dBY2NvdW50U3Rha2luZ1Bvb2xzLAogICAgLy8gICBBc3NldChhc3NldCksCiAgICAvLyAgIDAKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NTgKICAgIC8vIDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc1NS03NTkKICAgIC8vIHRoaXMub3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmQoCiAgICAvLyAgIEFraXRhREFPRXNjcm93QWNjb3VudFN0YWtpbmdQb29scywKICAgIC8vICAgQXNzZXQoYXNzZXQpLAogICAgLy8gICAwCiAgICAvLyApCiAgICBjYWxsc3ViIG9wdEFraXRhRXNjcm93SW5BbmRTZW5kCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmFkZFJld2FyZChwYXltZW50OiB1aW50NjQsIHJld2FyZDogYnl0ZXMpIC0+IGJ5dGVzOgphZGRSZXdhcmQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc2MgogICAgLy8gYWRkUmV3YXJkKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIHByb3RvIDIgMQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NjMKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTEgLy8gImNyZWF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NjMKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICA9PQogICAgYXNzZXJ0IC8vIEZvcmJpZGRlbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NjQKICAgIC8vIGFzc2VydChyZXdhcmQuYXNzZXQgPT09IDAsIEVSUl9OT1RfQUxHTykKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAhCiAgICBhc3NlcnQgLy8gTXVzdCBiZSBhbiBBbGdvIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gc3Rha2VLZXkgPSBHbG9iYWxTdGF0ZTxSb290S2V5Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3Rha2VLZXkgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMCAvLyAic3Rha2Vfa2V5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjQxCiAgICAvLyB0aGlzLnN0YWtlS2V5LnZhbHVlLmFkZHJlc3MubmF0aXZlICE9PSBHbG9iYWwuemVyb0FkZHJlc3MgfHwgcmV3YXJkLmRpc3RyaWJ1dGlvbiAhPT0gRGlzdHJpYnV0aW9uVHlwZVBlcmNlbnRhZ2UsCiAgICBleHRyYWN0IDAgMzIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJueiBhZGRSZXdhcmRfYm9vbF90cnVlQDcKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCA4IDEKICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgIT0KICAgIGJ6IGFkZFJld2FyZF9ib29sX2ZhbHNlQDgKCmFkZFJld2FyZF9ib29sX3RydWVANzoKICAgIGludGNfMSAvLyAxCgphZGRSZXdhcmRfYm9vbF9tZXJnZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NDAtNjQzCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHRoaXMuc3Rha2VLZXkudmFsdWUuYWRkcmVzcy5uYXRpdmUgIT09IEdsb2JhbC56ZXJvQWRkcmVzcyB8fCByZXdhcmQuZGlzdHJpYnV0aW9uICE9PSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZSwKICAgIC8vICAgRVJSX1NUQUtFX0tFWV9SRVFVSVJFRAogICAgLy8gKQogICAgYXNzZXJ0IC8vIFN0YWtlIGtleSByZXF1aXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NDYKICAgIC8vIGlmIChyZXdhcmQuZGlzdHJpYnV0aW9uID09PSBEaXN0cmlidXRpb25UeXBlU2h1ZmZsZSkgewogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDggMQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIHB1c2hieXRlcyAweDI4CiAgICA9PQogICAgYnogYWRkUmV3YXJkX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjQ3CiAgICAvLyBhc3NlcnQocmV3YXJkLnJhdGUgPiByZXdhcmQud2lubmVyQ291bnQgJiYgcmV3YXJkLndpbm5lckNvdW50IDw9IFdpbm5lckNvdW50Q2FwLCBFUlJfUkFURV9NVVNUX0JFX0dSRUFURVJfVEhBTl9XSU5ORVJfQ09VTlQpCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgID4KICAgIGJ6IGFkZFJld2FyZF9ib29sX2ZhbHNlQDEzCiAgICBmcmFtZV9kaWcgMQogICAgcHVzaGludCAxMCAvLyAxMAogICAgPD0KICAgIGJ6IGFkZFJld2FyZF9ib29sX2ZhbHNlQDEzCiAgICBpbnRjXzEgLy8gMQoKYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY0NwogICAgLy8gYXNzZXJ0KHJld2FyZC5yYXRlID4gcmV3YXJkLndpbm5lckNvdW50ICYmIHJld2FyZC53aW5uZXJDb3VudCA8PSBXaW5uZXJDb3VudENhcCwgRVJSX1JBVEVfTVVTVF9CRV9HUkVBVEVSX1RIQU5fV0lOTkVSX0NPVU5UKQogICAgYXNzZXJ0IC8vIFJhdGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gd2lubmVyIGNvdW50CgphZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjUxCiAgICAvLyBpZiAocmV3YXJkLmRpc3RyaWJ1dGlvbiA9PT0gRGlzdHJpYnV0aW9uVHlwZUV2ZW4pIHsKICAgIGZyYW1lX2RpZyAwCiAgICBieXRlYyAxMiAvLyAweDFlCiAgICA9PQogICAgYnogYWRkUmV3YXJkX2FmdGVyX2lmX2Vsc2VAMjEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBtYXhFbnRyaWVzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWF4RW50cmllcyB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJtYXhfZW50cmllcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjY1MgogICAgLy8gYXNzZXJ0KHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCB8fCB0aGlzLm1heEVudHJpZXMudmFsdWUgPD0gcmV3YXJkLnJhdGUsIEVSUl9NQVhfRU5UUklFU19DQU5OT1RfQkVfR1JFQVRFUl9USEFOX1JBVEUpCiAgICBieiBhZGRSZXdhcmRfYm9vbF90cnVlQDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMyAvLyAibWF4X2VudHJpZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NTIKICAgIC8vIGFzc2VydCh0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAgfHwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIDw9IHJld2FyZC5yYXRlLCBFUlJfTUFYX0VOVFJJRVNfQ0FOTk9UX0JFX0dSRUFURVJfVEhBTl9SQVRFKQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDkgLy8gOQogICAgZXh0cmFjdF91aW50NjQKICAgIDw9CiAgICBieiBhZGRSZXdhcmRfYm9vbF9mYWxzZUAxOQoKYWRkUmV3YXJkX2Jvb2xfdHJ1ZUAxODoKICAgIGludGNfMSAvLyAxCgphZGRSZXdhcmRfYm9vbF9tZXJnZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NjUyCiAgICAvLyBhc3NlcnQodGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwIHx8IHRoaXMubWF4RW50cmllcy52YWx1ZSA8PSByZXdhcmQucmF0ZSwgRVJSX01BWF9FTlRSSUVTX0NBTk5PVF9CRV9HUkVBVEVSX1RIQU5fUkFURSkKICAgIGFzc2VydCAvLyBNYXggZW50cmllcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHJhdGUKCmFkZFJld2FyZF9hZnRlcl9pZl9lbHNlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2NTUKICAgIC8vIGFzc2VydChyZXdhcmQucmF0ZSA+IDAsIEVSUl9SQVRFX01VU1RfQkVfR1JFQVRFUl9USEFOX1pFUk8pCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgYXNzZXJ0IC8vIFJhdGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo3NjgtNzc3CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuRXE6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc3MQogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzY4LTc3NwogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbkVxOiB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc3MwogICAgLy8gZ3JlYXRlclRoYW5FcTogdGhpcy5yZXdhcmRzTWJyKHJld2FyZC53aW5uZXJDb3VudCkKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA0OSAvLyA0OQogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2Jhc2UudHM6OQogICAgLy8gcmV0dXJuIE1pblBvb2xSZXdhcmRzTUJSICsgKEJveENvc3RQZXJCeXRlICogd2lubmluZ1RpY2tldHMpCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc2OC03NzcKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW5FcTogdGhpcy5yZXdhcmRzTWJyKHJld2FyZC53aW5uZXJDb3VudCkKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID49CiAgICAmJgogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHJld2FyZElEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5UmV3YXJkQ291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyNSAvLyAicmV3YXJkX2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc0CiAgICAvLyB0aGlzLnJld2FyZElELnZhbHVlICs9IDEKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIzCiAgICAvLyByZXdhcmRJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVJld2FyZENvdW50IH0pCiAgICBieXRlYyAyNSAvLyAicmV3YXJkX2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNzQKICAgIC8vIHRoaXMucmV3YXJkSUQudmFsdWUgKz0gMQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzgwCiAgICAvLyB0aGlzLnJld2FyZHMoaWQpLnZhbHVlID0gY2xvbmUocmV3YXJkKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTkKICAgIC8vIHJld2FyZHMgPSBCb3hNYXA8dWludDY0LCBSZXdhcmQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4UmV3YXJkcyB9KQogICAgYnl0ZWMgMTUgLy8gInIiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzgwCiAgICAvLyB0aGlzLnJld2FyZHMoaWQpLnZhbHVlID0gY2xvbmUocmV3YXJkKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3B1dAogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKYWRkUmV3YXJkX2Jvb2xfZmFsc2VAMTk6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRSZXdhcmRfYm9vbF9tZXJnZUAyMAoKYWRkUmV3YXJkX2Jvb2xfZmFsc2VAMTM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRSZXdhcmRfYm9vbF9tZXJnZUAxNAoKYWRkUmV3YXJkX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGFkZFJld2FyZF9ib29sX21lcmdlQDkKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmFkZFJld2FyZEFzYShwYXltZW50OiB1aW50NjQsIGFzc2V0WGZlcjogdWludDY0LCByZXdhcmQ6IGJ5dGVzKSAtPiB2b2lkOgphZGRSZXdhcmRBc2E6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4MwogICAgLy8gYWRkUmV3YXJkQXNhKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXRYZmVyOiBndHhuLkFzc2V0VHJhbnNmZXJUeG4sIHJld2FyZDogUmV3YXJkKTogdm9pZCB7CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0LTc5NAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIGFzc2V0WGZlciwKICAgIC8vICAgewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIC8vICAgICBhc3NldEFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW46IDAKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1RSQU5TRkVSCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg3CiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4NC03OTQKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBhc3NldFhmZXIsCiAgICAvLyAgIHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IEFzc2V0KHJld2FyZC5hc3NldCksCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuOiAwCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9UUkFOU0ZFUgogICAgLy8gKQogICAgPT0KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4OAogICAgLy8geGZlckFzc2V0OiBBc3NldChyZXdhcmQuYXNzZXQpLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0LTc5NAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIGFzc2V0WGZlciwKICAgIC8vICAgewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIC8vICAgICBhc3NldEFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW46IDAKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1RSQU5TRkVSCiAgICAvLyApCiAgICA9PQogICAgJiYKICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NzkwCiAgICAvLyBncmVhdGVyVGhhbjogMAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0LTc5NAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIGFzc2V0WGZlciwKICAgIC8vICAgewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIC8vICAgICBhc3NldEFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW46IDAKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1RSQU5TRkVSCiAgICAvLyApCiAgICA+CiAgICAmJgogICAgYXNzZXJ0IC8vIEludmFsaWQgdHJhbnNmZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzk2CiAgICAvLyB0aGlzLmFkZFJld2FyZChwYXltZW50LCByZXdhcmQpCiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBhZGRSZXdhcmQKICAgIGZyYW1lX2J1cnkgLTEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuZmluYWxpemUoc2lnbnVwVGltZXN0YW1wOiB1aW50NjQsIHN0YXJ0VGltZXN0YW1wOiB1aW50NjQsIGVuZFRpbWVzdGFtcDogdWludDY0KSAtPiB2b2lkOgpmaW5hbGl6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzk5CiAgICAvLyBmaW5hbGl6ZShzaWdudXBUaW1lc3RhbXA6IHVpbnQ2NCwgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwgZW5kVGltZXN0YW1wOiB1aW50NjQpIHsKICAgIHByb3RvIDMgMAogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgJ29ubHkgdGhlIGNyZWF0b3IgY2FuIGZpbmFsaXplIHRoZSBwb29sJykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiY3JlYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgJ29ubHkgdGhlIGNyZWF0b3IgY2FuIGZpbmFsaXplIHRoZSBwb29sJykKICAgID09CiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciBjYW4gZmluYWxpemUgdGhlIHBvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1CiAgICAvLyBzdGF0dXMgPSBHbG9iYWxTdGF0ZTxQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTAgLy8gInN0YXR1cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMQogICAgLy8gYXNzZXJ0KHRoaXMuc3RhdHVzLnZhbHVlID09PSBQb29sU3RhdHVzRHJhZnQsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IHN0YXRlIHRvIGZpbmFsaXplJykKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgPT0KICAgIGFzc2VydCAvLyB0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IHN0YXRlIHRvIGZpbmFsaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMwogICAgLy8gc2lnbnVwVGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCB8fCAoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSksCiAgICBmcmFtZV9kaWcgLTMKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIGJueiBmaW5hbGl6ZV9ib29sX3RydWVAMwogICAgZnJhbWVfZGlnIC0zCiAgICBibnogZmluYWxpemVfYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gYWxsb3dMYXRlU2lnbnVwcyA9IEdsb2JhbFN0YXRlPGJvb2xlYW4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBbGxvd0xhdGVTaWdudXBzIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjIgLy8gImFsbG93X2xhdGVfc2lnbnVwcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMwogICAgLy8gc2lnbnVwVGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCB8fCAoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSksCiAgICBieiBmaW5hbGl6ZV9ib29sX2ZhbHNlQDQKCmZpbmFsaXplX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCmZpbmFsaXplX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAyLTgwNQogICAgLy8gYXNzZXJ0KAogICAgLy8gICBzaWdudXBUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIHx8IChzaWdudXBUaW1lc3RhbXAgPT09IDAgJiYgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKSwKICAgIC8vICAgJ3RoZSBzaWdudXAgcm91bmQgbXVzdCBiZSB6ZXJvIGFuZCBsYXRlIHNpZ24gdXBzIGFsbG93ZWQgb3IgaW4gdGhlIGZ1dHVyZScKICAgIC8vICkKICAgIGFzc2VydCAvLyB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgbGF0ZSBzaWduIHVwcyBhbGxvd2VkIG9yIGluIHRoZSBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA4LTgwOQogICAgLy8gc3RhcnRUaW1lc3RhbXAgPT09IDAgfHwKICAgIC8vIHN0YXJ0VGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGZyYW1lX2RpZyAtMgogICAgYnogZmluYWxpemVfYm9vbF90cnVlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA5CiAgICAvLyBzdGFydFRpbWVzdGFtcCA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICBmcmFtZV9kaWcgLTIKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA4LTgwOQogICAgLy8gc3RhcnRUaW1lc3RhbXAgPT09IDAgfHwKICAgIC8vIHN0YXJ0VGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGJ6IGZpbmFsaXplX2Jvb2xfZmFsc2VAOAoKZmluYWxpemVfYm9vbF90cnVlQDc6CiAgICBpbnRjXzEgLy8gMQoKZmluYWxpemVfYm9vbF9tZXJnZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MDctODExCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHN0YXJ0VGltZXN0YW1wID09PSAwIHx8CiAgICAvLyAgIHN0YXJ0VGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIC8vICAgJ3RoZSBzdGFydGluZyByb3VuZCBtdXN0IGJlIHplcm8gb3IgaW4gdGhlIGZ1dHVyZScKICAgIC8vICkKICAgIGFzc2VydCAvLyB0aGUgc3RhcnRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGluIHRoZSBmdXR1cmUKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxMwogICAgLy8gaWYgKHN0YXJ0VGltZXN0YW1wID09PSAwKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiBmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxNAogICAgLy8gYXNzZXJ0KHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUsICdpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlJykKICAgIGZyYW1lX2RpZyAtMwogICAgYm56IGZpbmFsaXplX2Jvb2xfZmFsc2VAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEzCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMiAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODE0CiAgICAvLyBhc3NlcnQoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSwgJ2lmIHRoZSBzdGFydGluZyByb3VuZCBpcyB6ZXJvLCB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgYWxsb3dMYXRlU2lnbnVwcyBtdXN0IGJlIHRydWUnKQogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUAxMwogICAgaW50Y18xIC8vIDEKCmZpbmFsaXplX2Jvb2xfbWVyZ2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxNAogICAgLy8gYXNzZXJ0KHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUsICdpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlJykKICAgIGFzc2VydCAvLyBpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxNQogICAgLy8gc3RhcnRUaW1lc3RhbXAgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgLTIKICAgIGZyYW1lX2J1cnkgMAoKZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IC0yCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxOQogICAgLy8gZW5kVGltZXN0YW1wID09PSAwIHx8IGVuZFRpbWVzdGFtcCA+IChzdGFydFRpbWVzdGFtcCArIDEwKSwKICAgIGZyYW1lX2RpZyAtMQogICAgYnogZmluYWxpemVfYm9vbF90cnVlQDE3CiAgICBmcmFtZV9kaWcgLTIKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgPAogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUAxOAoKZmluYWxpemVfYm9vbF90cnVlQDE3OgogICAgaW50Y18xIC8vIDEKCmZpbmFsaXplX2Jvb2xfbWVyZ2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxOC04MjEKICAgIC8vIGFzc2VydCgKICAgIC8vICAgZW5kVGltZXN0YW1wID09PSAwIHx8IGVuZFRpbWVzdGFtcCA+IChzdGFydFRpbWVzdGFtcCArIDEwKSwKICAgIC8vICAgJ3RoZSBlbmRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGFmdGVyIHRoZSBzdGFydGluZyByb3VuZCArIDEwJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHRoZSBlbmRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGFmdGVyIHRoZSBzdGFydGluZyByb3VuZCArIDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gc2lnbnVwVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U2lnbnVwVGltZXN0YW1wIH0pCiAgICBieXRlYyAyNiAvLyAic2lnbnVwX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODIzCiAgICAvLyB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSA9IHNpZ251cFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTUKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE2IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyNAogICAgLy8gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSA9IHN0YXJ0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBieXRlYyAxNCAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODI1CiAgICAvLyB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSA9IGVuZFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDUKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFBvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDEwIC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyNgogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgPSBQb29sU3RhdHVzRmluYWwKICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKZmluYWxpemVfYm9vbF9mYWxzZUAxODoKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VAMTkKCmZpbmFsaXplX2Jvb2xfZmFsc2VAMTM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBmaW5hbGl6ZV9ib29sX21lcmdlQDE0CgpmaW5hbGl6ZV9ib29sX2ZhbHNlQDg6CiAgICBpbnRjXzAgLy8gMAogICAgYiBmaW5hbGl6ZV9ib29sX21lcmdlQDkKCmZpbmFsaXplX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuZW50ZXIocGF5bWVudDogdWludDY0LCBlbnRyaWVzOiBieXRlcywgYXJnczogYnl0ZXMpIC0+IHZvaWQ6CmVudGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MjkKICAgIC8vIGVudGVyKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgZW50cmllczogU3Rha2VFbnRyeVtdLCBhcmdzOiBHYXRlQXJncyk6IHZvaWQgewogICAgcHJvdG8gMyAwCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAzCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MzEKICAgIC8vIGFzc2VydCh0aGlzLmlzTGl2ZSgpLCAndGhlIHBvb2wgaXMgbm90IGxpdmUnKQogICAgY2FsbHN1YiBpc0xpdmUKICAgIGFzc2VydCAvLyB0aGUgcG9vbCBpcyBub3QgbGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImdhdGVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzMwogICAgLy8gaWYgKHRoaXMuZ2F0ZUlELnZhbHVlICE9PSAwKSB7CiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODM0CiAgICAvLyBjb25zdCB3YWxsZXQgPSBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBUeG4uc2VuZGVyKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICB0eG4gU2VuZGVyCiAgICBjYWxsc3ViIGdldFdhbGxldElEVXNpbmdBa2l0YURBTwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjExOQogICAgLy8gcmV0dXJuIG9yaWdpbk9yKHdhbGxldElELCBUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjExMgogICAgLy8gaWYgKHdhbGxldElELmlkID09PSAwKSB7CiAgICBibnogZW50ZXJfYWZ0ZXJfaWZfZWxzZUAyNQogICAgZnJhbWVfZGlnIDMKCmVudGVyX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6b3JpZ2luT3JAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzNwogICAgLy8gZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBhcmdzKSwKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImdhdGVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4MzcKICAgIC8vIGdhdGVDYWxsKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgb3JpZ2luLCB0aGlzLmdhdGVJRC52YWx1ZSwgYXJncyksCiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZ2F0ZUNhbGwKICAgIGZyYW1lX2J1cnkgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODM2LTgzOQogICAgLy8gYXNzZXJ0KAogICAgLy8gICBnYXRlQ2FsbChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQsIG9yaWdpbiwgdGhpcy5nYXRlSUQudmFsdWUsIGFyZ3MpLAogICAgLy8gICAndXNlciBkb2VzIG5vdCBtZWV0IGdhdGUgcmVxdWlyZW1lbnRzJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHVzZXIgZG9lcyBub3QgbWVldCBnYXRlIHJlcXVpcmVtZW50cwogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDExCgplbnRlcl9hZnRlcl9pZl9lbHNlQDI6CiAgICBmcmFtZV9kaWcgMTEKICAgIGZyYW1lX2J1cnkgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODQzCiAgICAvLyAodGhpcy5lbnRyeUlELnZhbHVlICsgMSkgPCB0aGlzLm1heEVudHJpZXMudmFsdWUgfHwKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMyAvLyAibWF4X2VudHJpZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NDMKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NDMtODQ0CiAgICAvLyAodGhpcy5lbnRyeUlELnZhbHVlICsgMSkgPCB0aGlzLm1heEVudHJpZXMudmFsdWUgfHwKICAgIC8vIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIGJueiBlbnRlcl9ib29sX3RydWVANAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTMgLy8gIm1heF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODQzLTg0NAogICAgLy8gKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpIDwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIHx8CiAgICAvLyB0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAsCiAgICBibnogZW50ZXJfYm9vbF9mYWxzZUA1CgplbnRlcl9ib29sX3RydWVANDoKICAgIGludGNfMSAvLyAxCgplbnRlcl9ib29sX21lcmdlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0Mi04NDYKICAgIC8vIGFzc2VydCgKICAgIC8vICAgKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpIDwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIHx8CiAgICAvLyAgIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIC8vICAgJ3Bvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHBvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1MAogICAgLy8gbGV0IHRvdGFsOiB1aW50NjQgPSBlbnRyeU1CUiAqIGVudHJpZXMubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDQKICAgIHB1c2hpbnQgNTA2MDAgLy8gNTA2MDAKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NQogICAgLy8gdW5pcXVlcyA9IEJveE1hcDxBY2NvdW50LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sR2xvYmFsU3RhdGVLZXlVbmlxdWVzIH0pCiAgICBwdXNoYnl0ZXMgInUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1MQogICAgLy8gaWYgKCF0aGlzLnVuaXF1ZXMoVHhuLnNlbmRlcikuZXhpc3RzKSB7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NQogICAgLy8gdW5pcXVlcyA9IEJveE1hcDxBY2NvdW50LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sR2xvYmFsU3RhdGVLZXlVbmlxdWVzIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODUxCiAgICAvLyBpZiAoIXRoaXMudW5pcXVlcyhUeG4uc2VuZGVyKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgc3dhcAogICAgZnJhbWVfYnVyeSA4CiAgICBibnogZW50ZXJfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1MgogICAgLy8gdG90YWwgKz0gUG9vbFVuaXF1ZXNNQlIKICAgIGZyYW1lX2RpZyA3CiAgICBwdXNoaW50IDE4OTAwIC8vIDE4OTAwCiAgICArCiAgICBmcmFtZV9idXJ5IDgKCmVudGVyX2FmdGVyX2lmX2Vsc2VAODoKICAgIGZyYW1lX2RpZyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1NS04NjIKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdG90YWwsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODU4CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NTUtODYyCiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRvdGFsLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBBbW91bnQKICAgIHVuY292ZXIgMgogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gc3Rha2VLZXkgPSBHbG9iYWxTdGF0ZTxSb290S2V5Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3Rha2VLZXkgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMCAvLyAic3Rha2Vfa2V5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICBmcmFtZV9idXJ5IDAKICAgIGR1cAogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICBsZW4KICAgIHN1YnN0cmluZzMKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NjYKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA2CgplbnRlcl93aGlsZV90b3BAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODY2CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykgewogICAgZnJhbWVfZGlnIDYKICAgIGZyYW1lX2RpZyA0CiAgICA8CiAgICBieiBlbnRlcl9hZnRlcl93aGlsZUAyMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NjcKICAgIC8vIGFzc2VydChlbnRyaWVzW2ldLnF1YW50aXR5ID49IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLCAncXVhbnRpdHkgaXMgbGVzcyB0aGFuIG1pbmltdW0gc3Rha2UgYW1vdW50JykKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyA2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAqCiAgICBkaWcgMQogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBmcmFtZV9kaWcgNAogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIG1pbmltdW1TdGFrZUFtb3VudCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1pbmltdW1TdGFrZUFtb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDI0IC8vICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg2NwogICAgLy8gYXNzZXJ0KGVudHJpZXNbaV0ucXVhbnRpdHkgPj0gdGhpcy5taW5pbXVtU3Rha2VBbW91bnQudmFsdWUsICdxdWFudGl0eSBpcyBsZXNzIHRoYW4gbWluaW11bSBzdGFrZSBhbW91bnQnKQogICAgPj0KICAgIGFzc2VydCAvLyBxdWFudGl0eSBpcyBsZXNzIHRoYW4gbWluaW11bSBzdGFrZSBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODY5CiAgICAvLyBpZiAoYWRkcmVzcy5uYXRpdmUgIT09IEdsb2JhbC56ZXJvQWRkcmVzcykgewogICAgZnJhbWVfZGlnIDAKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IGVudGVyX2FmdGVyX2lmX2Vsc2VAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODcwLTg4MgogICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhYmlDYWxsKAogICAgLy8gICBNZXRhTWVya2xlc0ludGVyZmFjZS5wcm90b3R5cGUudmVyaWZ5LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLm1ldGFNZXJrbGVzLAogICAgLy8gICAgIGFyZ3M6IFsKICAgIC8vICAgICAgIGFkZHJlc3MsCiAgICAvLyAgICAgICBuYW1lLAogICAgLy8gICAgICAgc2hhMjU2KHNoYTI1NihpdG9iKGVudHJpZXNbaV0uYXNzZXQpKSksCiAgICAvLyAgICAgICBlbnRyaWVzW2ldLnByb29mLAogICAgLy8gICAgICAgTUVSS0xFX1RSRUVfVFlQRV9BU1NFVCwKICAgIC8vICAgICBdLAogICAgLy8gICB9CiAgICAvLyApLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3MwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLm1ldGFNZXJrbGVzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODczCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkubWV0YU1lcmtsZXMsCiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NzcKICAgIC8vIHNoYTI1NihzaGEyNTYoaXRvYihlbnRyaWVzW2ldLmFzc2V0KSkpLAogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdG9iCiAgICBzaGEyNTYKICAgIHNoYTI1NgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NzgKICAgIC8vIGVudHJpZXNbaV0ucHJvb2YsCiAgICBkaWcgMQogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyCiAgICBsZW4KICAgIHVuY292ZXIgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NzkKICAgIC8vIE1FUktMRV9UUkVFX1RZUEVfQVNTRVQsCiAgICBpbnRjXzEgLy8gMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4NzAtODgyCiAgICAvLyBjb25zdCB2ZXJpZmllZCA9IGFiaUNhbGwoCiAgICAvLyAgIE1ldGFNZXJrbGVzSW50ZXJmYWNlLnByb3RvdHlwZS52ZXJpZnksCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkubWV0YU1lcmtsZXMsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgYWRkcmVzcywKICAgIC8vICAgICAgIG5hbWUsCiAgICAvLyAgICAgICBzaGEyNTYoc2hhMjU2KGl0b2IoZW50cmllc1tpXS5hc3NldCkpKSwKICAgIC8vICAgICAgIGVudHJpZXNbaV0ucHJvb2YsCiAgICAvLyAgICAgICBNRVJLTEVfVFJFRV9UWVBFX0FTU0VULAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGM5NDg5NjliIC8vIG1ldGhvZCAidmVyaWZ5KGJ5dGVbMzJdLHN0cmluZyxieXRlWzMyXSxieXRlWzMyXVtdLHVpbnQ2NClib29sIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4NAogICAgLy8gYXNzZXJ0KHZlcmlmaWVkLCAnZmFpbGVkIHRvIHZlcmlmeSBzdGFrZSByZXF1aXJlbWVudHMnKQogICAgYXNzZXJ0IC8vIGZhaWxlZCB0byB2ZXJpZnkgc3Rha2UgcmVxdWlyZW1lbnRzCgplbnRlcl9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDkKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAidHlwZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4OQogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQgfHwKICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODg5LTg5MAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQgfHwKICAgIC8vIHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfU09GVAogICAgYm56IGVudGVyX2lmX2JvZHlAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8UG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gInR5cGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4OTAKICAgIC8vIHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfU09GVAogICAgYnl0ZWMgOSAvLyAweDE0CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4ODktODkwCiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDIwCgplbnRlcl9pZl9ib2R5QDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4OTIKICAgIC8vIGNvbnN0IFtiYWxhbmNlLCBvcHRlZEluXSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2UoVHhuLnNlbmRlciwgZW50cmllc1tpXS5hc3NldCkKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgc3dhcAogICAgZnJhbWVfYnVyeSA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5MwogICAgLy8gYXNzZXJ0KG9wdGVkSW4gJiYgYmFsYW5jZSA+PSBlbnRyaWVzW2ldLnF1YW50aXR5LCAndXNlciBkb2VzIG5vdCBoYXZlIG1pbiBiYWxhbmNlJykKICAgIGJ6IGVudGVyX2Jvb2xfZmFsc2VAMTgKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgOQogICAgPj0KICAgIGJ6IGVudGVyX2Jvb2xfZmFsc2VAMTgKICAgIGludGNfMSAvLyAxCgplbnRlcl9ib29sX21lcmdlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4OTMKICAgIC8vIGFzc2VydChvcHRlZEluICYmIGJhbGFuY2UgPj0gZW50cmllc1tpXS5xdWFudGl0eSwgJ3VzZXIgZG9lcyBub3QgaGF2ZSBtaW4gYmFsYW5jZScpCiAgICBhc3NlcnQgLy8gdXNlciBkb2VzIG5vdCBoYXZlIG1pbiBiYWxhbmNlCgplbnRlcl9hZnRlcl9pZl9lbHNlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo4OTYtOTA4CiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSBhYmlDYWxsKAogICAgLy8gICBTdGFraW5nSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRJbmZvLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgbmV3IEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgICB7CiAgICAvLyAgICAgICAgIGFzc2V0OiBlbnRyaWVzW2ldLmFzc2V0LAogICAgLy8gICAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgICB9LAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk5CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMyAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5OQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTAxCiAgICAvLyBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTAzCiAgICAvLyBhc3NldDogZW50cmllc1tpXS5hc3NldCwKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTA0CiAgICAvLyB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICBjYWxsc3ViIHN0YWtpbmdUeXBlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkwMi05MDUKICAgIC8vIHsKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgIHR5cGU6IHRoaXMuc3Rha2luZ1R5cGUoKSwKICAgIC8vIH0sCiAgICBzd2FwCiAgICBpdG9iCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5Ni05MDgKICAgIC8vIGNvbnN0IHN0YWtlSW5mbyA9IGFiaUNhbGwoCiAgICAvLyAgIFN0YWtpbmdJbnRlcmZhY2UucHJvdG90eXBlLmdldEluZm8sCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICAgIHsKICAgIC8vICAgICAgICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgICAgICAgIHR5cGU6IHRoaXMuc3Rha2luZ1R5cGUoKSwKICAgIC8vICAgICAgIH0sCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgYnl0ZWMgMjkgLy8gbWV0aG9kICJnZXRJbmZvKGJ5dGVbMzJdLCh1aW50NjQsdWludDgpKSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18yIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIHB1c2hpbnQgNCAvLyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkxMAogICAgLy8gYXNzZXJ0KHN0YWtlSW5mby5hbW91bnQgPj0gZW50cmllc1tpXS5xdWFudGl0eSwgJ3VzZXIgZG9lcyBub3QgaGF2ZSBlbm91Z2ggc3Rha2VkJykKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgOQogICAgZHVwCiAgICBjb3ZlciAyCiAgICA+PQogICAgYXNzZXJ0IC8vIHVzZXIgZG9lcyBub3QgaGF2ZSBlbm91Z2ggc3Rha2VkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2OAogICAgLy8gdGhpcy5lbnRyeUlELnZhbHVlICs9IDEKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2OAogICAgLy8gdGhpcy5lbnRyeUlELnZhbHVlICs9IDEKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkxNAogICAgLy8gYWRkcmVzczogbmV3IEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkxMy05MTkKICAgIC8vIHRoaXMuZW50cmllcyhlbnRyeUlEKS52YWx1ZSA9IHsKICAgIC8vICAgYWRkcmVzczogbmV3IEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgIGFzc2V0OiBlbnRyaWVzW2ldLmFzc2V0LAogICAgLy8gICBxdWFudGl0eTogZW50cmllc1tpXS5xdWFudGl0eSwKICAgIC8vICAgZ2F0ZUFyZ3M6IGNsb25lKGFyZ3MpLAogICAgLy8gICBkaXNxdWFsaWZpZWQ6IGZhbHNlCiAgICAvLyB9CiAgICBkaWcgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAzMzAwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkxMwogICAgLy8gdGhpcy5lbnRyaWVzKGVudHJ5SUQpLnZhbHVlID0gewogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgOCAvLyAiZSIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTEzLTkxOQogICAgLy8gdGhpcy5lbnRyaWVzKGVudHJ5SUQpLnZhbHVlID0gewogICAgLy8gICBhZGRyZXNzOiBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgIHF1YW50aXR5OiBlbnRyaWVzW2ldLnF1YW50aXR5LAogICAgLy8gICBnYXRlQXJnczogY2xvbmUoYXJncyksCiAgICAvLyAgIGRpc3F1YWxpZmllZDogZmFsc2UKICAgIC8vIH0KICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICB1bmNvdmVyIDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTIyCiAgICAvLyBhZGRyZXNzOiBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTIxLTkyNAogICAgLy8gY29uc3QgYUtleSA9IHsKICAgIC8vICAgYWRkcmVzczogbmV3IEFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgIGFzc2V0OiBlbnRyaWVzW2ldLmFzc2V0LAogICAgLy8gfQogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTI2CiAgICAvLyB0aGlzLmVudHJpZXNCeUFkZHJlc3MoYUtleSkudmFsdWUgPSBlbnRyeUlECiAgICBkdXAKICAgIGV4dHJhY3QgMCAzMgogICAgc3dhcAogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTcKICAgIC8vIGVudHJpZXNCeUFkZHJlc3MgPSBCb3hNYXA8RW50cnlLZXksIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzQnlBZGRyZXNzIH0pCiAgICBwdXNoYnl0ZXMgImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTI2CiAgICAvLyB0aGlzLmVudHJpZXNCeUFkZHJlc3MoYUtleSkudmFsdWUgPSBlbnRyeUlECiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIGVudGVyX3doaWxlX3RvcEA5CgplbnRlcl9ib29sX2ZhbHNlQDE4OgogICAgaW50Y18wIC8vIDAKICAgIGIgZW50ZXJfYm9vbF9tZXJnZUAxOQoKZW50ZXJfYWZ0ZXJfd2hpbGVAMjI6CiAgICByZXRzdWIKCmVudGVyX2Jvb2xfZmFsc2VANToKICAgIGludGNfMCAvLyAwCiAgICBiIGVudGVyX2Jvb2xfbWVyZ2VANgoKZW50ZXJfYWZ0ZXJfaWZfZWxzZUAyNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIzLTEyNgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGZyYW1lX2RpZyAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjUKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgMzEgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIzLTEyNgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTE5CiAgICAvLyByZXR1cm4gb3JpZ2luT3Iod2FsbGV0SUQsIFR4bi5zZW5kZXIpCiAgICBiIGVudGVyX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6b3JpZ2luT3JAMjYKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLnN0YXJ0RGlzYnVyc2VtZW50KHJld2FyZElEOiB1aW50NjQpIC0+IHZvaWQ6CnN0YXJ0RGlzYnVyc2VtZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5MzAKICAgIC8vIHN0YXJ0RGlzYnVyc2VtZW50KHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5MzEKICAgIC8vIGFzc2VydCh0aGlzLmlzTGl2ZSgpLCAndGhlIHBvb2wgaXMgbm90IGxpdmUnKQogICAgY2FsbHN1YiBpc0xpdmUKICAgIGFzc2VydCAvLyB0aGUgcG9vbCBpcyBub3QgbGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5MzIKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU5CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDE1IC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTMyCiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRzKHJld2FyZElEKS5leGlzdHMsICdyZXdhcmQgZG9lcyBub3QgZXhpc3QnKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gcmV3YXJkIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzNAogICAgLy8gY29uc3QgeyBwaGFzZSwgaW50ZXJ2YWwsIGxhc3REaXNidXJzZW1lbnRUaW1lc3RhbXAsIGV4cGlyYXRpb24gfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGJveF9nZXQKICAgIHBvcAogICAgZHVwCiAgICBleHRyYWN0IDkxIDEKICAgIGRpZyAxCiAgICBwdXNoaW50IDI1IC8vIDI1CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDIKICAgIHB1c2hpbnQgMTE2IC8vIDExNgogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDMKICAgIHVuY292ZXIgMgogICAgcHVzaGludCAxNyAvLyAxNwogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTM2CiAgICAvLyBhc3NlcnQocGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlSWRsZSwgJ3Jld2FyZCBpcyBhbHJlYWR5IGluIGEgZGlzYnVyc2VtZW50IHBoYXNlJykKICAgIHN3YXAKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgPT0KICAgIGFzc2VydCAvLyByZXdhcmQgaXMgYWxyZWFkeSBpbiBhIGRpc2J1cnNlbWVudCBwaGFzZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MTQKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gKChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJSBpbnRlcnZhbCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTUKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNiAvLyAic3RhcnRfdGltZXN0YW1wIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTE0CiAgICAvLyByZXR1cm4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtICgoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICUgaW50ZXJ2YWwpCiAgICAtCiAgICB1bmNvdmVyIDIKICAgICUKICAgIC0KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MTkKICAgIC8vIHJldHVybiBsYXRlc3RXaW5kb3dTdGFydCAhPT0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAmJiBsYXN0IDwgbGF0ZXN0V2luZG93U3RhcnQKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgICE9CiAgICBieiBzdGFydERpc2J1cnNlbWVudF9ib29sX2ZhbHNlQDQKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMwogICAgPAogICAgYnogc3RhcnREaXNidXJzZW1lbnRfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKc3RhcnREaXNidXJzZW1lbnRfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5MzcKICAgIC8vIGFzc2VydCh0aGlzLnZhbGlkV2luZG93KGludGVydmFsLCBsYXN0RGlzYnVyc2VtZW50VGltZXN0YW1wKSwgJ2Rpc3RyaWJ1dGlvbiB3aW5kb3cgaXMgbm90IG9wZW4nKQogICAgYXNzZXJ0IC8vIGRpc3RyaWJ1dGlvbiB3aW5kb3cgaXMgbm90IG9wZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjMgLy8gInRpdGxlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQwCiAgICAvLyBgJHt0aGlzLnRpdGxlLnZhbHVlfSAtIFJld2FyZHNgLAogICAgcHVzaGJ5dGVzICIgLSBSZXdhcmRzIgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MQogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQyCiAgICAvLyBHbG9iYWwubGF0ZXN0VGltZXN0YW1wICsgZXhwaXJhdGlvbgogICAgZHVwCiAgICBmcmFtZV9kaWcgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NDkKICAgIC8vIGNvbnN0IHJld2FyZHNBcHAgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5yZXdhcmRzKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ5CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NTAKICAgIC8vIGNvbnN0IHJld2FyZE1CUjogdWludDY0ID0gTWluRGlzYnVyc2VtZW50c01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIEJ5dGVzKHRpdGxlKS5sZW5ndGgpCiAgICBkaWcgMwogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICBkaWcgMQogICAgKgogICAgcHVzaGludCAzNTMwMCAvLyAzNTMwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NTMKICAgIC8vIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICBkaWcgMgogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NTctNTY5CiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICAgIHRpdGxlLAogICAgLy8gICAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAgICcnLAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU1Mi01NTUKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHJld2FyZE1CUiwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU1Ny01NjkKICAgIC8vIHJldHVybiBhYmlDYWxsKAogICAgLy8gICBSZXdhcmRzSW50ZXJmYWNlLnByb3RvdHlwZS5jcmVhdGVEaXNidXJzZW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICBtYnJQYXltZW50LAogICAgLy8gICAgICAgdGl0bGUsCiAgICAvLyAgICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgICBleHBpcmF0aW9uLAogICAgLy8gICAgICAgJycsCiAgICAvLyAgICAgXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU2MwogICAgLy8gdGl0bGUsCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTY0CiAgICAvLyB0aW1lVG9VbmxvY2ssCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTY1CiAgICAvLyBleHBpcmF0aW9uLAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU2NgogICAgLy8gJycsCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NTctNTY5CiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICAgIHRpdGxlLAogICAgLy8gICAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAgICcnLAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDFjOWViYmRiIC8vIG1ldGhvZCAiY3JlYXRlRGlzYnVyc2VtZW50KHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjU2NgogICAgLy8gJycsCiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1NTctNTY5CiAgICAvLyByZXR1cm4gYWJpQ2FsbCgKICAgIC8vICAgUmV3YXJkc0ludGVyZmFjZS5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICAgIHRpdGxlLAogICAgLy8gICAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAgICcnLAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NDUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2VycyA9IDAKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMwogICAgcmVwbGFjZTIgMzMKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQ2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlID0gMAogICAgZGlnIDMKICAgIHJlcGxhY2UyIDQxCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0NwogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24KICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgcmVwbGFjZTIgOTEKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQ4CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIHVuY292ZXIgMwogICAgcmVwbGFjZTIgOTIKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQ5CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmFjdGl2ZURpc2J1cnNlbWVudElEID0gZGlzYnVyc2VtZW50SUQKICAgIHVuY292ZXIgMgogICAgcmVwbGFjZTIgMTAwCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ID0gR2xvYmFsLnJvdW5kCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIHJlcGxhY2UyIDEwOAogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NTEKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUubGFzdERpc2J1cnNlbWVudFRpbWVzdGFtcCA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIHJlcGxhY2UyIDExNgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpzdGFydERpc2J1cnNlbWVudF9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzdGFydERpc2J1cnNlbWVudF9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLnJhZmZsZShyZXdhcmRJRDogdWludDY0KSAtPiB2b2lkOgpyYWZmbGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1NAogICAgLy8gcmFmZmxlKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHByb3RvIDEgMAogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gMwogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU1CiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRzKHJld2FyZElEKS5leGlzdHMsICdyZXdhcmQgZG9lcyBub3QgZXhpc3QnKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1OQogICAgLy8gcmV3YXJkcyA9IEJveE1hcDx1aW50NjQsIFJld2FyZD4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhSZXdhcmRzIH0pCiAgICBieXRlYyAxNSAvLyAiciIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1NQogICAgLy8gYXNzZXJ0KHRoaXMucmV3YXJkcyhyZXdhcmRJRCkuZXhpc3RzLCAncmV3YXJkIGRvZXMgbm90IGV4aXN0JykKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHJld2FyZCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NjIKICAgIC8vIH0gPSBjbG9uZSh0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlKQogICAgYm94X2dldAogICAgcG9wCiAgICBkdXAKICAgIGV4dHJhY3QgOTEgMQogICAgZGlnIDEKICAgIHB1c2hpbnQgNTcgLy8gNTcKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgbGVuCiAgICBkaWcgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgZGlnIDIKICAgIHB1c2hpbnQgMTA4IC8vIDEwOAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAzCiAgICBwdXNoaW50IDgzIC8vIDgzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciA0CiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NjQKICAgIC8vIGFzc2VydChwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLCBFUlJfSU5WQUxJRF9ESVNCVVJTRU1FTlRfUEhBU0UpCiAgICB1bmNvdmVyIDMKICAgIGJ5dGVjIDkgLy8gMHgxNAogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGRpc2J1cnNlbWVudCBwaGFzZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NjUKICAgIC8vIGFzc2VydCh3aW5uaW5nVGlja2V0cy5sZW5ndGggPT09IDAsIEVSUl9XSU5OSU5HX1RJQ0tFVFNfQUxSRUFEWV9FWElTVCkKICAgIHVuY292ZXIgMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICAhCiAgICBhc3NlcnQgLy8gV2lubmluZyB0aWNrZXRzIGFscmVhZHkgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTY3CiAgICAvLyBjb25zdCByb3VuZFRvVXNlOiB1aW50NjQgPSBhY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ICsgMSArICg0ICogdnJmRmFpbHVyZUNvdW50KQogICAgc3dhcAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIHB1c2hpbnQgNCAvLyA0CiAgICB1bmNvdmVyIDIKICAgICoKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTY5LTk3NQogICAgLy8gY29uc3Qgc2VlZCA9IGFiaUNhbGwoCiAgICAvLyAgIFJhbmRvbW5lc3NCZWFjb24ucHJvdG90eXBlLmdldCwKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICAvLyAgICAgYXJnczogW3JvdW5kVG9Vc2UsIHRoaXMuc2FsdC52YWx1ZV0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTcyCiAgICAvLyBhcHBJZDogZ2V0T3RoZXJBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkudnJmQmVhY29uLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM1CiAgICAvLyBjb25zdCBbb3RoZXJBcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzT3RoZXJBcHBMaXN0KSkKICAgIHB1c2hieXRlcyAib3RoZXJfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3MgogICAgLy8gYXBwSWQ6IGdldE90aGVyQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnZyZkJlYWNvbiwKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NzMKICAgIC8vIGFyZ3M6IFtyb3VuZFRvVXNlLCB0aGlzLnNhbHQudmFsdWVdLAogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIHNhbHQgPSBHbG9iYWxTdGF0ZTxieXRlczwzMj4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTYWx0IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMzAgLy8gInNhbHQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTY5LTk3NQogICAgLy8gY29uc3Qgc2VlZCA9IGFiaUNhbGwoCiAgICAvLyAgIFJhbmRvbW5lc3NCZWFjb24ucHJvdG90eXBlLmdldCwKICAgIC8vICAgewogICAgLy8gICAgIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICAvLyAgICAgYXJnczogW3JvdW5kVG9Vc2UsIHRoaXMuc2FsdC52YWx1ZV0sCiAgICAvLyAgIH0KICAgIC8vICkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDE4OTM5MmM1IC8vIG1ldGhvZCAiZ2V0KHVpbnQ2NCxieXRlW10pYnl0ZVtdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZXh0cmFjdCA2IDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5NzcKICAgIC8vIGlmIChzZWVkLmxlbmd0aCA9PT0gMCkgewogICAgbGVuCiAgICBkdXAKICAgIGJueiByYWZmbGVfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS52cmZGYWlsdXJlQ291bnQgKz0gMQogICAgZnJhbWVfZGlnIDEyCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgODMgLy8gODMKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgODMKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTc5CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKcmFmZmxlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTgzCiAgICAvLyBjb25zdCBybmdTdGF0ZSA9IHBjZzY0SW5pdChzZWVkLnNsaWNlKDAsIDE2KSkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9kaWcgMTUKICAgIGR1cAogICAgY292ZXIgMgogICAgPj0KICAgIGludGNfMCAvLyAwCiAgICBkaWcgMgogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGRpZyAyCiAgICA+PQogICAgcHVzaGludCAxNiAvLyAxNgogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgZnJhbWVfZGlnIDE0CiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjE2CiAgICAvLyBhc3NlcnQoc2VlZC5sZW5ndGggPT09IDE2KQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTkKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgMCksIHBjZ0ZpcnN0SW5jcmVtZW50KSwKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjkyCiAgICAvLyBjb25zdCBzdGF0ZSA9IF9fcGNnMzJTdGVwKDAsIGluY3IpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxNwogICAgLy8gY29uc3QgWywgbXVsTG93XSA9IG9wLm11bHcoc3RhdGUsIHBjZ011bHRpcGxpZXIpCiAgICBpbnRjIDYgLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTkKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgMCksIHBjZ0ZpcnN0SW5jcmVtZW50KSwKICAgIGludGMgNyAvLyAxNDQyNjk1MDQwODg4OTYzNDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OTMKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KHN0YXRlLCBpbml0aWFsU3RhdGUpCiAgICB1bmNvdmVyIDIKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxNwogICAgLy8gY29uc3QgWywgbXVsTG93XSA9IG9wLm11bHcoc3RhdGUsIHBjZ011bHRpcGxpZXIpCiAgICBpbnRjIDYgLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjE5CiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDApLCBwY2dGaXJzdEluY3JlbWVudCksCiAgICBpbnRjIDcgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgYWRkdwogICAgY292ZXIgMgogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjIwCiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDgpLCBwY2dTZWNvbmRJbmNyZW1lbnQpLAogICAgdW5jb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MjAKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgOCksIHBjZ1NlY29uZEluY3JlbWVudCksCiAgICBpbnRjIDggLy8gMTQ0MjY5NTA0MDg4ODk2MzQwOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjkzCiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhzdGF0ZSwgaW5pdGlhbFN0YXRlKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGludGMgNiAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MjAKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgOCksIHBjZ1NlY29uZEluY3JlbWVudCksCiAgICBpbnRjIDggLy8gMTQ0MjY5NTA0MDg4ODk2MzQwOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjE4LTIxCiAgICAvLyByZXR1cm4gWwogICAgLy8gICAgIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgMCksIHBjZ0ZpcnN0SW5jcmVtZW50KSwKICAgIC8vICAgICBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDgpLCBwY2dTZWNvbmRJbmNyZW1lbnQpLAogICAgLy8gXQogICAgc3dhcAogICAgaXRvYgogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTg3CiAgICAvLyBpZiAodXBwZXJCb3VuZCA8IE1BWF9VSU5UNjQpIHsKICAgIGZyYW1lX2RpZyAxMwogICAgZHVwCiAgICBpbnRjIDEwIC8vIDE4NDQ2NzQ0MDczNzA5NTUxNjE1CiAgICA8CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDExCiAgICBieiByYWZmbGVfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4OAogICAgLy8gdXBwZXJCb3VuZCArPSAxCiAgICBmcmFtZV9kaWcgMTMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDExCgpyYWZmbGVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czozMAogICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IER5bmFtaWNBcnJheTxhcmM0LlVpbnQ2ND4oKQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGZyYW1lX2J1cnkgMAogICAgYnl0ZWMgNyAvLyAweDAwMDAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo0MgogICAgLy8gaWYgKHVwcGVyQm91bmQgIT09IDApIHsKICAgIGZyYW1lX2RpZyAxMQogICAgYnogcmFmZmxlX2Vsc2VfYm9keUAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo0MwogICAgLy8gYXNzZXJ0KHVwcGVyQm91bmQgPiAxKQogICAgZnJhbWVfZGlnIDExCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICA+CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NDQKICAgIC8vIGFzc2VydChsb3dlckJvdW5kIDwgdXBwZXJCb3VuZCAtIDEpCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTkxCiAgICAvLyBjb25zdCBybmdSZXN1bHQgPSBwY2c2NFJhbmRvbShybmdTdGF0ZSwgMSwgdXBwZXJCb3VuZCwgTWF4R2xvYmFsU3RhdGVVaW50NjRBcnJheSkKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjQ0CiAgICAvLyBhc3NlcnQobG93ZXJCb3VuZCA8IHVwcGVyQm91bmQgLSAxKQogICAgPgogICAgYXNzZXJ0CgpyYWZmbGVfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcofnZhbHVlLCAxKQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgfgogICAgaW50Y18xIC8vIDEKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1MwogICAgLy8gY29uc3QgdGhyZXNob2xkOiB1aW50NjQgPSBfX3VpbnQ2NFR3b3MoYWJzb2x1dGVCb3VuZCkgJSBhYnNvbHV0ZUJvdW5kCiAgICBzd2FwCiAgICAlCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDcKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDMKCnJhZmZsZV93aGlsZV90b3BAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5MQogICAgLy8gY29uc3Qgcm5nUmVzdWx0ID0gcGNnNjRSYW5kb20ocm5nU3RhdGUsIDEsIHVwcGVyQm91bmQsIE1heEdsb2JhbFN0YXRlVWludDY0QXJyYXkpCiAgICBwdXNoaW50IDE1IC8vIDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIDwKICAgIGJ6IHJhZmZsZV9hZnRlcl93aGlsZUAyMgoKcmFmZmxlX3doaWxlX3RvcEAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6OQogICAgLy8gY29uc3QgbmV3U3RhdGUxID0gX19wY2czMlN0ZXAoc3RhdGVbMF0sIHBjZ0ZpcnN0SW5jcmVtZW50KQogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxNwogICAgLy8gY29uc3QgWywgbXVsTG93XSA9IG9wLm11bHcoc3RhdGUsIHBjZ011bHRpcGxpZXIpCiAgICBpbnRjIDYgLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjkKICAgIC8vIGNvbnN0IG5ld1N0YXRlMSA9IF9fcGNnMzJTdGVwKHN0YXRlWzBdLCBwY2dGaXJzdEluY3JlbWVudCkKICAgIGludGMgNyAvLyAxNDQyNjk1MDQwODg4OTYzNDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBhZGR3CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgNQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjEwCiAgICAvLyBjb25zdCBuZXdTdGF0ZTIgPSBfX3BjZzMyU3RlcChzdGF0ZVsxXSwgbmV3U3RhdGUxID09PSAwID8gb3Auc2hsKHBjZ1NlY29uZEluY3JlbWVudCwgMSkgOiBwY2dTZWNvbmRJbmNyZW1lbnQpCiAgICBzd2FwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgOAogICAgYm56IHJhZmZsZV90ZXJuYXJ5X2ZhbHNlQDI2CiAgICBwdXNoaW50IDI4ODUzOTAwODE3Nzc5MjY4MTggLy8gMjg4NTM5MDA4MTc3NzkyNjgxOAoKcmFmZmxlX3Rlcm5hcnlfbWVyZ2VAMjc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGZyYW1lX2RpZyA4CiAgICBkdXAKICAgIGludGMgNiAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIHVuY292ZXIgMgogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjEyCiAgICAvLyByZXR1cm4gW1tuZXdTdGF0ZTEsIG5ld1N0YXRlMl0sIG9wLnNobChfX3BjZzMyT3V0cHV0KHN0YXRlWzBdKSwgMzIpIHwgX19wY2czMk91dHB1dChzdGF0ZVsxXSldCiAgICBmcmFtZV9kaWcgNQogICAgaXRvYgogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgOQogICAgY2FsbHN1YiBfX3BjZzMyT3V0cHV0CiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBzaGwKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfX3BjZzMyT3V0cHV0CiAgICB8CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTcKICAgIC8vIGNvbnN0IFtuZXdTdGF0ZSwgY2FuZGlkYXRlXSA9IF9fcGNnNjRVbmJvdW5kZWRSYW5kb20oc3RhdGUpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAxNgogICAgc3dhcAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU5CiAgICAvLyBpZiAoY2FuZGlkYXRlID49IHRocmVzaG9sZCkgewogICAgZnJhbWVfZGlnIDEwCiAgICA+PQogICAgYnogcmFmZmxlX2FmdGVyX2lmX2Vsc2VAMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NjAKICAgIC8vIHJlc3VsdC5wdXNoKG5ldyBhcmM0LlVpbnQ2NCgoY2FuZGlkYXRlICUgYWJzb2x1dGVCb3VuZCkgKyBsb3dlckJvdW5kKSkKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgNAogICAgJQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5OTEKICAgIC8vIGNvbnN0IHJuZ1Jlc3VsdCA9IHBjZzY0UmFuZG9tKHJuZ1N0YXRlLCAxLCB1cHBlckJvdW5kLCBNYXhHbG9iYWxTdGF0ZVVpbnQ2NEFycmF5KQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NjAKICAgIC8vIHJlc3VsdC5wdXNoKG5ldyBhcmM0LlVpbnQ2NCgoY2FuZGlkYXRlICUgYWJzb2x1dGVCb3VuZCkgKyBsb3dlckJvdW5kKSkKICAgICsKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA3CiAgICBmcmFtZV9idXJ5IDMKICAgIGIgcmFmZmxlX3doaWxlX3RvcEAxNgoKcmFmZmxlX2FmdGVyX2lmX2Vsc2VAMjA6CiAgICBmcmFtZV9idXJ5IDMKICAgIGIgcmFmZmxlX3doaWxlX3RvcEAxOAoKcmFmZmxlX3Rlcm5hcnlfZmFsc2VAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjEwCiAgICAvLyBjb25zdCBuZXdTdGF0ZTIgPSBfX3BjZzMyU3RlcChzdGF0ZVsxXSwgbmV3U3RhdGUxID09PSAwID8gb3Auc2hsKHBjZ1NlY29uZEluY3JlbWVudCwgMSkgOiBwY2dTZWNvbmRJbmNyZW1lbnQpCiAgICBpbnRjIDggLy8gMTQ0MjY5NTA0MDg4ODk2MzQwOQogICAgYiByYWZmbGVfdGVybmFyeV9tZXJnZUAyNwoKcmFmZmxlX2FmdGVyX3doaWxlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo2NwogICAgLy8gcmV0dXJuIFtzdGF0ZSwgcmVzdWx0XQogICAgZnJhbWVfZGlnIDMKICAgIHB1c2hieXRlcyAweDAwMTIKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo5OTMKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUud2lubmluZ1RpY2tldHMgPSBkZWNvZGVBcmM0PHVpbnQ2NFtdPihybmdSZXN1bHRbMV0uYnl0ZXMpCiAgICBkdXAKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgMTIKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgcHVzaGludCA1NyAvLyA1NwogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICBleHRyYWN0MwogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5NAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS52cmZGYWlsdXJlQ291bnQgPSAwCiAgICBmcmFtZV9kaWcgMAogICAgcmVwbGFjZTIgODMKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIHJldHN1YgoKcmFmZmxlX2Vsc2VfYm9keUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTAKICAgIC8vIGFic29sdXRlQm91bmQgPSBvcC5idG9pKEJ5dGVzKEJpZ1VpbnQoMiAqKiA2NCkgLSBCaWdVaW50KGxvd2VyQm91bmQpKSkKICAgIGludGMgMTAgLy8gMTg0NDY3NDQwNzM3MDk1NTE2MTUKICAgIGZyYW1lX2J1cnkgNAogICAgYiByYWZmbGVfYWZ0ZXJfaWZfZWxzZUAxNQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuZGlzYnVyc2VSZXdhcmRzKHJld2FyZElEOiB1aW50NjQsIGl0ZXJhdGlvbkFtb3VudDogdWludDY0KSAtPiB2b2lkOgpkaXNidXJzZVJld2FyZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5NwogICAgLy8gZGlzYnVyc2VSZXdhcmRzKHJld2FyZElEOiB1aW50NjQsIGl0ZXJhdGlvbkFtb3VudDogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAyIDAKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDExCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OTk5CiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRzKHJld2FyZElEKS5leGlzdHMsICdyZXdhcmQgZG9lcyBub3QgZXhpc3QnKQogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1OQogICAgLy8gcmV3YXJkcyA9IEJveE1hcDx1aW50NjQsIFJld2FyZD4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhSZXdhcmRzIH0pCiAgICBieXRlYyAxNSAvLyAiciIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5OQogICAgLy8gYXNzZXJ0KHRoaXMucmV3YXJkcyhyZXdhcmRJRCkuZXhpc3RzLCAncmV3YXJkIGRvZXMgbm90IGV4aXN0JykKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHJld2FyZCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDAxCiAgICAvLyBjb25zdCB7IHBoYXNlLCBkaXN0cmlidXRpb24sIHdpbm5pbmdUaWNrZXRzIH0gPSBjbG9uZSh0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlKQogICAgYm94X2dldAogICAgcG9wCiAgICBkdXAKICAgIGV4dHJhY3QgOTEgMQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGR1cAogICAgZXh0cmFjdCA4IDEKICAgIGNvdmVyIDIKICAgIGR1cAogICAgcHVzaGludCA1NyAvLyA1NwogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICBsZW4KICAgIHN1YnN0cmluZzMKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwNAogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24gfHwKICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgPT0KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDA0LTEwMDUKICAgIC8vIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZVByZXBhcmF0aW9uIHx8CiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLAogICAgYm56IGRpc2J1cnNlUmV3YXJkc19ib29sX3RydWVAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDA1CiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLAogICAgZnJhbWVfZGlnIDQ2CiAgICBieXRlYyA5IC8vIDB4MTQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMDQtMTAwNQogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24gfHwKICAgIC8vIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24sCiAgICBieiBkaXNidXJzZVJld2FyZHNfYm9vbF9mYWxzZUAzCgpkaXNidXJzZVJld2FyZHNfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKZGlzYnVyc2VSZXdhcmRzX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwMy0xMDA3CiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZVByZXBhcmF0aW9uIHx8CiAgICAvLyAgIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24sCiAgICAvLyAgIEVSUl9OT1RfUkVBRFlfVE9fRElTQlVSU0UKICAgIC8vICkKICAgIGFzc2VydCAvLyBOb3QgcmVhZHkgdG8gZGlzYnVyc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwOQogICAgLy8gaWYgKHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZVByZXBhcmF0aW9uKSB7CiAgICBmcmFtZV9kaWcgNDkKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMTAKICAgIC8vIGNvbnN0IHsgZGlzYnVyc2VtZW50Q3Vyc29yLCBkaXN0cmlidXRpb24sIHJhdGUsIGFzc2V0IH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBmcmFtZV9kaWcgNDUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgOTIgLy8gOTIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMjcKICAgIGR1cAogICAgZXh0cmFjdCA4IDEKICAgIGZyYW1lX2J1cnkgNDcKICAgIGR1cAogICAgcHVzaGludCA5IC8vIDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDM2CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjExCiAgICAvLyBsZXQgY291bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIxMgogICAgLy8gbGV0IHRvdGFsOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA0MgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMTQKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIxNAogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA4NQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMTUKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgZnJhbWVfZGlnIDI3CiAgICAtCiAgICBmcmFtZV9idXJ5IC0xCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA4NToKICAgIGZyYW1lX2RpZyAyNwogICAgZnJhbWVfYnVyeSAzMQoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA4NjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjE4CiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGZyYW1lX2RpZyAzMQogICAgZnJhbWVfZGlnIC0xCiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVAMTAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIxOQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGdhdGVBcmdzLCBxdWFudGl0eSB9ID0gY2xvbmUodGhpcy5lbnRyaWVzKGlkKS52YWx1ZSkKICAgIGZyYW1lX2RpZyAzMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgOCAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjE5CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgZ2F0ZUFyZ3MsIHF1YW50aXR5IH0gPSBjbG9uZSh0aGlzLmVudHJpZXMoaWQpLnZhbHVlKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50YyA0IC8vIDQwMAogICAgZ2V0Yml0CiAgICBkaWcgMQogICAgZXh0cmFjdCAwIDMyCiAgICBmcmFtZV9idXJ5IDAKICAgIGRpZyAxCiAgICBwdXNoaW50IDQ4IC8vIDQ4CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGxlbgogICAgZGlnIDMKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGZyYW1lX2J1cnkgOQogICAgc3dhcAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjIwCiAgICAvLyBpZiAoZGlzcXVhbGlmaWVkKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDkKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAidHlwZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjUyOAogICAgLy8gaWYgKHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSkgewogICAgYnl0ZWNfMiAvLyAweDAwCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA5MQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MjkKICAgIC8vIHJldHVybiB7IHZhbGlkOiB0cnVlLCBiYWxhbmNlOiAwIH0KICAgIHB1c2hieXRlcyAweDgwMDAwMDAwMDAwMDAwMDAwMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5nZXRTdGFrZVZhbHVlQDk0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMjUKICAgIC8vIGNvbnN0IHsgdmFsaWQgfSA9IHRoaXMuZ2V0U3Rha2VWYWx1ZShpZCkKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyBpZiAoIXZhbGlkKSB7CiAgICBieiBkaXNidXJzZVJld2FyZHNfYmxvY2tAMTAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzNAogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNiAvLyAiZ2F0ZV9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzMAogICAgLy8gaWYgKHRoaXMuZ2F0ZUlELnZhbHVlICE9PSAwKSB7CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjMxCiAgICAvLyBjb25zdCB3YWxsZXQgPSBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBhZGRyZXNzLm5hdGl2ZSkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgZnJhbWVfZGlnIDAKICAgIGNhbGxzdWIgZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTEyCiAgICAvLyBpZiAod2FsbGV0SUQuaWQgPT09IDApIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMjEKICAgIGZyYW1lX2RpZyAwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpvcmlnaW5PckAxMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzNAogICAgLy8gY29uc3QgcGFzc2VzID0gZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBnYXRlQXJncykKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImdhdGVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMzQKICAgIC8vIGNvbnN0IHBhc3NlcyA9IGdhdGVDYWxsKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgb3JpZ2luLCB0aGlzLmdhdGVJRC52YWx1ZSwgZ2F0ZUFyZ3MpCiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9kaWcgOQogICAgY2FsbHN1YiBnYXRlQ2FsbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzNQogICAgLy8gaWYgKCFwYXNzZXMpIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8UG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gInR5cGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMzYKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCkgewogICAgYnl0ZWMgNSAvLyAweDBhCiAgICAhPQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMzcKICAgIC8vIHRoaXMuZW50cmllcyhpZCkudmFsdWUuZGlzcXVhbGlmaWVkID0gdHJ1ZQogICAgZnJhbWVfZGlnIDgKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGMgNCAvLyA0MDAKICAgIGludGNfMSAvLyAxCiAgICBzZXRiaXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKCmRpc2J1cnNlUmV3YXJkc19ibG9ja0AxMDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIxOAogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBmcmFtZV9kaWcgMzEKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDMxCiAgICBiIGRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BAODYKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEwMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQzCiAgICAvLyBjb3VudCArPSAxCiAgICBmcmFtZV9kaWcgMTkKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gdG90YWwgKz0gcXVhbnRpdHkKICAgIGZyYW1lX2RpZyA0MgogICAgZnJhbWVfZGlnIDM1CiAgICArCiAgICBmcmFtZV9idXJ5IDQyCiAgICBiIGRpc2J1cnNlUmV3YXJkc19ibG9ja0AxMDIKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEyMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIzLTEyNgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGZyYW1lX2RpZyA0MwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjUKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgMzEgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIzLTEyNgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjMyCiAgICAvLyBjb25zdCBvcmlnaW4gPSBvcmlnaW5Pcih3YWxsZXQsIGFkZHJlc3MubmF0aXZlKQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpvcmlnaW5PckAxMjIKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAOTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOQogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFBvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJ0eXBlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTMwCiAgICAvLyB9IGVsc2UgaWYgKHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICBieXRlYyA1IC8vIDB4MGEKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MzEKICAgIC8vIGNvbnN0IHsgYWRkcmVzcywgYXNzZXQgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGZyYW1lX2RpZyA4CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgOAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MzMtNTM5CiAgICAvLyBjb25zdCBhdmcgPSBhYmlDYWxsKAogICAgLy8gICBTdGFraW5nSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRIZWFydGJlYXRBdmVyYWdlLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICAvLyAgICAgYXJnczogW2FkZHJlc3MsIGFzc2V0LCB0cnVlXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MzYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5zdGFraW5nLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18zIC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTM2CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MzMtNTM5CiAgICAvLyBjb25zdCBhdmcgPSBhYmlDYWxsKAogICAgLy8gICBTdGFraW5nSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRIZWFydGJlYXRBdmVyYWdlLAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnN0YWtpbmcsCiAgICAvLyAgICAgYXJnczogW2FkZHJlc3MsIGFzc2V0LCB0cnVlXSwKICAgIC8vICAgfQogICAgLy8gKS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4M2U3ZDI1OWEgLy8gbWV0aG9kICJnZXRIZWFydGJlYXRBdmVyYWdlKGJ5dGVbMzJdLHVpbnQ2NCxib29sKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo1MzcKICAgIC8vIGFyZ3M6IFthZGRyZXNzLCBhc3NldCwgdHJ1ZV0sCiAgICBieXRlYyAxOSAvLyAweDgwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzMy01MzkKICAgIC8vIGNvbnN0IGF2ZyA9IGFiaUNhbGwoCiAgICAvLyAgIFN0YWtpbmdJbnRlcmZhY2UucHJvdG90eXBlLmdldEhlYXJ0YmVhdEF2ZXJhZ2UsCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkuc3Rha2luZywKICAgIC8vICAgICBhcmdzOiBbYWRkcmVzcywgYXNzZXQsIHRydWVdLAogICAgLy8gICB9CiAgICAvLyApLnJldHVyblZhbHVlCiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQxCiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogYXZnIH0KICAgIGl0b2IKICAgIGJ5dGVjIDE5IC8vIDB4ODAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyMjUKICAgIC8vIGNvbnN0IHsgdmFsaWQgfSA9IHRoaXMuZ2V0U3Rha2VWYWx1ZShpZCkKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5nZXRTdGFrZVZhbHVlQDk0CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5MzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ0CiAgICAvLyByZXR1cm4gdGhpcy5jaGVja0J5SUQoaWQpCiAgICBmcmFtZV9kaWcgMzEKICAgIGNhbGxzdWIgY2hlY2tCeUlECiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyNQogICAgLy8gY29uc3QgeyB2YWxpZCB9ID0gdGhpcy5nZXRTdGFrZVZhbHVlKGlkKQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmdldFN0YWtlVmFsdWVAOTQKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl93aGlsZUAxMDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0NwogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZXJzICs9IGNvdW50CiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAxOQogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgMzMKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQ4CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlICs9IHRvdGFsCiAgICBkdXAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgNDIKICAgICsKICAgIGl0b2IKICAgIHJlcGxhY2UyIDQxCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1MAogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gZGlzYnVyc2VtZW50Q3Vyc29yKSB7CiAgICBmcmFtZV9kaWcgMjcKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDExMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNTIKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24KICAgIGZyYW1lX2RpZyA0NQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgYnl0ZWMgOSAvLyAweDE0CiAgICByZXBsYWNlMiA5MQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNTMKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIHJlcGxhY2UyIDkyCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBkaWcgMQogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNTUKICAgIC8vIHRoaXMucGF5QWtpdGFSb3lhbHR5KGRpc3RyaWJ1dGlvbiwgcmF0ZSwgYXNzZXQsIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2VycykKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDM0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4MAogICAgLy8gaWYgKGRpc3RyaWJ1dGlvbiA9PT0gRGlzdHJpYnV0aW9uVHlwZUZsYXQpIHsKICAgIGZyYW1lX2RpZyA0NwogICAgYnl0ZWMgOSAvLyAweDE0CiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgxCiAgICAvLyBhbW91bnQgPSBjYWxjUGVyY2VudCgocXVhbGlmaWVkU3Rha2VycyAqIHJhdGUpLCB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSkKICAgIGZyYW1lX2RpZyAzNAogICAgZnJhbWVfZGlnIDM2CiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gYWtpdGFSb3lhbHR5ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjEgLy8gImFraXRhX3JveWFsdHkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo3NAogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGR1cAogICAgaW50YyA1IC8vIDEwMDAwMAogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NzUKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBtdWx3CiAgICBpbnRjIDUgLy8gMTAwMDAwCiAgICBkaXZ3CiAgICBmcmFtZV9idXJ5IDE2CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBieXRlYyAxNyAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4NgogICAgLy8gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUgPSBhbW91bnQKICAgIGZyYW1lX2RpZyAxNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTg5CiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGZyYW1lX2RpZyAxNwogICAgYm56IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5MC0xOTUKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTkyCiAgICAvLyByZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBmcmFtZV9kaWcgMTYKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5MC0xOTQKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxOTAtMTk1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMjQ6CiAgICByZXRzdWIKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxOTcKICAgIC8vIGFzc2VydChHbG9iYWwuemVyb0FkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0KSksIEVSUl9EQU9fTk9UX09QVEVEX0lOKQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBmcmFtZV9kaWcgMTcKICAgIGR1cAogICAgY292ZXIgMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBEQU8gbm90IG9wdGVkIGluIHRvIHRoZSBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxOTktMjA1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjAxCiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgMTYKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxOTktMjA0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxOTktMjA1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICByZXRzdWIKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGFraXRhUm95YWx0eSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NzQKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNSAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjc1CiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIHApLCBESVZJU09SKQogICAgZnJhbWVfZGlnIDM2CiAgICBtdWx3CiAgICBpbnRjIDUgLy8gMTAwMDAwCiAgICBkaXZ3CiAgICBmcmFtZV9idXJ5IDE2CiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEwNwoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgKz0gaXRlcmF0aW9uQW1vdW50CiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgcHVzaGludCA5MiAvLyA5MgogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgOTIKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIHJldHN1YgoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDEzCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlOiB7CiAgICBmcmFtZV9kaWcgNDcKICAgIGJ5dGVjIDUgLy8gMHgwYQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAxMy0xMDE2CiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlOiB7CiAgICAvLyAgIHRoaXMuY3JlYXRlUGVyY2VudGFnZURpc2J1cnNlbWVudChyZXdhcmRJRCwgaXRlcmF0aW9uQW1vdW50KQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNjkKICAgIC8vIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBmcmFtZV9kaWcgNDUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxNwogICAgZHVwCiAgICBwdXNoaW50IDkyIC8vIDkyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9idXJ5IDI3CiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTIKICAgIGR1cAogICAgcHVzaGludCA0MSAvLyA0MQogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMzMKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNzEKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI3MQogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNzIKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgZnJhbWVfZGlnIDI3CiAgICAtCiAgICBmcmFtZV9idXJ5IC0xCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA3MzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNyAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNzUKICAgIC8vIGNvbnN0IGFjdHVhbEFtb3VudDogdWludDY0ID0gYW1vdW50IC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGZyYW1lX2RpZyAxNgogICAgc3dhcAogICAgLQogICAgZnJhbWVfYnVyeSAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNzYKICAgIC8vIGxldCBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgZnJhbWVfYnVyeSAyCiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI3NwogICAgLy8gbGV0IHN1bTogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMzkKICAgIGZyYW1lX2RpZyAyNwogICAgZnJhbWVfYnVyeSAzMQoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA3NDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjc5CiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGZyYW1lX2RpZyAzMQogICAgZnJhbWVfZGlnIC0xCiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANzkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgwCiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgcXVhbnRpdHksIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGZyYW1lX2RpZyAzMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgOCAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyODAKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBxdWFudGl0eSwgYWRkcmVzcyB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50YyA0IC8vIDQwMAogICAgZ2V0Yml0CiAgICBkaWcgMQogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMzUKICAgIHN3YXAKICAgIGV4dHJhY3QgMCAzMgogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MQogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A3OAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo3OQogICAgLy8gYXNzZXJ0KGEgPCBiLCBFUlJfSU5WQUxJRF9QRVJDRU5UQUdFX09GX0FSR1MpCiAgICBmcmFtZV9kaWcgMzUKICAgIGR1cAogICAgZnJhbWVfZGlnIDMzCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIDwKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2Ugb2YgYXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo4MAogICAgLy8gcmV0dXJuIG9wLmRpdncoLi4ub3AubXVsdyhhLCBESVZJU09SKSwgYikKICAgIGludGMgNSAvLyAxMDAwMDAKICAgIG11bHcKICAgIHVuY292ZXIgMgogICAgZGl2dwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo3NAogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGR1cAogICAgaW50YyA1IC8vIDEwMDAwMAogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NzUKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBmcmFtZV9kaWcgMTMKICAgIG11bHcKICAgIGludGMgNSAvLyAxMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg2CiAgICAvLyBhbGxvY2F0aW9ucy5wdXNoKHsgYWRkcmVzcywgYW1vdW50OiBpbmRpdmlkdWFsQW1vdW50IH0pCiAgICBkdXAKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyA2CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4NwogICAgLy8gc3VtICs9IGluZGl2aWR1YWxBbW91bnQKICAgIGZyYW1lX2RpZyAzOQogICAgKwogICAgZnJhbWVfYnVyeSAzOQoKZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDc4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyNzkKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZnJhbWVfZGlnIDMxCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAzMQogICAgYiBkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDc0CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANzk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjI5MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgKz0gaXRlcmF0aW9uQW1vdW50CiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgcHVzaGludCA5MiAvLyA5MgogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgOTIKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MjkyCiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGZyYW1lX2RpZyAxMgogICAgZnJhbWVfZGlnIDE3CiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDM5CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjk0CiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSAoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSkgewogICAgZnJhbWVfZGlnIDI3CiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAyNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyOTUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUZpbmFsaXphdGlvbgogICAgZnJhbWVfZGlnIDQ1CiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBieXRlYyAxMiAvLyAweDFlCiAgICByZXBsYWNlMiA5MQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoyOTYKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgZnJhbWVfZGlnIDIKICAgIHJlcGxhY2UyIDkyCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBib3hfcHV0CiAgICByZXRzdWIKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMTcKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZUZsYXQ6IHsKICAgIGZyYW1lX2RpZyA0NwogICAgYnl0ZWMgOSAvLyAweDE0CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDE3LTEwMjAKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZUZsYXQ6IHsKICAgIC8vICAgdGhpcy5jcmVhdGVGbGF0RGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICAvLyAgIGJyZWFrCiAgICAvLyB9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMDcKICAgIC8vIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBmcmFtZV9kaWcgNDUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTIKICAgIGR1cAogICAgcHVzaGludCA5MiAvLyA5MgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAyNwogICAgZHVwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMwogICAgZnJhbWVfYnVyeSAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMDkKICAgIC8vIGNvbnN0IHRvdGFsOiB1aW50NjQgPSAocXVhbGlmaWVkU3Rha2VycyAqIGFtb3VudCkgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgc3dhcAogICAgZGlnIDEKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNyAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMDkKICAgIC8vIGNvbnN0IHRvdGFsOiB1aW50NjQgPSAocXVhbGlmaWVkU3Rha2VycyAqIGFtb3VudCkgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGFraXRhUm95YWx0eSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NzQKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNSAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjc1CiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIHApLCBESVZJU09SKQogICAgZGlnIDIKICAgIG11bHcKICAgIGludGMgNSAvLyAxMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzExCiAgICAvLyBjb25zdCBhZGp1c3RlZEFtb3VudDogdWludDY0ID0gYW1vdW50IC0gcGVyY2VudGFnZUFraXRhRmVlCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIGZyYW1lX2J1cnkgMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzEyCiAgICAvLyBjb25zdCBbYmFsYW5jZV0gPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBhc3NldCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICB1bmNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMxNAogICAgLy8gYXNzZXJ0KGJhbGFuY2UgPj0gdG90YWwsIEVSUl9OT1RfRU5PVUdIX0ZVTkRTKQogICAgPD0KICAgIGFzc2VydCAvLyBOb3QgZW5vdWdoIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMxNgogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzE2CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgID4KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDYxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMxNwogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBmcmFtZV9kaWcgMjcKICAgIC0KICAgIGZyYW1lX2J1cnkgLTEKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDYxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMjAKICAgIC8vIGxldCBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgZnJhbWVfYnVyeSAzCiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyMQogICAgLy8gbGV0IHN1bTogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMzkKICAgIGZyYW1lX2RpZyAyNwogICAgZnJhbWVfYnVyeSAzMQoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA2MjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzIzCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGZyYW1lX2RpZyAzMQogICAgZnJhbWVfZGlnIC0xCiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcyB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZnJhbWVfZGlnIDMxCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1MwogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyA4IC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyNAogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGMgNCAvLyA0MDAKICAgIGdldGJpdAogICAgc3dhcAogICAgZXh0cmFjdCAwIDMyCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzI1CiAgICAvLyBpZiAoZGlzcXVhbGlmaWVkKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDY2CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyOQogICAgLy8gYWxsb2NhdGlvbnMucHVzaCh7IGFkZHJlc3MsIGFtb3VudDogYWRqdXN0ZWRBbW91bnQgfSkKICAgIGZyYW1lX2RpZyAxNQogICAgZHVwCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgNgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGZyYW1lX2J1cnkgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMzAKICAgIC8vIHN1bSArPSBhZGp1c3RlZEFtb3VudAogICAgZnJhbWVfZGlnIDM5CiAgICArCiAgICBmcmFtZV9idXJ5IDM5CgpkaXNidXJzZVJld2FyZHNfYmxvY2tANjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyMwogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBmcmFtZV9kaWcgMzEKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDMxCiAgICBiIGRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BANjIKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl93aGlsZUA2NzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzMzCiAgICAvLyBjb25zdCBuZXdDdXJzb3JWYWx1ZTogdWludDY0ID0gZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50CiAgICBmcmFtZV9kaWcgMjcKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozMzQKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gbmV3Q3Vyc29yVmFsdWUKICAgIGZyYW1lX2RpZyA0NQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZGlnIDEKICAgIGl0b2IKICAgIHJlcGxhY2UyIDkyCiAgICBkaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzM1CiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGZyYW1lX2RpZyAxMgogICAgZnJhbWVfZGlnIDE3CiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDM5CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzM3CiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSBuZXdDdXJzb3JWYWx1ZSkgewogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDI0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzOAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlRmluYWxpemF0aW9uCiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGJ5dGVjIDEyIC8vIDB4MWUKICAgIHJlcGxhY2UyIDkxCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzOQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBmcmFtZV9kaWcgMwogICAgcmVwbGFjZTIgOTIKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIHJldHN1YgoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMjEKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZUV2ZW46IHsKICAgIGZyYW1lX2RpZyA0NwogICAgYnl0ZWMgMTIgLy8gMHgxZQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyMS0xMDI0CiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVFdmVuOiB7CiAgICAvLyAgIHRoaXMuY3JlYXRlRXZlbkRpc2J1cnNlbWVudChyZXdhcmRJRCwgaXRlcmF0aW9uQW1vdW50KQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzUwCiAgICAvLyB9ID0gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZQogICAgZnJhbWVfZGlnIDQ1CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDEyCiAgICBkdXAKICAgIHB1c2hpbnQgOTIgLy8gOTIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMjcKICAgIGR1cAogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMzQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMTcKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9idXJ5IDM5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM1MgogICAgLy8gY29uc3QgYmFsYW5jZSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2UoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsIGFzc2V0KVswXQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTcgLy8gImFraXRhX3JveWFsdHlfYW1vdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzUzCiAgICAvLyBjb25zdCBhY3R1YWxTdW06IHVpbnQ2NCA9IHN1bSAtIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIGR1cAogICAgZnJhbWVfYnVyeSAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNTQKICAgIC8vIGFzc2VydChiYWxhbmNlID49IGFjdHVhbFN1bSwgRVJSX05PVF9FTk9VR0hfRlVORFMpCiAgICA+PQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggZnVuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzU2CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNTYKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgPgogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzU3CiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGZyYW1lX2RpZyAyNwogICAgLQogICAgZnJhbWVfYnVyeSAtMQoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2MAogICAgLy8gY29uc3QgYW1vdW50OiB1aW50NjQgPSBhY3R1YWxTdW0gLyBxdWFsaWZpZWRTdGFrZXJzCiAgICBmcmFtZV9kaWcgMTQKICAgIGZyYW1lX2RpZyAzNAogICAgLwogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNjEKICAgIC8vIGxldCBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgZnJhbWVfYnVyeSA0CiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgZnJhbWVfYnVyeSA2CiAgICBmcmFtZV9kaWcgMjcKICAgIGZyYW1lX2J1cnkgMzEKCmRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BANTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2MgogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBmcmFtZV9kaWcgMzEKICAgIGZyYW1lX2RpZyAtMQogICAgPAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2MwogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGZyYW1lX2RpZyAzMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgOCAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNjMKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzIH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBpbnRjIDQgLy8gNDAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIGV4dHJhY3QgMCAzMgogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2NAogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A1NAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNjgKICAgIC8vIGFsbG9jYXRpb25zLnB1c2goeyBhZGRyZXNzLCBhbW91bnQgfSkKICAgIGZyYW1lX2RpZyAxNgogICAgaXRvYgogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDYKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBmcmFtZV9idXJ5IDYKCmRpc2J1cnNlUmV3YXJkc19ibG9ja0A1NDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzYyCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGZyYW1lX2RpZyAzMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMzEKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA1MAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDU1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNzEKICAgIC8vIGNvbnN0IG5ld0N1cnNvclZhbHVlOiB1aW50NjQgPSBkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQKICAgIGZyYW1lX2RpZyAyNwogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3MgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSBuZXdDdXJzb3JWYWx1ZQogICAgZnJhbWVfZGlnIDQ1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMQogICAgaXRvYgogICAgcmVwbGFjZTIgOTIKICAgIGRpZyAyCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNzMKICAgIC8vIHRoaXMuY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMoYWN0aXZlRGlzYnVyc2VtZW50SUQsIGFzc2V0LCBhbGxvY2F0aW9ucywgc3VtKQogICAgZnJhbWVfZGlnIDEyCiAgICBmcmFtZV9kaWcgMTcKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgMzkKICAgIGNhbGxzdWIgY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozNzUKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IG5ld0N1cnNvclZhbHVlKSB7CiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzc2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGZyYW1lX2RpZyA0NQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgYnl0ZWMgMTIgLy8gMHgxZQogICAgcmVwbGFjZTIgOTEKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzc3CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGZyYW1lX2RpZyA0CiAgICByZXBsYWNlMiA5MgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyNQogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlU2h1ZmZsZTogewogICAgZnJhbWVfZGlnIDQ3CiAgICBwdXNoYnl0ZXMgMHgyOAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyNS0xMDMyCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVTaHVmZmxlOiB7CiAgICAvLyAgIGlmICh3aW5uaW5nVGlja2V0cy5sZW5ndGggPT09IDApIHsKICAgIC8vICAgICB0aGlzLnJhZmZsZShyZXdhcmRJRCkKICAgIC8vICAgfSBlbHNlIHsKICAgIC8vICAgICB0aGlzLmNyZWF0ZVNodWZmbGVEaXNidXJzZW1lbnQocmV3YXJkSUQsIGl0ZXJhdGlvbkFtb3VudCkKICAgIC8vICAgfQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYXNzZXJ0IC8vIHVua25vd24gcmV3YXJkIHJhdGUgdHlwZQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDI2CiAgICAvLyBpZiAod2lubmluZ1RpY2tldHMubGVuZ3RoID09PSAwKSB7CiAgICBmcmFtZV9kaWcgNDgKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgYm56IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyNwogICAgLy8gdGhpcy5yYWZmbGUocmV3YXJkSUQpCiAgICBmcmFtZV9kaWcgLTIKICAgIGNhbGxzdWIgcmFmZmxlCiAgICByZXRzdWIKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM5MAogICAgLy8gfSA9IGNsb25lKHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUpCiAgICBmcmFtZV9kaWcgNDUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTIKICAgIGR1cAogICAgcHVzaGludCA5MiAvLyA5MgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAyNwogICAgZHVwCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSA0NAogICAgZHVwCiAgICBwdXNoaW50IDU3IC8vIDU3CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGxlbgogICAgZGlnIDIKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGZyYW1lX2J1cnkgMTEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMTcKICAgIGR1cAogICAgcHVzaGludCA5IC8vIDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGZyYW1lX2J1cnkgMzkKICAgIGV4dHJhY3QgNTkgMjQKICAgIGZyYW1lX2J1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MzkyCiAgICAvLyBjb25zdCBiYWxhbmNlID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgYXNzZXQpWzBdCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNyAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozOTMKICAgIC8vIGNvbnN0IGFjdHVhbFN1bTogdWludDY0ID0gc3VtIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgLQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM5NAogICAgLy8gYXNzZXJ0KGJhbGFuY2UgPj0gYWN0dWFsU3VtLCBFUlJfTk9UX0VOT1VHSF9GVU5EUykKICAgID49CiAgICBhc3NlcnQgLy8gTm90IGVub3VnaCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozOTYKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJlbnRyeV9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjM5NgogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAyNwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiZW50cnlfY291bnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czozOTcKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgZnJhbWVfZGlnIDI3CiAgICAtCiAgICBmcmFtZV9idXJ5IC0xCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAyNzoKICAgIGZyYW1lX2RpZyAxNAogICAgZnJhbWVfYnVyeSAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MDEKICAgIC8vIGlmICh3aW5uZXJDb3VudCA+IDApIHsKICAgIGZyYW1lX2RpZyA0NAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMjkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDAyCiAgICAvLyBhbW91bnQgPSBhY3R1YWxTdW0gLyB3aW5uZXJDb3VudAogICAgZnJhbWVfZGlnIDE0CiAgICBmcmFtZV9kaWcgNDQKICAgIC8KICAgIGZyYW1lX2J1cnkgMTYKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDI5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MDUKICAgIC8vIGxldCB7IHN0YWtlLCB0aWNrZXQsIGRpc2J1cnNlZCB9ID0gcmFmZmxlQ3Vyc29yCiAgICBmcmFtZV9kaWcgMTAKICAgIGR1cAogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgNDAKICAgIHVuY292ZXIgMgogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDA2CiAgICAvLyBsZXQgY3VycmVudFRpY2tldCA9IHRpY2tldHNbdGlja2V0XQogICAgZnJhbWVfZGlnIDExCiAgICBleHRyYWN0IDIgMAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIHVuY292ZXIgMgogICAgaW50Y18zIC8vIDgKICAgICoKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQxMAogICAgLy8gbGV0IGFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbltdID0gW10KICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBmcmFtZV9idXJ5IDUKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICBmcmFtZV9idXJ5IDYKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyMgogICAgZnJhbWVfYnVyeSAzNwogICAgZnJhbWVfZGlnIDI3CiAgICBmcmFtZV9idXJ5IDI5CgpkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDMwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MTEKICAgIC8vIGZvciAobGV0IGkgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGkgPCBpdGVyYXRpb25BbW91bnQ7IGkrKykgewogICAgZnJhbWVfZGlnIDI5CiAgICBmcmFtZV9kaWcgLTEKICAgIDwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A0MgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MTIKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzLCBhc3NldCwgcXVhbnRpdHkgfSA9IHRoaXMuZW50cmllcyhpKS52YWx1ZQogICAgZnJhbWVfZGlnIDI5CiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTUzCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDggLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDEyCiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgYXNzZXQsIHF1YW50aXR5IH0gPSB0aGlzLmVudHJpZXMoaSkudmFsdWUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGMgNCAvLyA0MDAKICAgIGdldGJpdAogICAgZnJhbWVfYnVyeSAyOAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIGZyYW1lX2J1cnkgMAogICAgZHVwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxOAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE0CiAgICAvLyBjdXJyZW50UmFuZ2VFbmQgPSBjdXJyZW50UmFuZ2VTdGFydCArIHF1YW50aXR5CiAgICBmcmFtZV9kaWcgMjIKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICArCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE1CiAgICAvLyBpZiAoY3VycmVudFRpY2tldCA+PSBjdXJyZW50UmFuZ2VTdGFydCAmJiBjdXJyZW50VGlja2V0IDw9IGN1cnJlbnRSYW5nZUVuZCkgewogICAgZnJhbWVfZGlnIDIzCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgPj0KICAgIGZyYW1lX2RpZyAzNwogICAgZnJhbWVfYnVyeSAzOAogICAgZnJhbWVfZGlnIDQwCiAgICBmcmFtZV9idXJ5IDQxCiAgICBmcmFtZV9kaWcgMjUKICAgIGZyYW1lX2J1cnkgMjYKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9idXJ5IDcKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMjQKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfYnVyeSAzMgogICAgdW5jb3ZlciAyCiAgICBmcmFtZV9idXJ5IDMwCiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDIxCiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA0MAogICAgZnJhbWVfZGlnIDIzCiAgICBkdXAKICAgIGZyYW1lX2RpZyAyMAogICAgZHVwCiAgICBjb3ZlciAzCiAgICA8PQogICAgZnJhbWVfZGlnIDM3CiAgICBmcmFtZV9idXJ5IDM4CiAgICBmcmFtZV9kaWcgNDAKICAgIGZyYW1lX2J1cnkgNDEKICAgIGZyYW1lX2RpZyAyNQogICAgZnJhbWVfYnVyeSAyNgogICAgZnJhbWVfZGlnIDYKICAgIGZyYW1lX2J1cnkgNwogICAgc3dhcAogICAgZnJhbWVfYnVyeSAyNAogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDMyCiAgICBmcmFtZV9kaWcgMjkKICAgIGZyYW1lX2J1cnkgMzAKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMjEKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQwCiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfYnVyeSA3CiAgICBmcmFtZV9kaWcgMjUKICAgIGZyYW1lX2J1cnkgMjYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE2CiAgICAvLyBpZiAoIWRpc3F1YWxpZmllZCkgewogICAgZnJhbWVfZGlnIDI4CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE3CiAgICAvLyBhbGxvY2F0aW9ucy5wdXNoKHsgYWRkcmVzcywgYW1vdW50IH0pCiAgICBmcmFtZV9kaWcgMTYKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyA2CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MTgKICAgIC8vIGRpc2J1cnNlZCsrCiAgICBmcmFtZV9kaWcgMjUKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDI2CiAgICBmcmFtZV9idXJ5IDcKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDM1OgogICAgZnJhbWVfZGlnIDcKICAgIGZyYW1lX2J1cnkgNgogICAgZnJhbWVfZGlnIDI2CiAgICBmcmFtZV9idXJ5IDI1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyMQogICAgLy8gaWYgKHRpY2tldCA9PT0gdGlja2V0cy5sZW5ndGggLSAxKSB7CiAgICBmcmFtZV9kaWcgMTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGZyYW1lX2RpZyA0MAogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDM5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyMwogICAgLy8gaWYgKHdpbm5lckNvdW50ICE9PSBkaXNidXJzZWQpIHsKICAgIGZyYW1lX2RpZyA0NAogICAgZnJhbWVfZGlnIDI1CiAgICAhPQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDQyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyNAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGZyYW1lX2RpZyA1CiAgICByZXBsYWNlMiA5MgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MjUtNDI5CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnJhZmZsZUN1cnNvciA9IHsKICAgIC8vICAgdGlja2V0OiAwLAogICAgLy8gICBzdGFrZTogMCwKICAgIC8vICAgZGlzYnVyc2VkOiAwLAogICAgLy8gfQogICAgYnl0ZWMgMzIgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIHJlcGxhY2UyIDU5CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzMAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS53aW5uaW5nVGlja2V0cyA9IFtdCiAgICBkdXAKICAgIHB1c2hpbnQgNTcgLy8gNTcKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgZXh0cmFjdDMKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDMxCiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGZyYW1lX2RpZyAxMgogICAgZnJhbWVfZGlnIDE4CiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDM5CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIHJldHN1YgoKZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDQyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NDgKICAgIC8vIHRoaXMuY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMoYWN0aXZlRGlzYnVyc2VtZW50SUQsIGFzc2V0LCBhbGxvY2F0aW9ucywgc3VtKQogICAgZnJhbWVfZGlnIDEyCiAgICBmcmFtZV9kaWcgMTcKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgMzkKICAgIGNhbGxzdWIgY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NTAKICAgIC8vIGlmICh3aW5uZXJDb3VudCA9PT0gZGlzYnVyc2VkKSB7CiAgICBmcmFtZV9kaWcgNDQKICAgIGZyYW1lX2RpZyAyNQogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDUxCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGZyYW1lX2RpZyA0NQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgYnl0ZWMgMTIgLy8gMHgxZQogICAgcmVwbGFjZTIgOTEKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDUyCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGZyYW1lX2RpZyA1CiAgICByZXBsYWNlMiA5MgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NTMtNDU3CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnJhZmZsZUN1cnNvciA9IHsKICAgIC8vICAgdGlja2V0OiAwLAogICAgLy8gICBzdGFrZTogMCwKICAgIC8vICAgZGlzYnVyc2VkOiAwLAogICAgLy8gfQogICAgYnl0ZWMgMzIgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIHJlcGxhY2UyIDU5CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkdXAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS53aW5uaW5nVGlja2V0cyA9IFtdCiAgICBkdXAKICAgIHB1c2hpbnQgNTcgLy8gNTcKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgZXh0cmFjdDMKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIHJldHN1YgoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA0NDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDYwCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciArPSBpdGVyYXRpb25BbW91bnQKICAgIGZyYW1lX2RpZyA0NQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDkyIC8vIDkyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBpdG9iCiAgICByZXBsYWNlMiA5MgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgZHVwMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NjEKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucmFmZmxlQ3Vyc29yID0geyB0aWNrZXQsIHN0YWtlLCBkaXNidXJzZWQgfQogICAgZnJhbWVfZGlnIDQwCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMzcKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDI1CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHJlcGxhY2UyIDU5CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBib3hfcHV0CiAgICByZXRzdWIKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDM5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MzcKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCAtPSBpCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2RpZyAyOQogICAgLQogICAgZnJhbWVfYnVyeSAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0MzgKICAgIC8vIHRpY2tldCsrCiAgICBmcmFtZV9kaWcgNDAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzOQogICAgLy8gY3VycmVudFRpY2tldCA9IHRpY2tldHNbdGlja2V0XQogICAgZHVwCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ0MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBmcmFtZV9kaWcgNDUKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGZyYW1lX2RpZyA1CiAgICByZXBsYWNlMiA5MgogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NDEKICAgIC8vIGkgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NDItNDQzCiAgICAvLyBzdGFrZSA9IDAKICAgIC8vIGN1cnJlbnRSYW5nZUVuZCA9IDAKICAgIGR1cG4gMgogICAgZnJhbWVfYnVyeSAzOAogICAgdW5jb3ZlciAzCiAgICBmcmFtZV9idXJ5IDQxCiAgICBmcmFtZV9kaWcgMjUKICAgIGZyYW1lX2J1cnkgMjYKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9idXJ5IDcKICAgIHVuY292ZXIgMgogICAgZnJhbWVfYnVyeSAyNAogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDMyCiAgICBmcmFtZV9idXJ5IDIxCiAgICBmcmFtZV9idXJ5IDMwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA0MDoKICAgIGZyYW1lX2RpZyAzOAogICAgZnJhbWVfYnVyeSAzNwogICAgZnJhbWVfZGlnIDQxCiAgICBmcmFtZV9idXJ5IDQwCiAgICBmcmFtZV9kaWcgMjYKICAgIGZyYW1lX2J1cnkgMjUKICAgIGZyYW1lX2RpZyA3CiAgICBmcmFtZV9idXJ5IDYKICAgIGZyYW1lX2RpZyAyNAogICAgZnJhbWVfYnVyeSAyMwogICAgZnJhbWVfZGlnIDMyCiAgICBmcmFtZV9idXJ5IC0xCiAgICBmcmFtZV9kaWcgMzAKICAgIGZyYW1lX2RpZyAyMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo0NDUKICAgIC8vIGN1cnJlbnRSYW5nZVN0YXJ0ID0gY3VycmVudFJhbmdlRW5kICsgMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMjIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6NDExCiAgICAvLyBmb3IgKGxldCBpID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpIDwgaXRlcmF0aW9uQW1vdW50OyBpKyspIHsKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDI5CiAgICBiIGRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BAMzAKCmRpc2J1cnNlUmV3YXJkc19ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBkaXNidXJzZVJld2FyZHNfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5maW5hbGl6ZURpc3RyaWJ1dGlvbihyZXdhcmRJRDogdWludDY0KSAtPiB2b2lkOgpmaW5hbGl6ZURpc3RyaWJ1dGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0MAogICAgLy8gZmluYWxpemVEaXN0cmlidXRpb24ocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDEKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU5CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDE1IC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDEKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHJld2FyZCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDQyCiAgICAvLyBjb25zdCB7IHBoYXNlLCBhY3RpdmVEaXNidXJzZW1lbnRJRCB9ID0gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGR1cAogICAgZXh0cmFjdCA5MSAxCiAgICBkaWcgMQogICAgZXh0cmFjdCAxMDAgOAogICAgdW5jb3ZlciAyCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDMKICAgIC8vIGFzc2VydChwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24sIEVSUl9ESVNCVVJTRU1FTlRfTk9UX1JFQURZX0ZPUl9GSU5BTElaQVRJT04pCiAgICB1bmNvdmVyIDIKICAgIGJ5dGVjIDEyIC8vIDB4MWUKICAgID09CiAgICBhc3NlcnQgLy8gRGlzYnVyc2VtZW50IG5vdCByZWFkeSBmb3IgZmluYWxpemF0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjYyMwogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnJld2FyZHMpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzMgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo2MjMKICAgIC8vIGNvbnN0IHJld2FyZHNBcHAgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS5yZXdhcmRzKQogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjYyNS02MzEKICAgIC8vIGFiaUNhbGwoCiAgICAvLyAgIFJld2FyZHNJbnRlcmZhY2UucHJvdG90eXBlLmZpbmFsaXplRGlzYnVyc2VtZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgICAgYXJnczogW2Rpc2J1cnNlbWVudElEXSwKICAgIC8vICAgfQogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgcHVzaGJ5dGVzIDB4NTQyNGE1OTEgLy8gbWV0aG9kICJmaW5hbGl6ZURpc2J1cnNlbWVudCh1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDcKICAgIC8vIHRoaXMuZGlzYnVyc2VtZW50cyhhY3RpdmVEaXNidXJzZW1lbnRJRCkuY3JlYXRlKCkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBkaXNidXJzZW1lbnRzID0gQm94TWFwPHVpbnQ2NCwgYnl0ZXM8MD4+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RGlzYnVyc2VtZW50cyB9KQogICAgcHVzaGJ5dGVzICJkIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDcKICAgIC8vIHRoaXMuZGlzYnVyc2VtZW50cyhhY3RpdmVEaXNidXJzZW1lbnRJRCkuY3JlYXRlKCkKICAgIGludGNfMCAvLyAwCiAgICBib3hfY3JlYXRlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0OQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlSWRsZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgcmVwbGFjZTIgOTEKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGR1cDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRJRCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBzd2FwCiAgICBkaWcgMQogICAgcmVwbGFjZTIgMTAwCiAgICBkaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICBkaWcgMgogICAgZGlnIDEKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ID0gMAogICAgZGlnIDEKICAgIHJlcGxhY2UyIDEwOAogICAgZGlnIDIKICAgIGJveF9kZWwKICAgIHBvcAogICAgZGlnIDIKICAgIGRpZyAxCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNTIKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgZGlnIDEKICAgIHJlcGxhY2UyIDkyCiAgICBkaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICBkaWcgMgogICAgZGlnIDEKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MwogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZXJzID0gMAogICAgZGlnIDEKICAgIHJlcGxhY2UyIDMzCiAgICBkaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICBkaWcgMgogICAgZGlnIDEKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1NAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZSA9IDAKICAgIHN3YXAKICAgIHJlcGxhY2UyIDQxCiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBib3hfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmNoZWNrKGFkZHJlc3M6IGJ5dGVzLCBhc3NldDogdWludDY0KSAtPiBieXRlczoKY2hlY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNTcKICAgIC8vIGNoZWNrKGFkZHJlc3M6IEFkZHJlc3MsIGFzc2V0OiB1aW50NjQpOiB7IHZhbGlkOiBib29sZWFuLCBiYWxhbmNlOiB1aW50NjQgfSB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1OAogICAgLy8gY29uc3Qga2V5OiBFbnRyeUtleSA9IHsgYWRkcmVzcywgYXNzZXQgfQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTcKICAgIC8vIGVudHJpZXNCeUFkZHJlc3MgPSBCb3hNYXA8RW50cnlLZXksIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzQnlBZGRyZXNzIH0pCiAgICBwdXNoYnl0ZXMgImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1OQogICAgLy8gY29uc3QgaWQgPSB0aGlzLmVudHJpZXNCeUFkZHJlc3Moa2V5KS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2MAogICAgLy8gcmV0dXJuIHRoaXMuY2hlY2tCeUlEKGlkKQogICAgY2FsbHN1YiBjaGVja0J5SUQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuc2lnblVwc09wZW4oKSAtPiB1aW50NjQ6CnNpZ25VcHNPcGVuOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDUKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFBvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAic3RhdHVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2OQogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgYnl0ZWNfMiAvLyAweDAwCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDY5LTEwNzAKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSAmJgogICAgYnogc2lnblVwc09wZW5fYm9vbF9mYWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzAKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSAmJgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTEKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVNpZ251cFRpbWVzdGFtcCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDI2IC8vICJzaWdudXBfdGltZXN0YW1wIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MAogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICA+CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjktMTA3MAogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICBieiBzaWduVXBzT3Blbl9ib29sX2ZhbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXJ0VGltZXN0YW1wIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzEKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUpCiAgICA8CiAgICBibnogc2lnblVwc09wZW5fYm9vbF90cnVlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEzCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMiAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSkKICAgIGJ6IHNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANQoKc2lnblVwc09wZW5fYm9vbF90cnVlQDQ6CiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDY4LTEwNzIKICAgIC8vIHJldHVybiAoCiAgICAvLyAgIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vICAgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUpCiAgICAvLyApCiAgICByZXRzdWIKCnNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANToKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjgtMTA3MgogICAgLy8gcmV0dXJuICgKICAgIC8vICAgdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gICBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUgJiYKICAgIC8vICAgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSkKICAgIC8vICkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6OlBvb2wuaXNMaXZlKCkgLT4gdWludDY0Ogppc0xpdmU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNQogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8UG9vbFN0YXR1cz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXR1cyB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJzdGF0dXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDc5CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICBieXRlY18yIC8vIDB4MDAKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzktMTA4MAogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIGJ6IGlzTGl2ZV9ib29sX2ZhbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4MAogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXJ0VGltZXN0YW1wIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODAKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDc5LTEwODAKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICBieiBpc0xpdmVfYm9vbF9mYWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODEKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDw9IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID09PSAwKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE0IC8vICJlbmRfdGltZXN0YW1wIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4MQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICA8PQogICAgYm56IGlzTGl2ZV9ib29sX3RydWVANAogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDE0IC8vICJlbmRfdGltZXN0YW1wIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4MQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICBibnogaXNMaXZlX2Jvb2xfZmFsc2VANQoKaXNMaXZlX2Jvb2xfdHJ1ZUA0OgogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3OC0xMDgyCiAgICAvLyByZXR1cm4gKAogICAgLy8gICB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDw9IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID09PSAwKQogICAgLy8gKQogICAgcmV0c3ViCgppc0xpdmVfYm9vbF9mYWxzZUA1OgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3OC0xMDgyCiAgICAvLyByZXR1cm4gKAogICAgLy8gICB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDw9IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID09PSAwKQogICAgLy8gKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czo6UG9vbC5pc0VudGVyZWQoYWRkcmVzczogYnl0ZXMpIC0+IHVpbnQ2NDoKaXNFbnRlcmVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDg2LTEwODcKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gaXNFbnRlcmVkKGFkZHJlc3M6IEFkZHJlc3MpOiBib29sZWFuIHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxNTUKICAgIC8vIHVuaXF1ZXMgPSBCb3hNYXA8QWNjb3VudCwgdWludDY0Pih7IGtleVByZWZpeDogUG9vbEdsb2JhbFN0YXRlS2V5VW5pcXVlcyB9KQogICAgcHVzaGJ5dGVzICJ1IgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4OAogICAgLy8gcmV0dXJuIHRoaXMudW5pcXVlcyhhZGRyZXNzLm5hdGl2ZSkuZXhpc3RzOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjpQb29sLmdldFN0YXRlKCkgLT4gYnl0ZXM6CmdldFN0YXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMDUKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFBvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAic3RhdHVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjMgLy8gInRpdGxlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8UG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gInR5cGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTEKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVNpZ251cFRpbWVzdGFtcCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDI2IC8vICJzaWdudXBfdGltZXN0YW1wIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEzCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAyMiAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXJ0VGltZXN0YW1wIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTQgLy8gImVuZF90aW1lc3RhbXAiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTMgLy8gIm1heF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImVudHJ5X2NvdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEwMgogICAgLy8gZW50cnlDb3VudDogKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpLAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIzCiAgICAvLyByZXdhcmRJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVJld2FyZENvdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjUgLy8gInJld2FyZF9jb3VudCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMDMKICAgIC8vIHJld2FyZENvdW50OiAodGhpcy5yZXdhcmRJRC52YWx1ZSArIDEpLAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI1CiAgICAvLyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRvdGFsU3Rha2VkIH0pCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICJ0b3RhbF9zdGFrZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvY29udHJhY3QuYWxnby50czoxMzAKICAgIC8vIHN0YWtlS2V5ID0gR2xvYmFsU3RhdGU8Um9vdEtleT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YWtlS2V5IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjAgLy8gInN0YWtlX2tleSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gbWluaW11bVN0YWtlQW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWluaW11bVN0YWtlQW1vdW50IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjQgLy8gIm1pbmltdW1fc3Rha2VfYW1vdW50IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM0CiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJnYXRlX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiY3JlYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTMtMTEwOQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgc3RhdHVzOiB0aGlzLnN0YXR1cy52YWx1ZSwKICAgIC8vICAgdGl0bGU6IHRoaXMudGl0bGUudmFsdWUsCiAgICAvLyAgIHR5cGU6IHRoaXMudHlwZS52YWx1ZSwKICAgIC8vICAgc2lnbnVwVGltZXN0YW1wOiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgYWxsb3dMYXRlU2lnbnVwczogdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLAogICAgLy8gICBzdGFydFRpbWVzdGFtcDogdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgZW5kVGltZXN0YW1wOiB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgbWF4RW50cmllczogdGhpcy5tYXhFbnRyaWVzLnZhbHVlLAogICAgLy8gICBlbnRyeUNvdW50OiAodGhpcy5lbnRyeUlELnZhbHVlICsgMSksCiAgICAvLyAgIHJld2FyZENvdW50OiAodGhpcy5yZXdhcmRJRC52YWx1ZSArIDEpLAogICAgLy8gICB0b3RhbFN0YWtlZDogdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIC8vICAgc3Rha2VLZXk6IHRoaXMuc3Rha2VLZXkudmFsdWUsCiAgICAvLyAgIG1pbmltdW1TdGFrZUFtb3VudDogdGhpcy5taW5pbXVtU3Rha2VBbW91bnQudmFsdWUsCiAgICAvLyAgIGdhdGVJRDogdGhpcy5nYXRlSUQudmFsdWUsCiAgICAvLyAgIGNyZWF0b3I6IG5ldyBBZGRyZXNzKHRoaXMuY3JlYXRvci52YWx1ZSksCiAgICAvLyB9CiAgICBkaWcgMTMKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMTQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxNAogICAgcHVzaGJ5dGVzIDB4MDA2ZgogICAgY29uY2F0CiAgICBkaWcgMQogICAgbGVuCiAgICBwdXNoaW50IDExMSAvLyAxMTEKICAgICsKICAgIHN3YXAKICAgIHVuY292ZXIgMTUKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxNAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDEyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjXzIgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMTQKICAgIHNldGJpdAogICAgY29uY2F0CiAgICB1bmNvdmVyIDExCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMTAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciA5CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgOAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDcKICAgIGl0b2IKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2Jhc2UudHM6OkJhc2VQb29sLm1icih3aW5uaW5nVGlja2V0czogdWludDY0KSAtPiBieXRlczoKbWJyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvYmFzZS50czoxMy0xNAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBtYnIod2lubmluZ1RpY2tldHM6IHVpbnQ2NCk6IFBvb2xNQlJEYXRhIHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvYmFzZS50czo5CiAgICAvLyByZXR1cm4gTWluUG9vbFJld2FyZHNNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiB3aW5uaW5nVGlja2V0cykKICAgIGludGMgNCAvLyA0MDAKICAgIGZyYW1lX2RpZyAtMQogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3Bvb2wvYmFzZS50czoxNS0yMQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgZW50cmllczogUG9vbEVudHJpZXNNQlIsCiAgICAvLyAgIHVuaXF1ZXM6IFBvb2xVbmlxdWVzTUJSLAogICAgLy8gICBlbnRyaWVzQnlBZGRyZXNzOiBQb29sRW50cmllc0J5QWRkcmVzc01CUiwKICAgIC8vICAgcmV3YXJkczogdGhpcy5yZXdhcmRzTWJyKHdpbm5pbmdUaWNrZXRzKSwKICAgIC8vICAgZGlzYnVyc2VtZW50czogUG9vbERpc2J1cnNlbWVudFNNQlIKICAgIC8vIH0KICAgIGl0b2IKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDYyZDQwMDAwMDAwMDAwMDA0OWQ0MDAwMDAwMDAwMDAwNjJkNAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcG9vbC9iYXNlLnRzOjIwCiAgICAvLyBkaXNidXJzZW1lbnRzOiBQb29sRGlzYnVyc2VtZW50U01CUgogICAgcHVzaGludCA2MTAwIC8vIDYxMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9wb29sL2Jhc2UudHM6MTUtMjEKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGVudHJpZXM6IFBvb2xFbnRyaWVzTUJSLAogICAgLy8gICB1bmlxdWVzOiBQb29sVW5pcXVlc01CUiwKICAgIC8vICAgZW50cmllc0J5QWRkcmVzczogUG9vbEVudHJpZXNCeUFkZHJlc3NNQlIsCiAgICAvLyAgIHJld2FyZHM6IHRoaXMucmV3YXJkc01icih3aW5uaW5nVGlja2V0cyksCiAgICAvLyAgIGRpc2J1cnNlbWVudHM6IFBvb2xEaXNidXJzZW1lbnRTTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6OkFraXRhQmFzZUVzY3Jvdy5vcHRBa2l0YUVzY3Jvd0luQW5kU2VuZChuYW1lOiBieXRlcywgYXNzZXQ6IHVpbnQ2NCwgYW1vdW50OiB1aW50NjQpIC0+IHZvaWQ6Cm9wdEFraXRhRXNjcm93SW5BbmRTZW5kOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czoyMAogICAgLy8gb3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmQobmFtZTogc3RyaW5nLCBhc3NldDogQXNzZXQsIGFtb3VudDogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MjEtMzQKICAgIC8vIGFiaUNhbGwoCiAgICAvLyAgIEFraXRhREFPSW50ZXJmYWNlLnByb3RvdHlwZS5vcHRpblJlY2VpdmVFc2Nyb3csCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogdGhpcy5ha2l0YURBTy52YWx1ZSwKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgICByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgICBhbW91bnQ6IChHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiA0KSwKICAgIC8vICAgICAgIH0pLAogICAgLy8gICAgICAgbmFtZSwKICAgIC8vICAgICAgIGFzc2V0LmlkCiAgICAvLyAgICAgXSwKICAgIC8vICAgfSwKICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTYKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjcgLy8gImFraXRhX2VzY3JvdyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjI3CiAgICAvLyByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czoyOAogICAgLy8gYW1vdW50OiAoR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogNCksCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIHB1c2hpbnQgNCAvLyA0CiAgICAqCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czoyNi0yOQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiAoR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogNCksCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MjEtMzQKICAgIC8vIGFiaUNhbGwoCiAgICAvLyAgIEFraXRhREFPSW50ZXJmYWNlLnByb3RvdHlwZS5vcHRpblJlY2VpdmVFc2Nyb3csCiAgICAvLyAgIHsKICAgIC8vICAgICBhcHBJZDogdGhpcy5ha2l0YURBTy52YWx1ZSwKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgICByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgICBhbW91bnQ6IChHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiA0KSwKICAgIC8vICAgICAgIH0pLAogICAgLy8gICAgICAgbmFtZSwKICAgIC8vICAgICAgIGFzc2V0LmlkCiAgICAvLyAgICAgXSwKICAgIC8vICAgfSwKICAgIC8vICkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czoxNAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxOCAvLyAiYWtpdGFfZGFvIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MzAKICAgIC8vIG5hbWUsCiAgICBmcmFtZV9kaWcgLTMKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGZyYW1lX2RpZyAtMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjMxCiAgICAvLyBhc3NldC5pZAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjIxLTM0CiAgICAvLyBhYmlDYWxsKAogICAgLy8gICBBa2l0YURBT0ludGVyZmFjZS5wcm90b3R5cGUub3B0aW5SZWNlaXZlRXNjcm93LAogICAgLy8gICB7CiAgICAvLyAgICAgYXBwSWQ6IHRoaXMuYWtpdGFEQU8udmFsdWUsCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgICAgYW1vdW50OiAoR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogNCksCiAgICAvLyAgICAgICB9KSwKICAgIC8vICAgICAgIG5hbWUsCiAgICAvLyAgICAgICBhc3NldC5pZAogICAgLy8gICAgIF0sCiAgICAvLyAgIH0sCiAgICAvLyApCiAgICBwdXNoYnl0ZXMgMHgzY2MzZDBhNCAvLyBtZXRob2QgIm9wdGluUmVjZWl2ZUVzY3JvdyhwYXksc3RyaW5nLHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzIgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czozNgogICAgLy8gaWYgKGFtb3VudCA+IDApIHsKICAgIGZyYW1lX2RpZyAtMQogICAgYnogb3B0QWtpdGFFc2Nyb3dJbkFuZFNlbmRfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjM3LTQzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTYKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjcgLy8gImFraXRhX2VzY3JvdyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjM5CiAgICAvLyBhc3NldFJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czozNy00MgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MzctNDMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCm9wdEFraXRhRXNjcm93SW5BbmRTZW5kX2FmdGVyX2lmX2Vsc2VANToKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6OkFraXRhQmFzZUVzY3Jvdy51cGRhdGUobmV3VmVyc2lvbjogYnl0ZXMpIC0+IHZvaWQ6CnVwZGF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6NDktNTAKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgLy8gdXBkYXRlKG5ld1ZlcnNpb246IHN0cmluZyk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjUxCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTQKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTggLy8gImFraXRhX2RhbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjUxCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTIKICAgIC8vIHZlcnNpb24gPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVZlcnNpb24gfSkKICAgIHB1c2hieXRlcyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6NTIKICAgIC8vIHRoaXMudmVyc2lvbi52YWx1ZSA9IG5ld1ZlcnNpb24KICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6OkFraXRhQmFzZUVzY3Jvdy51cGRhdGVBa2l0YURBTyhhcHA6IHVpbnQ2NCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjU3CiAgICAvLyB1cGRhdGVBa2l0YURBTyhhcHA6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjU4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTQKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTggLy8gImFraXRhX2RhbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjU4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTQKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlYyAxOCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czo1OQogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IEFwcGxpY2F0aW9uKGFwcCkKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6OkFraXRhQmFzZUVzY3Jvdy51cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IHVpbnQ2NCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEQU9Fc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjYyCiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjYzCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTQKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTggLy8gImFraXRhX2RhbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZXNjcm93LnRzOjYzCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9lc2Nyb3cudHM6MTYKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBieXRlYyAyNyAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2VzY3Jvdy50czo2NAogICAgLy8gdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZSA9IEFwcGxpY2F0aW9uKGFwcCkKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1Ygo=","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CiALAAEGCJADoI0Grf7V5NSF/ahYz4Keu+/v3oIU0YKeu+/v3oIU/////w////////////8BJiELZW50cnlfY291bnQEFR98dQEACGFraXRhX2FsBHR5cGUBCgdnYXRlX2lkAgAAAWUBFAZzdGF0dXMHY3JlYXRvcgEeC21heF9lbnRyaWVzDWVuZF90aW1lc3RhbXABcg9zdGFydF90aW1lc3RhbXAUYWtpdGFfcm95YWx0eV9hbW91bnQJYWtpdGFfZGFvAYAJc3Rha2Vfa2V5DWFraXRhX3JveWFsdHkSYWxsb3dfbGF0ZV9zaWdudXBzBXRpdGxlFG1pbmltdW1fc3Rha2VfYW1vdW50DHJld2FyZF9jb3VudBBzaWdudXBfdGltZXN0YW1wDGFraXRhX2VzY3JvdwkAAAAAAAAAAAAEQOkU5gRzYWx0EmNvbnRyb2xsZWRfYWRkcmVzcxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxG0EAoYIWBNXzwGoEg/FHSASriyE6BD6hGDIEZFp7zAQPL8MSBBgegpEEaFWMcASpQY03BPxpnLMEbnayygTNsKxqBLIj010EWS7jQQSPpKFgBOM3c0IEcXBGSQSks+eJBIWHWEAE6pGA3QQz6SyUBB6tIKk2GgCOFgG9AbEBoAGGAWwBRwEvARMBAwDzAN8AzwC4AKMAjgB2AGYAUgA2ACIAEgACIkMxGRREMRhENhoBF4gW7yNDMRkURDEYRDYaAReIFsojQzEZgQQSRDEYRDYaAVcCAIgWmiNDMRkURDEYRDYaAVcCADYaAhfAMDYaAxeIFhkjQzEZFEQxGEQ2GgEXiBXeKUxQsCNDMRkURDEYRIgVISlMULAjQzEZFEQxGEQ2GgGIFQEqIk8CVClMULAjQzEZFEQxGESIFMAqIk8CVClMULAjQzEZFEQxGESIFH8qIk8CVClMULAjQzEZFEQxGEQ2GgE2GgIXiBRNKUxQsCNDMRkURDEYRDYaAReIE6EjQzEZFEQxGEQ2GgEXNhoCF4gLmCNDMRkURDEYRDYaAReICW4jQzEZFEQxGEQ2GgEXiAhDI0MxGRREMRhEMRYjCUk4ECMSRDYaATYaAogGGSNDMRkURDEYRDYaARc2GgIXNhoDF4gFayNDMRkURDEYRDEWgQIJSTgQIxJEMRYjCUk4EIEEEkQ2GgGIBSAjQzEZFEQxGEQxFiMJSTgQIxJENhoBiARJSCNDMRkURDEYRDEWIwlJOBAjEkQ2GgEXiAPSI0MxGYEFEkQxGEQ2GgGIA5MjQzEZFEQxGESIAzsjQzEZFEQxGBRENhoBVwIANhoCNhoDNhoENhoFNhoGFzYaBxc2GggXNhoJF4gCVyNDigEBi/+BEpGL/xuBG5EhCRqL/4E7kUqRTBwjHkUBgR8aTwJMkCEJGhmJigIBi/6ADmVzY3Jvd19mYWN0b3J5ZUixgAR5NFrcshqL/7IashgkshAisgGztD5JVwAEKRJEVwYASRVJQQAHiwElE0EABCKMAImLABdC//eKBAKxi/wrZUiBKFuL/haABJux0N2yGov9shqyGov/shqyGCSyECKyAbO0PklXBABMVwAEKRJEIlOL/4mKAQEiRwKAAEcDIicEZUQqE0AACyInBGVEJwUTQQDVI0SL/xYnCExQSYwCvkRJIQRTSwFXACCMAEsBVyAIjAFLAYEgW4wDTIEoW4wEQQAFJxyMAIkiJwRlRCcJEkEAU7EyCCtlSCJbgASDe+Q+shqLALIaiwGyGrIYJLIQIrIBs7Q+SVcABCkSRIEFW0mMBYsED0EACosFFicTTFCMAImLAkm+RCEEI1RLAbxIvyccjACJsTIIK2VIIluIADuLAxZMUCcdshqLALIashqyGCSyECKyAbO0PklXAAQpEkSBBFtJjAaLBA9B/7WLBhYnE0xQjACJIkL/KCInBGVESSoTRBcjCRZJkyUORFcHAYmKBAEyCCtlSCVbi/4iWYHEwgELTIv9QAAzsUlyCESLAIv/CLIIsgcjshAisgG2i/wWgAQJeakMshqyGov+shqyGCSyECKyAbOL/kyJsUlyCESLALIIsgcjshAisgG2SXIIRIv/shKL/bIRshSBBLIQIrIBtov8FoAEbzE3lrIashqL/rIashgkshAisgGzQv+3igkAJwoqZycXi/dnJwSL+GcnC4v5Z4ALbWFya2V0cGxhY2WL+mcnFIv7ZycYi/xnJwaL/WcnDYv+ZyceMRdnMghJjP+ADHN0YWtpbmdfZmVlc2VIMgiM/yInC2VEsYv/K2VIgWhbgAQKWTcNshqyGLIaJLIQIrIBs7Q+SVcEAExXAAQpEkQXSU4CSwElW04CTIEQW0wjDUEAF4sAIwmLAkmLAQlPAguB6AcKCScVTGeJI0L/6TIOMgkSRCInBmVEQQA9sTIIK2VIgShbIicGZUQWgATfVrAeshqyGrIYJLIQIrIBs7Q+SVcEAExXAAQpEkQXgAlnYXRlX3NpemVMZ4mKAQAxADIJEkQiJwtlRIv/EkQiJwplRCoSQAALMgciJw5lRA1BAAMjRIkiQv/6igIAMQAiJwtlRBJEMgOL/3AARQEUMhAjgQRPA00Li/44BzIKEov+OAhPAoHAPggSEESxMgqL/7IRIrISshSBBLIQIrIBs4ANc3Rha2luZ19wb29sc4v/IogQnomKAgEigAAxACInC2VEEkSL/yJbFEQiJxRlRFcAIDIDE0AAC4v/VwgBJwUTQQCMI0SL/1cIAUmMAIABKBJBABuL/4EJW4v/gTFbSYwBDUEAZosBgQoOQQBeI0SLACcMEkEAGCInDWVEQQAOIicNZUSL/4EJWw5BADojRIv/gQlbRIv+OAcyChKL/jgIi/+BMVshBAsPEEQiJxllREkjCCcZTGcWJw9MUEm8SIv/v4v/jACJIkL/wyJC/58iQv9xigMAi/44FDIKEov+OBGL/yJbEhCL/jgSIg0QRIv9i/+I/x+M/4mKAwCAADEAIicLZUQSRCInCmVEKhJEi/0yBw1AAA2L/UAAbyInFmVEQQBnI0SL/kEACIv+MgcNQQBUI0SL/owAi/5AABaL/UAAQCInFmVEQQA4I0QyB0mM/owAiwCM/ov/QQALi/6BCgiL/wxBABcjRCcai/1nJxCL/mcnDov/ZycKJwVniSJC/+YiQv/FIkL/qSJC/5aKAwAiRwOAAEcGiA4FRCInBmVEi/9MQQApMggxAIj6sEmMCjEAjANAAduLAzIIIicGZURMTgKL/4j65Yz/RIv/jAuLC4z/IihlRCMIIicNZUQMQAAIIicNZURAAaQjRIv+IllJjASBqIsDC0mMB4ABdTEAUL1FAUyMCEAACYsHgdSTAQiMCIsIi/04BzIKEov9OAhPAhIQRCInFGVESVcAIIwASYEgWUsBFVKMASKMBosGiwQMQQFIi/5XAgCLBklOAoECC0sBTFlPAiMISYwGiwRLAQlLAxVPAoECC0sETFlPAk1SSYwCJVtJjAkiJxhlRA9EiwAyAxNBAFKxMggrZUiBSFuLAkkiWxYBAUsBgRBZSwIVTwNOAlIjFoAEyUiWm7IaiwCyGosBshpPArIaTLIashqyGCSyECKyAbO0PklXBABMVwAEKRJEIlNEIicEZUQnBRJAAAsiJwRlRCcJEkEAGDEAiwIiW3AATIwFQQCKiwWLCQ9BAIIjRLEyCCtlSCJbMQCLAiJbiPrHTBZJTwJQJx2yGk8CshqyGkyyGCSyECKyAbO0PklXAAQpEkSBBFuLCUlOAg9EIihlREkjCChMZzEASwNQTwIWUIADADMAUIv/UEwWJwhLAVBJvEhPAr8xAE8CUElXACBMgSBbFlCAAWFMUEy/Qv60IkL/e4kiQv5ZiwonH2VIQv4eigEAiAv+RIv/FicPTFBHAr1FAUS+SElXWwFLAYEZW0sCgXRbTgNPAoERW04CTCoSRDIHSSInEGVECU8CGAlJMgcTQQDSiwGLAwxBAMojRCInF2VEgAogLSBSZXdhcmRzUDIHSYsCCDIIK2VIJVtLAxUhBEsBC4HkkwIISwJyCESxsgeyCCOyECKyAbYWVwYCTwRQTwMWTwMWIhaABByeu9uyGk8DshpPArIaTLIaJweyGkyyGCSyECKyAbO3AT5JVwQATFcABCkSRIsASb5ESwNcIUsBvEhKv0sDXClLAbxISr8nBVxbSwG8SEq/TwNcXEsBvEhKv08CXGRLAbxISr8yBhZcbEsBvEhKvzIHFlx0SwG8SL+JIkL/M4oBACJHA4AARweL/xYnD0xQRwK9RQFEvkhJV1sBSwGBOVlLAhVLA04CUksCgWxbSwOBU1tPBIEpW04ETwMnCRJETwIiWRRETCMIgQRPAgsIsTIIgAhvdGhlcl9hbGVIIltMFiInHmVESRUWVwYCTFCABBiTksWyGkyyGrIashgkshAisgGztD5JVwAEKRJEVwYASRVJQAAUiwxJvkRJgVNbIwgWXFNLAbxIv4kiiw9JTgIPIksCTwJNgRBLAg+BEE8DTwJNiw5OAlJJFYEQEkRJIlsiIQYdRQFJIQceRQFPAh5FASEGHUUBIQceTgJITwIlW0whCB5FAR5FASEGHUUBIQgeRQFMFkwWUIwCiw1JIQoMTIwLQQAGiw0jCIwLIhaMACcHjAGLC0EA54sLSSMNRCMJSYwEIw1EiwRJHCMeRQFMGIwKIowHiwKMA4sHgQ8MQQCMiwNJIltJjAkhBh1FASEHHklOAowFSEwlW4wIQABpgaKFvPbe372FKIsISSEGHUUBTwIeRQGLBRZMFlCLCYj16IEgkE8CiPXgGRZQSVcAEEyBEFtJjAaLCg9BACaLBosEGCMIFosBSU8CUEwiWSMIFlcGAlwAjAGLByMIjAeMA0L/dowDQv95IQhC/5yLA4ACABJQiwFQSYEQWUsBFVKLDElOAr5ESYE5WSJMWExQSwG8SEq/iwBcU0sBvEi/iSEKjARC/yCKAgAiRwuAAEcgi/4WJw9MUEcCvUUBRL5ISVdbAUlPAklXCAFOAkmBOVlLARVSTCcFEklAAAiLLicJEkEHsyNEizFBAhuLLb5ESYFcW0lOAowbSVcIAYwvSYEJW4wkIluMESKMEyKMKov/CCIoZUQNQQAJIihlRIsbCYz/ixuMH4sfi/8MQQEHix8WJwhMUEmMCL5ESSEEU0sBVwAgjABLAYEwWUsCFUsDTgJSjAlMgShbjCNAAF0iJwRlRCoSQQB1gAmAAAAAAAAAAAAiU0EAQyInBmVEQQBEMgiLAIj0rUmMK0AAR4sAMggiJwZlRExOAosJiPTmSEAAIiInBGVEJwUTQQAOiwhJvkQhBCNUSwG8SL+LHyMIjB9C/2OLEyMIjBOLKosjCIwqQv/niysnH2VIQv+yIicEZUQnBRJBAEaLCL5ESVcAIExXIAixMggrZUgiW4AEPn0lmrIaTwKyGkyyGicTshqyGCSyECKyAbO0PklXBABMVwAEKRJEFxYnE0xQQv9Fix+I9I1C/z2LLUm+REmBIVuLEwgWXCFLAbxISr9JgSlbiyoIFlwpSwG8SL8iKGVEixsSQQCOiy1JvkQnCVxbSwG8SEq/IhZcXEsBvEhMSwG/gSFbjCKLLycJEkEAUYsiiyQLIicVZURJIQUORB0hBZeMECcRixBnixFAABGxMgOLELIIsgcjshAisgGziTIDixFJTgJwAEUBRLEyA0yyEYsQshKyFIEEshAisgGziSInFWVESSEFDkSLJB0hBZeMEEL/r4stSb5ESYFcW4v/CBZcXEsBvEi/iYsvJwUSQQD+iy2+REkiW4wRSYFcW0lOAowbSYFkW4wMSYEpW4whgQlbjBCL/wgiKGVEDUEACSIoZUSLGwmM/yInEWVEixBMCYwNIhaMAicHjAYijCeLG4wfix+L/wxBAF+LHxYnCExQvkRJIQRTSwGBKFuMI0xXACCMAEAAOYsjSYshSU4DDEQhBR1PApdJIQUORIsNHSEFl0kWiwBMUIsGSU8CUEwiWSMIFlcGAlwAjAaLJwiMJ4sfIwiMH0L/mYstSb5ESYFcW4v/CBZcXEsBvEi/iwyLEYsGiyeI8+hIIihlRIsbi/8IEkH+x4stSb5EJwxcW0sBvEhKv4sCXFxLAbxIv4mLLycJEkEA/ostvkRJgWRbjAxJgVxbSU4CjBtJgSFbSwGBCVtPAiJbSU4DjBFMSwELIicRZUQJIicVZURJIQUOREsCHSEFl08CTAmMDzIKTwJwAEgORIv/CCIoZUQNQQAJIihlRIsbCYz/IhaMAycHjAYijCeLG4wfix+L/wxBAD+LHxYnCExQvkRJIQRTTFcAIIwAQAAgiw9JFosATFCLBklPAlBMIlkjCBZXBgJcAIwGiycIjCeLHyMIjB9C/7mLG4v/CIstSU4CvkRLARZcXEsCvEhPAky/iwyLEYsGiyeI8t1IIihlRBJB/cGLLUm+RCcMXFtLAbxISr+LA1xcSwG8SL+Jiy8nDBJBAOuLLb5ESYFkW4wMSYFcW0lOAowbSYEhW4wiSSJbSU4CjBGBCVtJTgKMJzIKTHAASCInEWVETwJMCUmMDg9Ei/8IIihlRA1BAAkiKGVEixsJjP+LDosiCowQIhaMBCcHjAaLG4wfix+L/wxBADmLHxYnCExQvkRJIQRTTFcAIIwAQAAaixAWiwBMUIsGSU8CUEwiWSMIFlcGAlwAjAaLHyMIjB9C/7+LG4v/CIstSU4CvkRLARZcXEsCvEhPAky/iwyLEYsGiyeI8epIIihlRBJB/M6LLUm+RCcMXFtLAbxISr+LBFxcSwG8SL+Jiy+AASgSRIswIllAAAaL/oj4dImLLb5ESYFkW4wMSYFcW0lOAowbSYExW4wsSYE5WUsBFUsCTgJSjAtJIltJTgKMEUmBCVtJTgOMJ1c7GIwKMgpMcABIIicRZURPAkwJSYwOD0SL/wgiKGVEDUEACSIoZUSLGwmM/4sOjBCLLEEAB4sOiywKjBCLCkklW0sBIltJTgKMKE8CgRBbjBmLC1cCAEmMAU8CJQtbjBciFowFJweMBkmMFowlixuMHYsdi/8MQQD5ix1JFicITFC+REkhBFOMHElXACCMAEmBIFuMEoEoW4sWSU8CCElOAowUixdJTwIPiyWMJosojCmLGYwaiwaMB0yMGIv/jCBPAoweTIwVQQFUixdJixRJTgMOiyWMJosojCmLGYwaiwaMB0yMGIv/jCCLHYweTIwVQQEqiwaMB4sZjBqLHEAAIIsQFosATFCLBklPAlBMIlkjCBZXBgJcAIsZIwiMGowHiweMBosajBmLCyJZIwmLKBJBAKyLLIsZE0EANYstSb5EiwVcXEsBvEhKvycgXDtLAbxISr9JgTlZIkxYJwdQSwG8SL+LDIsSiwaLJ4jwC0iJiwyLEYsGiyeI7/5IiyyLGRJBADOLLUm+RCcMXFtLAbxISr+LBVxcSwG8SEq/JyBcO0sBvEhKv0mBOVkiTFgnB1BLAbxIv4mLLUm+REmBXFuL/wgWXFxLAbxISr+LKBaLJRZQixkWUFw7SwG8SL+Ji/+LHQmM/4soIwhJJQuLAUxbiy1JvkSLBVxcSwG8SL8iRwKMJk8DjCmLGYwaiwaMB08CjBiL/4wgjBWMHosmjCWLKYwoixqMGYsHjAaLGIwXiyCM/4seixUjCIwWIwiMHUL+LCJC+EqKAQCL/xYnD0xQSb1FAURJvkhJV1sBSwFXZAhPAoFkW08CJwwSRDIIK2VIJVuxgARUJKWRshpPArIashgkshAisgGzFoABZExQIrlISb5IKlxbSwG8SEq/IhZMSwFcZEsCvEhLAksBv0sBXGxLArxISwJLAb9LAVxcSwK8SEsCSwG/SwFcIUsCvEhLAksBv0xcKUsBvEi/iYoCAYv/Fov+TFCAAWFMUL5EF4jtd4kiJwplRCoTQQAgMgciJxplRA1BABUyByInEGVEDEAACCInFmVEQQACI4kiiSInCmVEKhNBACAyByInEGVED0EAFTIHIicOZUQOQAAIIicOZURAAAIjiSKJigEBgAF1i/9QvUUBiSInCmVEIicXZUQiJwRlRCInGmVEIicWZUQiJxBlRCInDmVEIicNZUQiKGVEIwgiJxllRCMIIoAMdG90YWxfc3Rha2VkZUQiJxRlRCInGGVEIicGZUQiJwtlREsNFRZXBgJPDlBPDoACAG9QSwEVgW8ITE8PUE8OFlBPDBZQKiJPDlRQTwsWUE8KFlBPCRZQTwgWUE8HFlBMFlcGAlBPBBZQTwMWUE8CUExQTFCJigEBIQSL/wsWgBgAAAAAAABi1AAAAAAAAEnUAAAAAAAAYtRMUIHULxZQiYoDALEiJxtlRHIIRDIQgQQLsgiyByOyECKyAbYiJxJlRIv9FRZXBgKL/VCL/haABDzD0KSyGkyyGrIashgkshAisgGzi/9BABuxIicbZURyCESL/rIRi/+yErIUgQSyECKyAbOJigEAMQAiJxJlRHIIRBJEgAd2ZXJzaW9ui/9niYoBADEAIicSZURyCEQSRCcSi/9niYoBADEAIicSZURyCEQSRCcbi/9niQ==","clear":"CoEBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":5,"minor":0,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type ObjectC3416591 = {
  valid: boolean,
  balance: bigint
}


/**
 * Converts the ABI tuple representation of a ObjectC3416591 to the struct representation
 */
export function ObjectC3416591FromTuple(abiTuple: [boolean, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ObjectC3416591, APP_SPEC.structs) as ObjectC3416591
}

export type RootKey = {
  address: string,
  name: string
}


/**
 * Converts the ABI tuple representation of a RootKey to the struct representation
 */
export function RootKeyFromTuple(abiTuple: [string, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RootKey, APP_SPEC.structs) as RootKey
}

export type EntryData = {
  address: string,
  asset: bigint,
  quantity: bigint,
  gateArgs: Uint8Array[],
  disqualified: boolean
}


/**
 * Converts the ABI tuple representation of a EntryData to the struct representation
 */
export function EntryDataFromTuple(abiTuple: [string, bigint, bigint, Uint8Array[], boolean]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryData, APP_SPEC.structs) as EntryData
}

export type EntryKey = {
  address: string,
  asset: bigint
}


/**
 * Converts the ABI tuple representation of a EntryKey to the struct representation
 */
export function EntryKeyFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryKey, APP_SPEC.structs) as EntryKey
}

export type PoolMbrData = {
  entries: bigint,
  uniques: bigint,
  entriesByAddress: bigint,
  rewards: bigint,
  disbursements: bigint
}


/**
 * Converts the ABI tuple representation of a PoolMBRData to the struct representation
 */
export function PoolMbrDataFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PoolMBRData, APP_SPEC.structs) as PoolMbrData
}

export type PoolState = {
  status: number,
  title: string,
  type: number,
  signupTimestamp: bigint,
  startTimestamp: bigint,
  allowLateSignups: boolean,
  endTimestamp: bigint,
  maxEntries: bigint,
  entryCount: bigint,
  rewardCount: bigint,
  totalStaked: bigint,
  stakeKey: RootKey,
  minimumStakeAmount: bigint,
  gateId: bigint,
  creator: string
}


/**
 * Converts the ABI tuple representation of a PoolState to the struct representation
 */
export function PoolStateFromTuple(abiTuple: [number, string, number, bigint, bigint, boolean, bigint, bigint, bigint, bigint, bigint, [string, string], bigint, bigint, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PoolState, APP_SPEC.structs) as PoolState
}

export type RaffleCursor = {
  ticket: bigint,
  stake: bigint,
  disbursed: bigint
}


/**
 * Converts the ABI tuple representation of a RaffleCursor to the struct representation
 */
export function RaffleCursorFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RaffleCursor, APP_SPEC.structs) as RaffleCursor
}

export type Reward = {
  asset: bigint,
  distribution: number,
  rate: bigint,
  expiration: bigint,
  interval: bigint,
  qualifiedStakers: bigint,
  qualifiedStake: bigint,
  winnerCount: bigint,
  winningTickets: bigint[],
  raffleCursor: RaffleCursor,
  vrfFailureCount: bigint,
  phase: number,
  disbursementCursor: bigint,
  activeDisbursementId: bigint,
  activeDisbursementRoundStart: bigint,
  lastDisbursementTimestamp: bigint
}


/**
 * Converts the ABI tuple representation of a Reward to the struct representation
 */
export function RewardFromTuple(abiTuple: [bigint, number, bigint, bigint, bigint, bigint, bigint, bigint, bigint[], [bigint, bigint, bigint], bigint, number, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Reward, APP_SPEC.structs) as Reward
}

/**
 * The argument types for the Pool contract
 */
export type PoolArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void': {
      title: string
      type: bigint | number
      creator: string
      marketplace: string
      stakeKey: RootKey
      minimumStakeAmount: bigint | number
      gateId: bigint | number
      maxEntries: bigint | number
      akitaDao: bigint | number
    }
    'init()void': Record<string, never>
    'delete(address)void': {
      caller: string
    }
    'optin(pay,uint64)void': {
      /**
       * The payment transaction
       */
      payment: AppMethodCallTransactionArgument
      /**
       * The asset to be opted into
       */
      asset: bigint | number
    }
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      reward: Reward
    }
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      assetXfer: AppMethodCallTransactionArgument
      reward: Reward
    }
    'finalize(uint64,uint64,uint64)void': {
      signupTimestamp: bigint | number
      startTimestamp: bigint | number
      endTimestamp: bigint | number
    }
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': {
      payment: AppMethodCallTransactionArgument
      entries: [bigint | number, bigint | number, Uint8Array[]][]
      args: Uint8Array[]
    }
    'startDisbursement(uint64)void': {
      rewardId: bigint | number
    }
    'raffle(uint64)void': {
      rewardId: bigint | number
    }
    'disburseRewards(uint64,uint64)void': {
      rewardId: bigint | number
      iterationAmount: bigint | number
    }
    'finalizeDistribution(uint64)void': {
      rewardId: bigint | number
    }
    'check(address,uint64)(bool,uint64)': {
      address: string
      asset: bigint | number
    }
    'signUpsOpen()bool': Record<string, never>
    'isLive()bool': Record<string, never>
    'isEntered(address)bool': {
      address: string
    }
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': Record<string, never>
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': {
      winningTickets: bigint | number
    }
    'optAkitaEscrowInAndSend(string,asset,uint64)void': {
      name: string
      asset: bigint
      amount: bigint | number
    }
    'update(string)void': {
      newVersion: string
    }
    'updateAkitaDAO(uint64)void': {
      app: bigint | number
    }
    'updateAkitaDAOEscrow(uint64)void': {
      app: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void': [title: string, type: bigint | number, creator: string, marketplace: string, stakeKey: RootKey, minimumStakeAmount: bigint | number, gateId: bigint | number, maxEntries: bigint | number, akitaDao: bigint | number]
    'init()void': []
    'delete(address)void': [caller: string]
    'optin(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number]
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, reward: Reward]
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, reward: Reward]
    'finalize(uint64,uint64,uint64)void': [signupTimestamp: bigint | number, startTimestamp: bigint | number, endTimestamp: bigint | number]
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': [payment: AppMethodCallTransactionArgument, entries: [bigint | number, bigint | number, Uint8Array[]][], args: Uint8Array[]]
    'startDisbursement(uint64)void': [rewardId: bigint | number]
    'raffle(uint64)void': [rewardId: bigint | number]
    'disburseRewards(uint64,uint64)void': [rewardId: bigint | number, iterationAmount: bigint | number]
    'finalizeDistribution(uint64)void': [rewardId: bigint | number]
    'check(address,uint64)(bool,uint64)': [address: string, asset: bigint | number]
    'signUpsOpen()bool': []
    'isLive()bool': []
    'isEntered(address)bool': [address: string]
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': []
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': [winningTickets: bigint | number]
    'optAkitaEscrowInAndSend(string,asset,uint64)void': [name: string, asset: bigint, amount: bigint | number]
    'update(string)void': [newVersion: string]
    'updateAkitaDAO(uint64)void': [app: bigint | number]
    'updateAkitaDAOEscrow(uint64)void': [app: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type PoolReturns = {
  'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void': void
  'init()void': void
  'delete(address)void': void
  'optin(pay,uint64)void': void
  'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'finalize(uint64,uint64,uint64)void': void
  'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': void
  'startDisbursement(uint64)void': void
  'raffle(uint64)void': void
  'disburseRewards(uint64,uint64)void': void
  'finalizeDistribution(uint64)void': void
  'check(address,uint64)(bool,uint64)': ObjectC3416591
  'signUpsOpen()bool': boolean
  'isLive()bool': boolean
  'isEntered(address)bool': boolean
  'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': PoolState
  'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': PoolMbrData
  'optAkitaEscrowInAndSend(string,asset,uint64)void': void
  'update(string)void': void
  'updateAkitaDAO(uint64)void': void
  'updateAkitaDAOEscrow(uint64)void': void
}

/**
 * Defines the types of available calls and state of the Pool smart contract.
 */
export type PoolTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void' | 'create', {
      argsObj: PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']
      argsTuple: PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']
      returns: PoolReturns['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']
    }>
    & Record<'init()void' | 'init', {
      argsObj: PoolArgs['obj']['init()void']
      argsTuple: PoolArgs['tuple']['init()void']
      returns: PoolReturns['init()void']
    }>
    & Record<'delete(address)void' | 'delete', {
      argsObj: PoolArgs['obj']['delete(address)void']
      argsTuple: PoolArgs['tuple']['delete(address)void']
      returns: PoolReturns['delete(address)void']
    }>
    & Record<'optin(pay,uint64)void' | 'optin', {
      argsObj: PoolArgs['obj']['optin(pay,uint64)void']
      argsTuple: PoolArgs['tuple']['optin(pay,uint64)void']
      returns: PoolReturns['optin(pay,uint64)void']
    }>
    & Record<'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addReward', {
      argsObj: PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: PoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addRewardAsa', {
      argsObj: PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: PoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'finalize(uint64,uint64,uint64)void' | 'finalize', {
      argsObj: PoolArgs['obj']['finalize(uint64,uint64,uint64)void']
      argsTuple: PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']
      returns: PoolReturns['finalize(uint64,uint64,uint64)void']
    }>
    & Record<'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' | 'enter', {
      argsObj: PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      argsTuple: PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      returns: PoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
    }>
    & Record<'startDisbursement(uint64)void' | 'startDisbursement', {
      argsObj: PoolArgs['obj']['startDisbursement(uint64)void']
      argsTuple: PoolArgs['tuple']['startDisbursement(uint64)void']
      returns: PoolReturns['startDisbursement(uint64)void']
    }>
    & Record<'raffle(uint64)void' | 'raffle', {
      argsObj: PoolArgs['obj']['raffle(uint64)void']
      argsTuple: PoolArgs['tuple']['raffle(uint64)void']
      returns: PoolReturns['raffle(uint64)void']
    }>
    & Record<'disburseRewards(uint64,uint64)void' | 'disburseRewards', {
      argsObj: PoolArgs['obj']['disburseRewards(uint64,uint64)void']
      argsTuple: PoolArgs['tuple']['disburseRewards(uint64,uint64)void']
      returns: PoolReturns['disburseRewards(uint64,uint64)void']
    }>
    & Record<'finalizeDistribution(uint64)void' | 'finalizeDistribution', {
      argsObj: PoolArgs['obj']['finalizeDistribution(uint64)void']
      argsTuple: PoolArgs['tuple']['finalizeDistribution(uint64)void']
      returns: PoolReturns['finalizeDistribution(uint64)void']
    }>
    & Record<'check(address,uint64)(bool,uint64)' | 'check', {
      argsObj: PoolArgs['obj']['check(address,uint64)(bool,uint64)']
      argsTuple: PoolArgs['tuple']['check(address,uint64)(bool,uint64)']
      returns: PoolReturns['check(address,uint64)(bool,uint64)']
    }>
    & Record<'signUpsOpen()bool' | 'signUpsOpen', {
      argsObj: PoolArgs['obj']['signUpsOpen()bool']
      argsTuple: PoolArgs['tuple']['signUpsOpen()bool']
      /**
       * a boolean of whether sign ups are open
       */
      returns: PoolReturns['signUpsOpen()bool']
    }>
    & Record<'isLive()bool' | 'isLive', {
      argsObj: PoolArgs['obj']['isLive()bool']
      argsTuple: PoolArgs['tuple']['isLive()bool']
      /**
       * a boolean of whether the pool is live
       */
      returns: PoolReturns['isLive()bool']
    }>
    & Record<'isEntered(address)bool' | 'isEntered', {
      argsObj: PoolArgs['obj']['isEntered(address)bool']
      argsTuple: PoolArgs['tuple']['isEntered(address)bool']
      /**
       * a boolean indicating if the address has entered the staking pool
       */
      returns: PoolReturns['isEntered(address)bool']
    }>
    & Record<'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' | 'getState', {
      argsObj: PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      argsTuple: PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      returns: PoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
    }>
    & Record<'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' | 'mbr', {
      argsObj: PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      /**
       * the mbr created for each boxmap entry
       */
      returns: PoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
    }>
    & Record<'optAkitaEscrowInAndSend(string,asset,uint64)void' | 'optAkitaEscrowInAndSend', {
      argsObj: PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void']
      argsTuple: PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']
      returns: PoolReturns['optAkitaEscrowInAndSend(string,asset,uint64)void']
    }>
    & Record<'update(string)void' | 'update', {
      argsObj: PoolArgs['obj']['update(string)void']
      argsTuple: PoolArgs['tuple']['update(string)void']
      returns: PoolReturns['update(string)void']
    }>
    & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
      argsObj: PoolArgs['obj']['updateAkitaDAO(uint64)void']
      argsTuple: PoolArgs['tuple']['updateAkitaDAO(uint64)void']
      returns: PoolReturns['updateAkitaDAO(uint64)void']
    }>
    & Record<'updateAkitaDAOEscrow(uint64)void' | 'updateAkitaDAOEscrow', {
      argsObj: PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void']
      argsTuple: PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']
      returns: PoolReturns['updateAkitaDAOEscrow(uint64)void']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        /**
         * the status the pool is in
         */
        status: number
        /**
         * title of the staking pool
         */
        title: string
        /**
         * the method of staking to be used for the pool
         */
        type: number
        /**
         * the timestamp when sign ups for the pool are allowed
         */
        signupTimestamp: bigint
        /**
         * whether signups are allowed after the staking pool begins
         */
        allowLateSignups: bigint
        /**
         * the timestamp when the pool starts
         */
        startTimestamp: bigint
        /**
         * the timestamp when the pool ends
         */
        endTimestamp: bigint
        /**
         * the maximum entries allowed for the pool
         */
        maxEntries: bigint
        /**
         * the number of entries in a pool
         */
        entryId: bigint
        /**
         * the number of rewards for the pool
         */
        rewardId: bigint
        /**
         * the total amount staked in the pool
         */
        totalStaked: bigint
        /**
        * the name for the meta merkle asset group to validate staking
        stake key can be empty if distribution !== DistributionTypePercentage

         */
        stakeKey: RootKey
        /**
         * minimum stake amount
         */
        minimumStakeAmount: bigint
        /**
         * the gate id of the pool
         */
        gateId: bigint
        /**
         * the size of the gate were using
         */
        gateSize: bigint
        /**
         * the address of the creator of the staking pool
         */
        creator: string
        /**
         * marketplace is pool creation side marketplace
         */
        marketplace: string
        /**
         * the amount the marketplaces will get for the sale
         */
        marketplaceRoyalties: bigint
        /**
         * the akita royalty for the pool
         */
        akitaRoyalty: bigint
        /**
         * the amount of royalties that were paid in a disbursement
         */
        akitaRoyaltyAmount: bigint
        /**
         * salt for randomness
         */
        salt: BinaryState
        /**
         * the current version of the contract
         */
        version: string
        /**
         * the app ID of the Akita DAO
         */
        akitaDao: bigint
        /**
         * the escrow account to use when making payments to the Akita DAO
         */
        akitaDaoEscrow: bigint
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        /**
         * indexed entries for efficient iteration
         */
        entries: Map<bigint | number, EntryData>
        /**
         * the number of unique asset entries by address
         */
        uniques: Map<string, bigint>
        /**
         * the entries in the pool
         */
        entriesByAddress: Map<EntryKey, bigint>
        /**
         * the rewards for this staking pool
         */
        rewards: Map<bigint | number, Reward>
        /**
         * the disbursements this pool as created & finalized
         */
        disbursements: Map<bigint | number, Uint8Array>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type PoolSignatures = keyof PoolTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type PoolNonVoidMethodSignatures = keyof PoolTypes['methods'] extends infer T ? T extends keyof PoolTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the Pool smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends PoolSignatures> = PoolTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Pool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends PoolSignatures> = PoolTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = PoolTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = PoolTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type PoolCreateCallParams =
  | Expand<CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & {method: 'create'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & {method: 'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type PoolUpdateCallParams =
  | Expand<CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & {method: 'update'}>
  | Expand<CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & {method: 'update(string)void'}>
/**
 * Defines supported delete method params for this smart contract
 */
export type PoolDeleteCallParams =
  | Expand<CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']> & {method: 'delete'}>
  | Expand<CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']> & {method: 'delete(address)void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type PoolDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: PoolCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: PoolUpdateCallParams
  /**
   * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  deleteParams?: PoolDeleteCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Pool smart contract
 */
export abstract class PoolParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends PoolCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'create':
          case 'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void':
            return PoolParamsFactory.create.create(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the Pool smart contract using the create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params: CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.title, params.args.type, params.args.creator, params.args.marketplace, params.args.stakeKey, params.args.minimumStakeAmount, params.args.gateId, params.args.maxEntries, params.args.akitaDao],
        }
      },
    }
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends PoolUpdateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'update':
          case 'update(string)void':
            return PoolParamsFactory.update.update(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs update ABI call params for the Pool smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: 'update(string)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.newVersion],
        }
      },
    }
  }

  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod<TParams extends PoolDeleteCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'delete':
          case 'delete(address)void':
            return PoolParamsFactory.delete.delete(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs delete ABI call params for the Pool smart contract using the delete(address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      delete(params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'delete(address)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.caller],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the init()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static init(params: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'init()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the optin(pay,uint64)void ABI method
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optin(params: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'optin(pay,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addReward(params: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addRewardAsa(params: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.assetXfer, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the finalize(uint64,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalize(params: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalize(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.signupTimestamp, params.args.startTimestamp, params.args.endTimestamp],
    }
  }
  /**
   * Constructs a no op call for the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static enter(params: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.entries, params.args.args],
    }
  }
  /**
   * Constructs a no op call for the startDisbursement(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static startDisbursement(params: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'startDisbursement(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the raffle(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static raffle(params: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'raffle(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the disburseRewards(uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static disburseRewards(params: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'disburseRewards(uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId, params.args.iterationAmount],
    }
  }
  /**
   * Constructs a no op call for the finalizeDistribution(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeDistribution(params: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalizeDistribution(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the check(address,uint64)(bool,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static check(params: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'check(address,uint64)(bool,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the signUpsOpen()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static signUpsOpen(params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'signUpsOpen()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isLive()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isLive(params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isLive()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isEntered(address)bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isEntered(params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isEntered(address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address],
    }
  }
  /**
   * Constructs a no op call for the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getState(params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.winningTickets],
    }
  }
  /**
   * Constructs a no op call for the optAkitaEscrowInAndSend(string,asset,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optAkitaEscrowInAndSend(params: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'optAkitaEscrowInAndSend(string,asset,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.name, params.args.asset, params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAO(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.app],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoEscrow(params: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAOEscrow(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.app],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the Pool smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class PoolFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `PoolFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new PoolClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new PoolClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the Pool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: PoolDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? PoolParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (PoolCreateCallParams & { args: Uint8Array[] }) : undefined,
      updateParams: params.updateParams?.method ? PoolParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams as (PoolUpdateCallParams & { args: Uint8Array[] }) : undefined,
      deleteParams: params.deleteParams?.method ? PoolParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams as (PoolDeleteCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new PoolClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Pool smart contract using the create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params: CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(PoolParamsFactory.create.create(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the Pool smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appFactory.params.deployUpdate(PoolParamsFactory.update.update(params))
      },
    },

    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the Pool smart contract using the delete(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      delete: (params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>) => {
        return this.appFactory.params.deployDelete(PoolParamsFactory.delete.delete(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Pool smart contract using the create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params: CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(PoolParamsFactory.create.create(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Pool smart contract using an ABI method call using the create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params: CallParams<PoolArgs['obj']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void'] | PoolArgs['tuple']['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(PoolParamsFactory.create.create(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | PoolReturns['create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void']) }, appClient: new PoolClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the Pool smart contract
 */
export class PoolClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `PoolClient`
   *
   * @param appClient An `AppClient` instance which has been created with the Pool app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `PoolClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends PoolNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `PoolClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<PoolClient> {
    return new PoolClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `PoolClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<PoolClient> {
    return new PoolClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Pool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.params.update(PoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the Pool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      delete: (params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.params.delete(PoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Pool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the Pool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    init: (params: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(PoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `optin(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optin: (params: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.optin(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addReward: (params: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addRewardAsa: (params: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalize: (params: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    enter: (params: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    startDisbursement: (params: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    raffle: (params: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    disburseRewards: (params: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeDistribution: (params: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    check: (params: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(PoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(PoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getState: (params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(PoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.mbr(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `optAkitaEscrowInAndSend(string,asset,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optAkitaEscrowInAndSend: (params: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.optAkitaEscrowInAndSend(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoEscrow: (params: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(PoolParamsFactory.updateAkitaDaoEscrow(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Pool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.createTransaction.update(PoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the Pool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      delete: (params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.createTransaction.delete(PoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Pool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the Pool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    init: (params: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `optin(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optin: (params: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.optin(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addReward: (params: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addRewardAsa: (params: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalize: (params: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    enter: (params: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    startDisbursement: (params: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    raffle: (params: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    disburseRewards: (params: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeDistribution: (params: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    check: (params: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getState: (params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.mbr(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `optAkitaEscrowInAndSend(string,asset,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optAkitaEscrowInAndSend: (params: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.optAkitaEscrowInAndSend(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoEscrow: (params: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(PoolParamsFactory.updateAkitaDaoEscrow(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Pool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams & SendParams) => {
        const result = await this.appClient.send.update(PoolParamsFactory.update.update(params))
        return {...result, return: result.return as unknown as (undefined | PoolReturns['update(string)void'])}
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the Pool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      delete: async (params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']> & SendParams) => {
        const result = await this.appClient.send.delete(PoolParamsFactory.delete.delete(params))
        return {...result, return: result.return as unknown as (undefined | PoolReturns['delete(address)void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Pool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the Pool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    init: async (params: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.init(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['init()void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `optin(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optin: async (params: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.optin(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['optin(pay,uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addReward: async (params: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.addReward(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addRewardAsa: async (params: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.addRewardAsa(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalize: async (params: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.finalize(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['finalize(uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    enter: async (params: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.enter(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    startDisbursement: async (params: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.startDisbursement(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['startDisbursement(uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    raffle: async (params: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.raffle(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['raffle(uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    disburseRewards: async (params: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.disburseRewards(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['disburseRewards(uint64,uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeDistribution: async (params: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.finalizeDistribution(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['finalizeDistribution(uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    check: async (params: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.check(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['check(address,uint64)(bool,uint64)'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether sign ups are open
     */
    signUpsOpen: async (params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.signUpsOpen(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['signUpsOpen()bool'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether the pool is live
     */
    isLive: async (params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.isLive(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['isLive()bool'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean indicating if the address has entered the staking pool
     */
    isEntered: async (params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.isEntered(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['isEntered(address)bool'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getState: async (params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.getState(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: the mbr created for each boxmap entry
     */
    mbr: async (params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.mbr(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `optAkitaEscrowInAndSend(string,asset,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optAkitaEscrowInAndSend: async (params: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.optAkitaEscrowInAndSend(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['optAkitaEscrowInAndSend(string,asset,uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.updateAkitaDao(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['updateAkitaDAO(uint64)void'])}
    },

    /**
     * Makes a call to the Pool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoEscrow: async (params: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(PoolParamsFactory.updateAkitaDaoEscrow(params))
      return {...result, return: result.return as unknown as (undefined | PoolReturns['updateAkitaDAOEscrow(uint64)void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new PoolClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the Pool smart contract using the `signUpsOpen()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether sign ups are open
   */
  async signUpsOpen(params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> = {args: []}) {
    const result = await this.appClient.send.call(PoolParamsFactory.signUpsOpen(params))
    return result.return as unknown as PoolReturns['signUpsOpen()bool']
  }

  /**
   * Makes a readonly (simulated) call to the Pool smart contract using the `isLive()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether the pool is live
   */
  async isLive(params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> = {args: []}) {
    const result = await this.appClient.send.call(PoolParamsFactory.isLive(params))
    return result.return as unknown as PoolReturns['isLive()bool']
  }

  /**
   * Makes a readonly (simulated) call to the Pool smart contract using the `isEntered(address)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean indicating if the address has entered the staking pool
   */
  async isEntered(params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']>) {
    const result = await this.appClient.send.call(PoolParamsFactory.isEntered(params))
    return result.return as unknown as PoolReturns['isEntered(address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the Pool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getState(params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> = {args: []}) {
    const result = await this.appClient.send.call(PoolParamsFactory.getState(params))
    return result.return as unknown as PoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
  }

  /**
   * Makes a readonly (simulated) call to the Pool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: the mbr created for each boxmap entry
   */
  async mbr(params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(PoolParamsFactory.mbr(params))
    return result.return as unknown as PoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Methods to access state for the current Pool app
   */
  state = {
    /**
     * Methods to access global state for the current Pool app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          status: result.status,
          title: result.title,
          type: result.type,
          signupTimestamp: result.signupTimestamp,
          allowLateSignups: result.allowLateSignups,
          startTimestamp: result.startTimestamp,
          endTimestamp: result.endTimestamp,
          maxEntries: result.maxEntries,
          entryId: result.entryID,
          rewardId: result.rewardID,
          totalStaked: result.totalStaked,
          stakeKey: result.stakeKey,
          minimumStakeAmount: result.minimumStakeAmount,
          gateId: result.gateID,
          gateSize: result.gateSize,
          creator: result.creator,
          marketplace: result.marketplace,
          marketplaceRoyalties: result.marketplaceRoyalties,
          akitaRoyalty: result.akitaRoyalty,
          akitaRoyaltyAmount: result.akitaRoyaltyAmount,
          salt: new BinaryStateValue(result.salt),
          version: result.version,
          akitaDao: result.akitaDAO,
          akitaDaoEscrow: result.akitaDAOEscrow,
        }
      },
      /**
       * Get the current value of the status key in global state
       */
      status: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("status")) as number | undefined },
      /**
       * Get the current value of the title key in global state
       */
      title: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("title")) as string | undefined },
      /**
       * Get the current value of the type key in global state
       */
      type: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("type")) as number | undefined },
      /**
       * Get the current value of the signupTimestamp key in global state
       */
      signupTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("signupTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the allowLateSignups key in global state
       */
      allowLateSignups: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("allowLateSignups")) as bigint | undefined },
      /**
       * Get the current value of the startTimestamp key in global state
       */
      startTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("startTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the endTimestamp key in global state
       */
      endTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("endTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the maxEntries key in global state
       */
      maxEntries: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("maxEntries")) as bigint | undefined },
      /**
       * Get the current value of the entryID key in global state
       */
      entryId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("entryID")) as bigint | undefined },
      /**
       * Get the current value of the rewardID key in global state
       */
      rewardId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("rewardID")) as bigint | undefined },
      /**
       * Get the current value of the totalStaked key in global state
       */
      totalStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("totalStaked")) as bigint | undefined },
      /**
       * Get the current value of the stakeKey key in global state
       */
      stakeKey: async (): Promise<RootKey | undefined> => { return (await this.appClient.state.global.getValue("stakeKey")) as RootKey | undefined },
      /**
       * Get the current value of the minimumStakeAmount key in global state
       */
      minimumStakeAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("minimumStakeAmount")) as bigint | undefined },
      /**
       * Get the current value of the gateID key in global state
       */
      gateId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateID")) as bigint | undefined },
      /**
       * Get the current value of the gateSize key in global state
       */
      gateSize: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateSize")) as bigint | undefined },
      /**
       * Get the current value of the creator key in global state
       */
      creator: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("creator")) as string | undefined },
      /**
       * Get the current value of the marketplace key in global state
       */
      marketplace: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("marketplace")) as string | undefined },
      /**
       * Get the current value of the marketplaceRoyalties key in global state
       */
      marketplaceRoyalties: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("marketplaceRoyalties")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyalty key in global state
       */
      akitaRoyalty: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyalty")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyaltyAmount key in global state
       */
      akitaRoyaltyAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyaltyAmount")) as bigint | undefined },
      /**
       * Get the current value of the salt key in global state
       */
      salt: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("salt")) as Uint8Array | undefined) },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("version")) as string | undefined },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAO")) as bigint | undefined },
      /**
       * Get the current value of the akitaDAOEscrow key in global state
       */
      akitaDaoEscrow: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAOEscrow")) as bigint | undefined },
    },
    /**
     * Methods to access box state for the current Pool app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the entries map in box state
       */
      entries: {
        /**
         * Get all current values of the entries map in box state
         */
        getMap: async (): Promise<Map<bigint, EntryData>> => { return (await this.appClient.state.box.getMap("entries")) as Map<bigint, EntryData> },
        /**
         * Get a current value of the entries map by key from box state
         */
        value: async (key: bigint | number): Promise<EntryData | undefined> => { return await this.appClient.state.box.getMapValue("entries", key) as EntryData | undefined },
      },
      /**
       * Get values from the uniques map in box state
       */
      uniques: {
        /**
         * Get all current values of the uniques map in box state
         */
        getMap: async (): Promise<Map<string, bigint>> => { return (await this.appClient.state.box.getMap("uniques")) as Map<string, bigint> },
        /**
         * Get a current value of the uniques map by key from box state
         */
        value: async (key: string): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("uniques", key) as bigint | undefined },
      },
      /**
       * Get values from the entriesByAddress map in box state
       */
      entriesByAddress: {
        /**
         * Get all current values of the entriesByAddress map in box state
         */
        getMap: async (): Promise<Map<EntryKey, bigint>> => { return (await this.appClient.state.box.getMap("entriesByAddress")) as Map<EntryKey, bigint> },
        /**
         * Get a current value of the entriesByAddress map by key from box state
         */
        value: async (key: EntryKey): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("entriesByAddress", key) as bigint | undefined },
      },
      /**
       * Get values from the rewards map in box state
       */
      rewards: {
        /**
         * Get all current values of the rewards map in box state
         */
        getMap: async (): Promise<Map<bigint, Reward>> => { return (await this.appClient.state.box.getMap("rewards")) as Map<bigint, Reward> },
        /**
         * Get a current value of the rewards map by key from box state
         */
        value: async (key: bigint | number): Promise<Reward | undefined> => { return await this.appClient.state.box.getMapValue("rewards", key) as Reward | undefined },
      },
      /**
       * Get values from the disbursements map in box state
       */
      disbursements: {
        /**
         * Get all current values of the disbursements map in box state
         */
        getMap: async (): Promise<Map<bigint, Uint8Array>> => { return (await this.appClient.state.box.getMap("disbursements")) as Map<bigint, Uint8Array> },
        /**
         * Get a current value of the disbursements map by key from box state
         */
        value: async (key: bigint | number): Promise<Uint8Array | undefined> => { return await this.appClient.state.box.getMapValue("disbursements", key) as Uint8Array | undefined },
      },
    },
  }

  public newGroup(): PoolComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a init()void method call against the Pool contract
       */
      init(params: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.init(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a optin(pay,uint64)void method call against the Pool contract
       */
      optin(params: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optin(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the Pool contract
       */
      addReward(params: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addReward(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the Pool contract
       */
      addRewardAsa(params: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addRewardAsa(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalize(uint64,uint64,uint64)void method call against the Pool contract
       */
      finalize(params: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalize(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a enter(pay,(uint64,uint64,byte[32][])[],byte[][])void method call against the Pool contract
       */
      enter(params: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.enter(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a startDisbursement(uint64)void method call against the Pool contract
       */
      startDisbursement(params: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.startDisbursement(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a raffle(uint64)void method call against the Pool contract
       */
      raffle(params: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.raffle(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a disburseRewards(uint64,uint64)void method call against the Pool contract
       */
      disburseRewards(params: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.disburseRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalizeDistribution(uint64)void method call against the Pool contract
       */
      finalizeDistribution(params: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeDistribution(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a check(address,uint64)(bool,uint64) method call against the Pool contract
       */
      check(params: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.check(params)))
        resultMappers.push((v) => client.decodeReturnValue('check(address,uint64)(bool,uint64)', v))
        return this
      },
      /**
       * Add a signUpsOpen()bool method call against the Pool contract
       */
      signUpsOpen(params: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.signUpsOpen(params)))
        resultMappers.push((v) => client.decodeReturnValue('signUpsOpen()bool', v))
        return this
      },
      /**
       * Add a isLive()bool method call against the Pool contract
       */
      isLive(params: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isLive(params)))
        resultMappers.push((v) => client.decodeReturnValue('isLive()bool', v))
        return this
      },
      /**
       * Add a isEntered(address)bool method call against the Pool contract
       */
      isEntered(params: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isEntered(params)))
        resultMappers.push((v) => client.decodeReturnValue('isEntered(address)bool', v))
        return this
      },
      /**
       * Add a getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) method call against the Pool contract
       */
      getState(params: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getState(params)))
        resultMappers.push((v) => client.decodeReturnValue('getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)', v))
        return this
      },
      /**
       * Add a mbr(uint64)(uint64,uint64,uint64,uint64,uint64) method call against the Pool contract
       */
      mbr(params: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)))
        resultMappers.push((v) => client.decodeReturnValue('mbr(uint64)(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a optAkitaEscrowInAndSend(string,asset,uint64)void method call against the Pool contract
       */
      optAkitaEscrowInAndSend(params: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optAkitaEscrowInAndSend(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the Pool contract
       */
      updateAkitaDao(params: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAkitaDAOEscrow(uint64)void method call against the Pool contract
       */
      updateAkitaDaoEscrow(params: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoEscrow(params)))
        resultMappers.push(undefined)
        return this
      },
      get update() {
        return {
          update: (params: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      get delete() {
        return {
          delete: (params: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.delete(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the Pool contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as PoolComposer
  }
}
export type PoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the init()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  init(params?: CallParams<PoolArgs['obj']['init()void'] | PoolArgs['tuple']['init()void']>): PoolComposer<[...TReturns, PoolReturns['init()void'] | undefined]>

  /**
   * Calls the optin(pay,uint64)void ABI method.
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  optin(params?: CallParams<PoolArgs['obj']['optin(pay,uint64)void'] | PoolArgs['tuple']['optin(pay,uint64)void']>): PoolComposer<[...TReturns, PoolReturns['optin(pay,uint64)void'] | undefined]>

  /**
   * Calls the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addReward(params?: CallParams<PoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): PoolComposer<[...TReturns, PoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addRewardAsa(params?: CallParams<PoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | PoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): PoolComposer<[...TReturns, PoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the finalize(uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalize(params?: CallParams<PoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | PoolArgs['tuple']['finalize(uint64,uint64,uint64)void']>): PoolComposer<[...TReturns, PoolReturns['finalize(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  enter(params?: CallParams<PoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | PoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']>): PoolComposer<[...TReturns, PoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | undefined]>

  /**
   * Calls the startDisbursement(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startDisbursement(params?: CallParams<PoolArgs['obj']['startDisbursement(uint64)void'] | PoolArgs['tuple']['startDisbursement(uint64)void']>): PoolComposer<[...TReturns, PoolReturns['startDisbursement(uint64)void'] | undefined]>

  /**
   * Calls the raffle(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  raffle(params?: CallParams<PoolArgs['obj']['raffle(uint64)void'] | PoolArgs['tuple']['raffle(uint64)void']>): PoolComposer<[...TReturns, PoolReturns['raffle(uint64)void'] | undefined]>

  /**
   * Calls the disburseRewards(uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  disburseRewards(params?: CallParams<PoolArgs['obj']['disburseRewards(uint64,uint64)void'] | PoolArgs['tuple']['disburseRewards(uint64,uint64)void']>): PoolComposer<[...TReturns, PoolReturns['disburseRewards(uint64,uint64)void'] | undefined]>

  /**
   * Calls the finalizeDistribution(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalizeDistribution(params?: CallParams<PoolArgs['obj']['finalizeDistribution(uint64)void'] | PoolArgs['tuple']['finalizeDistribution(uint64)void']>): PoolComposer<[...TReturns, PoolReturns['finalizeDistribution(uint64)void'] | undefined]>

  /**
   * Calls the check(address,uint64)(bool,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  check(params?: CallParams<PoolArgs['obj']['check(address,uint64)(bool,uint64)'] | PoolArgs['tuple']['check(address,uint64)(bool,uint64)']>): PoolComposer<[...TReturns, PoolReturns['check(address,uint64)(bool,uint64)'] | undefined]>

  /**
   * Calls the signUpsOpen()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  signUpsOpen(params?: CallParams<PoolArgs['obj']['signUpsOpen()bool'] | PoolArgs['tuple']['signUpsOpen()bool']>): PoolComposer<[...TReturns, PoolReturns['signUpsOpen()bool'] | undefined]>

  /**
   * Calls the isLive()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isLive(params?: CallParams<PoolArgs['obj']['isLive()bool'] | PoolArgs['tuple']['isLive()bool']>): PoolComposer<[...TReturns, PoolReturns['isLive()bool'] | undefined]>

  /**
   * Calls the isEntered(address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isEntered(params?: CallParams<PoolArgs['obj']['isEntered(address)bool'] | PoolArgs['tuple']['isEntered(address)bool']>): PoolComposer<[...TReturns, PoolReturns['isEntered(address)bool'] | undefined]>

  /**
   * Calls the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getState(params?: CallParams<PoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | PoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']>): PoolComposer<[...TReturns, PoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | undefined]>

  /**
   * Calls the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mbr(params?: CallParams<PoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | PoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>): PoolComposer<[...TReturns, PoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the optAkitaEscrowInAndSend(string,asset,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  optAkitaEscrowInAndSend(params?: CallParams<PoolArgs['obj']['optAkitaEscrowInAndSend(string,asset,uint64)void'] | PoolArgs['tuple']['optAkitaEscrowInAndSend(string,asset,uint64)void']>): PoolComposer<[...TReturns, PoolReturns['optAkitaEscrowInAndSend(string,asset,uint64)void'] | undefined]>

  /**
   * Calls the updateAkitaDAO(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDao(params?: CallParams<PoolArgs['obj']['updateAkitaDAO(uint64)void'] | PoolArgs['tuple']['updateAkitaDAO(uint64)void']>): PoolComposer<[...TReturns, PoolReturns['updateAkitaDAO(uint64)void'] | undefined]>

  /**
   * Calls the updateAkitaDAOEscrow(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDaoEscrow(params?: CallParams<PoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | PoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']>): PoolComposer<[...TReturns, PoolReturns['updateAkitaDAOEscrow(uint64)void'] | undefined]>

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the Pool smart contract using the delete(address)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    delete(params?: CallParams<PoolArgs['obj']['delete(address)void'] | PoolArgs['tuple']['delete(address)void']>): PoolComposer<[...TReturns, PoolReturns['delete(address)void'] | undefined]>
  }

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the Pool smart contract using the update(string)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    update(params?: CallParams<PoolArgs['obj']['update(string)void'] | PoolArgs['tuple']['update(string)void']>): PoolComposer<[...TReturns, PoolReturns['update(string)void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the Pool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): PoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): PoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<PoolComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<PoolComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<PoolComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<PoolComposerResults<TReturns>>
}
export type PoolComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

