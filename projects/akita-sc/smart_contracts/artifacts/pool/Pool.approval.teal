#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 92 100000 6364136223846793005 400 1442695040888963407 1442695040888963409 4294967295 18446744073709551615
    bytecblock 0x151f7c75 "entry_count" 0x00 "akita_al" "type" 0x0a "gate_id" 0x0000 "status" "creator" "akita_dao" 0x14 "e" 0x1e "max_entries" "end_timestamp" "wallet" "start_timestamp" "r" "akita_royalty_amount" "stake_key" "akita_royalty" "allow_late_signups" 0x80 "title" "minimum_stake_amount" "akita_escrow" "signup_timestamp" "reward_count" "salt" 0xc9068809 "controlled_address" 0x000000000000000000000000000000000000000000000000 0x000000000000000000
    // smart_contracts/pool/contract.algo.ts:104-108
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    pushbytess 0xab8b213a 0xea9180dd // method "delete(address)void", method "update(string)void"
    txna ApplicationArgs 0
    match main_delete_route@4 main_update_route@5

main_switch_case_next@6:
    // smart_contracts/pool/contract.algo.ts:104-108
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@28
    pushbytess 0x83f14748 0x3ea11832 0x645a7bcc 0x0f2fc312 0x181e8291 0x68558c70 0xa9418d37 0xfc699cb3 0x6e76b2ca 0xcdb0ac6a 0xb223d35d 0x592ee341 0x8fa4a160 0xe3377342 0x71704649 0x1ead20a9 0x33e92c94 0x854dede0 0xa4b3e789 // method "init()void", method "optin(pay,uint64)void", method "addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "finalize(uint64,uint64,uint64)void", method "enter(pay,(uint64,uint64,byte[32][])[],byte[][])void", method "startDisbursement(uint64)void", method "raffle(uint64)void", method "disburseRewards(uint64,uint64)void", method "finalizeDistribution(uint64)void", method "check(address,uint64)(bool,uint64)", method "signUpsOpen()bool", method "isLive()bool", method "isEntered(address)bool", method "getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)", method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void", method "mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match init optin addReward addRewardAsa finalize enter startDisbursement raffle disburseRewards finalizeDistribution check signUpsOpen isLive isEntered getState updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@25 mbr
    err

main_opUp_route@25:
    // smart_contracts/utils/base-contracts/base.ts:41
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@28:
    // smart_contracts/pool/contract.algo.ts:104-108
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    pushbytes 0x777ec3e5 // method "create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@5:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update

main_delete_route@4:
    // smart_contracts/pool/contract.algo.ts:697
    // @abimethod({ allowActions: 'DeleteApplication' })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete


// smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
__pcg32Output:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:23
    // export function __pcg32Output(state: PCG32STATE): uint64 {
    proto 1 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:24
    // const xorshifted = __maskToUint32(op.shr(op.shr(state, 18) ^ state, 27))
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:25
    // const rot = op.shr(state, 59)
    frame_dig -1
    pushint 59 // 59
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    dup2
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    |
    retsub


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:164
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:53
    // return op.AppGlobal.getExUint64(akitaDAO, Bytes(AbstractAccountGlobalStateKeysEscrowFactory))[0]
    frame_dig -2
    pushbytes "escrow_factory"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:170-173
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:175
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:176
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:179
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCall(akitaDAO: uint64, caller: bytes, id: uint64, args: bytes) -> uint64, bytes:
gateCall:
    // smart_contracts/utils/functions.ts:192
    // export function gateCall(akitaDAO: Application, caller: Account, id: uint64, args: GateArgs): boolean {
    proto 4 2
    // smart_contracts/utils/functions.ts:193-200
    // return abiCall<typeof Gate.prototype.check>({
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [
    //     caller,
    //     id,
    //     args,
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -4
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:194
    // appId: getAkitaAppList(akitaDAO).gate,
    pushint 40 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:197
    // id,
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:193-200
    // return abiCall<typeof Gate.prototype.check>({
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [
    //     caller,
    //     id,
    //     args,
    //   ],
    // }).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    frame_dig -1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.create[routing]() -> void:
create:
    // smart_contracts/pool/contract.algo.ts:651
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 10
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 11
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:665
    // this.status.value = PoolStatusDraft
    bytec_2 // 0x00
    app_global_put
    // smart_contracts/pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 24 // "title"
    // smart_contracts/pool/contract.algo.ts:666
    // this.title.value = title
    uncover 11
    app_global_put
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:667
    // this.type.value = type
    uncover 10
    app_global_put
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:668
    // this.creator.value = creator
    uncover 9
    app_global_put
    // smart_contracts/utils/base-contracts/child.ts:11
    // funder = GlobalState<FunderInfo>({ key: GlobalStateKeyFunder })
    pushbytes "funder"
    // smart_contracts/pool/contract.algo.ts:669
    // this.funder.value = clone(funder)
    uncover 8
    app_global_put
    // smart_contracts/pool/contract.algo.ts:148
    // marketplace = GlobalState<Account>({ key: PoolGlobalStateKeyMarketplace })
    pushbytes "marketplace"
    // smart_contracts/pool/contract.algo.ts:670
    // this.marketplace.value = marketplace
    uncover 7
    app_global_put
    // smart_contracts/pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 20 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:672
    // this.stakeKey.value = clone(stakeKey)
    uncover 6
    app_global_put
    // smart_contracts/pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 25 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:673
    // this.minimumStakeAmount.value = minimumStakeAmount
    uncover 5
    app_global_put
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:674
    // this.gateID.value = gateID
    uncover 4
    app_global_put
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:675
    // this.maxEntries.value = maxEntries
    uncover 3
    app_global_put
    // smart_contracts/pool/contract.algo.ts:156
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 29 // "salt"
    // smart_contracts/pool/contract.algo.ts:677
    // this.salt.value = Txn.txId
    txn TxID
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/pool/contract.algo.ts:678
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 26 // "akita_escrow"
    // smart_contracts/pool/contract.algo.ts:679
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:681
    // const fees = getStakingFees(Global.currentApplicationId)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:67
    // const [stakingFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysStakingFees))
    pushbytes "staking_fees"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:682
    // const impact = getUserImpact(Global.currentApplicationId, this.creator.value)
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:682
    // const impact = getUserImpact(Global.currentApplicationId, this.creator.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:120-123
    // return abiCall<typeof AkitaSocialImpact.prototype.getUserImpact>({
    //   appId: getAkitaAppList(akitaDAO).impact,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:121
    // appId: getAkitaAppList(akitaDAO).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/utils/functions.ts:120-123
    // return abiCall<typeof AkitaSocialImpact.prototype.getUserImpact>({
    //   appId: getAkitaAppList(akitaDAO).impact,
    //   args: [account]
    // }).returnValue
    pushbytes 0xd574bb10 // method "getUserImpact(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    // smart_contracts/pool/contract.algo.ts:683
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    dig 1
    intc_2 // 8
    extract_uint64
    cover 2
    swap
    pushint 16 // 16
    extract_uint64
    swap
    // smart_contracts/utils/functions.ts:115
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    >
    bz create_ternary_false@7
    dig 2
    intc_1 // 1
    -

create_ternary_merge@8:
    // smart_contracts/utils/functions.ts:116
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    dig 1
    dup
    dig 4
    -
    uncover 2
    *
    pushint 1000 // 1000
    /
    -
    // smart_contracts/pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 21 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:683
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:651
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return

create_ternary_false@7:
    // smart_contracts/utils/functions.ts:115
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b create_ternary_merge@8


// smart_contracts/pool/contract.algo.ts::Pool.init[routing]() -> void:
init:
    // smart_contracts/pool/contract.algo.ts:687
    // assert(Global.callerApplicationAddress === Global.creatorAddress, 'only the factory can init the pool')
    global CallerApplicationAddress
    global CreatorAddress
    ==
    assert // only the factory can init the pool
    // smart_contracts/pool/contract.algo.ts:689
    // if (this.gateID.value > 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:689
    // if (this.gateID.value > 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz init_after_if_else@4
    // smart_contracts/pool/contract.algo.ts:690-693
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(Global.currentApplicationId).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:691
    // appId: getAkitaAppList(Global.currentApplicationId).gate,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:691
    // appId: getAkitaAppList(Global.currentApplicationId).gate,
    pushint 40 // 40
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:692
    // args: [this.gateID.value],
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:692
    // args: [this.gateID.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/pool/contract.algo.ts:690-693
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(Global.currentApplicationId).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    pushbytes 0xdf56b01e // method "size(uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:144
    // gateSize = GlobalState<uint64>({ key: PoolGlobalStateKeyGateSize })
    pushbytes "gate_size"
    // smart_contracts/pool/contract.algo.ts:690-693
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(Global.currentApplicationId).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    swap
    app_global_put

init_after_if_else@4:
    // smart_contracts/pool/contract.algo.ts:686
    // init() {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.delete[routing]() -> void:
delete:
    // smart_contracts/pool/contract.algo.ts:697
    // @abimethod({ allowActions: 'DeleteApplication' })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/pool/contract.algo.ts:699
    // assert(Txn.sender === Global.creatorAddress, 'call must come from factory')
    txn Sender
    global CreatorAddress
    ==
    assert // call must come from factory
    // smart_contracts/pool/contract.algo.ts:700
    // assert(caller === this.creator.value, 'only the creator can delete the pool')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:700
    // assert(caller === this.creator.value, 'only the creator can delete the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can delete the pool
    // smart_contracts/pool/contract.algo.ts:701
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:701
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    bnz delete_bool_true@3
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:701
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz delete_bool_false@4

delete_bool_true@3:
    intc_1 // 1

delete_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:701
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    assert // the pool must be in draft or ended
    // smart_contracts/pool/contract.algo.ts:705-707
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:706
    // .payment({ closeRemainderTo: Global.creatorAddress })
    global CreatorAddress
    itxn_field CloseRemainderTo
    // smart_contracts/pool/contract.algo.ts:705-706
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:705-707
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    //   .submit()
    itxn_submit
    // smart_contracts/pool/contract.algo.ts:697
    // @abimethod({ allowActions: 'DeleteApplication' })
    intc_1 // 1
    return

delete_bool_false@4:
    intc_0 // 0
    b delete_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.optin[routing]() -> void:
optin:
    // smart_contracts/pool/contract.algo.ts:717
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:718
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:718
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/pool/contract.algo.ts:722
    // const daoEscrowNeedsToOptIn = !Global.zeroAddress.isOptedIn(Asset(asset))
    global ZeroAddress
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    // smart_contracts/pool/contract.algo.ts:726
    // Global.assetOptInMinBalance * (
    global AssetOptInMinBalance
    // smart_contracts/pool/contract.algo.ts:727
    // daoEscrowNeedsToOptIn ? 4 : 1
    intc_1 // 1
    pushint 4 // 4
    uncover 3
    select
    // smart_contracts/pool/contract.algo.ts:726-728
    // Global.assetOptInMinBalance * (
    //   daoEscrowNeedsToOptIn ? 4 : 1
    // )
    *
    // smart_contracts/pool/contract.algo.ts:733-740
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:736
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:733-740
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 3
    gtxns Amount
    // smart_contracts/pool/contract.algo.ts:737
    // amount: optinMBR + rewardsMBR,
    uncover 2
    // smart_contracts/pool/contract.algo.ts:731
    // const rewardsMBR: uint64 = this.rewardsMbr(WinnerCountCap) * 2
    pushint 8000 // 8000
    // smart_contracts/pool/contract.algo.ts:737
    // amount: optinMBR + rewardsMBR,
    +
    // smart_contracts/pool/contract.algo.ts:733-740
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:742-748
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:744
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 1
    itxn_field XferAsset
    // smart_contracts/pool/contract.algo.ts:745
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:742-747
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:742-748
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 16 // "wallet"
    app_global_get_ex
    pop
    swap
    bytec 16 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:69-72
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    itxn_begin
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:71
    // args: [[name]],
    pushbytes 0x00010002000d7374616b696e675f706f6f6c73
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:69-72
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/utils/base-contracts/base.ts:74
    // assert(escrow.id !== 0, ERR_ESCROW_DOES_NOT_EXIST)
    extract 6 9
    intc_0 // 0
    extract_uint64
    dup
    assert // Escrow does not exist
    // smart_contracts/utils/base-contracts/base.ts:84
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 26 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:84
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Wrong escrow for this operation
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:94
    // receiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/base-contracts/base.ts:95
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/base-contracts/base.ts:93-96
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: Global.assetOptInMinBalance,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:89
    // Global.currentApplicationId.id,
    global CurrentApplicationID
    itob
    // smart_contracts/utils/base-contracts/base.ts:90
    // Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/base.ts:92
    // [asset.id],
    uncover 3
    itob
    pushbytes 0x0001
    swap
    concat
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    pushbytes 0x9d3f8918 // method "arc58_pluginOptinEscrow(uint64,address,string,uint64[],pay)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:91
    // name,
    pushbytes 0x000d7374616b696e675f706f6f6c73
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/pool/contract.algo.ts:717
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.addReward[routing]() -> void:
addReward:
    // smart_contracts/pool/contract.algo.ts:757
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    callsub smart_contracts/pool/contract.algo.ts::Pool.addReward
    pop
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.addRewardAsa[routing]() -> void:
addRewardAsa:
    // smart_contracts/pool/contract.algo.ts:778
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/pool/contract.algo.ts:779-789
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    dig 1
    gtxns AssetReceiver
    // smart_contracts/pool/contract.algo.ts:782
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:779-789
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    dig 2
    gtxns XferAsset
    // smart_contracts/pool/contract.algo.ts:783
    // xferAsset: Asset(reward.asset),
    dig 2
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:779-789
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    uncover 2
    gtxns AssetAmount
    &&
    assert // Invalid transfer
    // smart_contracts/pool/contract.algo.ts:791
    // this.addReward(payment, reward)
    callsub smart_contracts/pool/contract.algo.ts::Pool.addReward
    pop
    // smart_contracts/pool/contract.algo.ts:778
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.finalize[routing]() -> void:
finalize:
    // smart_contracts/pool/contract.algo.ts:794
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/pool/contract.algo.ts:795
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:795
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can finalize the pool
    // smart_contracts/pool/contract.algo.ts:796
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:796
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    assert // the pool must be in draft state to finalize
    // smart_contracts/pool/contract.algo.ts:798
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    global LatestTimestamp
    >
    bnz finalize_bool_true@4
    dig 2
    bnz finalize_bool_false@5
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 22 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:798
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@5

finalize_bool_true@4:
    intc_1 // 1

finalize_bool_merge@6:
    // smart_contracts/pool/contract.algo.ts:797-800
    // assert(
    //   signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    //   'the signup round must be zero and late sign ups allowed or in the future'
    // )
    assert // the signup round must be zero and late sign ups allowed or in the future
    // smart_contracts/pool/contract.algo.ts:803-804
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    dig 1
    bz finalize_bool_true@8
    // smart_contracts/pool/contract.algo.ts:804
    // startTimestamp > Global.latestTimestamp,
    dig 1
    global LatestTimestamp
    >
    // smart_contracts/pool/contract.algo.ts:803-804
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    bz finalize_bool_false@9

finalize_bool_true@8:
    intc_1 // 1

finalize_bool_merge@10:
    // smart_contracts/pool/contract.algo.ts:802-806
    // assert(
    //   startTimestamp === 0 ||
    //   startTimestamp > Global.latestTimestamp,
    //   'the starting round must be zero or in the future'
    // )
    assert // the starting round must be zero or in the future
    // smart_contracts/pool/contract.algo.ts:808
    // if (startTimestamp === 0) {
    dig 1
    bnz finalize_after_if_else@16
    // smart_contracts/pool/contract.algo.ts:809
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    dig 2
    bnz finalize_bool_false@14
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 22 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:809
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@14
    intc_1 // 1

finalize_bool_merge@15:
    // smart_contracts/pool/contract.algo.ts:809
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    assert // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
    // smart_contracts/pool/contract.algo.ts:810
    // startTimestamp = Global.latestTimestamp
    global LatestTimestamp
    bury 2

finalize_after_if_else@16:
    // smart_contracts/pool/contract.algo.ts:814
    // endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    dup
    bz finalize_bool_true@18
    dig 1
    pushint 10 // 10
    +
    dig 1
    <
    bz finalize_bool_false@19

finalize_bool_true@18:
    intc_1 // 1

finalize_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:813-816
    // assert(
    //   endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    //   'the ending round must be zero or after the starting round + 10'
    // )
    assert // the ending round must be zero or after the starting round + 10
    // smart_contracts/pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 27 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:818
    // this.signupTimestamp.value = signupTimestamp
    dig 3
    app_global_put
    // smart_contracts/pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 17 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:819
    // this.startTimestamp.value = startTimestamp
    dig 2
    app_global_put
    // smart_contracts/pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:820
    // this.endTimestamp.value = endTimestamp
    dig 1
    app_global_put
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:821
    // this.status.value = PoolStatusFinal
    bytec 5 // 0x0a
    app_global_put
    // smart_contracts/pool/contract.algo.ts:794
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    intc_1 // 1
    return

finalize_bool_false@19:
    intc_0 // 0
    b finalize_bool_merge@20

finalize_bool_false@14:
    intc_0 // 0
    b finalize_bool_merge@15

finalize_bool_false@9:
    intc_0 // 0
    b finalize_bool_merge@10

finalize_bool_false@5:
    intc_0 // 0
    b finalize_bool_merge@6


// smart_contracts/pool/contract.algo.ts::Pool.enter[routing]() -> void:
enter:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 4
    // smart_contracts/pool/contract.algo.ts:824
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pool/contract.algo.ts:826
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    assert // the pool is not live
    // smart_contracts/pool/contract.algo.ts:828
    // if (this.gateID.value !== 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:828
    // if (this.gateID.value !== 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz enter_after_if_else@3
    // smart_contracts/pool/contract.algo.ts:829
    // const wallet = getWalletIDUsingAkitaDAO(Global.currentApplicationId, Txn.sender)
    global CurrentApplicationID
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    bury 5
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    bury 10
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz enter_after_if_else@30
    dig 8

enter_after_inlined_smart_contracts/utils/functions.ts::originOr@31:
    // smart_contracts/pool/contract.algo.ts:832
    // gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:832
    // gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    app_global_get_ex
    assert // check GlobalState exists
    swap
    cover 2
    dig 3
    callsub gateCall
    bury 2
    // smart_contracts/pool/contract.algo.ts:831-834
    // assert(
    //   gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    //   'user does not meet gate requirements'
    // )
    assert // user does not meet gate requirements

enter_after_if_else@3:
    // smart_contracts/pool/contract.algo.ts:838
    // (this.entryID.value + 1) < this.maxEntries.value ||
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:838
    // (this.entryID.value + 1) < this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:838
    // (this.entryID.value + 1) < this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    <
    // smart_contracts/pool/contract.algo.ts:838-839
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_true@5
    // smart_contracts/pool/contract.algo.ts:839
    // this.maxEntries.value === 0,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:839
    // this.maxEntries.value === 0,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:838-839
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_false@6

enter_bool_true@5:
    intc_1 // 1

enter_bool_merge@7:
    // smart_contracts/pool/contract.algo.ts:837-841
    // assert(
    //   (this.entryID.value + 1) < this.maxEntries.value ||
    //   this.maxEntries.value === 0,
    //   'pool has reached maximum entries'
    // )
    assert // pool has reached maximum entries
    // smart_contracts/pool/contract.algo.ts:845
    // let total: uint64 = entryMBR * entries.length
    dig 1
    intc_0 // 0
    extract_uint16
    dup
    bury 9
    pushint 50600 // 50600
    *
    // smart_contracts/pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    pushbytes "u"
    // smart_contracts/pool/contract.algo.ts:846
    // if (!this.uniques(Txn.sender).exists) {
    txn Sender
    // smart_contracts/pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    concat
    // smart_contracts/pool/contract.algo.ts:846
    // if (!this.uniques(Txn.sender).exists) {
    box_len
    bury 1
    bnz enter_after_if_else@9
    // smart_contracts/pool/contract.algo.ts:847
    // total += PoolUniquesMBR
    pushint 18900 // 18900
    +

enter_after_if_else@9:
    // smart_contracts/pool/contract.algo.ts:850-857
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 3
    dup
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:853
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:850-857
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:859
    // const { address, name } = this.stakeKey.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 20 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:859
    // const { address, name } = this.stakeKey.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    extract 0 32
    bury 13
    dup
    pushint 32 // 32
    extract_uint16
    dig 1
    len
    substring3
    bury 11
    // smart_contracts/pool/contract.algo.ts:861
    // for (let i: uint64 = 0; i < entries.length; i++) {
    intc_0 // 0
    bury 6

enter_while_top@10:
    // smart_contracts/pool/contract.algo.ts:861
    // for (let i: uint64 = 0; i < entries.length; i++) {
    dig 5
    dig 8
    <
    bz enter_after_while@23
    // smart_contracts/pool/contract.algo.ts:862
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    dig 1
    extract 2 0
    dig 6
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    bury 9
    dig 10
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    bury 11
    intc_2 // 8
    extract_uint64
    dup
    bury 6
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 25 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:862
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    app_global_get_ex
    assert // check GlobalState exists
    >=
    assert // quantity is less than minimum stake amount
    // smart_contracts/pool/contract.algo.ts:864
    // if (address !== Global.zeroAddress) {
    dig 11
    global ZeroAddress
    !=
    bz enter_after_if_else@14
    // smart_contracts/pool/contract.algo.ts:865-874
    // const verified = abiCall<typeof MetaMerkles.prototype.verify>({
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     sha256(sha256(itob(entries[i].asset))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:866
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/pool/contract.algo.ts:866
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:866
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    pushint 72 // 72
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:870
    // sha256(sha256(itob(entries[i].asset))),
    dig 10
    dup
    extract 0 8
    sha256
    sha256
    // smart_contracts/pool/contract.algo.ts:871
    // entries[i].proof,
    dig 1
    pushint 16 // 16
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    // smart_contracts/pool/contract.algo.ts:872
    // MERKLE_TREE_TYPE_ASSET,
    intc_1 // 1
    itob
    // smart_contracts/pool/contract.algo.ts:865-874
    // const verified = abiCall<typeof MetaMerkles.prototype.verify>({
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     sha256(sha256(itob(entries[i].asset))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    // }).returnValue
    pushbytes 0x2bf3cc5a // method "verify(address,string,byte[32],byte[32][],uint64)bool"
    itxn_field ApplicationArgs
    dig 15
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:876
    // assert(verified, 'failed to verify stake requirements')
    assert // failed to verify stake requirements

enter_after_if_else@14:
    // smart_contracts/pool/contract.algo.ts:881
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:881
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    ==
    // smart_contracts/pool/contract.algo.ts:881-882
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bnz enter_if_body@16
    // smart_contracts/pool/contract.algo.ts:882
    // this.type.value === POOL_STAKING_TYPE_SOFT
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:882
    // this.type.value === POOL_STAKING_TYPE_SOFT
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:881-882
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bz enter_after_if_else@21

enter_if_body@16:
    // smart_contracts/pool/contract.algo.ts:884
    // const [balance, optedIn] = AssetHolding.assetBalance(Txn.sender, entries[i].asset)
    txn Sender
    dig 10
    intc_0 // 0
    extract_uint64
    asset_holding_get AssetBalance
    swap
    bury 8
    // smart_contracts/pool/contract.algo.ts:885
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    bz enter_bool_false@19
    dig 6
    dig 5
    >=
    bz enter_bool_false@19
    intc_1 // 1

enter_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:885
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    assert // user does not have min balance

enter_after_if_else@21:
    // smart_contracts/pool/contract.algo.ts:888-897
    // const stakeInfo = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [
    //     Txn.sender,
    //     {
    //       asset: entries[i].asset,
    //       type: this.stakingType(),
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:889
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:889
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:891
    // Txn.sender,
    txn Sender
    // smart_contracts/pool/contract.algo.ts:894
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:892-895
    // {
    //   asset: entries[i].asset,
    //   type: this.stakingType(),
    // },
    dig 12
    extract 0 8
    dup
    uncover 2
    concat
    // smart_contracts/pool/contract.algo.ts:888-897
    // const stakeInfo = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [
    //     Txn.sender,
    //     {
    //       asset: entries[i].asset,
    //       type: this.stakingType(),
    //     },
    //   ],
    // }).returnValue
    bytec 30 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 4 // 4
    // smart_contracts/pool/contract.algo.ts:899
    // assert(stakeInfo.amount >= entries[i].quantity, 'user does not have enough staked')
    extract_uint64
    dig 6
    dup
    cover 2
    >=
    assert // user does not have enough staked
    // smart_contracts/pool/contract.algo.ts:175
    // const id = this.entryID.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:175
    // const id = this.entryID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:176
    // this.entryID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:176
    // this.entryID.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:903
    // address: Txn.sender,
    txn Sender
    // smart_contracts/pool/contract.algo.ts:902-908
    // this.entries(entryID).value = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(args),
    //   disqualified: false
    // }
    dig 3
    concat
    uncover 2
    itob
    concat
    pushbytes 0x003300
    concat
    dig 3
    concat
    // smart_contracts/pool/contract.algo.ts:902
    // this.entries(entryID).value = {
    swap
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    dig 1
    concat
    // smart_contracts/pool/contract.algo.ts:902-908
    // this.entries(entryID).value = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(args),
    //   disqualified: false
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/pool/contract.algo.ts:911
    // address: Txn.sender,
    txn Sender
    // smart_contracts/pool/contract.algo.ts:910-913
    // const aKey = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    // }
    uncover 2
    concat
    // smart_contracts/pool/contract.algo.ts:915
    // this.entriesByAddress(aKey).value = entryID
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/pool/contract.algo.ts:165
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:915
    // this.entriesByAddress(aKey).value = entryID
    swap
    box_put
    b enter_while_top@10

enter_bool_false@19:
    intc_0 // 0
    b enter_bool_merge@20

enter_after_while@23:
    // smart_contracts/pool/contract.algo.ts:824
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    intc_1 // 1
    return

enter_bool_false@6:
    intc_0 // 0
    b enter_bool_merge@7

enter_after_if_else@30:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 31 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b enter_after_inlined_smart_contracts/utils/functions.ts::originOr@31


// smart_contracts/pool/contract.algo.ts::Pool.startDisbursement[routing]() -> void:
startDisbursement:
    // smart_contracts/pool/contract.algo.ts:919
    // startDisbursement(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:920
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    assert // the pool is not live
    // smart_contracts/pool/contract.algo.ts:921
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 18 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:921
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:923
    // const { phase, interval, lastDisbursementTimestamp, expiration } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 116 // 116
    intc_2 // 8
    box_extract
    btoi
    cover 3
    uncover 2
    pushint 17 // 17
    intc_2 // 8
    box_extract
    btoi
    cover 2
    // smart_contracts/pool/contract.algo.ts:925
    // assert(phase === DisbursementPhaseIdle, 'reward is already in a disbursement phase')
    swap
    bytec_2 // 0x00
    ==
    assert // reward is already in a disbursement phase
    // smart_contracts/pool/contract.algo.ts:516
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    global LatestTimestamp
    dup
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 17 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:516
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    app_global_get_ex
    assert // check GlobalState exists
    -
    uncover 2
    %
    -
    dup
    // smart_contracts/pool/contract.algo.ts:521
    // return latestWindowStart !== Global.latestTimestamp && last < latestWindowStart
    global LatestTimestamp
    !=
    bz startDisbursement_bool_false@4
    dig 2
    dig 1
    <
    bz startDisbursement_bool_false@4
    intc_1 // 1

startDisbursement_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:926
    // assert(this.validWindow(interval, lastDisbursementTimestamp), 'distribution window is not open')
    assert // distribution window is not open
    // smart_contracts/pool/contract.algo.ts:929
    // `${this.title.value} - Rewards`,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 24 // "title"
    // smart_contracts/pool/contract.algo.ts:929
    // `${this.title.value} - Rewards`,
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes " - Rewards"
    concat
    // smart_contracts/pool/contract.algo.ts:930
    // Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/pool/contract.algo.ts:931
    // Global.latestTimestamp + expiration
    dup
    dig 4
    +
    // smart_contracts/pool/contract.algo.ts:548
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:548
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:549
    // const rewardMBR: uint64 = MinDisbursementsMBR + (BoxCostPerByte * Bytes(title).length)
    dig 3
    len
    intc 6 // 400
    dig 1
    *
    pushint 35300 // 35300
    +
    // smart_contracts/pool/contract.algo.ts:552
    // receiver: rewardsApp.address,
    dig 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:556-565
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    itxn_begin
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/pool/contract.algo.ts:551-554
    // const mbrPayment = itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: rewardMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:556-565
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    itxn_next
    // smart_contracts/pool/contract.algo.ts:560
    // title,
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/pool/contract.algo.ts:561
    // timeToUnlock,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:562
    // expiration,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:563
    // '',
    intc_0 // 0
    itob
    // smart_contracts/pool/contract.algo.ts:556-565
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    pushbytes 0x1c9ebbdb // method "createDisbursement(pay,string,uint64,uint64,string)uint64"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:563
    // '',
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:556-565
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/pool/contract.algo.ts:934
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 5
    dup
    pushint 33 // 33
    dig 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:935
    // this.rewards(rewardID).value.qualifiedStake = 0
    dup
    pushint 41 // 41
    dig 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:936
    // this.rewards(rewardID).value.phase = DisbursementPhasePreparation
    dup
    pushint 91 // 91
    bytec 5 // 0x0a
    box_replace
    // smart_contracts/pool/contract.algo.ts:937
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    uncover 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:938
    // this.rewards(rewardID).value.activeDisbursementID = disbursementID
    dup
    pushint 100 // 100
    uncover 3
    box_replace
    // smart_contracts/pool/contract.algo.ts:939
    // this.rewards(rewardID).value.activeDisbursementRoundStart = Global.round
    global Round
    itob
    dig 1
    pushint 108 // 108
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:940
    // this.rewards(rewardID).value.lastDisbursementTimestamp = Global.latestTimestamp
    global LatestTimestamp
    itob
    pushint 116 // 116
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:919
    // startDisbursement(rewardID: uint64): void {
    intc_1 // 1
    return

startDisbursement_bool_false@4:
    intc_0 // 0
    b startDisbursement_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.raffle[routing]() -> void:
raffle:
    // smart_contracts/pool/contract.algo.ts:943
    // raffle(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/pool/contract.algo.ts::Pool.raffle
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.disburseRewards[routing]() -> void:
disburseRewards:
    intc_0 // 0
    dupn 7
    pushbytes ""
    dupn 25
    // smart_contracts/pool/contract.algo.ts:983
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/pool/contract.algo.ts:985
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 18 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:985
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:987
    // const { phase, distribution, winningTickets } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dup
    uncover 2
    intc_2 // 8
    intc_1 // 1
    box_extract
    swap
    // smart_contracts/pool/contract.algo.ts:990
    // phase === DisbursementPhasePreparation ||
    bytec 5 // 0x0a
    ==
    dup
    // smart_contracts/pool/contract.algo.ts:990-991
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bnz disburseRewards_bool_true@3
    // smart_contracts/pool/contract.algo.ts:991
    // phase === DisbursementPhaseAllocation,
    dig 2
    bytec 11 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:990-991
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bz disburseRewards_bool_false@4

disburseRewards_bool_true@3:
    intc_1 // 1

disburseRewards_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:989-993
    // assert(
    //   phase === DisbursementPhasePreparation ||
    //   phase === DisbursementPhaseAllocation,
    //   ERR_NOT_READY_TO_DISBURSE
    // )
    assert // Not ready to disburse
    // smart_contracts/pool/contract.algo.ts:995
    // if (phase === DisbursementPhasePreparation) {
    dup
    bz disburseRewards_else_body@7
    // smart_contracts/pool/contract.algo.ts:218
    // const { disbursementCursor, distribution, rate, asset } = this.rewards(rewardID).value
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    bury 4
    dup
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 15
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 28
    // smart_contracts/pool/contract.algo.ts:219
    // let count: uint64 = 0
    intc_0 // 0
    bury 26
    // smart_contracts/pool/contract.algo.ts:220
    // let total: uint64 = 0
    intc_0 // 0
    bury 10
    // smart_contracts/pool/contract.algo.ts:222
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:222
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@91
    // smart_contracts/pool/contract.algo.ts:223
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:223
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@91:
    dig 19
    bury 17

disburseRewards_while_top@92:
    // smart_contracts/pool/contract.algo.ts:226
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@109
    // smart_contracts/pool/contract.algo.ts:227
    // const { disqualified, address, gateArgs, quantity } = clone(this.entries(id).value)
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    dup
    bury 35
    // smart_contracts/pool/contract.algo.ts:227
    // const { disqualified, address, gateArgs, quantity } = clone(this.entries(id).value)
    dup
    box_get
    assert // Box must have value
    dig 1
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 2
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 43
    dig 1
    pushint 48 // 48
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    bury 35
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 15
    // smart_contracts/pool/contract.algo.ts:228
    // if (disqualified) {
    bnz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:530
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:530
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    bz disburseRewards_else_body@97
    // smart_contracts/pool/contract.algo.ts:531
    // return { valid: true, balance: 0 }
    pushbytes 0x800000000000000000

disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100:
    // smart_contracts/pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:234
    // if (!valid) {
    bz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:238
    // if (this.gateID.value !== 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:238
    // if (this.gateID.value !== 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz disburseRewards_after_if_else@107
    // smart_contracts/pool/contract.algo.ts:239
    // const wallet = getWalletIDUsingAkitaDAO(Global.currentApplicationId, address)
    global CurrentApplicationID
    dig 40
    callsub getWalletIDUsingAkitaDAO
    dup
    bury 9
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    bnz disburseRewards_after_if_else@127
    dig 39

disburseRewards_after_inlined_smart_contracts/utils/functions.ts::originOr@128:
    // smart_contracts/pool/contract.algo.ts:242
    // const passes = gateCall(Global.currentApplicationId, origin, this.gateID.value, gateArgs)
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:242
    // const passes = gateCall(Global.currentApplicationId, origin, this.gateID.value, gateArgs)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    cover 2
    dig 35
    callsub gateCall
    pop
    // smart_contracts/pool/contract.algo.ts:243
    // if (!passes) {
    bnz disburseRewards_after_if_else@107
    // smart_contracts/pool/contract.algo.ts:244
    // if (this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:244
    // if (this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    !=
    bz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:245
    // this.entries(id).value.disqualified = true
    dig 33
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace

disburseRewards_block@108:
    // smart_contracts/pool/contract.algo.ts:226
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@92

disburseRewards_after_if_else@107:
    // smart_contracts/pool/contract.algo.ts:251
    // count += 1
    dig 24
    intc_1 // 1
    +
    bury 25
    // smart_contracts/pool/contract.algo.ts:252
    // total += quantity
    dig 8
    dig 14
    +
    bury 9
    b disburseRewards_block@108

disburseRewards_after_if_else@127:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 7
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 31 // "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:240
    // const origin = originOr(wallet, address)
    b disburseRewards_after_inlined_smart_contracts/utils/functions.ts::originOr@128

disburseRewards_else_body@97:
    // smart_contracts/pool/contract.algo.ts:532
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:532
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    ==
    bz disburseRewards_after_if_else@99
    // smart_contracts/pool/contract.algo.ts:533
    // const { address, asset } = this.entries(id).value
    dig 33
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    swap
    pushint 32 // 32
    intc_2 // 8
    box_extract
    // smart_contracts/pool/contract.algo.ts:535-538
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [address, asset, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:536
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:536
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:535-538
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [address, asset, true],
    // }).returnValue
    pushbytes 0xc6fd0ca5 // method "getHeartbeatAverage(address,uint64,bool)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:537
    // args: [address, asset, true],
    bytec 23 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:535-538
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [address, asset, true],
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:540
    // return { valid: true, balance: avg }
    itob
    bytec 23 // 0x80
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100

disburseRewards_after_if_else@99:
    // smart_contracts/pool/contract.algo.ts:543
    // return this.checkByID(id)
    dig 16
    callsub checkByID
    // smart_contracts/pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100

disburseRewards_after_while@109:
    // smart_contracts/pool/contract.algo.ts:255
    // this.rewards(rewardID).value.qualifiedStakers += count
    dig 3
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 26
    +
    itob
    dig 1
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:256
    // this.rewards(rewardID).value.qualifiedStake += total
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    dig 10
    +
    itob
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:258
    // if (this.entryID.value === disbursementCursor) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:258
    // if (this.entryID.value === disbursementCursor) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    ==
    bz disburseRewards_else_body@116
    // smart_contracts/pool/contract.algo.ts:260
    // this.rewards(rewardID).value.phase = DisbursementPhaseAllocation
    dig 3
    dup
    pushint 91 // 91
    bytec 11 // 0x14
    box_replace
    // smart_contracts/pool/contract.algo.ts:261
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_0 // 0
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:263
    // this.payAkitaRoyalty(distribution, rate, asset, this.rewards(rewardID).value.qualifiedStakers)
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 15
    // smart_contracts/pool/contract.algo.ts:188
    // if (distribution === DistributionTypeFlat) {
    dig 1
    bytec 11 // 0x14
    ==
    bz disburseRewards_else_body@112
    // smart_contracts/pool/contract.algo.ts:189
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    dig 14
    dig 13
    *
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 21 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:189
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    mulw
    intc 4 // 100000
    divw
    bury 28

disburseRewards_after_if_else@113:
    // smart_contracts/pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 19 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:194
    // this.akitaRoyaltyAmount.value = amount
    dig 28
    app_global_put
    // smart_contracts/pool/contract.algo.ts:197
    // if (asset === 0) {
    dig 26
    bnz disburseRewards_else_body@115
    // smart_contracts/pool/contract.algo.ts:198-203
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:200
    // receiver: Global.zeroAddress,
    global ZeroAddress
    dig 28
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:198-202
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:198-203
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_submit

disburseRewards_after_if_else@30:
    // smart_contracts/pool/contract.algo.ts:983
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    intc_1 // 1
    return

disburseRewards_else_body@115:
    // smart_contracts/pool/contract.algo.ts:205
    // assert(Global.zeroAddress.isOptedIn(Asset(asset)), ERR_DAO_NOT_OPTED_IN)
    global ZeroAddress
    dig 27
    dup
    cover 2
    asset_holding_get AssetBalance
    bury 1
    assert // DAO not opted in to the asset
    // smart_contracts/pool/contract.algo.ts:207-213
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:209
    // assetReceiver: Global.zeroAddress,
    global ZeroAddress
    swap
    itxn_field XferAsset
    dig 28
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:207-212
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:207-213
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    b disburseRewards_after_if_else@30

disburseRewards_else_body@112:
    // smart_contracts/pool/contract.algo.ts:191
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 21 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:191
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 13
    mulw
    intc 4 // 100000
    divw
    bury 28
    b disburseRewards_after_if_else@113

disburseRewards_else_body@116:
    // smart_contracts/pool/contract.algo.ts:266
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    intc_3 // 92
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_else_body@7:
    // smart_contracts/pool/contract.algo.ts:999
    // case DistributionTypePercentage: {
    dig 1
    bytec 5 // 0x0a
    ==
    // smart_contracts/pool/contract.algo.ts:999-1002
    // case DistributionTypePercentage: {
    //   this.createPercentageDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@11
    // smart_contracts/pool/contract.algo.ts:277
    // } = this.rewards(rewardID).value
    dig 3
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 28
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 34
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    bury 18
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 29
    // smart_contracts/pool/contract.algo.ts:279
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:279
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@79
    // smart_contracts/pool/contract.algo.ts:280
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:280
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@79:
    // smart_contracts/pool/contract.algo.ts:283
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 19 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:283
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    dig 28
    swap
    -
    bury 31
    // smart_contracts/pool/contract.algo.ts:284
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 39
    bytec 7 // 0x0000
    bury 35
    // smart_contracts/pool/contract.algo.ts:285
    // let sum: uint64 = 0
    intc_0 // 0
    bury 11
    dig 19
    bury 17

disburseRewards_while_top@80:
    // smart_contracts/pool/contract.algo.ts:287
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@85
    // smart_contracts/pool/contract.algo.ts:288
    // const { disqualified, quantity, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:288
    // const { disqualified, quantity, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 16
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:289
    // if (disqualified) {
    bnz disburseRewards_block@84
    // smart_contracts/utils/functions.ts:97
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    dig 13
    dup
    dig 17
    dup
    cover 3
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:98
    // return op.divw(...op.mulw(a, DIVISOR), b)
    intc 4 // 100000
    mulw
    uncover 2
    divw
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 31
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/pool/contract.algo.ts:294
    // allocations.push({ address, amount: individualAmount })
    dup
    itob
    dig 41
    swap
    concat
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    // smart_contracts/pool/contract.algo.ts:295
    // sum += individualAmount
    dig 11
    +
    bury 11

disburseRewards_block@84:
    // smart_contracts/pool/contract.algo.ts:287
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@80

disburseRewards_after_while@85:
    // smart_contracts/pool/contract.algo.ts:298
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    dup
    cover 3
    +
    itob
    intc_3 // 92
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:300
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:302
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:302
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 21
    uncover 2
    +
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:303
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:304
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 40
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@11:
    // smart_contracts/pool/contract.algo.ts:1003
    // case DistributionTypeFlat: {
    dig 1
    bytec 11 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:1003-1006
    // case DistributionTypeFlat: {
    //   this.createFlatDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:315
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    uncover 2
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 3
    bury 31
    // smart_contracts/pool/contract.algo.ts:317
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    swap
    dig 1
    *
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 19 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:317
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    -
    // smart_contracts/pool/contract.algo.ts:318
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 21 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:318
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 2
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/pool/contract.algo.ts:319
    // const adjustedAmount: uint64 = amount - percentageAkitaFee
    uncover 2
    swap
    -
    bury 32
    // smart_contracts/pool/contract.algo.ts:320
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    uncover 2
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:322
    // assert(balance >= total, ERR_NOT_ENOUGH_FUNDS)
    <=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:324
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:324
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@67
    // smart_contracts/pool/contract.algo.ts:325
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:325
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@67:
    // smart_contracts/pool/contract.algo.ts:328
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 38
    bytec 7 // 0x0000
    bury 35
    // smart_contracts/pool/contract.algo.ts:329
    // let sum: uint64 = 0
    intc_0 // 0
    bury 11
    dig 19
    bury 17

disburseRewards_while_top@68:
    // smart_contracts/pool/contract.algo.ts:331
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@73
    // smart_contracts/pool/contract.algo.ts:332
    // const { disqualified, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:332
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:333
    // if (disqualified) {
    bnz disburseRewards_block@72
    // smart_contracts/pool/contract.algo.ts:337
    // allocations.push({ address, amount: adjustedAmount })
    dig 28
    dup
    itob
    dig 41
    swap
    concat
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    // smart_contracts/pool/contract.algo.ts:338
    // sum += adjustedAmount
    dig 11
    +
    bury 11

disburseRewards_block@72:
    // smart_contracts/pool/contract.algo.ts:331
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@68

disburseRewards_after_while@73:
    // smart_contracts/pool/contract.algo.ts:341
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 19
    dig 5
    +
    // smart_contracts/pool/contract.algo.ts:342
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:343
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:345
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:345
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:346
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:347
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 39
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:1007
    // case DistributionTypeEven: {
    dig 1
    bytec 13 // 0x1e
    ==
    // smart_contracts/pool/contract.algo.ts:1007-1010
    // case DistributionTypeEven: {
    //   this.createEvenDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@19
    // smart_contracts/pool/contract.algo.ts:358
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 17
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 30
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 14
    // smart_contracts/pool/contract.algo.ts:360
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:361
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 19 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:361
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 33
    // smart_contracts/pool/contract.algo.ts:362
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:364
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:364
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@55
    // smart_contracts/pool/contract.algo.ts:365
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:365
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@55:
    // smart_contracts/pool/contract.algo.ts:368
    // const amount: uint64 = actualSum / qualifiedStakers
    dig 29
    dig 15
    /
    bury 28
    // smart_contracts/pool/contract.algo.ts:369
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 37
    bytec 7 // 0x0000
    bury 35
    dig 19
    bury 17

disburseRewards_while_top@56:
    // smart_contracts/pool/contract.algo.ts:370
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@61
    // smart_contracts/pool/contract.algo.ts:371
    // const { disqualified, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:371
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:372
    // if (disqualified) {
    bnz disburseRewards_block@60
    // smart_contracts/pool/contract.algo.ts:376
    // allocations.push({ address, amount })
    dig 27
    itob
    dig 40
    swap
    concat
    dig 35
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 35

disburseRewards_block@60:
    // smart_contracts/pool/contract.algo.ts:370
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@56

disburseRewards_after_while@61:
    // smart_contracts/pool/contract.algo.ts:379
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 19
    dig 5
    +
    // smart_contracts/pool/contract.algo.ts:380
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:381
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:383
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:383
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:384
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:385
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 38
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@19:
    // smart_contracts/pool/contract.algo.ts:1011
    // case DistributionTypeShuffle: {
    dig 1
    pushbytes 0x28
    ==
    // smart_contracts/pool/contract.algo.ts:1011-1018
    // case DistributionTypeShuffle: {
    //   if (winningTickets.length === 0) {
    //     this.raffle(rewardID)
    //   } else {
    //     this.createShuffleDisbursement(rewardID, iterationAmount)
    //   }
    //   break
    // }
    assert // unknown reward rate type
    // smart_contracts/pool/contract.algo.ts:1012
    // if (winningTickets.length === 0) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    bnz disburseRewards_else_body@24
    // smart_contracts/pool/contract.algo.ts:1013
    // this.raffle(rewardID)
    dig 5
    callsub smart_contracts/pool/contract.algo.ts::Pool.raffle
    b disburseRewards_after_if_else@30

disburseRewards_else_body@24:
    // smart_contracts/pool/contract.algo.ts:398
    // } = clone(this.rewards(rewardID).value)
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    bury 9
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 30
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 14
    // smart_contracts/pool/contract.algo.ts:400
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:401
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 19 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:401
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 33
    // smart_contracts/pool/contract.algo.ts:402
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:404
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:404
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@33
    // smart_contracts/pool/contract.algo.ts:405
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:405
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@33:
    // smart_contracts/pool/contract.algo.ts:409
    // if (winnerCount > 0) {
    dig 6
    bnz disburseRewards_if_body@34
    dig 29
    bury 28

disburseRewards_after_if_else@35:
    // smart_contracts/pool/contract.algo.ts:413
    // let { stake, ticket, disbursed } = raffleCursor
    dig 3
    dup
    pushints 59 24 // 59, 24
    box_extract
    dup
    intc_2 // 8
    extract_uint64
    dup
    cover 3
    bury 15
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    bury 14
    pushint 16 // 16
    extract_uint64
    bury 24
    // smart_contracts/pool/contract.algo.ts:414
    // let currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    intc_2 // 8
    box_extract
    btoi
    bury 23
    // smart_contracts/pool/contract.algo.ts:418
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 37
    bytec 7 // 0x0000
    bury 36
    bury 23
    dig 19
    bury 18

disburseRewards_while_top@36:
    // smart_contracts/pool/contract.algo.ts:419
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 17
    dig 5
    <
    bz disburseRewards_block@48
    // smart_contracts/pool/contract.algo.ts:420
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dig 17
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:420
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bury 20
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    dup
    pushint 32 // 32
    intc_2 // 8
    box_extract
    btoi
    bury 27
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/pool/contract.algo.ts:422
    // currentRangeEnd = currentRangeStart + quantity
    dig 23
    dup
    uncover 2
    +
    bury 25
    // smart_contracts/pool/contract.algo.ts:423
    // if (currentTicket >= currentRangeStart && currentTicket <= currentRangeEnd) {
    dig 22
    <=
    bz disburseRewards_after_if_else@46
    dig 21
    dig 24
    <=
    bz disburseRewards_after_if_else@46
    // smart_contracts/pool/contract.algo.ts:424
    // if (!disqualified) {
    dig 18
    bnz disburseRewards_after_if_else@41
    // smart_contracts/pool/contract.algo.ts:425
    // allocations.push({ address, amount })
    dig 27
    itob
    dig 40
    swap
    concat
    dig 35
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 35
    // smart_contracts/pool/contract.algo.ts:426
    // disbursed++
    dig 20
    intc_1 // 1
    +
    bury 21

disburseRewards_after_if_else@41:
    // smart_contracts/pool/contract.algo.ts:429
    // if (ticket === tickets.length - 1) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    intc_1 // 1
    -
    dig 10
    ==
    bz disburseRewards_after_if_else@45
    // smart_contracts/pool/contract.algo.ts:431
    // if (winnerCount !== disbursed) {
    dig 6
    dig 21
    !=
    bz disburseRewards_block@48
    // smart_contracts/pool/contract.algo.ts:432
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 3
    dup
    intc_3 // 92
    dig 38
    box_replace
    // smart_contracts/pool/contract.algo.ts:433-437
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 32 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/pool/contract.algo.ts:438
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 7 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/pool/contract.algo.ts:439
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 26
    dig 36
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:1015
    // this.createShuffleDisbursement(rewardID, iterationAmount)
    b disburseRewards_after_if_else@30

disburseRewards_block@48:
    // smart_contracts/pool/contract.algo.ts:456
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 27
    dig 36
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:458
    // if (winnerCount === disbursed) {
    dig 6
    dig 21
    ==
    bz disburseRewards_else_body@50
    // smart_contracts/pool/contract.algo.ts:459
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:460
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    dig 38
    box_replace
    // smart_contracts/pool/contract.algo.ts:461-465
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 32 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/pool/contract.algo.ts:466
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 7 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    b disburseRewards_after_if_else@30

disburseRewards_else_body@50:
    // smart_contracts/pool/contract.algo.ts:468
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:469
    // this.rewards(rewardID).value.raffleCursor = { ticket, stake, disbursed }
    dig 10
    itob
    dig 13
    itob
    concat
    dig 22
    itob
    concat
    pushint 59 // 59
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@45:
    // smart_contracts/pool/contract.algo.ts:445
    // iterationAmount -= i
    dig 4
    dig 18
    -
    bury 5
    // smart_contracts/pool/contract.algo.ts:446
    // ticket++
    dig 9
    intc_1 // 1
    +
    dup
    bury 11
    // smart_contracts/pool/contract.algo.ts:447
    // currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    dig 4
    dup
    uncover 2
    intc_2 // 8
    box_extract
    btoi
    bury 23
    // smart_contracts/pool/contract.algo.ts:448
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 37
    box_replace
    // smart_contracts/pool/contract.algo.ts:449
    // i = 0
    intc_0 // 0
    bury 18
    // smart_contracts/pool/contract.algo.ts:450
    // stake = 0
    intc_0 // 0
    bury 12
    // smart_contracts/pool/contract.algo.ts:451
    // currentRangeEnd = 0
    intc_0 // 0
    bury 24

disburseRewards_after_if_else@46:
    // smart_contracts/pool/contract.algo.ts:453
    // currentRangeStart = currentRangeEnd + 1
    dig 23
    intc_1 // 1
    +
    bury 23
    // smart_contracts/pool/contract.algo.ts:419
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 17
    intc_1 // 1
    +
    bury 18
    b disburseRewards_while_top@36

disburseRewards_if_body@34:
    // smart_contracts/pool/contract.algo.ts:410
    // amount = actualSum / winnerCount
    dig 29
    dig 7
    /
    bury 28
    b disburseRewards_after_if_else@35

disburseRewards_bool_false@4:
    intc_0 // 0
    b disburseRewards_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution[routing]() -> void:
finalizeDistribution:
    // smart_contracts/pool/contract.algo.ts:1026
    // finalizeDistribution(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:1027
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 18 // "r"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1027
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    dup
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:1028
    // const { phase, activeDisbursementID } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 100 // 100
    intc_2 // 8
    box_extract
    dup
    btoi
    // smart_contracts/pool/contract.algo.ts:1029
    // assert(phase === DisbursementPhaseFinalization, ERR_DISBURSEMENT_NOT_READY_FOR_FINALIZATION)
    uncover 2
    bytec 13 // 0x1e
    ==
    assert // Disbursement not ready for finalization
    // smart_contracts/pool/contract.algo.ts:613
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:613
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:615-618
    // abiCall<typeof Rewards.prototype.finalizeDisbursement>({
    //   appId: rewardsApp,
    //   args: [disbursementID],
    // })
    itxn_begin
    pushbytes 0x5424a591 // method "finalizeDisbursement(uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/pool/contract.algo.ts:1033
    // this.disbursements(activeDisbursementID).create()
    itob
    // smart_contracts/pool/contract.algo.ts:169
    // disbursements = BoxMap<uint64, bytes<0>>({ keyPrefix: PoolBoxPrefixDisbursements })
    pushbytes "d"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1033
    // this.disbursements(activeDisbursementID).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/pool/contract.algo.ts:1035
    // this.rewards(rewardID).value.phase = DisbursementPhaseIdle
    dup
    pushint 91 // 91
    bytec_2 // 0x00
    box_replace
    // smart_contracts/pool/contract.algo.ts:1036
    // this.rewards(rewardID).value.activeDisbursementID = 0
    intc_0 // 0
    itob
    dig 1
    pushint 100 // 100
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1037
    // this.rewards(rewardID).value.activeDisbursementRoundStart = 0
    dig 1
    pushint 108 // 108
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1038
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 1
    intc_3 // 92
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1039
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 1
    pushint 33 // 33
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1040
    // this.rewards(rewardID).value.qualifiedStake = 0
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:1026
    // finalizeDistribution(rewardID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.check[routing]() -> void:
check:
    // smart_contracts/pool/contract.algo.ts:1043
    // check(address: Account, asset: uint64): { valid: boolean, balance: uint64 } {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:1044
    // const key: EntryKey = { address, asset }
    itob
    concat
    // smart_contracts/pool/contract.algo.ts:165
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1045
    // const id = this.entriesByAddress(key).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/pool/contract.algo.ts:1046
    // return this.checkByID(id)
    callsub checkByID
    // smart_contracts/pool/contract.algo.ts:1043
    // check(address: Account, asset: uint64): { valid: boolean, balance: uint64 } {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen[routing]() -> void:
signUpsOpen:
    // smart_contracts/pool/contract.algo.ts:1055
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1055
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    // smart_contracts/pool/contract.algo.ts:1055-1056
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/pool/contract.algo.ts:1056
    // Global.latestTimestamp > this.signupTimestamp.value &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 27 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:1056
    // Global.latestTimestamp > this.signupTimestamp.value &&
    app_global_get_ex
    assert // check GlobalState exists
    >
    // smart_contracts/pool/contract.algo.ts:1055-1056
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/pool/contract.algo.ts:1057
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 17 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1057
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    <
    bnz signUpsOpen_bool_true@5
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 22 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:1057
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    bz signUpsOpen_bool_false@6

signUpsOpen_bool_true@5:
    intc_1 // 1

signUpsOpen_bool_merge@7:
    // smart_contracts/pool/contract.algo.ts:1052
    // @abimethod({ readonly: true })
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

signUpsOpen_bool_false@6:
    intc_0 // 0
    b signUpsOpen_bool_merge@7


// smart_contracts/pool/contract.algo.ts::Pool.isLive[routing]() -> void:
isLive:
    // smart_contracts/pool/contract.algo.ts:1062
    // @abimethod({ readonly: true })
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.isEntered[routing]() -> void:
isEntered:
    // smart_contracts/pool/contract.algo.ts:1072
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    pushbytes "u"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1074
    // return this.uniques(address).exists;
    box_len
    bury 1
    // smart_contracts/pool/contract.algo.ts:1072
    // @abimethod({ readonly: true })
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.getState[routing]() -> void:
getState:
    // smart_contracts/pool/contract.algo.ts:1080
    // status: this.status.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1080
    // status: this.status.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1081
    // title: this.title.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 24 // "title"
    // smart_contracts/pool/contract.algo.ts:1081
    // title: this.title.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1082
    // type: this.type.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:1082
    // type: this.type.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1083
    // signupTimestamp: this.signupTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 27 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:1083
    // signupTimestamp: this.signupTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1084
    // allowLateSignups: this.allowLateSignups.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 22 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:1084
    // allowLateSignups: this.allowLateSignups.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1085
    // startTimestamp: this.startTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 17 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1085
    // startTimestamp: this.startTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1086
    // endTimestamp: this.endTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1086
    // endTimestamp: this.endTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1087
    // maxEntries: this.maxEntries.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:1087
    // maxEntries: this.maxEntries.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1088
    // entryCount: (this.entryID.value + 1),
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:1088
    // entryCount: (this.entryID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:1089
    // rewardCount: (this.rewardID.value + 1),
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 28 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:1089
    // rewardCount: (this.rewardID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:1090
    // totalStaked: this.totalStaked.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:133
    // totalStaked = GlobalState<uint64>({ key: PoolGlobalStateKeyTotalStaked })
    pushbytes "total_staked"
    // smart_contracts/pool/contract.algo.ts:1090
    // totalStaked: this.totalStaked.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1091
    // stakeKey: this.stakeKey.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 20 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:1091
    // stakeKey: this.stakeKey.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1092
    // minimumStakeAmount: this.minimumStakeAmount.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 25 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:1092
    // minimumStakeAmount: this.minimumStakeAmount.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1093
    // gateID: this.gateID.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:1093
    // gateID: this.gateID.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1094
    // creator: this.creator.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:1094
    // creator: this.creator.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1079-1095
    // return {
    //   status: this.status.value,
    //   title: this.title.value,
    //   type: this.type.value,
    //   signupTimestamp: this.signupTimestamp.value,
    //   allowLateSignups: this.allowLateSignups.value,
    //   startTimestamp: this.startTimestamp.value,
    //   endTimestamp: this.endTimestamp.value,
    //   maxEntries: this.maxEntries.value,
    //   entryCount: (this.entryID.value + 1),
    //   rewardCount: (this.rewardID.value + 1),
    //   totalStaked: this.totalStaked.value,
    //   stakeKey: this.stakeKey.value,
    //   minimumStakeAmount: this.minimumStakeAmount.value,
    //   gateID: this.gateID.value,
    //   creator: this.creator.value,
    // }
    dig 13
    len
    itob
    extract 6 2
    uncover 14
    concat
    uncover 14
    pushbytes 0x006f
    concat
    dig 1
    len
    pushint 111 // 111
    +
    swap
    uncover 15
    concat
    uncover 14
    itob
    concat
    uncover 12
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 14
    setbit
    concat
    uncover 11
    itob
    concat
    uncover 10
    itob
    concat
    uncover 9
    itob
    concat
    uncover 8
    itob
    concat
    uncover 7
    itob
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1077
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 16 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 26 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:113
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 16 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:52
    // args: [Txn.lease, Global.currentApplicationId.id],
    txn Lease
    global CurrentApplicationID
    itob
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    pushbytes 0x2c2f51c3 // method "isValidUpgrade(byte[32],uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/base-contracts/base.ts:55
    // assert(valid, ERR_INVALID_UPGRADE)
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:57
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 16 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 10 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:38
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/pool/base.ts::BasePool.mbr[routing]() -> void:
mbr:
    // smart_contracts/pool/base.ts:13
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    pushbytes 0x00000000000062d400000000000049d400000000000062d4
    swap
    concat
    // smart_contracts/pool/base.ts:20
    // disbursements: PoolDisbursementSMBR
    pushint 6100 // 6100
    // smart_contracts/pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    concat
    // smart_contracts/pool/base.ts:13
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.checkByID(id: uint64) -> bytes:
checkByID:
    // smart_contracts/pool/contract.algo.ts:473
    // private checkByID(id: uint64): { valid: boolean, balance: uint64 } {
    proto 1 1
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 3
    // smart_contracts/pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    bnz checkByID_bool_true@2
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    !=
    bz checkByID_bool_false@3

checkByID_bool_true@2:
    intc_1 // 1

checkByID_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:474-477
    // assert(
    //   this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    //   ERR_INVALID_POOL_TYPE_FOR_CHECK
    // )
    assert // Invalid pool type for check
    // smart_contracts/pool/contract.algo.ts:479
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    frame_dig -1
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 12 // "e"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/pool/contract.algo.ts:479
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    intc_0 // 0
    pushint 32 // 32
    box_extract
    frame_bury 0
    dig 1
    pushint 32 // 32
    intc_2 // 8
    box_extract
    dup
    frame_bury 1
    btoi
    frame_bury 3
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    frame_bury 4
    // smart_contracts/pool/contract.algo.ts:481
    // if (disqualified) {
    bz checkByID_after_if_else@6
    // smart_contracts/pool/contract.algo.ts:482
    // return { valid: false, balance: 0 }
    bytec 33 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_after_if_else@6:
    // smart_contracts/pool/contract.algo.ts:485
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:485
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 11 // 0x14
    ==
    bz checkByID_else_body@11
    // smart_contracts/pool/contract.algo.ts:486-489
    // const check = abiCall<typeof Staking.prototype.softCheck>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [address, asset],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:487
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:487
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:486-489
    // const check = abiCall<typeof Staking.prototype.softCheck>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [address, asset],
    // }).returnValue
    pushbytes 0x48716f1a // method "softCheck(address,uint64)(bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 9 // 9
    ==
    assert // invalid number of bytes for (bool1,uint64)
    pushint 5 // 5
    // smart_contracts/pool/contract.algo.ts:491
    // if (check.balance >= quantity) {
    extract_uint64
    dup
    frame_bury 5
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:492
    // return { valid: true, balance: check.balance }
    frame_dig 5
    itob
    bytec 23 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:511
    // this.entries(id).value.disqualified = true
    frame_dig 2
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:512
    // return { valid: false, balance: 0 }
    bytec 33 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_else_body@11:
    // smart_contracts/pool/contract.algo.ts:495-504
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [
    //     address,
    //     {
    //       asset: asset,
    //       type: this.stakingType(),
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:496
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:496
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:501
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:499-502
    // {
    //   asset: asset,
    //   type: this.stakingType(),
    // },
    frame_dig 3
    itob
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:495-504
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(Global.currentApplicationId).staking,
    //   args: [
    //     address,
    //     {
    //       asset: asset,
    //       type: this.stakingType(),
    //     },
    //   ],
    // }).returnValue
    bytec 30 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 4 // 4
    // smart_contracts/pool/contract.algo.ts:506
    // if (info.amount >= quantity) {
    extract_uint64
    dup
    frame_bury 6
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:507
    // return { valid: true, balance: info.amount }
    frame_dig 6
    itob
    bytec 23 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_bool_false@3:
    intc_0 // 0
    b checkByID_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.stakingType() -> bytes:
stakingType:
    // smart_contracts/pool/contract.algo.ts:525
    // assert(this.type.value !== POOL_STAKING_TYPE_NONE, 'pool staking type is not set')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:525
    // assert(this.type.value !== POOL_STAKING_TYPE_NONE, 'pool staking type is not set')
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec_2 // 0x00
    !=
    assert // pool staking type is not set
    // smart_contracts/pool/contract.algo.ts:526
    // return new Uint8(this.type.value.asUint64() - 1)
    btoi
    intc_1 // 1
    -
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
createRewardAllocations:
    // smart_contracts/pool/contract.algo.ts:568-573
    // private createRewardAllocations(
    //   disbursementID: uint64,
    //   asset: uint64,
    //   allocations: UserAllocation[],
    //   sum: uint64
    // ): void {
    proto 4 1
    // smart_contracts/pool/contract.algo.ts:575
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:575
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:646
    // return 24_900 * allocations.length
    frame_dig -2
    intc_0 // 0
    extract_uint16
    pushint 24900 // 24900
    *
    swap
    // smart_contracts/pool/contract.algo.ts:578
    // if (asset === 0) {
    frame_dig -3
    bnz createRewardAllocations_else_body@6
    // smart_contracts/pool/contract.algo.ts:580-590
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:584
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:585
    // amount: mbrAmount + sum,
    frame_dig 0
    frame_dig -1
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:583-586
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount + sum,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:580-590
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/pool/contract.algo.ts:587
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:580-590
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x5656acf9 // method "createUserAllocations(pay,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

createRewardAllocations_after_if_else@10:
    frame_dig -2
    swap
    retsub

createRewardAllocations_else_body@6:
    // smart_contracts/pool/contract.algo.ts:593-608
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:597
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:596-599
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:600-604
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    itxn_next
    // smart_contracts/pool/contract.algo.ts:601
    // assetReceiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:600-604
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:593-608
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/pool/contract.algo.ts:605
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:593-608
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x3c60dfa0 // method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b createRewardAllocations_after_if_else@10


// smart_contracts/pool/contract.algo.ts::Pool.addReward(payment: uint64, reward: bytes) -> bytes:
smart_contracts/pool/contract.algo.ts::Pool.addReward:
    // smart_contracts/pool/contract.algo.ts:757
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    proto 2 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/pool/contract.algo.ts:758
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:758
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/pool/contract.algo.ts:759
    // assert(reward.asset === 0, ERR_NOT_ALGO)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    !
    assert // Must be an Algo asset
    // smart_contracts/pool/contract.algo.ts:628
    // this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 20 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:628
    // this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    app_global_get_ex
    assert // check GlobalState exists
    extract 0 32
    global ZeroAddress
    !=
    bnz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@7
    frame_dig -1
    extract 8 1
    bytec 5 // 0x0a
    !=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@8

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@7:
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@9:
    // smart_contracts/pool/contract.algo.ts:627-630
    // assert(
    //   this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    //   ERR_STAKE_KEY_REQUIRED
    // )
    assert // Stake key required
    // smart_contracts/pool/contract.algo.ts:633
    // if (reward.distribution === DistributionTypeShuffle) {
    frame_dig -1
    extract 8 1
    dup
    frame_bury 0
    pushbytes 0x28
    ==
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:634
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    dup
    frame_bury 1
    >
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13
    frame_dig 1
    pushint 10 // 10
    <=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@14:
    // smart_contracts/pool/contract.algo.ts:634
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    assert // Rate must be greater than winner count

smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:638
    // if (reward.distribution === DistributionTypeEven) {
    frame_dig 0
    bytec 13 // 0x1e
    ==
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@21
    // smart_contracts/pool/contract.algo.ts:639
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:639
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@18
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 14 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:639
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    <=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@19

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@18:
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:639
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    assert // Max entries cannot be greater than rate

smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@21:
    // smart_contracts/pool/contract.algo.ts:642
    // assert(reward.rate > 0, ERR_RATE_MUST_BE_GREATER_THAN_ZERO)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    assert // Rate must be greater than zero
    // smart_contracts/pool/contract.algo.ts:763-772
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:766
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:763-772
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/pool/contract.algo.ts:768
    // greaterThanEq: this.rewardsMbr(reward.winnerCount)
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    // smart_contracts/pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/pool/contract.algo.ts:763-772
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    >=
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:181
    // const id = this.rewardID.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 28 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:181
    // const id = this.rewardID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:182
    // this.rewardID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 28 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:182
    // this.rewardID.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:775
    // this.rewards(id).value = clone(reward)
    itob
    // smart_contracts/pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 18 // "r"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:775
    // this.rewards(id).value = clone(reward)
    dup
    box_del
    pop
    frame_dig -1
    box_put
    frame_dig -1
    frame_bury 0
    retsub

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@19:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@20

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@14

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@8:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@9


// smart_contracts/pool/contract.algo.ts::Pool.raffle(rewardID: uint64) -> void:
smart_contracts/pool/contract.algo.ts::Pool.raffle:
    // smart_contracts/pool/contract.algo.ts:943
    // raffle(rewardID: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 7
    // smart_contracts/pool/contract.algo.ts:944
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    frame_dig -1
    itob
    // smart_contracts/pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 18 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:944
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:951
    // } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 108 // 108
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    cover 4
    // smart_contracts/pool/contract.algo.ts:953
    // assert(phase === DisbursementPhaseAllocation, ERR_INVALID_DISBURSEMENT_PHASE)
    uncover 2
    bytec 11 // 0x14
    ==
    assert // Invalid disbursement phase
    // smart_contracts/pool/contract.algo.ts:954
    // assert(winningTickets.length === 0, ERR_WINNING_TICKETS_ALREADY_EXIST)
    uncover 2
    pushints 124 2 // 124, 2
    box_extract
    btoi
    !
    assert // Winning tickets already exist
    // smart_contracts/pool/contract.algo.ts:956
    // const roundToUse: uint64 = activeDisbursementRoundStart + 1 + (4 * vrfFailureCount)
    swap
    intc_1 // 1
    +
    pushint 4 // 4
    uncover 2
    *
    +
    // smart_contracts/pool/contract.algo.ts:958-961
    // const seed = abiCall<typeof RandomnessBeacon.prototype.get>({
    //   appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //   args: [roundToUse, this.salt.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:959
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:48
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:959
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:960
    // args: [roundToUse, this.salt.value],
    swap
    itob
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:156
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 29 // "salt"
    // smart_contracts/pool/contract.algo.ts:960
    // args: [roundToUse, this.salt.value],
    app_global_get_ex
    assert // check GlobalState exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:958-961
    // const seed = abiCall<typeof RandomnessBeacon.prototype.get>({
    //   appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //   args: [roundToUse, this.salt.value],
    // }).returnValue
    pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/pool/contract.algo.ts:963
    // if (seed.length === 0) {
    len
    dup
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@3
    // smart_contracts/pool/contract.algo.ts:964
    // this.rewards(rewardID).value.vrfFailureCount += 1
    frame_dig 12
    dup
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    pushint 83 // 83
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:965
    // return
    retsub

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@3:
    // smart_contracts/pool/contract.algo.ts:969
    // const rngState = pcg64Init(seed.slice(0, 16))
    intc_0 // 0
    frame_dig 15
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig 14
    cover 2
    substring3
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:16
    // assert(seed.length === 16)
    dup
    len
    pushint 16 // 16
    ==
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:92
    // const state = __pcg32Step(0, incr)
    intc_0 // 0
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    dup
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    cover 2
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    uncover 2
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    swap
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:18-21
    // return [
    //     __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    //     __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    // ]
    swap
    itob
    swap
    itob
    concat
    frame_bury 2
    // smart_contracts/pool/contract.algo.ts:973
    // if (upperBound < MAX_UINT64) {
    frame_dig 13
    intc 10 // 18446744073709551615
    <
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_if_body@4
    frame_dig 13
    frame_bury 11

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@5:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:30
    // const result = new DynamicArray<arc4.Uint64>()
    intc_0 // 0
    itob
    frame_bury 0
    bytec 7 // 0x0000
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:42
    // if (upperBound !== 0) {
    frame_dig 11
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_else_body@14
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:43
    // assert(upperBound > 1)
    frame_dig 11
    dup
    intc_1 // 1
    >
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    intc_1 // 1
    -
    dup
    frame_bury 4
    // smart_contracts/pool/contract.algo.ts:977
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    >
    assert

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@15:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    frame_dig 4
    dup
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:53
    // const threshold: uint64 = __uint64Twos(absoluteBound) % absoluteBound
    swap
    %
    frame_bury 10
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    intc_0 // 0
    frame_bury 7
    frame_dig 2
    frame_bury 3

smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@16:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    // smart_contracts/pool/contract.algo.ts:977
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    pushint 15 // 15
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    <
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_while@22

smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@18:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    frame_dig 3
    dup
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 9
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    dup
    cover 2
    frame_bury 5
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    swap
    intc_2 // 8
    extract_uint64
    frame_bury 8
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_false@26
    pushint 2885390081777926818 // 2885390081777926818

smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_merge@27:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    frame_dig 8
    dup
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:12
    // return [[newState1, newState2], op.shl(__pcg32Output(state[0]), 32) | __pcg32Output(state[1])]
    frame_dig 5
    itob
    swap
    itob
    concat
    frame_dig 9
    callsub __pcg32Output
    pushint 32 // 32
    shl
    uncover 2
    callsub __pcg32Output
    |
    itob
    concat
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:57
    // const [newState, candidate] = __pcg64UnboundedRandom(state)
    dup
    extract 0 16
    swap
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 6
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:59
    // if (candidate >= threshold) {
    frame_dig 10
    >=
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@20
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    frame_dig 6
    frame_dig 4
    %
    // smart_contracts/pool/contract.algo.ts:977
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    +
    itob
    frame_dig 1
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    frame_bury 3
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@16

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@20:
    frame_bury 3
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@18

smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_false@26:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    intc 8 // 1442695040888963409
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_merge@27

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_while@22:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:67
    // return [state, result]
    frame_dig 3
    pushbytes 0x0012
    concat
    frame_dig 1
    concat
    // smart_contracts/pool/contract.algo.ts:979
    // this.rewards(rewardID).value.winningTickets = decodeArc4<uint64[]>(rngResult[1].bytes)
    dup
    pushint 16 // 16
    extract_uint16
    dig 1
    len
    substring3
    frame_dig 12
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    dig 1
    swap
    box_put
    // smart_contracts/pool/contract.algo.ts:980
    // this.rewards(rewardID).value.vrfFailureCount = 0
    pushint 83 // 83
    frame_dig 0
    box_replace
    retsub

smart_contracts/pool/contract.algo.ts::Pool.raffle_else_body@14:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:50
    // absoluteBound = op.btoi(Bytes(BigUint(2 ** 64) - BigUint(lowerBound)))
    intc 10 // 18446744073709551615
    frame_bury 4
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@15

smart_contracts/pool/contract.algo.ts::Pool.raffle_if_body@4:
    // smart_contracts/pool/contract.algo.ts:974
    // upperBound += 1
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 11
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@5


// smart_contracts/pool/contract.algo.ts::Pool.isLive() -> uint64:
smart_contracts/pool/contract.algo.ts::Pool.isLive:
    // smart_contracts/pool/contract.algo.ts:1065
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1065
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    // smart_contracts/pool/contract.algo.ts:1065-1066
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:1066
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 17 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1066
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    app_global_get_ex
    assert // check GlobalState exists
    >=
    // smart_contracts/pool/contract.algo.ts:1065-1066
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:1067
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1067
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    <=
    bnz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_true@4
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1067
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    bnz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5

smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_true@4:
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:1064-1068
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub

smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5:
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:1064-1068
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub
