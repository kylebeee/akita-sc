#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 6 40 400 6364136223846793005 1442695040888963407 1442695040888963409 100000 4294967295 18446744073709551615
    bytecblock "disbursement_cursor" 0x00 "entry_count" "akita_dao" "disbursement_phase" "qualified_stake" 0x151f7c75 "type" "akita_al" "status" "active_disbursement_id" 0x01 0x02 0x0000 "e" 0x03 "wtickets" "reward" "gate_id" "start_timestamp" "vrf_failure_count" "end_timestamp" "creator" "max_entries" "allow_late_signups" "raffle_cursor" "title" "stake_key" "minimum_stake_amount" "active_disbursement_window" "signup_timestamp" 0xc9068809 "salt" "last_disbursement_timestamp"
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txn NumAppArgs
    bz main_after_if_else@26
    pushbytess 0x3b5075f4 0x83f14748 0x215215e0 0x181e8291 0x68558c70 0xb7355fd1 0x22267cc0 0x696501de 0x5fedc91a 0x5f502c1e 0xb223d35d 0x592ee341 0x8fa4a160 0x655e772e 0x1747405b 0x33e92c94 0x3ea11832 0xd9a35fa4 // method "createApplication(string,uint8,(uint64,uint8,uint64,uint64,uint64),address,address,(address,string),uint64,uint64,uint64,uint64)void", method "init()void", method "deleteApplication(address)void", method "finalize(uint64,uint64,uint64)void", method "enter(pay,(uint64,uint64,byte[32][])[],byte[][])void", method "withdraw()void", method "startDisbursement()void", method "raffle()void", method "disburseRewards(uint64)void", method "finalizeDistribution()void", method "check(address,uint64)(bool,uint64)", method "signUpsOpen()bool", method "isLive()bool", method "getState()(uint8,string,uint8,(uint64,uint8,uint64,uint64,uint64),uint64,uint64,bool,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)", method "updateApplication(string)void", method "updateAkitaDAO(uint64)void", method "optin(pay,uint64)void", method "mbr()(uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match main_createApplication_route@5 main_init_route@6 main_deleteApplication_route@7 main_finalize_route@8 main_enter_route@9 main_withdraw_route@10 main_startDisbursement_route@11 main_raffle_route@12 main_disburseRewards_route@13 main_finalizeDistribution_route@14 main_check_route@15 main_signUpsOpen_route@16 main_isLive_route@17 main_getState_route@18 main_updateApplication_route@19 main_updateAkitaDAO_route@20 main_optin_route@21 main_mbr_route@22

main_after_if_else@26:
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    intc_0 // 0
    return

main_mbr_route@22:
    // smart_contracts/pool/base.ts:6
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500000000000062d400000000000062d400000000000017d4
    log
    intc_1 // 1
    return

main_optin_route@21:
    // smart_contracts/utils/base-contracts/optin.ts:51
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/optin.ts:51
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    callsub optin
    intc_1 // 1
    return

main_updateAkitaDAO_route@20:
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_updateApplication_route@19:
    // smart_contracts/utils/base-contracts/base.ts:19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_1 // 1
    return

main_getState_route@18:
    // smart_contracts/pool/contract.algo.ts:903
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getState
    dig 18
    len
    itob
    extract 6 2
    uncover 19
    concat
    uncover 17
    itob
    uncover 16
    itob
    uncover 16
    itob
    uncover 16
    itob
    uncover 3
    uncover 17
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 13
    itob
    uncover 13
    itob
    bytec_1 // 0x00
    intc_0 // 0
    uncover 15
    setbit
    uncover 13
    itob
    uncover 13
    itob
    uncover 13
    itob
    uncover 13
    itob
    dig 12
    len
    itob
    extract 6 2
    uncover 13
    concat
    uncover 13
    pushbytes 0x0022
    concat
    swap
    concat
    uncover 12
    itob
    uncover 12
    itob
    uncover 14
    pushbytes 0x0088
    concat
    dig 12
    len
    pushint 136 // 136
    +
    swap
    uncover 15
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isLive_route@17:
    // smart_contracts/pool/contract.algo.ts:894
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub isLive
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_signUpsOpen_route@16:
    // smart_contracts/pool/contract.algo.ts:884
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub signUpsOpen
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_check_route@15:
    // smart_contracts/pool/contract.algo.ts:875
    // check(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/pool/contract.algo.ts:875
    // check(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    callsub check
    bytec_1 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    swap
    itob
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_finalizeDistribution_route@14:
    // smart_contracts/pool/contract.algo.ts:860
    // finalizeDistribution(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalizeDistribution
    intc_1 // 1
    return

main_disburseRewards_route@13:
    // smart_contracts/pool/contract.algo.ts:829
    // disburseRewards(iterationAmount: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/pool/contract.algo.ts:829
    // disburseRewards(iterationAmount: uint64): void {
    callsub disburseRewards
    intc_1 // 1
    return

main_raffle_route@12:
    // smart_contracts/pool/contract.algo.ts:795
    // raffle(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub raffle
    intc_1 // 1
    return

main_startDisbursement_route@11:
    // smart_contracts/pool/contract.algo.ts:774
    // startDisbursement(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub startDisbursement
    intc_1 // 1
    return

main_withdraw_route@10:
    // smart_contracts/pool/contract.algo.ts:772
    // withdraw(): void { }
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_enter_route@9:
    // smart_contracts/pool/contract.algo.ts:692
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pool/contract.algo.ts:692
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    callsub enter
    intc_1 // 1
    return

main_finalize_route@8:
    // smart_contracts/pool/contract.algo.ts:662
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/pool/contract.algo.ts:662
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    callsub finalize
    intc_1 // 1
    return

main_deleteApplication_route@7:
    // smart_contracts/pool/contract.algo.ts:653
    // @abimethod({ allowActions: 'DeleteApplication' })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    // smart_contracts/pool/contract.algo.ts:653
    // @abimethod({ allowActions: 'DeleteApplication' })
    callsub deleteApplication
    intc_1 // 1
    return

main_init_route@6:
    // smart_contracts/pool/contract.algo.ts:641
    // init() {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub init
    intc_1 // 1
    return

main_createApplication_route@5:
    // smart_contracts/pool/contract.algo.ts:581
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/pool/contract.algo.ts:100-104
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseContract,
    //   ContractWithCreatorOnlyOptIn
    // ) {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    btoi
    txna ApplicationArgs 9
    btoi
    txna ApplicationArgs 10
    btoi
    // smart_contracts/pool/contract.algo.ts:581
    // @abimethod({ onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
__pcg32Output:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:23
    // export function __pcg32Output(state: PCG32STATE): uint64 {
    proto 1 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:24
    // const xorshifted = __maskToUint32(op.shr(op.shr(state, 18) ^ state, 27))
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:25
    // const rot = op.shr(state, 59)
    frame_dig -1
    pushint 59 // 59
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    dup2
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    |
    retsub


// smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes, id: uint64, args: bytes) -> uint64, bytes:
gateCheck:
    // smart_contracts/utils/functions.ts:128
    // export function gateCheck(akitaDAO: Application, caller: Address, id: uint64, args: GateArgs): boolean {
    proto 4 2
    // smart_contracts/utils/functions.ts:129
    // if (id === 0) {
    frame_dig -2
    bnz gateCheck_after_if_else@2
    // smart_contracts/utils/functions.ts:130
    // return true
    intc_1 // 1
    frame_dig -1
    retsub

gateCheck_after_if_else@2:
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -4
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:135
    // args: [caller, id, args],
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:136
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    frame_dig -1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.checkByID(id: uint64) -> uint64, uint64:
checkByID:
    // smart_contracts/pool/contract.algo.ts:418
    // private checkByID(id: uint64): { valid: boolean, balance: uint64 } {
    proto 1 2
    intc_0 // 0
    dup
    pushbytes ""
    dupn 3
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:33
    // export const POOL_STAKING_TYPE_NONE: PoolStakingType = new arc4.UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:420
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    !=
    bnz checkByID_bool_true@2
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:34
    // export const POOL_STAKING_TYPE_HEARTBEAT: PoolStakingType = new arc4.UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:420
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    !=
    bz checkByID_bool_false@3

checkByID_bool_true@2:
    intc_1 // 1

checkByID_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:419-422
    // assert(
    //   this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    //   ERR_INVALID_POOL_TYPE_FOR_CHECK
    // )
    assert // Invalid pool type for check
    // smart_contracts/pool/contract.algo.ts:424
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig -1
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:424
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 1
    dup
    pushint 32 // 32
    extract_uint64
    frame_bury 3
    dup
    intc_3 // 40
    extract_uint64
    frame_bury 4
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:426
    // if (entry.disqualified) {
    bz checkByID_after_if_else@6
    // smart_contracts/pool/contract.algo.ts:427
    // return { valid: false, balance: 0 }
    intc_0 // 0
    dup
    frame_bury 1
    frame_bury 0
    retsub

checkByID_after_if_else@6:
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:35
    // export const POOL_STAKING_TYPE_SOFT: PoolStakingType = new arc4.UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:430
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    ==
    bz checkByID_else_body@11
    // smart_contracts/pool/contract.algo.ts:431-435
    // const check = abiCall(Staking.prototype.softCheck, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:433
    // args: [entry.address, entry.asset],
    frame_dig 3
    itob
    // smart_contracts/pool/contract.algo.ts:431-435
    // const check = abiCall(Staking.prototype.softCheck, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset],
    //   fee,
    // }).returnValue
    pushbytes 0x48716f1a // method "softCheck(address,uint64)(bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:431-435
    // const check = abiCall(Staking.prototype.softCheck, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 5 // 5
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/pool/contract.algo.ts:437
    // if (check.balance >= entry.quantity) {
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:438
    // return { valid: true, balance: check.balance }
    intc_1 // 1
    frame_dig 2
    frame_bury 1
    frame_bury 0
    retsub

checkByID_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:458
    // this.entries(id).value.disqualified = new Bool(true)
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    intc 4 // 400
    intc_1 // 1
    setbit
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/pool/contract.algo.ts:459
    // return { valid: false, balance: 0 }
    intc_0 // 0
    dup
    frame_bury 1
    frame_bury 0
    retsub

checkByID_else_body@11:
    // smart_contracts/pool/contract.algo.ts:441-451
    // const info = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     entry.address,
    //     new arc4StakeInfo({
    //       asset: new UintN64(entry.asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:446
    // asset: new UintN64(entry.asset),
    frame_dig 3
    itob
    // smart_contracts/pool/contract.algo.ts:447
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:445-448
    // new arc4StakeInfo({
    //   asset: new UintN64(entry.asset),
    //   type: this.stakingType(),
    // }),
    concat
    // smart_contracts/pool/contract.algo.ts:441-451
    // const info = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     entry.address,
    //     new arc4StakeInfo({
    //       asset: new UintN64(entry.asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    bytec 31 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:441-451
    // const info = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     entry.address,
    //     new arc4StakeInfo({
    //       asset: new UintN64(entry.asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 4 // 4
    extract_uint64
    dup
    frame_bury 5
    // smart_contracts/pool/contract.algo.ts:453
    // if (info.amount >= entry.quantity) {
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:454
    // return { valid: true, balance: info.amount }
    intc_1 // 1
    frame_dig 5
    frame_bury 1
    frame_bury 0
    retsub

checkByID_bool_false@3:
    intc_0 // 0
    b checkByID_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart() -> uint64:
getLatestWindowStart:
    // smart_contracts/pool/contract.algo.ts:463
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % this.rewardInterval.value)
    global LatestTimestamp
    dup
    // smart_contracts/pool/constants.ts:11
    // export const PoolGlobalStateKeyStartTimestamp = 'start_timestamp'
    intc_0 // 0
    bytec 19 // "start_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:463
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % this.rewardInterval.value)
    -
    // smart_contracts/pool/constants.ts:13
    // export const PoolGlobalStateKeyRewardInterval = 'reward_interval'
    intc_0 // 0
    pushbytes "reward_interval"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:463
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % this.rewardInterval.value)
    %
    -
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.stakingType() -> bytes:
stakingType:
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:33
    // export const POOL_STAKING_TYPE_NONE: PoolStakingType = new arc4.UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:472
    // assert(this.type.value !== POOL_STAKING_TYPE_NONE, 'pool staking type is not set')
    !=
    assert // pool staking type is not set
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:473
    // return new UintN8(this.type.value.native - 1)
    btoi
    intc_1 // 1
    -
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
createRewardAllocations:
    // smart_contracts/pool/contract.algo.ts:518-523
    // private createRewardAllocations(
    //   disbursementID: uint64,
    //   asset: uint64,
    //   allocations: arc4UserAllocations,
    //   sum: uint64
    // ): void {
    proto 4 1
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:576
    // return 24_900 * allocations.length
    frame_dig -2
    intc_0 // 0
    extract_uint16
    pushint 24900 // 24900
    *
    swap
    // smart_contracts/pool/contract.algo.ts:528
    // if (asset === 0) {
    frame_dig -3
    bnz createRewardAllocations_else_body@6
    // smart_contracts/pool/contract.algo.ts:530-541
    // abiCall(Rewards.prototype.createUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:534
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:535
    // amount: mbrAmount + sum,
    frame_dig 0
    frame_dig -1
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:533-537
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount + sum,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:530-541
    // abiCall(Rewards.prototype.createUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/pool/contract.algo.ts:538
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:530-541
    // abiCall(Rewards.prototype.createUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x5656acf9 // method "createUserAllocations(pay,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

createRewardAllocations_after_if_else@10:
    frame_dig -2
    swap
    retsub

createRewardAllocations_else_body@6:
    // smart_contracts/pool/contract.algo.ts:544-561
    // abiCall(Rewards.prototype.createAsaUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //       fee,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:548
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:547-551
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:552-557
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    //   fee,
    // }),
    itxn_next
    // smart_contracts/pool/contract.algo.ts:553
    // assetReceiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:552-557
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    //   fee,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:544-561
    // abiCall(Rewards.prototype.createAsaUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //       fee,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/pool/contract.algo.ts:558
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:544-561
    // abiCall(Rewards.prototype.createAsaUserAllocations, {
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //       fee,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //       fee,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x3c60dfa0 // method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b createRewardAllocations_after_if_else@10


// smart_contracts/pool/contract.algo.ts::Pool.createApplication(title: bytes, type: bytes, reward: bytes, creator: bytes, marketplace: bytes, stakeKey: bytes, minimumStakeAmount: uint64, gateID: uint64, maxEntries: uint64, akitaDAO: uint64) -> void:
createApplication:
    // smart_contracts/pool/contract.algo.ts:581-593
    // @abimethod({ onCreate: 'require' })
    // createApplication(
    //   title: string,
    //   type: StakingType,
    //   reward: arc4Reward,
    //   creator: Address,
    //   marketplace: Address,
    //   stakeKey: arc4RootKey,
    //   minimumStakeAmount: uint64,
    //   gateID: uint64,
    //   maxEntries: uint64,
    //   akitaDAO: uint64
    // ): void {
    proto 10 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    bytec 9 // "status"
    // smart_contracts/pool/constants.ts:38
    // export const PoolStatusDraft = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:594
    // this.status.value = PoolStatusDraft
    app_global_put
    // smart_contracts/pool/constants.ts:6
    // export const PoolGlobalStateKeyTitle = 'title'
    bytec 26 // "title"
    // smart_contracts/pool/contract.algo.ts:595
    // this.title.value = title
    frame_dig -10
    app_global_put
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    bytec 7 // "type"
    // smart_contracts/pool/contract.algo.ts:596
    // this.type.value = type
    frame_dig -9
    app_global_put
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    bytec 17 // "reward"
    // smart_contracts/pool/contract.algo.ts:597
    // this.reward.value = reward.copy()
    frame_dig -8
    app_global_put
    // smart_contracts/pool/contract.algo.ts:598
    // const decodedReward = decodeArc4<Reward>(reward.bytes)
    frame_dig -8
    pushint 9 // 9
    extract_uint64
    dup
    frame_dig -8
    pushint 25 // 25
    extract_uint64
    swap
    // smart_contracts/pool/contract.algo.ts:599
    // assert(decodedReward.rate > 0, ERR_RATE_MUST_BE_GREATER_THAN_ZERO)
    assert // Rate must be greater than zero
    // smart_contracts/pool/constants.ts:23
    // export const PoolGlobalStateKeyCreator = 'creator'
    bytec 22 // "creator"
    // smart_contracts/pool/contract.algo.ts:600
    // this.creator.value = creator
    frame_dig -7
    app_global_put
    // smart_contracts/pool/constants.ts:24
    // export const PoolGlobalStateKeyMarketplace = 'marketplace'
    pushbytes "marketplace"
    // smart_contracts/pool/contract.algo.ts:601
    // this.marketplace.value = marketplace
    frame_dig -6
    app_global_put
    // smart_contracts/pool/contract.algo.ts:609
    // stakeKey.address.native !== Global.zeroAddress ||
    frame_dig -5
    extract 0 32 // on error: Index access is out of bounds
    global ZeroAddress
    !=
    // smart_contracts/pool/contract.algo.ts:609-610
    // stakeKey.address.native !== Global.zeroAddress ||
    // reward.distribution !== DistributionTypePercentage,
    bnz createApplication_bool_true@2
    // smart_contracts/pool/contract.algo.ts:610
    // reward.distribution !== DistributionTypePercentage,
    frame_dig -8
    extract 8 1 // on error: Index access is out of bounds
    // smart_contracts/pool/types.ts:14
    // export const DistributionTypePercentage = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:610
    // reward.distribution !== DistributionTypePercentage,
    !=
    // smart_contracts/pool/contract.algo.ts:609-610
    // stakeKey.address.native !== Global.zeroAddress ||
    // reward.distribution !== DistributionTypePercentage,
    bz createApplication_bool_false@3

createApplication_bool_true@2:
    intc_1 // 1

createApplication_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:608-612
    // assert(
    //   stakeKey.address.native !== Global.zeroAddress ||
    //   reward.distribution !== DistributionTypePercentage,
    //   ERR_STAKE_KEY_REQUIRED
    // )
    assert // Stake key required
    // smart_contracts/pool/contract.algo.ts:614
    // if (reward.distribution === DistributionTypeShuffle) {
    frame_dig -8
    extract 8 1 // on error: Index access is out of bounds
    dup
    frame_bury 0
    // smart_contracts/pool/types.ts:29
    // export const DistributionTypeShuffle = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:614
    // if (reward.distribution === DistributionTypeShuffle) {
    ==
    bz createApplication_after_if_else@6
    // smart_contracts/pool/contract.algo.ts:615
    // assert(decodedReward.rate > decodedReward.winnerCount, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    frame_dig 2
    frame_dig 3
    >
    assert // Rate must be greater than winner count

createApplication_after_if_else@6:
    // smart_contracts/pool/contract.algo.ts:618
    // if (reward.distribution === DistributionTypeEven) {
    frame_dig 0
    // smart_contracts/pool/types.ts:24
    // export const DistributionTypeEven = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:618
    // if (reward.distribution === DistributionTypeEven) {
    ==
    frame_dig -2
    frame_bury 1
    bz createApplication_after_if_else@10
    // smart_contracts/pool/contract.algo.ts:619
    // assert(maxEntries < decodedReward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    frame_dig -2
    frame_dig 2
    <
    assert // Max entries cannot be greater than rate
    frame_dig -2
    frame_bury 1
    // smart_contracts/pool/contract.algo.ts:620
    // if (maxEntries === 0) {
    frame_dig -2
    bnz createApplication_after_if_else@9
    frame_dig 2
    frame_bury 1

createApplication_after_if_else@9:
    frame_dig 1
    dup
    frame_bury -2
    frame_bury 1

createApplication_after_if_else@10:
    frame_dig 1
    frame_bury -2
    // smart_contracts/pool/constants.ts:19
    // export const PoolGlobalStateKeyStakeKey = 'stake_key'
    bytec 27 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:625
    // this.stakeKey.value = stakeKey.copy()
    frame_dig -5
    app_global_put
    // smart_contracts/pool/constants.ts:20
    // export const PoolGlobalStateKeyMinimumStakeAmount = 'minimum_stake_amount'
    bytec 28 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:626
    // this.minimumStakeAmount.value = minimumStakeAmount
    frame_dig -4
    app_global_put
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    bytec 18 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:627
    // this.gateID.value = gateID
    frame_dig -3
    app_global_put
    // smart_contracts/pool/constants.ts:15
    // export const PoolGlobalStateKeyMaxEntries = 'max_entries'
    bytec 23 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:628
    // this.maxEntries.value = maxEntries
    frame_dig -2
    app_global_put
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_3 // "akita_dao"
    // smart_contracts/pool/contract.algo.ts:629
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -1
    app_global_put
    // smart_contracts/pool/constants.ts:25
    // export const PoolGlobalStateKeySalt = 'salt'
    bytec 32 // "salt"
    // smart_contracts/pool/contract.algo.ts:630
    // this.salt.value = Txn.txId
    txn TxID
    app_global_put
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:42
    // export const DisbursementPhaseIdle = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:631
    // this.disbursementPhase.value = DisbursementPhaseIdle
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    bytec 10 // "active_disbursement_id"
    // smart_contracts/pool/contract.algo.ts:632
    // this.activeDisbursementID.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:27
    // export const PoolGlobalStateKeyActiveDisbursementWindow = 'active_disbursement_window'
    bytec 29 // "active_disbursement_window"
    // smart_contracts/pool/contract.algo.ts:633
    // this.activeDisbursementWindow.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:634
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:635
    // this.qualifiedStakers.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:636
    // this.qualifiedStake.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    bytec 16 // "wtickets"
    // smart_contracts/pool/contract.algo.ts:637
    // this.winningTickets.value = new DynamicArray<UintN64>()
    bytec 13 // 0x0000
    app_global_put
    // smart_contracts/pool/constants.ts:32
    // export const PoolGlobalStateKeyVRFFailureCount = 'vrf_failure_count'
    bytec 20 // "vrf_failure_count"
    // smart_contracts/pool/contract.algo.ts:638
    // this.vrfGetFailureCount.value = 0
    intc_0 // 0
    app_global_put
    retsub

createApplication_bool_false@3:
    intc_0 // 0
    b createApplication_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.init() -> void:
init:
    // smart_contracts/pool/contract.algo.ts:642
    // assert(Global.callerApplicationAddress === Global.creatorAddress, 'only the factory can init the pool')
    global CallerApplicationAddress
    global CreatorAddress
    ==
    assert // only the factory can init the pool
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 18 // "gate_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:644
    // if (this.gateID.value > 0) {
    bz init_after_if_else@3
    // smart_contracts/pool/contract.algo.ts:645-649
    // this.gateSize.value = abiCall(Gate.prototype.size, {
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 40
    extract_uint64
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 18 // "gate_id"
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/pool/contract.algo.ts:645-649
    // this.gateSize.value = abiCall(Gate.prototype.size, {
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    //   fee,
    // }).returnValue
    pushbytes 0xdf56b01e // method "size(uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:645-649
    // this.gateSize.value = abiCall(Gate.prototype.size, {
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/pool/constants.ts:22
    // export const PoolGlobalStateKeyGateSize = 'gate_size'
    pushbytes "gate_size"
    // smart_contracts/pool/contract.algo.ts:645-649
    // this.gateSize.value = abiCall(Gate.prototype.size, {
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    //   fee,
    // }).returnValue
    swap
    app_global_put

init_after_if_else@3:
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.deleteApplication(caller: bytes) -> void:
deleteApplication:
    // smart_contracts/pool/contract.algo.ts:653-654
    // @abimethod({ allowActions: 'DeleteApplication' })
    // deleteApplication(caller: Address): void {
    proto 1 0
    // smart_contracts/pool/contract.algo.ts:655
    // assert(Txn.sender === Global.creatorAddress, 'call must come from factory')
    txn Sender
    global CreatorAddress
    ==
    assert // call must come from factory
    // smart_contracts/pool/constants.ts:23
    // export const PoolGlobalStateKeyCreator = 'creator'
    intc_0 // 0
    bytec 22 // "creator"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:656
    // assert(caller.native === this.creator.value.native, 'only the creator can delete the pool')
    frame_dig -1
    ==
    assert // only the creator can delete the pool
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:38
    // export const PoolStatusDraft = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:657
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    ==
    bnz deleteApplication_bool_true@2
    global LatestTimestamp
    // smart_contracts/pool/constants.ts:12
    // export const PoolGlobalStateKeyEndTimestamp = 'end_timestamp'
    intc_0 // 0
    bytec 21 // "end_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:657
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    >
    bz deleteApplication_bool_false@3

deleteApplication_bool_true@2:
    intc_1 // 1

deleteApplication_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:657
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    assert // the pool must be in draft or ended
    retsub

deleteApplication_bool_false@3:
    intc_0 // 0
    b deleteApplication_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) -> void:
finalize:
    // smart_contracts/pool/contract.algo.ts:662
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    proto 3 0
    pushbytes ""
    // smart_contracts/pool/contract.algo.ts:663
    // assert(Txn.sender === this.creator.value.native, 'only the creator can finalize the pool')
    txn Sender
    // smart_contracts/pool/constants.ts:23
    // export const PoolGlobalStateKeyCreator = 'creator'
    intc_0 // 0
    bytec 22 // "creator"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:663
    // assert(Txn.sender === this.creator.value.native, 'only the creator can finalize the pool')
    ==
    assert // only the creator can finalize the pool
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:38
    // export const PoolStatusDraft = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:664
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    ==
    assert // the pool must be in draft state to finalize
    // smart_contracts/pool/contract.algo.ts:666
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    frame_dig -3
    global LatestTimestamp
    >
    bnz finalize_bool_true@3
    frame_dig -3
    bnz finalize_bool_false@4
    // smart_contracts/pool/constants.ts:10
    // export const PoolGlobalStateKeyAllowLateSignups = 'allow_late_signups'
    intc_0 // 0
    bytec 24 // "allow_late_signups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:666
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    bz finalize_bool_false@4

finalize_bool_true@3:
    intc_1 // 1

finalize_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:665-668
    // assert(
    //   signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    //   'the signup round must be zero and late sign ups allowed or in the future'
    // )
    assert // the signup round must be zero and late sign ups allowed or in the future
    // smart_contracts/pool/contract.algo.ts:671-672
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    frame_dig -2
    bz finalize_bool_true@7
    // smart_contracts/pool/contract.algo.ts:672
    // startTimestamp > Global.latestTimestamp,
    frame_dig -2
    global LatestTimestamp
    >
    // smart_contracts/pool/contract.algo.ts:671-672
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    bz finalize_bool_false@8

finalize_bool_true@7:
    intc_1 // 1

finalize_bool_merge@9:
    // smart_contracts/pool/contract.algo.ts:670-674
    // assert(
    //   startTimestamp === 0 ||
    //   startTimestamp > Global.latestTimestamp,
    //   'the starting round must be zero or in the future'
    // )
    assert // the starting round must be zero or in the future
    frame_dig -2
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:676
    // if (startTimestamp === 0) {
    frame_dig -2
    bnz finalize_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:677
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    frame_dig -3
    bnz finalize_bool_false@13
    // smart_contracts/pool/constants.ts:10
    // export const PoolGlobalStateKeyAllowLateSignups = 'allow_late_signups'
    intc_0 // 0
    bytec 24 // "allow_late_signups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:677
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    bz finalize_bool_false@13
    intc_1 // 1

finalize_bool_merge@14:
    // smart_contracts/pool/contract.algo.ts:677
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    assert // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
    // smart_contracts/pool/contract.algo.ts:678
    // startTimestamp = Global.latestTimestamp
    global LatestTimestamp
    dup
    frame_bury -2
    frame_bury 0

finalize_after_if_else@15:
    frame_dig 0
    frame_bury -2
    // smart_contracts/pool/contract.algo.ts:682
    // endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    frame_dig -1
    bz finalize_bool_true@17
    frame_dig -2
    pushint 10 // 10
    +
    frame_dig -1
    <
    bz finalize_bool_false@18

finalize_bool_true@17:
    intc_1 // 1

finalize_bool_merge@19:
    // smart_contracts/pool/contract.algo.ts:681-684
    // assert(
    //   endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    //   'the ending round must be zero or after the starting round + 10'
    // )
    assert // the ending round must be zero or after the starting round + 10
    // smart_contracts/pool/constants.ts:9
    // export const PoolGlobalStateKeySignupTimestamp = 'signup_timestamp'
    bytec 30 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:686
    // this.signupTimestamp.value = signupTimestamp
    frame_dig -3
    app_global_put
    // smart_contracts/pool/constants.ts:11
    // export const PoolGlobalStateKeyStartTimestamp = 'start_timestamp'
    bytec 19 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:687
    // this.startTimestamp.value = startTimestamp
    frame_dig -2
    app_global_put
    // smart_contracts/pool/constants.ts:12
    // export const PoolGlobalStateKeyEndTimestamp = 'end_timestamp'
    bytec 21 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:688
    // this.endTimestamp.value = endTimestamp
    frame_dig -1
    app_global_put
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    bytec 9 // "status"
    // smart_contracts/pool/constants.ts:39
    // export const PoolStatusFinal = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:689
    // this.status.value = PoolStatusFinal
    app_global_put
    retsub

finalize_bool_false@18:
    intc_0 // 0
    b finalize_bool_merge@19

finalize_bool_false@13:
    intc_0 // 0
    b finalize_bool_merge@14

finalize_bool_false@8:
    intc_0 // 0
    b finalize_bool_merge@9

finalize_bool_false@4:
    intc_0 // 0
    b finalize_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.enter(payment: uint64, entries: bytes, args: bytes) -> void:
enter:
    // smart_contracts/pool/contract.algo.ts:692
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    proto 3 0
    intc_0 // 0
    pushbytes ""
    dupn 5
    // smart_contracts/pool/contract.algo.ts:694
    // assert(this.isLive(), 'the pool is not live')
    callsub isLive
    assert // the pool is not live
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:696
    // gateCheck(this.akitaDAO.value, new Address(Txn.sender), this.gateID.value, args),
    txn Sender
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 18 // "gate_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:696
    // gateCheck(this.akitaDAO.value, new Address(Txn.sender), this.gateID.value, args),
    frame_dig -1
    callsub gateCheck
    frame_bury -1
    // smart_contracts/pool/contract.algo.ts:695-698
    // assert(
    //   gateCheck(this.akitaDAO.value, new Address(Txn.sender), this.gateID.value, args),
    //   'user does not meet gate requirements'
    // )
    assert // user does not meet gate requirements
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:700
    // (this.entryID.value + 1) < this.maxEntries.value ||
    intc_1 // 1
    +
    // smart_contracts/pool/constants.ts:15
    // export const PoolGlobalStateKeyMaxEntries = 'max_entries'
    intc_0 // 0
    bytec 23 // "max_entries"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:700
    // (this.entryID.value + 1) < this.maxEntries.value ||
    <
    // smart_contracts/pool/contract.algo.ts:700-701
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_true@2
    // smart_contracts/pool/constants.ts:15
    // export const PoolGlobalStateKeyMaxEntries = 'max_entries'
    intc_0 // 0
    bytec 23 // "max_entries"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:700-701
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_false@3

enter_bool_true@2:
    intc_1 // 1

enter_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:699-703
    // assert(
    //   (this.entryID.value + 1) < this.maxEntries.value ||
    //   this.maxEntries.value === 0,
    //   'pool has reached maximum entries'
    // )
    assert // pool has reached maximum entries
    // smart_contracts/pool/contract.algo.ts:705
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/pool/contract.algo.ts:710
    // assert(payment.amount === (entryMBR * entries.length), ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -3
    gtxns Amount
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 6
    // smart_contracts/pool/contract.algo.ts:708
    // const entryMBR: uint64 = costs.entries + costs.entriesByAddress
    pushint 50600 // 50600
    // smart_contracts/pool/contract.algo.ts:710
    // assert(payment.amount === (entryMBR * entries.length), ERR_INVALID_PAYMENT_AMOUNT)
    *
    ==
    assert // Invalid payment amount
    // smart_contracts/pool/contract.algo.ts:712
    // for (let i: uint64 = 0; i < entries.length; i++) {
    intc_0 // 0
    frame_bury 2

enter_while_top@5:
    // smart_contracts/pool/contract.algo.ts:712
    // for (let i: uint64 = 0; i < entries.length; i++) {
    frame_dig 2
    frame_dig 6
    <
    bz enter_after_while@16
    // smart_contracts/pool/contract.algo.ts:713
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    frame_dig -2
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 2
    frame_dig 6
    dig 1
    - // on error: Index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    frame_bury 0
    dup
    pushint 8 // 8
    extract_uint64
    dup
    cover 2
    frame_bury 3
    dup
    pushint 16 // 16
    extract_uint16
    frame_bury 5
    len
    frame_bury 4
    // smart_contracts/pool/constants.ts:20
    // export const PoolGlobalStateKeyMinimumStakeAmount = 'minimum_stake_amount'
    intc_0 // 0
    bytec 28 // "minimum_stake_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:713
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    >=
    assert // quantity is less than minimum stake amount
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:34
    // export const POOL_STAKING_TYPE_HEARTBEAT: PoolStakingType = new arc4.UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:717
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    ==
    // smart_contracts/pool/contract.algo.ts:717-718
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bnz enter_if_body@8
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:35
    // export const POOL_STAKING_TYPE_SOFT: PoolStakingType = new arc4.UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:718
    // this.type.value === POOL_STAKING_TYPE_SOFT
    ==
    // smart_contracts/pool/contract.algo.ts:717-718
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bz enter_after_if_else@13

enter_if_body@8:
    // smart_contracts/pool/contract.algo.ts:720
    // const [balance, optedIn] = AssetHolding.assetBalance(Txn.sender, entries[i].asset)
    txn Sender
    frame_dig 0
    intc_0 // 0
    extract_uint64
    asset_holding_get AssetBalance
    swap
    frame_bury 1
    // smart_contracts/pool/contract.algo.ts:721
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    bz enter_bool_false@11
    frame_dig 1
    frame_dig 3
    >=
    bz enter_bool_false@11
    intc_1 // 1

enter_bool_merge@12:
    // smart_contracts/pool/contract.algo.ts:721
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    assert // user does not have min balance

enter_after_if_else@13:
    // smart_contracts/pool/contract.algo.ts:724-734
    // const stakeInfo = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(Txn.sender),
    //     new arc4StakeInfo({
    //       asset: new UintN64(entries[i].asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:727
    // new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:729
    // asset: new UintN64(entries[i].asset),
    frame_dig 0
    dup
    cover 3
    intc_0 // 0
    extract_uint64
    itob
    // smart_contracts/pool/contract.algo.ts:730
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:728-731
    // new arc4StakeInfo({
    //   asset: new UintN64(entries[i].asset),
    //   type: this.stakingType(),
    // }),
    dig 1
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:724-734
    // const stakeInfo = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(Txn.sender),
    //     new arc4StakeInfo({
    //       asset: new UintN64(entries[i].asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    bytec 31 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:724-734
    // const stakeInfo = abiCall(Staking.prototype.getInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(Txn.sender),
    //     new arc4StakeInfo({
    //       asset: new UintN64(entries[i].asset),
    //       type: this.stakingType(),
    //     }),
    //   ],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 4 // 4
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:736
    // assert(stakeInfo.amount >= entries[i].quantity, 'user does not have enough staked')
    frame_dig 3
    dup
    cover 4
    >=
    assert // user does not have enough staked
    // smart_contracts/pool/constants.ts:19
    // export const PoolGlobalStateKeyStakeKey = 'stake_key'
    intc_0 // 0
    bytec 27 // "stake_key"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:738
    // const { address, name } = decodeArc4<RootKey>(this.stakeKey.value.bytes)
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 32 // 32
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/pool/contract.algo.ts:739-749
    // const verified = abiCall(MetaMerkles.prototype.verify, {
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     bytes32(sha256(sha256(itob(entries[i].asset)))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 72 // 72
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:743
    // name,
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    // smart_contracts/pool/contract.algo.ts:744
    // bytes32(sha256(sha256(itob(entries[i].asset)))),
    dig 3
    sha256
    sha256
    // smart_contracts/utils/types/base.ts:25
    // return new arc4.StaticBytes<32>(value)
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/pool/contract.algo.ts:745
    // entries[i].proof,
    uncover 5
    frame_dig 5
    frame_dig 4
    substring3
    // smart_contracts/pool/contract.algo.ts:98
    // const MERKLE_TREE_TYPE_ASSET: uint64 = 1
    intc_1 // 1
    itob
    // smart_contracts/pool/contract.algo.ts:739-749
    // const verified = abiCall(MetaMerkles.prototype.verify, {
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     bytes32(sha256(sha256(itob(entries[i].asset)))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    //   fee,
    // }).returnValue
    pushbytes 0x2bf3cc5a // method "verify(address,string,byte[32],byte[32][],uint64)bool"
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:739-749
    // const verified = abiCall(MetaMerkles.prototype.verify, {
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     bytes32(sha256(sha256(itob(entries[i].asset)))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:751
    // assert(verified, 'failed to verify stake requirements')
    assert // failed to verify stake requirements
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:185
    // this.entryID.value += 1
    intc_1 // 1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    bytec_2 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:185
    // this.entryID.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:755
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:757
    // quantity: new UintN64(entries[i].quantity),
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:754-760
    // this.entries(entryID).value = new arc4EntryData({
    //   address: new Address(Txn.sender),
    //   asset: new UintN64(entries[i].asset),
    //   quantity: new UintN64(entries[i].quantity),
    //   gateArgs: args.copy(),
    //   disqualified: new Bool(false)
    // })
    swap
    dig 3
    concat
    swap
    concat
    pushbytes 0x0033
    concat
    // smart_contracts/pool/contract.algo.ts:759
    // disqualified: new Bool(false)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:754-760
    // this.entries(entryID).value = new arc4EntryData({
    //   address: new Address(Txn.sender),
    //   asset: new UintN64(entries[i].asset),
    //   quantity: new UintN64(entries[i].quantity),
    //   gateArgs: args.copy(),
    //   disqualified: new Bool(false)
    // })
    concat
    frame_dig -1
    concat
    // smart_contracts/pool/contract.algo.ts:754
    // this.entries(entryID).value = new arc4EntryData({
    swap
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    dig 1
    concat
    // smart_contracts/pool/contract.algo.ts:754-760
    // this.entries(entryID).value = new arc4EntryData({
    //   address: new Address(Txn.sender),
    //   asset: new UintN64(entries[i].asset),
    //   quantity: new UintN64(entries[i].quantity),
    //   gateArgs: args.copy(),
    //   disqualified: new Bool(false)
    // })
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/pool/contract.algo.ts:763
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:762-765
    // const aKey = new arc4EntryKey({
    //   address: new Address(Txn.sender),
    //   asset: new UintN64(entries[i].asset),
    // })
    uncover 2
    concat
    // smart_contracts/pool/constants.ts:35
    // export const PoolBoxPrefixEntriesByAddress = 'a'
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:767
    // this.entriesByAddress(aKey).value = entryID
    swap
    box_put
    b enter_while_top@5

enter_bool_false@11:
    intc_0 // 0
    b enter_bool_merge@12

enter_after_while@16:
    retsub

enter_bool_false@3:
    intc_0 // 0
    b enter_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.startDisbursement() -> void:
startDisbursement:
    // smart_contracts/pool/contract.algo.ts:774
    // startDisbursement(): void {
    proto 0 0
    // smart_contracts/pool/contract.algo.ts:775
    // assert(this.isLive(), 'the pool is not live')
    callsub isLive
    assert // the pool is not live
    // smart_contracts/pool/contract.algo.ts:467
    // const latestWindowStart = this.getLatestWindowStart()
    callsub getLatestWindowStart
    dup
    // smart_contracts/pool/contract.algo.ts:468
    // return latestWindowStart !== Global.latestTimestamp && this.lastDisbursementTimestamp.value < latestWindowStart
    global LatestTimestamp
    !=
    bz startDisbursement_bool_false@4
    // smart_contracts/pool/constants.ts:14
    // export const PoolGlobalStateKeyLastDisbursementTimestamp = 'last_disbursement_timestamp'
    intc_0 // 0
    bytec 33 // "last_disbursement_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:468
    // return latestWindowStart !== Global.latestTimestamp && this.lastDisbursementTimestamp.value < latestWindowStart
    frame_dig 0
    <
    bz startDisbursement_bool_false@4
    intc_1 // 1

startDisbursement_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:776
    // assert(this.validWindow(), 'distribution window is not open')
    assert // distribution window is not open
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:42
    // export const DisbursementPhaseIdle = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:777
    // assert(this.disbursementPhase.value === DisbursementPhaseIdle, 'distribution already in progress')
    ==
    assert // distribution already in progress
    // smart_contracts/pool/constants.ts:6
    // export const PoolGlobalStateKeyTitle = 'title'
    intc_0 // 0
    bytec 26 // "title"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:780
    // `${this.title.value} - Rewards`,
    pushbytes " - Rewards"
    concat
    // smart_contracts/pool/contract.algo.ts:781
    // Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/pool/contract.algo.ts:782
    // Global.latestTimestamp + this.reward.value.expiration.native
    dup
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    intc_0 // 0
    bytec 17 // "reward"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:782
    // Global.latestTimestamp + this.reward.value.expiration.native
    pushint 17 // 17
    extract_uint64
    +
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:497
    // const rewardMBR: uint64 = 35_300 + (400 * Bytes(title).length)
    dig 3
    len
    intc 4 // 400
    dig 1
    *
    pushint 35300 // 35300
    +
    // smart_contracts/pool/contract.algo.ts:500
    // receiver: rewardsApp.address,
    dig 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:505-515
    // return abiCall(Rewards.prototype.createDisbursement, {
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    //   fee,
    // }).returnValue
    itxn_begin
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/pool/contract.algo.ts:499-503
    // const mbrPayment = itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: rewardMBR,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:505-515
    // return abiCall(Rewards.prototype.createDisbursement, {
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    //   fee,
    // }).returnValue
    itxn_next
    // smart_contracts/pool/contract.algo.ts:509
    // title,
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/pool/contract.algo.ts:510
    // timeToUnlock,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:511
    // expiration,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:505-515
    // return abiCall(Rewards.prototype.createDisbursement, {
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    //   fee,
    // }).returnValue
    pushbytes 0x1c9ebbdb // method "createDisbursement(pay,string,uint64,uint64,string)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:512
    // '',
    bytec 13 // 0x0000
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:505-515
    // return abiCall(Rewards.prototype.createDisbursement, {
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    //   fee,
    // }).returnValue
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:505-515
    // return abiCall(Rewards.prototype.createDisbursement, {
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    //   fee,
    // }).returnValue
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    bytec 9 // "status"
    // smart_contracts/pool/constants.ts:40
    // export const PoolStatusDisbursing = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:785
    // this.status.value = PoolStatusDisbursing
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    bytec 10 // "active_disbursement_id"
    // smart_contracts/pool/contract.algo.ts:786
    // this.activeDisbursementID.value = disbursementID
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:787
    // this.activeDisbursementWindow.value = this.getLatestWindowStart()
    callsub getLatestWindowStart
    // smart_contracts/pool/constants.ts:27
    // export const PoolGlobalStateKeyActiveDisbursementWindow = 'active_disbursement_window'
    bytec 29 // "active_disbursement_window"
    // smart_contracts/pool/contract.algo.ts:787
    // this.activeDisbursementWindow.value = this.getLatestWindowStart()
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:14
    // export const PoolGlobalStateKeyLastDisbursementTimestamp = 'last_disbursement_timestamp'
    bytec 33 // "last_disbursement_timestamp"
    // smart_contracts/pool/contract.algo.ts:788
    // this.lastDisbursementTimestamp.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:789
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:790
    // this.qualifiedStakers.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:791
    // this.qualifiedStake.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:43
    // export const DisbursementPhasePreparation = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:792
    // this.disbursementPhase.value = DisbursementPhasePreparation
    app_global_put
    retsub

startDisbursement_bool_false@4:
    intc_0 // 0
    b startDisbursement_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.raffle() -> void:
raffle:
    // smart_contracts/pool/contract.algo.ts:795
    // raffle(): void {
    proto 0 0
    intc_0 // 0
    pushbytes ""
    dupn 9
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:44
    // export const DisbursementPhaseAllocation = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:796
    // assert(this.disbursementPhase.value === DisbursementPhaseAllocation, ERR_INVALID_DISBURSEMENT_PHASE)
    ==
    assert // Invalid disbursement phase
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    intc_0 // 0
    bytec 16 // "wtickets"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:797
    // assert(this.winningTickets.value.length === 0, ERR_WINNING_TICKETS_ALREADY_EXIST)
    intc_0 // 0
    extract_uint16
    !
    assert // Winning tickets already exist
    // smart_contracts/pool/constants.ts:27
    // export const PoolGlobalStateKeyActiveDisbursementWindow = 'active_disbursement_window'
    intc_0 // 0
    bytec 29 // "active_disbursement_window"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:799
    // const roundToUse: uint64 = this.activeDisbursementWindow.value + 1 + (4 * this.vrfGetFailureCount.value)
    intc_1 // 1
    +
    // smart_contracts/pool/constants.ts:32
    // export const PoolGlobalStateKeyVRFFailureCount = 'vrf_failure_count'
    intc_0 // 0
    bytec 20 // "vrf_failure_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:799
    // const roundToUse: uint64 = this.activeDisbursementWindow.value + 1 + (4 * this.vrfGetFailureCount.value)
    pushint 4 // 4
    *
    +
    // smart_contracts/pool/contract.algo.ts:801-808
    // const seed = abiCall(
    //   RandomnessBeacon.prototype.get,
    //   {
    //     appId: getOtherAppList(this.akitaDAO.value).vrfBeacon,
    //     args: [roundToUse, this.salt.value],
    //     fee
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    pushbytes "other_al"
    // smart_contracts/utils/functions.ts:33
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:34
    // return decodeArc4<OtherAppList>(otherAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:805
    // args: [roundToUse, this.salt.value],
    swap
    itob
    // smart_contracts/pool/constants.ts:25
    // export const PoolGlobalStateKeySalt = 'salt'
    intc_0 // 0
    bytec 32 // "salt"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:801-808
    // const seed = abiCall(
    //   RandomnessBeacon.prototype.get,
    //   {
    //     appId: getOtherAppList(this.akitaDAO.value).vrfBeacon,
    //     args: [roundToUse, this.salt.value],
    //     fee
    //   }
    // ).returnValue
    pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:801-808
    // const seed = abiCall(
    //   RandomnessBeacon.prototype.get,
    //   {
    //     appId: getOtherAppList(this.akitaDAO.value).vrfBeacon,
    //     args: [roundToUse, this.salt.value],
    //     fee
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    dup
    // smart_contracts/pool/contract.algo.ts:810
    // if (seed.length === 0) {
    len
    dup
    bnz raffle_after_if_else@3
    // smart_contracts/pool/constants.ts:32
    // export const PoolGlobalStateKeyVRFFailureCount = 'vrf_failure_count'
    intc_0 // 0
    bytec 20 // "vrf_failure_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:811
    // this.vrfGetFailureCount.value += 1
    intc_1 // 1
    +
    // smart_contracts/pool/constants.ts:32
    // export const PoolGlobalStateKeyVRFFailureCount = 'vrf_failure_count'
    bytec 20 // "vrf_failure_count"
    // smart_contracts/pool/contract.algo.ts:811
    // this.vrfGetFailureCount.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:812
    // return
    retsub

raffle_after_if_else@3:
    // smart_contracts/pool/contract.algo.ts:816
    // const rngState = pcg64Init(seed.slice(0, 16))
    intc_0 // 0
    frame_dig 12
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig 11
    cover 2
    substring3
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:16
    // assert(seed.length === 16)
    dup
    len
    pushint 16 // 16
    ==
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:92
    // const state = __pcg32Step(0, incr)
    intc_0 // 0
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:3
    // export const pcgMultiplier = Uint64(6364136223846793005n)
    intc 5 // 6364136223846793005
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    dup
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:5
    // export const pcgFirstIncrement = Uint64(1442695040888963407n)
    intc 6 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:3
    // export const pcgMultiplier = Uint64(6364136223846793005n)
    intc 5 // 6364136223846793005
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:5
    // export const pcgFirstIncrement = Uint64(1442695040888963407n)
    intc 6 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    frame_bury 3
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    swap
    pushint 8 // 8
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    swap
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:7
    // export const pcgSecondIncrement = Uint64(1442695040888963409n)
    intc 7 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:3
    // export const pcgMultiplier = Uint64(6364136223846793005n)
    intc 5 // 6364136223846793005
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:7
    // export const pcgSecondIncrement = Uint64(1442695040888963409n)
    intc 7 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    frame_bury 2
    pop
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 9
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:820
    // if (upperBound < MAX_UINT64) {
    dup
    // smart_contracts/utils/constants.ts:22
    // export const MAX_UINT64: uint64 = Uint64('18446744073709551615')
    intc 10 // 18446744073709551615
    // smart_contracts/pool/contract.algo.ts:820
    // if (upperBound < MAX_UINT64) {
    <
    swap
    frame_bury 10
    bz raffle_after_if_else@5
    // smart_contracts/pool/contract.algo.ts:821
    // upperBound += 1
    frame_dig 9
    intc_1 // 1
    +
    frame_bury 10

raffle_after_if_else@5:
    frame_dig 10
    dup
    frame_bury 9
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:30
    // const result = new DynamicArray<UintN64>()
    bytec 13 // 0x0000
    frame_bury 0
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:42
    // if (upperBound !== 0) {
    bz raffle_else_body@14
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:43
    // assert(upperBound > 1)
    frame_dig 9
    dup
    intc_1 // 1
    >
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    intc_1 // 1
    -
    dup
    frame_bury 1
    // smart_contracts/pool/contract.algo.ts:824
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    >
    assert

raffle_after_if_else@15:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    frame_dig 1
    dup
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:53
    // const threshold: uint64 = __uint64Twos(absoluteBound) % absoluteBound
    swap
    %
    frame_bury 8
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    intc_0 // 0
    frame_bury 5
    frame_dig 2
    frame_bury 7
    frame_dig 3
    frame_bury 6

raffle_while_top@16:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 5
    // smart_contracts/pool/constants.ts:55
    // export const MaxGlobalStateUint64Array: uint64 = 15
    pushint 15 // 15
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    <
    bz raffle_after_while@22

raffle_while_top@18:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    frame_dig 6
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:3
    // export const pcgMultiplier = Uint64(6364136223846793005n)
    intc 5 // 6364136223846793005
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:5
    // export const pcgFirstIncrement = Uint64(1442695040888963407n)
    intc 6 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    dup
    cover 2
    frame_bury 3
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    bnz raffle_ternary_false@26
    pushint 2885390081777926818 // 2885390081777926818

raffle_ternary_merge@27:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    frame_dig 7
    dup
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:3
    // export const pcgMultiplier = Uint64(6364136223846793005n)
    intc 5 // 6364136223846793005
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    uncover 2
    addw
    frame_bury 2
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:12
    // return [[newState1, newState2], op.shl(__pcg32Output(state[0]), 32) | __pcg32Output(state[1])]
    frame_dig 6
    callsub __pcg32Output
    pushint 32 // 32
    shl
    swap
    callsub __pcg32Output
    |
    dup
    frame_bury 4
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:59
    // if (candidate >= threshold) {
    frame_dig 8
    >=
    bz raffle_after_if_else@20
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new UintN64((candidate % absoluteBound) + lowerBound))
    frame_dig 0
    extract 2 0
    frame_dig 4
    frame_dig 1
    %
    // smart_contracts/pool/contract.algo.ts:824
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new UintN64((candidate % absoluteBound) + lowerBound))
    +
    itob
    concat
    dup
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    frame_dig 2
    frame_bury 7
    frame_dig 3
    frame_bury 6
    b raffle_while_top@16

raffle_after_if_else@20:
    frame_dig 2
    frame_bury 7
    frame_dig 3
    frame_bury 6
    b raffle_while_top@18

raffle_ternary_false@26:
    // smart_contracts/utils/types/lib_pcg/consts.algo.ts:7
    // export const pcgSecondIncrement = Uint64(1442695040888963409n)
    intc 7 // 1442695040888963409
    b raffle_ternary_merge@27

raffle_after_while@22:
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    bytec 16 // "wtickets"
    // smart_contracts/pool/contract.algo.ts:825
    // this.winningTickets.value = rngResult[1].copy()
    frame_dig 0
    app_global_put
    // smart_contracts/pool/constants.ts:32
    // export const PoolGlobalStateKeyVRFFailureCount = 'vrf_failure_count'
    bytec 20 // "vrf_failure_count"
    // smart_contracts/pool/contract.algo.ts:826
    // this.vrfGetFailureCount.value = 0
    intc_0 // 0
    app_global_put
    retsub

raffle_else_body@14:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:50
    // absoluteBound = op.btoi(Bytes(BigUint(2 ** 64) - BigUint(lowerBound)))
    intc 10 // 18446744073709551615
    frame_bury 1
    b raffle_after_if_else@15


// smart_contracts/pool/contract.algo.ts::Pool.disburseRewards(iterationAmount: uint64) -> void:
disburseRewards:
    // smart_contracts/pool/contract.algo.ts:829
    // disburseRewards(iterationAmount: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 7
    pushbytes ""
    dupn 24
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:40
    // export const PoolStatusDisbursing = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:830
    // assert(this.status.value === PoolStatusDisbursing, 'pool is not in disbursement phase')
    ==
    assert // pool is not in disbursement phase
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:43
    // export const DisbursementPhasePreparation = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:832
    // this.disbursementPhase.value === DisbursementPhasePreparation ||
    ==
    // smart_contracts/pool/contract.algo.ts:832-833
    // this.disbursementPhase.value === DisbursementPhasePreparation ||
    // this.disbursementPhase.value === DisbursementPhaseAllocation,
    bnz disburseRewards_bool_true@2
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:44
    // export const DisbursementPhaseAllocation = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:833
    // this.disbursementPhase.value === DisbursementPhaseAllocation,
    ==
    // smart_contracts/pool/contract.algo.ts:832-833
    // this.disbursementPhase.value === DisbursementPhasePreparation ||
    // this.disbursementPhase.value === DisbursementPhaseAllocation,
    bz disburseRewards_bool_false@3

disburseRewards_bool_true@2:
    intc_1 // 1

disburseRewards_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:831-835
    // assert(
    //   this.disbursementPhase.value === DisbursementPhasePreparation ||
    //   this.disbursementPhase.value === DisbursementPhaseAllocation,
    //   ERR_NOT_READY_TO_DISBURSE
    // )
    assert // Not ready to disburse
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    intc_0 // 0
    bytec 17 // "reward"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:837
    // const reward = decodeArc4<Reward>(this.reward.value.bytes)
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 23
    dup
    extract 8 1 // on error: Index access is out of bounds
    frame_bury 6
    pushint 9 // 9
    extract_uint64
    frame_bury 24
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:43
    // export const DisbursementPhasePreparation = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:839
    // if (this.disbursementPhase.value === DisbursementPhasePreparation) {
    ==
    bz disburseRewards_else_body@6
    // smart_contracts/pool/contract.algo.ts:190
    // let count: uint64 = 0
    intc_0 // 0
    frame_bury 9
    // smart_contracts/pool/contract.algo.ts:191
    // let total: uint64 = 0
    intc_0 // 0
    frame_bury 32
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:193
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:193
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    >
    bz disburseRewards_after_if_else@82
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:194
    // iterationAmount = this.entryID.value - this.disbursementCursor.value
    -
    frame_bury -1

disburseRewards_after_if_else@82:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    swap
    frame_bury 21
    assert // check GlobalState exists

disburseRewards_while_top@83:
    // smart_contracts/pool/contract.algo.ts:197
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    frame_dig -1
    <
    bz disburseRewards_after_while@97
    // smart_contracts/pool/contract.algo.ts:198
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig 21
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    dup
    frame_bury 3
    // smart_contracts/pool/contract.algo.ts:198
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 4
    dup
    intc_3 // 40
    extract_uint64
    frame_bury 18
    dup
    pushint 48 // 48
    extract_uint16
    dig 1
    len
    dig 2
    cover 2
    substring3
    frame_bury 5
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:199
    // if (entry.disqualified) {
    bnz disburseRewards_block@96
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:33
    // export const POOL_STAKING_TYPE_NONE: PoolStakingType = new arc4.UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:477
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    ==
    bz disburseRewards_else_body@88
    // smart_contracts/pool/contract.algo.ts:478
    // return { valid: true, balance: 0 }
    intc_1 // 1

disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@91:
    // smart_contracts/pool/contract.algo.ts:204
    // if (!valid) {
    bz disburseRewards_block@96
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 18 // "gate_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:208
    // const passes = gateCheck(this.akitaDAO.value, entry.address, this.gateID.value, entry.gateArgs.copy())
    frame_dig 4
    swap
    frame_dig 5
    callsub gateCheck
    pop
    // smart_contracts/pool/contract.algo.ts:209
    // if (!passes) {
    bz disburseRewards_block@96
    // smart_contracts/pool/contract.algo.ts:213
    // count += 1
    frame_dig 9
    intc_1 // 1
    +
    frame_bury 9
    // smart_contracts/pool/contract.algo.ts:214
    // total += entry.quantity
    frame_dig 32
    frame_dig 18
    +
    frame_bury 32

disburseRewards_block@96:
    // smart_contracts/pool/contract.algo.ts:197
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    intc_1 // 1
    +
    frame_bury 21
    b disburseRewards_while_top@83

disburseRewards_else_body@88:
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/types.ts:34
    // export const POOL_STAKING_TYPE_HEARTBEAT: PoolStakingType = new arc4.UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:479
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    ==
    bz disburseRewards_after_if_else@90
    // smart_contracts/pool/contract.algo.ts:480
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    pushint 32 // 32
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:482-486
    // const avg = abiCall(Staking.prototype.getHeartbeatAverage, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset, true],
    //   fee,
    // }).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:484
    // args: [entry.address, entry.asset, true],
    swap
    itob
    // smart_contracts/pool/contract.algo.ts:482-486
    // const avg = abiCall(Staking.prototype.getHeartbeatAverage, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset, true],
    //   fee,
    // }).returnValue
    pushbytes 0xc6fd0ca5 // method "getHeartbeatAverage(address,uint64,bool)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:484
    // args: [entry.address, entry.asset, true],
    pushbytes 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:482-486
    // const avg = abiCall(Staking.prototype.getHeartbeatAverage, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset, true],
    //   fee,
    // }).returnValue
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:482-486
    // const avg = abiCall(Staking.prototype.getHeartbeatAverage, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [entry.address, entry.asset, true],
    //   fee,
    // }).returnValue
    itxn_submit
    itxn LastLog
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/pool/contract.algo.ts:488
    // return { valid: true, balance: avg }
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:203
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@91

disburseRewards_after_if_else@90:
    // smart_contracts/pool/contract.algo.ts:491
    // return this.checkByID(id)
    frame_dig 21
    callsub checkByID
    pop
    // smart_contracts/pool/contract.algo.ts:203
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@91

disburseRewards_after_while@97:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:217
    // this.disbursementCursor.value += iterationAmount
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:217
    // this.disbursementCursor.value += iterationAmount
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:218
    // this.qualifiedStakers.value += count
    frame_dig 9
    +
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:218
    // this.qualifiedStakers.value += count
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:219
    // this.qualifiedStake.value += total
    frame_dig 32
    +
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:219
    // this.qualifiedStake.value += total
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:221
    // if (this.entryID.value === this.disbursementCursor.value) {
    ==
    bz disburseRewards_after_if_else@22
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:44
    // export const DisbursementPhaseAllocation = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:222
    // this.disbursementPhase.value = DisbursementPhaseAllocation
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:223
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put

disburseRewards_after_if_else@22:
    retsub

disburseRewards_else_body@6:
    // smart_contracts/pool/contract.algo.ts:842
    // if (reward.distribution === DistributionTypePercentage) {
    frame_dig 6
    // smart_contracts/pool/types.ts:14
    // export const DistributionTypePercentage = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:842
    // if (reward.distribution === DistributionTypePercentage) {
    ==
    bz disburseRewards_else_body@8
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:229
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:229
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    >
    bz disburseRewards_after_if_else@70
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:230
    // iterationAmount = this.entryID.value - this.disbursementCursor.value
    -
    frame_bury -1

disburseRewards_after_if_else@70:
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    intc_0 // 0
    bytec 17 // "reward"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:233
    // const reward = decodeArc4<Reward>(this.reward.value.bytes)
    pushint 9 // 9
    extract_uint64
    frame_bury 24
    // smart_contracts/pool/contract.algo.ts:234
    // const allocations = new DynamicArray<arc4UserAllocation>()
    bytec 13 // 0x0000
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:235
    // let sum: uint64 = 0
    intc_0 // 0
    frame_bury 29
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    swap
    frame_bury 21
    assert // check GlobalState exists

disburseRewards_while_top@71:
    // smart_contracts/pool/contract.algo.ts:237
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    frame_dig -1
    <
    bz disburseRewards_after_while@76
    // smart_contracts/pool/contract.algo.ts:238
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig 21
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:238
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 4
    dup
    intc_3 // 40
    extract_uint64
    frame_bury 18
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:239
    // if (entry.disqualified) {
    bnz disburseRewards_block@75
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:73
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    frame_dig 18
    dup
    cover 2
    dig 1
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:74
    // return op.divw(...op.mulw(a, DIVISOR), b)
    swap
    // smart_contracts/utils/constants.ts:16
    // export const DIVISOR: uint64 = 100_000
    intc 8 // 100000
    // smart_contracts/utils/functions.ts:74
    // return op.divw(...op.mulw(a, DIVISOR), b)
    mulw
    uncover 2
    divw
    // smart_contracts/utils/functions.ts:68
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    // smart_contracts/utils/constants.ts:16
    // export const DIVISOR: uint64 = 100_000
    intc 8 // 100000
    // smart_contracts/utils/functions.ts:68
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:69
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig 24
    mulw
    // smart_contracts/utils/constants.ts:16
    // export const DIVISOR: uint64 = 100_000
    intc 8 // 100000
    // smart_contracts/utils/functions.ts:69
    // return op.divw(...op.mulw(a, p), DIVISOR)
    divw
    // smart_contracts/pool/contract.algo.ts:245-250
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    frame_dig 0
    extract 2 0
    // smart_contracts/pool/contract.algo.ts:248
    // amount: new UintN64(amount)
    dig 1
    itob
    // smart_contracts/pool/contract.algo.ts:246-249
    // new arc4UserAllocation({
    //   address: entry.address,
    //   amount: new UintN64(amount)
    // }),
    frame_dig 4
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:245-250
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    concat
    dup
    len
    intc_3 // 40
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:251
    // sum += amount
    frame_dig 29
    +
    frame_bury 29

disburseRewards_block@75:
    // smart_contracts/pool/contract.algo.ts:237
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    intc_1 // 1
    +
    frame_bury 21
    b disburseRewards_while_top@71

disburseRewards_after_while@76:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:254
    // this.disbursementCursor.value += iterationAmount
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:254
    // this.disbursementCursor.value += iterationAmount
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:255
    // this.createRewardAllocations(this.activeDisbursementID.value, asset, allocations, sum)
    frame_dig 23
    frame_dig 0
    frame_dig 29
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:257
    // if (this.entryID.value === this.disbursementCursor.value) {
    ==
    bz disburseRewards_after_if_else@22
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:45
    // export const DisbursementPhaseFinalization = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:258
    // this.disbursementPhase.value = DisbursementPhaseFinalization
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:259
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    retsub

disburseRewards_else_body@8:
    // smart_contracts/pool/contract.algo.ts:844
    // } else if (reward.distribution === DistributionTypeFlat) {
    frame_dig 6
    // smart_contracts/pool/types.ts:19
    // export const DistributionTypeFlat = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:844
    // } else if (reward.distribution === DistributionTypeFlat) {
    ==
    bz disburseRewards_else_body@10
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:264
    // const total: uint64 = this.qualifiedStakers.value * amount
    frame_dig 24
    *
    // smart_contracts/pool/contract.algo.ts:265
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 23
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:267
    // assert(balance >= total, ERR_NOT_ENOUGH_FUNDS)
    <=
    assert // Not enough funds
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:269
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:269
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    >
    bz disburseRewards_after_if_else@58
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:270
    // iterationAmount = this.entryID.value - this.disbursementCursor.value
    -
    frame_bury -1

disburseRewards_after_if_else@58:
    // smart_contracts/pool/contract.algo.ts:273
    // const allocations = new DynamicArray<arc4UserAllocation>()
    bytec 13 // 0x0000
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:274
    // let sum: uint64 = 0
    intc_0 // 0
    frame_bury 29
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    swap
    frame_bury 21
    assert // check GlobalState exists

disburseRewards_while_top@59:
    // smart_contracts/pool/contract.algo.ts:276
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    frame_dig -1
    <
    bz disburseRewards_after_while@64
    // smart_contracts/pool/contract.algo.ts:277
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig 21
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:277
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 4
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:278
    // if (entry.disqualified) {
    bnz disburseRewards_block@63
    // smart_contracts/pool/contract.algo.ts:282-287
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    frame_dig 0
    extract 2 0
    // smart_contracts/pool/contract.algo.ts:285
    // amount: new UintN64(amount)
    frame_dig 24
    dup
    cover 2
    itob
    // smart_contracts/pool/contract.algo.ts:283-286
    // new arc4UserAllocation({
    //   address: entry.address,
    //   amount: new UintN64(amount)
    // }),
    frame_dig 4
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:282-287
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    concat
    dup
    len
    intc_3 // 40
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // smart_contracts/pool/contract.algo.ts:288
    // sum += amount
    frame_dig 29
    +
    frame_bury 29

disburseRewards_block@63:
    // smart_contracts/pool/contract.algo.ts:276
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    intc_1 // 1
    +
    frame_bury 21
    b disburseRewards_while_top@59

disburseRewards_after_while@64:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:291
    // this.disbursementCursor.value += iterationAmount
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:291
    // this.disbursementCursor.value += iterationAmount
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:292
    // this.createRewardAllocations(this.activeDisbursementID.value, asset, allocations, sum)
    frame_dig 23
    frame_dig 0
    frame_dig 29
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:294
    // if (this.entryID.value === this.disbursementCursor.value) {
    ==
    bz disburseRewards_after_if_else@22
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:45
    // export const DisbursementPhaseFinalization = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:295
    // this.disbursementPhase.value = DisbursementPhaseFinalization
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:296
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    retsub

disburseRewards_else_body@10:
    // smart_contracts/pool/contract.algo.ts:846
    // } else if (reward.distribution === DistributionTypeEven) {
    frame_dig 6
    // smart_contracts/pool/types.ts:24
    // export const DistributionTypeEven = new UintN8(2)
    bytec 12 // 0x02
    // smart_contracts/pool/contract.algo.ts:846
    // } else if (reward.distribution === DistributionTypeEven) {
    ==
    bz disburseRewards_else_body@12
    // smart_contracts/pool/contract.algo.ts:301
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 23
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:302
    // assert(balance >= sum, ERR_NOT_ENOUGH_FUNDS)
    frame_dig 24
    >=
    assert // Not enough funds
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:304
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:304
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    >
    bz disburseRewards_after_if_else@46
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:305
    // iterationAmount = this.entryID.value - this.disbursementCursor.value
    -
    frame_bury -1

disburseRewards_after_if_else@46:
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    intc_0 // 0
    bytec 5 // "qualified_stake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:308
    // const amount: uint64 = sum / this.qualifiedStakers.value
    frame_dig 24
    swap
    /
    frame_bury 8
    // smart_contracts/pool/contract.algo.ts:309
    // const allocations = new DynamicArray<arc4UserAllocation>()
    bytec 13 // 0x0000
    frame_bury 0
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    swap
    frame_bury 21
    assert // check GlobalState exists

disburseRewards_while_top@47:
    // smart_contracts/pool/contract.algo.ts:310
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    frame_dig -1
    <
    bz disburseRewards_after_while@52
    // smart_contracts/pool/contract.algo.ts:311
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    frame_dig 21
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:311
    // const entry = decodeArc4<EntryData>(this.entries(id).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 4
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:312
    // if (entry.disqualified) {
    bnz disburseRewards_block@51
    // smart_contracts/pool/contract.algo.ts:316-321
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    frame_dig 0
    extract 2 0
    // smart_contracts/pool/contract.algo.ts:319
    // amount: new UintN64(amount)
    frame_dig 8
    itob
    // smart_contracts/pool/contract.algo.ts:317-320
    // new arc4UserAllocation({
    //   address: entry.address,
    //   amount: new UintN64(amount)
    // }),
    frame_dig 4
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:316-321
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    concat
    dup
    len
    intc_3 // 40
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0

disburseRewards_block@51:
    // smart_contracts/pool/contract.algo.ts:310
    // for (let id = this.disbursementCursor.value; id < iterationAmount; id++) {
    frame_dig 21
    intc_1 // 1
    +
    frame_bury 21
    b disburseRewards_while_top@47

disburseRewards_after_while@52:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:324
    // this.disbursementCursor.value += iterationAmount
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:324
    // this.disbursementCursor.value += iterationAmount
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:325
    // this.createRewardAllocations(this.activeDisbursementID.value, asset, allocations, sum)
    frame_dig 23
    frame_dig 0
    frame_dig 24
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:327
    // if (this.entryID.value === this.disbursementCursor.value) {
    ==
    bz disburseRewards_after_if_else@22
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:45
    // export const DisbursementPhaseFinalization = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:328
    // this.disbursementPhase.value = DisbursementPhaseFinalization
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:329
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    retsub

disburseRewards_else_body@12:
    // smart_contracts/pool/contract.algo.ts:848
    // } else if (reward.distribution === DistributionTypeShuffle) {
    frame_dig 6
    // smart_contracts/pool/types.ts:29
    // export const DistributionTypeShuffle = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:848
    // } else if (reward.distribution === DistributionTypeShuffle) {
    ==
    assert // unknown reward rate type
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    intc_0 // 0
    bytec 16 // "wtickets"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:849
    // if (this.winningTickets.value.length === 0) {
    intc_0 // 0
    extract_uint16
    bnz disburseRewards_else_body@15
    // smart_contracts/pool/contract.algo.ts:850
    // this.raffle()
    callsub raffle
    retsub

disburseRewards_else_body@15:
    // smart_contracts/pool/contract.algo.ts:340
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 23
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:341
    // assert(balance >= sum, ERR_NOT_ENOUGH_FUNDS)
    frame_dig 24
    >=
    assert // Not enough funds
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:343
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:343
    // if ((this.disbursementCursor.value + iterationAmount) > this.entryID.value) {
    >
    bz disburseRewards_after_if_else@25
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:344
    // iterationAmount = this.entryID.value - this.disbursementCursor.value
    -
    frame_bury -1

disburseRewards_after_if_else@25:
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    intc_0 // 0
    bytec 17 // "reward"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:347
    // const reward = decodeArc4<Reward>(this.reward.value.bytes)
    dup
    pushint 9 // 9
    extract_uint64
    dup
    cover 2
    frame_bury 25
    pushint 25 // 25
    extract_uint64
    dup
    frame_bury 26
    swap
    frame_bury 8
    // smart_contracts/pool/contract.algo.ts:350
    // if (reward.winnerCount > 0) {
    bz disburseRewards_after_if_else@27
    // smart_contracts/pool/contract.algo.ts:351
    // amount = reward.rate / reward.winnerCount
    frame_dig 25
    frame_dig 26
    /
    frame_bury 8

disburseRewards_after_if_else@27:
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    intc_0 // 0
    bytec 16 // "wtickets"
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 7
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:31
    // export const PoolGlobalStateKeyRaffleCursor = 'raffle_cursor'
    intc_0 // 0
    bytec 25 // "raffle_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:355
    // let { stake, ticket, disbursed } = decodeArc4<RaffleCursor>(this.raffleCursor.value.bytes)
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    frame_bury 30
    dup
    pushint 8 // 8
    extract_uint64
    swap
    pushint 16 // 16
    extract_uint64
    frame_bury 15
    // smart_contracts/pool/contract.algo.ts:356
    // let currentTicket = tickets[ticket]
    uncover 2
    extract 2 0
    dup
    frame_bury 2
    uncover 2
    pushint 8 // 8
    *
    extract_uint64
    frame_bury 13
    // smart_contracts/pool/contract.algo.ts:360
    // const allocations = new DynamicArray<arc4UserAllocation>()
    bytec 13 // 0x0000
    frame_bury 0
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    swap
    frame_bury 19
    assert // check GlobalState exists
    dup
    frame_bury 12
    frame_bury 27

disburseRewards_while_top@28:
    // smart_contracts/pool/contract.algo.ts:361
    // for (let i = this.disbursementCursor.value; i < iterationAmount; i++) {
    frame_dig 19
    frame_dig -1
    <
    bz disburseRewards_block@40
    // smart_contracts/pool/contract.algo.ts:362
    // const entry = decodeArc4<EntryData>(this.entries(i).value.bytes)
    frame_dig 19
    dup
    itob
    // smart_contracts/pool/constants.ts:34
    // export const PoolBoxPrefixEntries = 'e'
    bytec 14 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:362
    // const entry = decodeArc4<EntryData>(this.entries(i).value.bytes)
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 4
    dup
    intc_3 // 40
    extract_uint64
    swap
    intc 4 // 400
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 17
    // smart_contracts/pool/contract.algo.ts:364
    // currentRangeEnd = currentRangeStart + entry.quantity
    frame_dig 12
    dup
    uncover 2
    +
    dup
    cover 2
    frame_bury 10
    // smart_contracts/pool/contract.algo.ts:365
    // if (currentTicket >= currentRangeStart && currentTicket <= currentRangeEnd) {
    frame_dig 13
    dup
    uncover 2
    >=
    frame_dig 27
    frame_bury 28
    frame_dig 30
    frame_bury 31
    frame_dig 15
    frame_bury 16
    frame_dig 0
    frame_bury 1
    swap
    frame_bury 14
    frame_dig -1
    frame_bury 22
    uncover 2
    frame_bury 20
    swap
    frame_bury 11
    bz disburseRewards_after_if_else@38
    frame_dig 13
    dup
    frame_dig 10
    dup
    cover 3
    <=
    frame_dig 27
    frame_bury 28
    frame_dig 30
    frame_bury 31
    frame_dig 15
    frame_bury 16
    frame_dig 0
    frame_bury 1
    swap
    frame_bury 14
    frame_dig -1
    frame_bury 22
    frame_dig 19
    frame_bury 20
    swap
    frame_bury 11
    bz disburseRewards_after_if_else@38
    frame_dig 0
    frame_bury 1
    frame_dig 15
    frame_bury 16
    // smart_contracts/pool/contract.algo.ts:366
    // if (!entry.disqualified) {
    frame_dig 17
    bnz disburseRewards_after_if_else@33
    // smart_contracts/pool/contract.algo.ts:367-372
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    frame_dig 0
    extract 2 0
    // smart_contracts/pool/contract.algo.ts:370
    // amount: new UintN64(amount)
    frame_dig 8
    itob
    // smart_contracts/pool/contract.algo.ts:368-371
    // new arc4UserAllocation({
    //   address: entry.address,
    //   amount: new UintN64(amount)
    // }),
    frame_dig 4
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:367-372
    // allocations.push(
    //   new arc4UserAllocation({
    //     address: entry.address,
    //     amount: new UintN64(amount)
    //   }),
    // )
    concat
    dup
    len
    intc_3 // 40
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:373
    // disbursed++
    frame_dig 15
    intc_1 // 1
    +
    frame_bury 16
    frame_bury 1

disburseRewards_after_if_else@33:
    frame_dig 1
    frame_bury 0
    frame_dig 16
    frame_bury 15
    // smart_contracts/pool/contract.algo.ts:376
    // if (ticket === tickets.length - 1) {
    frame_dig 7
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    frame_dig 30
    ==
    bz disburseRewards_after_if_else@37
    // smart_contracts/pool/contract.algo.ts:378
    // if (reward.winnerCount !== disbursed) {
    frame_dig 26
    frame_dig 15
    !=
    bz disburseRewards_block@40
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:379
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/contract.algo.ts:383
    // disbursed: new UintN64(disbursed),
    frame_dig 15
    itob
    // smart_contracts/pool/contract.algo.ts:380-384
    // this.raffleCursor.value = new arc4RaffleCursor({
    //   ticket: new UintN64(0),
    //   stake: new UintN64(0),
    //   disbursed: new UintN64(disbursed),
    // })
    pushbytes 0x00000000000000000000000000000000
    swap
    concat
    // smart_contracts/pool/constants.ts:31
    // export const PoolGlobalStateKeyRaffleCursor = 'raffle_cursor'
    bytec 25 // "raffle_cursor"
    // smart_contracts/pool/contract.algo.ts:380-384
    // this.raffleCursor.value = new arc4RaffleCursor({
    //   ticket: new UintN64(0),
    //   stake: new UintN64(0),
    //   disbursed: new UintN64(disbursed),
    // })
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    bytec 16 // "wtickets"
    // smart_contracts/pool/contract.algo.ts:385
    // this.winningTickets.value = new DynamicArray<UintN64>()
    bytec 13 // 0x0000
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:386
    // this.createRewardAllocations(this.activeDisbursementID.value, asset, allocations, sum)
    frame_dig 23
    frame_dig 0
    frame_dig 24
    callsub createRewardAllocations
    pop
    retsub

disburseRewards_block@40:
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    intc_0 // 0
    bytec_0 // "disbursement_cursor"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:403
    // this.disbursementCursor.value += iterationAmount
    frame_dig -1
    +
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:403
    // this.disbursementCursor.value += iterationAmount
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:405
    // ticket: new UintN64(ticket),
    frame_dig 30
    itob
    // smart_contracts/pool/contract.algo.ts:406
    // stake: new UintN64(stake),
    frame_dig 27
    itob
    // smart_contracts/pool/contract.algo.ts:407
    // disbursed: new UintN64(disbursed),
    frame_dig 15
    dup
    cover 3
    itob
    // smart_contracts/pool/contract.algo.ts:404-408
    // this.raffleCursor.value = new arc4RaffleCursor({
    //   ticket: new UintN64(ticket),
    //   stake: new UintN64(stake),
    //   disbursed: new UintN64(disbursed),
    // })
    cover 2
    concat
    swap
    concat
    // smart_contracts/pool/constants.ts:31
    // export const PoolGlobalStateKeyRaffleCursor = 'raffle_cursor'
    bytec 25 // "raffle_cursor"
    // smart_contracts/pool/contract.algo.ts:404-408
    // this.raffleCursor.value = new arc4RaffleCursor({
    //   ticket: new UintN64(ticket),
    //   stake: new UintN64(stake),
    //   disbursed: new UintN64(disbursed),
    // })
    swap
    app_global_put
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:409
    // this.createRewardAllocations(this.activeDisbursementID.value, asset, allocations, sum)
    frame_dig 23
    frame_dig 0
    frame_dig 24
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:411
    // if (reward.winnerCount === disbursed) {
    frame_dig 26
    ==
    bz disburseRewards_after_if_else@22
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:45
    // export const DisbursementPhaseFinalization = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:412
    // this.disbursementPhase.value = DisbursementPhaseFinalization
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:413
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:31
    // export const PoolGlobalStateKeyRaffleCursor = 'raffle_cursor'
    bytec 25 // "raffle_cursor"
    // smart_contracts/pool/contract.algo.ts:335
    // this.raffleCursor.value = new arc4RaffleCursor({ ticket: zero, stake: zero, disbursed: zero })
    pushbytes 0x000000000000000000000000000000000000000000000000
    app_global_put
    // smart_contracts/pool/constants.ts:30
    // export const PoolGlobalStateKeyWinningTickets = 'wtickets'
    bytec 16 // "wtickets"
    // smart_contracts/pool/contract.algo.ts:336
    // this.winningTickets.value = new DynamicArray<UintN64>()
    bytec 13 // 0x0000
    app_global_put
    retsub

disburseRewards_after_if_else@37:
    // smart_contracts/pool/contract.algo.ts:392
    // iterationAmount -= i
    frame_dig -1
    frame_dig 19
    -
    frame_bury -1
    // smart_contracts/pool/contract.algo.ts:393
    // ticket++
    frame_dig 30
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:394
    // currentTicket = tickets[ticket]
    dup
    pushint 8 // 8
    *
    frame_dig 2
    swap
    extract_uint64
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:395
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/contract.algo.ts:396
    // i = 0
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:397-398
    // stake = 0
    // currentRangeEnd = 0
    dupn 2
    frame_bury 28
    uncover 3
    frame_bury 31
    frame_dig 15
    frame_bury 16
    frame_dig 0
    frame_bury 1
    uncover 2
    frame_bury 14
    frame_dig -1
    frame_bury 22
    frame_bury 11
    frame_bury 20

disburseRewards_after_if_else@38:
    frame_dig 28
    frame_bury 27
    frame_dig 31
    frame_bury 30
    frame_dig 16
    frame_bury 15
    frame_dig 1
    frame_bury 0
    frame_dig 14
    frame_bury 13
    frame_dig 22
    frame_bury -1
    frame_dig 20
    frame_dig 11
    // smart_contracts/pool/contract.algo.ts:400
    // currentRangeStart = currentRangeEnd + 1
    intc_1 // 1
    +
    frame_bury 12
    // smart_contracts/pool/contract.algo.ts:361
    // for (let i = this.disbursementCursor.value; i < iterationAmount; i++) {
    intc_1 // 1
    +
    frame_bury 19
    b disburseRewards_while_top@28

disburseRewards_bool_false@3:
    intc_0 // 0
    b disburseRewards_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution() -> void:
finalizeDistribution:
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    intc_0 // 0
    bytec 4 // "disbursement_phase"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:45
    // export const DisbursementPhaseFinalization = new UintN8(3)
    bytec 15 // 0x03
    // smart_contracts/pool/contract.algo.ts:861
    // assert(this.disbursementPhase.value === DisbursementPhaseFinalization, ERR_DISBURSEMENT_NOT_READY_FOR_FINALIZATION)
    ==
    assert // Disbursement not ready for finalization
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec 8 // "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:568-572
    // abiCall(Rewards.prototype.finalizeDisbursement, {
    //   appId: rewardsApp,
    //   args: [disbursementID],
    //   fee,
    // })
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:570
    // args: [disbursementID],
    swap
    itob
    // smart_contracts/pool/contract.algo.ts:568-572
    // abiCall(Rewards.prototype.finalizeDisbursement, {
    //   appId: rewardsApp,
    //   args: [disbursementID],
    //   fee,
    // })
    pushbytes 0x5424a591 // method "finalizeDisbursement(uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:568-572
    // abiCall(Rewards.prototype.finalizeDisbursement, {
    //   appId: rewardsApp,
    //   args: [disbursementID],
    //   fee,
    // })
    itxn_submit
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    intc_0 // 0
    bytec 10 // "active_disbursement_id"
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/pool/constants.ts:36
    // export const PoolBoxPrefixDisbursements = 'd'
    pushbytes "d"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:865
    // this.disbursements(this.activeDisbursementID.value).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/pool/constants.ts:26
    // export const PoolGlobalStateKeyActiveDisbursementID = 'active_disbursement_id'
    bytec 10 // "active_disbursement_id"
    // smart_contracts/pool/contract.algo.ts:867
    // this.activeDisbursementID.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:5
    // export const PoolGlobalStateKeyDisbursementPhase = 'disbursement_phase'
    bytec 4 // "disbursement_phase"
    // smart_contracts/pool/constants.ts:42
    // export const DisbursementPhaseIdle = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:868
    // this.disbursementPhase.value = DisbursementPhaseIdle
    app_global_put
    // smart_contracts/pool/constants.ts:28
    // export const PoolGlobalStateKeyDisbursementCursor = 'disbursement_cursor'
    bytec_0 // "disbursement_cursor"
    // smart_contracts/pool/contract.algo.ts:869
    // this.disbursementCursor.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:870
    // this.qualifiedStakers.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:29
    // export const PoolGlobalStateKeyQualifiedStake = 'qualified_stake'
    bytec 5 // "qualified_stake"
    // smart_contracts/pool/contract.algo.ts:871
    // this.qualifiedStake.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    bytec 9 // "status"
    // smart_contracts/pool/constants.ts:39
    // export const PoolStatusFinal = new UintN8(1)
    bytec 11 // 0x01
    // smart_contracts/pool/contract.algo.ts:872
    // this.status.value = PoolStatusFinal
    app_global_put
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.check(address: bytes, asset: uint64) -> uint64, uint64:
check:
    // smart_contracts/pool/contract.algo.ts:875
    // check(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    proto 2 2
    // smart_contracts/pool/contract.algo.ts:876
    // const key = new arc4EntryKey({ address, asset: new UintN64(asset) })
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/pool/constants.ts:35
    // export const PoolBoxPrefixEntriesByAddress = 'a'
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:877
    // const id = this.entriesByAddress(key).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/pool/contract.algo.ts:878
    // return this.checkByID(id)
    callsub checkByID
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen() -> uint64:
signUpsOpen:
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:38
    // export const PoolStatusDraft = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:887
    // this.status.value !== PoolStatusDraft &&
    !=
    // smart_contracts/pool/contract.algo.ts:887-888
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@5
    // smart_contracts/pool/contract.algo.ts:888
    // Global.latestTimestamp > this.signupTimestamp.value &&
    global LatestTimestamp
    // smart_contracts/pool/constants.ts:9
    // export const PoolGlobalStateKeySignupTimestamp = 'signup_timestamp'
    intc_0 // 0
    bytec 30 // "signup_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:888
    // Global.latestTimestamp > this.signupTimestamp.value &&
    >
    // smart_contracts/pool/contract.algo.ts:887-888
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@5
    // smart_contracts/pool/contract.algo.ts:889
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    global LatestTimestamp
    // smart_contracts/pool/constants.ts:11
    // export const PoolGlobalStateKeyStartTimestamp = 'start_timestamp'
    intc_0 // 0
    bytec 19 // "start_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:889
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    <
    bnz signUpsOpen_bool_true@4
    // smart_contracts/pool/constants.ts:10
    // export const PoolGlobalStateKeyAllowLateSignups = 'allow_late_signups'
    intc_0 // 0
    bytec 24 // "allow_late_signups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:889
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    bz signUpsOpen_bool_false@5

signUpsOpen_bool_true@4:
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:886-890
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   Global.latestTimestamp > this.signupTimestamp.value &&
    //   (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    // )
    retsub

signUpsOpen_bool_false@5:
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:886-890
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   Global.latestTimestamp > this.signupTimestamp.value &&
    //   (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    // )
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.isLive() -> uint64:
isLive:
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:38
    // export const PoolStatusDraft = new UintN8(0)
    bytec_1 // 0x00
    // smart_contracts/pool/contract.algo.ts:897
    // this.status.value !== PoolStatusDraft &&
    !=
    // smart_contracts/pool/contract.algo.ts:897-898
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:898
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    global LatestTimestamp
    // smart_contracts/pool/constants.ts:11
    // export const PoolGlobalStateKeyStartTimestamp = 'start_timestamp'
    intc_0 // 0
    bytec 19 // "start_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:898
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    >=
    // smart_contracts/pool/contract.algo.ts:897-898
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:899
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    global LatestTimestamp
    // smart_contracts/pool/constants.ts:12
    // export const PoolGlobalStateKeyEndTimestamp = 'end_timestamp'
    intc_0 // 0
    bytec 21 // "end_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:899
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    <=
    bnz isLive_bool_true@4
    // smart_contracts/pool/constants.ts:12
    // export const PoolGlobalStateKeyEndTimestamp = 'end_timestamp'
    intc_0 // 0
    bytec 21 // "end_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:899
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    bnz isLive_bool_false@5

isLive_bool_true@4:
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:896-900
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub

isLive_bool_false@5:
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:896-900
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.getState() -> bytes, bytes, bytes, uint64, bytes, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, bytes, bytes, uint64, uint64, bytes:
getState:
    // smart_contracts/pool/constants.ts:4
    // export const PoolGlobalStateKeyStatus = 'status'
    intc_0 // 0
    bytec 9 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:6
    // export const PoolGlobalStateKeyTitle = 'title'
    intc_0 // 0
    bytec 26 // "title"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:7
    // export const PoolGlobalStateKeyType = 'type'
    intc_0 // 0
    bytec 7 // "type"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:8
    // export const PoolGlobalStateKeyReward = 'reward'
    intc_0 // 0
    bytec 17 // "reward"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:909
    // reward: decodeArc4<Reward>(this.reward.value.bytes),
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    extract 8 1 // on error: Index access is out of bounds
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    pushint 17 // 17
    extract_uint64
    uncover 4
    pushint 25 // 25
    extract_uint64
    // smart_contracts/pool/constants.ts:9
    // export const PoolGlobalStateKeySignupTimestamp = 'signup_timestamp'
    intc_0 // 0
    bytec 30 // "signup_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:10
    // export const PoolGlobalStateKeyAllowLateSignups = 'allow_late_signups'
    intc_0 // 0
    bytec 24 // "allow_late_signups"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:11
    // export const PoolGlobalStateKeyStartTimestamp = 'start_timestamp'
    intc_0 // 0
    bytec 19 // "start_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:12
    // export const PoolGlobalStateKeyEndTimestamp = 'end_timestamp'
    intc_0 // 0
    bytec 21 // "end_timestamp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:15
    // export const PoolGlobalStateKeyMaxEntries = 'max_entries'
    intc_0 // 0
    bytec 23 // "max_entries"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:16
    // export const PoolGlobalStateKeyEntryCount = 'entry_count'
    intc_0 // 0
    bytec_2 // "entry_count"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:915
    // entryCount: (this.entryID.value + 1),
    intc_1 // 1
    +
    // smart_contracts/pool/constants.ts:17
    // export const PoolGlobalStateKeyTotalStaked = 'total_staked'
    intc_0 // 0
    pushbytes "total_staked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:19
    // export const PoolGlobalStateKeyStakeKey = 'stake_key'
    intc_0 // 0
    bytec 27 // "stake_key"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:917
    // stakeKey: decodeArc4<RootKey>(this.stakeKey.value.bytes),
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 32 // 32
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/pool/constants.ts:20
    // export const PoolGlobalStateKeyMinimumStakeAmount = 'minimum_stake_amount'
    intc_0 // 0
    bytec 28 // "minimum_stake_amount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:21
    // export const PoolGlobalStateKeyGateID = 'gate_id'
    intc_0 // 0
    bytec 18 // "gate_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/constants.ts:23
    // export const PoolGlobalStateKeyCreator = 'creator'
    intc_0 // 0
    bytec 22 // "creator"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:905-921
    // return {
    //   status: this.status.value,
    //   title: this.title.value,
    //   type: this.type.value,
    //   reward: decodeArc4<Reward>(this.reward.value.bytes),
    //   signupTimestamp: this.signupTimestamp.value,
    //   allowLateSignups: this.allowLateSignups.value,
    //   startTimestamp: this.startTimestamp.value,
    //   endTimestamp: this.endTimestamp.value,
    //   maxEntries: this.maxEntries.value,
    //   entryCount: (this.entryID.value + 1),
    //   totalStaked: this.totalStaked.value,
    //   stakeKey: decodeArc4<RootKey>(this.stakeKey.value.bytes),
    //   minimumStakeAmount: this.minimumStakeAmount.value,
    //   gateID: this.gateID.value,
    //   creator: this.creator.value,
    // }
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 18
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    uncover 19
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateApplication(newVersion: bytes) -> void:
updateApplication:
    // smart_contracts/utils/base-contracts/base.ts:19-20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:21
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:21
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:22
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:27
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_3 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_3 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:29
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn.optin(payment: uint64, asset: uint64) -> void:
optin:
    // smart_contracts/utils/base-contracts/optin.ts:51
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/optin.ts:52
    // assert(Txn.sender === Global.creatorAddress)
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/utils/base-contracts/optin.ts:54-61
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/utils/base-contracts/optin.ts:57
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/optin.ts:54-61
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@3
    frame_dig -2
    gtxns Amount
    // smart_contracts/utils/base-contracts/optin.ts:58
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/utils/base-contracts/optin.ts:54-61
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@3
    intc_1 // 1

optin_bool_merge@4:
    // smart_contracts/utils/base-contracts/optin.ts:54-61
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/utils/base-contracts/optin.ts:63-68
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/optin.ts:64
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/utils/base-contracts/optin.ts:65
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/optin.ts:63-68
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/base-contracts/optin.ts:67
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/optin.ts:63-68
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee: 0,
    // }).submit()
    itxn_submit
    retsub

optin_bool_false@3:
    intc_0 // 0
    b optin_bool_merge@4
