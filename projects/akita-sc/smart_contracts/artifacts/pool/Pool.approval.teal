#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 92 100000 6364136223846793005 400 1442695040888963407 1442695040888963409 4294967295 18446744073709551615
    bytecblock "entry_count" 0x151f7c75 0x00 "akita_al" "type" 0x0a "gate_id" 0x0000 "status" "creator" 0x14 "e" 0x1e "max_entries" "akita_dao" "end_timestamp" "start_timestamp" "r" "akita_royalty_amount" "stake_key" "akita_royalty" "allow_late_signups" 0x80 "title" "minimum_stake_amount" "signup_timestamp" "reward_count" "akita_escrow" "salt" 0xc9068809 "controlled_address" 0x000000000000000000000000000000000000000000000000 0x000000000000000000
    // smart_contracts/pool/contract.algo.ts:97-100
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseEscrow
    // ) {
    pushbytess 0xab8b213a 0xea9180dd // method "delete(address)void", method "update(string)void"
    txna ApplicationArgs 0
    match main_delete_route@4 main_update_route@5

main_switch_case_next@6:
    // smart_contracts/pool/contract.algo.ts:97-100
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseEscrow
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@28
    pushbytess 0x83f14748 0x3ea11832 0x645a7bcc 0x0f2fc312 0x181e8291 0x68558c70 0xa9418d37 0xfc699cb3 0x6e76b2ca 0xcdb0ac6a 0xb223d35d 0x592ee341 0x8fa4a160 0xe3377342 0x71704649 0x776e3a65 0x33e92c94 0x1ead20a9 0xa4b3e789 // method "init()void", method "optin(pay,uint64)void", method "addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "finalize(uint64,uint64,uint64)void", method "enter(pay,(uint64,uint64,byte[32][])[],byte[][])void", method "startDisbursement(uint64)void", method "raffle(uint64)void", method "disburseRewards(uint64,uint64)void", method "finalizeDistribution(uint64)void", method "check(address,uint64)(bool,uint64)", method "signUpsOpen()bool", method "isLive()bool", method "isEntered(address)bool", method "getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)", method "optAkitaEscrowInAndSend(string,uint64,uint64)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void", method "mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match init optin addReward addRewardAsa finalize enter startDisbursement raffle disburseRewards finalizeDistribution check signUpsOpen isLive isEntered getState optAkitaEscrowInAndSend updateAkitaDAO updateAkitaDAOEscrow mbr
    err

main_create_NoOp@28:
    // smart_contracts/pool/contract.algo.ts:97-100
    // export class Pool extends classes(
    //   BasePool,
    //   AkitaBaseEscrow
    // ) {
    pushbytes 0xd5f3c06a // method "create(string,uint8,address,address,(address,string),uint64,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@5:
    // smart_contracts/utils/base-contracts/escrow.ts:49
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update

main_delete_route@4:
    // smart_contracts/pool/contract.algo.ts:709
    // @abimethod({ allowActions: 'DeleteApplication' })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete


// smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
__pcg32Output:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:23
    // export function __pcg32Output(state: PCG32STATE): uint64 {
    proto 1 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:24
    // const xorshifted = __maskToUint32(op.shr(op.shr(state, 18) ^ state, 27))
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:25
    // const rot = op.shr(state, 59)
    frame_dig -1
    pushint 59 // 59
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    dup2
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    |
    retsub


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:158
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:44
    // return op.AppGlobal.getExUint64(akitaDAO, Bytes(AbstractAccountGlobalStateKeysEscrowFactory))[0]
    frame_dig -2
    pushbytes "escrow_factory"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:164-170
    // const data = abiCall(
    //   EscrowFactoryInterface.prototype.get,
    //   {
    //     appId: escrowFactory,
    //     args: [new Address(address)]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:172
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:173
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:160
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:176
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:160
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCall(akitaDAO: uint64, caller: bytes, id: uint64, args: bytes) -> uint64, bytes:
gateCall:
    // smart_contracts/utils/functions.ts:189
    // export function gateCall(akitaDAO: Application, caller: Account, id: uint64, args: GateArgs): boolean {
    proto 4 2
    // smart_contracts/utils/functions.ts:190-200
    // return abiCall(
    //   GateInterface.prototype.check,
    //   {
    //     appId: getAkitaAppList(akitaDAO).gate,
    //     args: [
    //       new Address(caller),
    //       id,
    //       args,
    //     ],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -4
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:193
    // appId: getAkitaAppList(akitaDAO).gate,
    pushint 40 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:196
    // id,
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:190-200
    // return abiCall(
    //   GateInterface.prototype.check,
    //   {
    //     appId: getAkitaAppList(akitaDAO).gate,
    //     args: [
    //       new Address(caller),
    //       id,
    //       args,
    //     ],
    //   }
    // ).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    frame_dig -1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.create[routing]() -> void:
create:
    // smart_contracts/pool/contract.algo.ts:664
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:676
    // this.status.value = PoolStatusDraft
    bytec_2 // 0x00
    app_global_put
    // smart_contracts/pool/contract.algo.ts:107
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 23 // "title"
    // smart_contracts/pool/contract.algo.ts:677
    // this.title.value = title
    uncover 9
    app_global_put
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:678
    // this.type.value = type
    uncover 8
    app_global_put
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:679
    // this.creator.value = creator.native
    uncover 7
    app_global_put
    // smart_contracts/pool/contract.algo.ts:140
    // marketplace = GlobalState<Account>({ key: PoolGlobalStateKeyMarketplace })
    pushbytes "marketplace"
    // smart_contracts/pool/contract.algo.ts:680
    // this.marketplace.value = marketplace.native
    uncover 6
    app_global_put
    // smart_contracts/pool/contract.algo.ts:130
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 19 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:682
    // this.stakeKey.value = clone(stakeKey)
    uncover 5
    app_global_put
    // smart_contracts/pool/contract.algo.ts:132
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 24 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:683
    // this.minimumStakeAmount.value = minimumStakeAmount
    uncover 4
    app_global_put
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:684
    // this.gateID.value = gateID
    uncover 3
    app_global_put
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:685
    // this.maxEntries.value = maxEntries
    uncover 2
    app_global_put
    // smart_contracts/pool/contract.algo.ts:148
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 28 // "salt"
    // smart_contracts/pool/contract.algo.ts:687
    // this.salt.value = Txn.txId
    txn TxID
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/pool/contract.algo.ts:688
    // this.akitaDAO.value = Application(akitaDAO)
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:690
    // const fees = getStakingFees(Global.currentApplicationId)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:58
    // const [stakingFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysStakingFees))
    pushbytes "staking_fees"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:691
    // const impact = getUserImpact(Global.currentApplicationId, this.creator.value)
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:691
    // const impact = getUserImpact(Global.currentApplicationId, this.creator.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:111-117
    // return abiCall(
    //   AkitaSocialImpactInterface.prototype.getUserImpact,
    //   {
    //     appId: getAkitaAppList(akitaDAO).impact,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    swap
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:114
    // appId: getAkitaAppList(akitaDAO).impact,
    pushint 104 // 104
    extract_uint64
    // smart_contracts/utils/functions.ts:111-117
    // return abiCall(
    //   AkitaSocialImpactInterface.prototype.getUserImpact,
    //   {
    //     appId: getAkitaAppList(akitaDAO).impact,
    //     args: [new Address(account)]
    //   }
    // ).returnValue
    pushbytes 0xd574bb10 // method "getUserImpact(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    dup
    cover 2
    // smart_contracts/pool/contract.algo.ts:692
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    dig 1
    intc_2 // 8
    extract_uint64
    cover 2
    swap
    pushint 16 // 16
    extract_uint64
    swap
    // smart_contracts/utils/functions.ts:106
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    >
    bz create_ternary_false@7
    dig 2
    intc_1 // 1
    -

create_ternary_merge@8:
    // smart_contracts/utils/functions.ts:107
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    dig 1
    dup
    dig 4
    -
    uncover 2
    *
    pushint 1000 // 1000
    /
    -
    // smart_contracts/pool/contract.algo.ts:144
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 20 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:692
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:664
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return

create_ternary_false@7:
    // smart_contracts/utils/functions.ts:106
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b create_ternary_merge@8


// smart_contracts/pool/contract.algo.ts::Pool.init[routing]() -> void:
init:
    // smart_contracts/pool/contract.algo.ts:696
    // assert(Global.callerApplicationAddress === Global.creatorAddress, 'only the factory can init the pool')
    global CallerApplicationAddress
    global CreatorAddress
    ==
    assert // only the factory can init the pool
    // smart_contracts/pool/contract.algo.ts:698
    // if (this.gateID.value > 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:698
    // if (this.gateID.value > 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz init_after_if_else@4
    // smart_contracts/pool/contract.algo.ts:699-705
    // this.gateSize.value = abiCall(
    //   GateInterface.prototype.size,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).gate,
    //     args: [this.gateID.value],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:702
    // appId: getAkitaAppList(Global.currentApplicationId).gate,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:702
    // appId: getAkitaAppList(Global.currentApplicationId).gate,
    pushint 40 // 40
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:703
    // args: [this.gateID.value],
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:703
    // args: [this.gateID.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/pool/contract.algo.ts:699-705
    // this.gateSize.value = abiCall(
    //   GateInterface.prototype.size,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).gate,
    //     args: [this.gateID.value],
    //   }
    // ).returnValue
    pushbytes 0xdf56b01e // method "size(uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/pool/contract.algo.ts:136
    // gateSize = GlobalState<uint64>({ key: PoolGlobalStateKeyGateSize })
    pushbytes "gate_size"
    // smart_contracts/pool/contract.algo.ts:699-705
    // this.gateSize.value = abiCall(
    //   GateInterface.prototype.size,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).gate,
    //     args: [this.gateID.value],
    //   }
    // ).returnValue
    swap
    app_global_put

init_after_if_else@4:
    // smart_contracts/pool/contract.algo.ts:695
    // init() {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.delete[routing]() -> void:
delete:
    // smart_contracts/pool/contract.algo.ts:709
    // @abimethod({ allowActions: 'DeleteApplication' })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/pool/contract.algo.ts:711
    // assert(Txn.sender === Global.creatorAddress, 'call must come from factory')
    txn Sender
    global CreatorAddress
    ==
    assert // call must come from factory
    // smart_contracts/pool/contract.algo.ts:712
    // assert(caller.native === this.creator.value, 'only the creator can delete the pool')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:712
    // assert(caller.native === this.creator.value, 'only the creator can delete the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can delete the pool
    // smart_contracts/pool/contract.algo.ts:713
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:713
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    bnz delete_bool_true@3
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:713
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz delete_bool_false@4

delete_bool_true@3:
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:709
    // @abimethod({ allowActions: 'DeleteApplication' })
    return // on error: the pool must be in draft or ended

delete_bool_false@4:
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:709
    // @abimethod({ allowActions: 'DeleteApplication' })
    return // on error: the pool must be in draft or ended


// smart_contracts/pool/contract.algo.ts::Pool.optin[routing]() -> void:
optin:
    // smart_contracts/pool/contract.algo.ts:723
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:724
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:724
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/pool/contract.algo.ts:728
    // const daoEscrowNeedsToOptIn = !Global.zeroAddress.isOptedIn(Asset(asset))
    global ZeroAddress
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    // smart_contracts/pool/contract.algo.ts:732
    // Global.assetOptInMinBalance * (
    global AssetOptInMinBalance
    // smart_contracts/pool/contract.algo.ts:733
    // daoEscrowNeedsToOptIn ? 4 : 1
    intc_1 // 1
    pushint 4 // 4
    uncover 3
    select
    // smart_contracts/pool/contract.algo.ts:732-734
    // Global.assetOptInMinBalance * (
    //   daoEscrowNeedsToOptIn ? 4 : 1
    // )
    *
    // smart_contracts/pool/contract.algo.ts:739-746
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:742
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:739-746
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 3
    gtxns Amount
    // smart_contracts/pool/contract.algo.ts:743
    // amount: optinMBR + rewardsMBR,
    uncover 2
    // smart_contracts/pool/contract.algo.ts:737
    // const rewardsMBR: uint64 = this.rewardsMbr(WinnerCountCap) * 2
    pushint 8000 // 8000
    // smart_contracts/pool/contract.algo.ts:743
    // amount: optinMBR + rewardsMBR,
    +
    // smart_contracts/pool/contract.algo.ts:739-746
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:748-754
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:750
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 1
    itxn_field XferAsset
    // smart_contracts/pool/contract.algo.ts:751
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:748-753
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:748-754
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/pool/contract.algo.ts:757
    // AkitaDAOEscrowAccountStakingPools,
    pushbytes "staking_pools"
    // smart_contracts/pool/contract.algo.ts:756-760
    // this.optAkitaEscrowInAndSend(
    //   AkitaDAOEscrowAccountStakingPools,
    //   Asset(asset),
    //   0
    // )
    swap
    // smart_contracts/pool/contract.algo.ts:759
    // 0
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:756-760
    // this.optAkitaEscrowInAndSend(
    //   AkitaDAOEscrowAccountStakingPools,
    //   Asset(asset),
    //   0
    // )
    callsub smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend
    // smart_contracts/pool/contract.algo.ts:723
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.addReward[routing]() -> void:
addReward:
    // smart_contracts/pool/contract.algo.ts:763
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    callsub smart_contracts/pool/contract.algo.ts::Pool.addReward
    pop
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.addRewardAsa[routing]() -> void:
addRewardAsa:
    // smart_contracts/pool/contract.algo.ts:784
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/pool/contract.algo.ts:785-795
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    dig 1
    gtxns AssetReceiver
    // smart_contracts/pool/contract.algo.ts:788
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:785-795
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    dig 2
    gtxns XferAsset
    // smart_contracts/pool/contract.algo.ts:789
    // xferAsset: Asset(reward.asset),
    dig 2
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:785-795
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    uncover 2
    gtxns AssetAmount
    &&
    assert // Invalid transfer
    // smart_contracts/pool/contract.algo.ts:797
    // this.addReward(payment, reward)
    callsub smart_contracts/pool/contract.algo.ts::Pool.addReward
    pop
    // smart_contracts/pool/contract.algo.ts:784
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.finalize[routing]() -> void:
finalize:
    // smart_contracts/pool/contract.algo.ts:800
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/pool/contract.algo.ts:801
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:801
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can finalize the pool
    // smart_contracts/pool/contract.algo.ts:802
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:802
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    assert // the pool must be in draft state to finalize
    // smart_contracts/pool/contract.algo.ts:804
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    global LatestTimestamp
    >
    bnz finalize_bool_true@4
    dig 2
    bnz finalize_bool_false@5
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 21 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:804
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@5

finalize_bool_true@4:
    intc_1 // 1

finalize_bool_merge@6:
    // smart_contracts/pool/contract.algo.ts:803-806
    // assert(
    //   signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    //   'the signup round must be zero and late sign ups allowed or in the future'
    // )
    assert // the signup round must be zero and late sign ups allowed or in the future
    // smart_contracts/pool/contract.algo.ts:809-810
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    dig 1
    bz finalize_bool_true@8
    // smart_contracts/pool/contract.algo.ts:810
    // startTimestamp > Global.latestTimestamp,
    dig 1
    global LatestTimestamp
    >
    // smart_contracts/pool/contract.algo.ts:809-810
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    bz finalize_bool_false@9

finalize_bool_true@8:
    intc_1 // 1

finalize_bool_merge@10:
    // smart_contracts/pool/contract.algo.ts:808-812
    // assert(
    //   startTimestamp === 0 ||
    //   startTimestamp > Global.latestTimestamp,
    //   'the starting round must be zero or in the future'
    // )
    assert // the starting round must be zero or in the future
    // smart_contracts/pool/contract.algo.ts:814
    // if (startTimestamp === 0) {
    dig 1
    bnz finalize_after_if_else@16
    // smart_contracts/pool/contract.algo.ts:815
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    dig 2
    bnz finalize_bool_false@14
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 21 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:815
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@14
    intc_1 // 1

finalize_bool_merge@15:
    // smart_contracts/pool/contract.algo.ts:815
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    assert // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
    // smart_contracts/pool/contract.algo.ts:816
    // startTimestamp = Global.latestTimestamp
    global LatestTimestamp
    bury 2

finalize_after_if_else@16:
    // smart_contracts/pool/contract.algo.ts:820
    // endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    dup
    bz finalize_bool_true@18
    dig 1
    pushint 10 // 10
    +
    dig 1
    <
    bz finalize_bool_false@19

finalize_bool_true@18:
    intc_1 // 1

finalize_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:819-822
    // assert(
    //   endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    //   'the ending round must be zero or after the starting round + 10'
    // )
    assert // the ending round must be zero or after the starting round + 10
    // smart_contracts/pool/contract.algo.ts:111
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 25 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:824
    // this.signupTimestamp.value = signupTimestamp
    dig 3
    app_global_put
    // smart_contracts/pool/contract.algo.ts:115
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 16 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:825
    // this.startTimestamp.value = startTimestamp
    dig 2
    app_global_put
    // smart_contracts/pool/contract.algo.ts:117
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:826
    // this.endTimestamp.value = endTimestamp
    dig 1
    app_global_put
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:827
    // this.status.value = PoolStatusFinal
    bytec 5 // 0x0a
    app_global_put
    // smart_contracts/pool/contract.algo.ts:800
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    intc_1 // 1
    return

finalize_bool_false@19:
    intc_0 // 0
    b finalize_bool_merge@20

finalize_bool_false@14:
    intc_0 // 0
    b finalize_bool_merge@15

finalize_bool_false@9:
    intc_0 // 0
    b finalize_bool_merge@10

finalize_bool_false@5:
    intc_0 // 0
    b finalize_bool_merge@6


// smart_contracts/pool/contract.algo.ts::Pool.enter[routing]() -> void:
enter:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 4
    // smart_contracts/pool/contract.algo.ts:830
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/pool/contract.algo.ts:832
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    assert // the pool is not live
    // smart_contracts/pool/contract.algo.ts:834
    // if (this.gateID.value !== 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:834
    // if (this.gateID.value !== 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz enter_after_if_else@3
    // smart_contracts/pool/contract.algo.ts:835
    // const wallet = getWalletIDUsingAkitaDAO(Global.currentApplicationId, Txn.sender)
    global CurrentApplicationID
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    bury 5
    // smart_contracts/utils/functions.ts:128
    // return originOr(walletID, Txn.sender)
    txn Sender
    bury 10
    // smart_contracts/utils/functions.ts:121
    // if (walletID.id === 0) {
    bnz enter_after_if_else@30
    dig 8

enter_after_inlined_smart_contracts/utils/functions.ts::originOr@31:
    // smart_contracts/pool/contract.algo.ts:838
    // gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:838
    // gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    app_global_get_ex
    assert // check GlobalState exists
    swap
    cover 2
    dig 3
    callsub gateCall
    bury 2
    // smart_contracts/pool/contract.algo.ts:837-840
    // assert(
    //   gateCall(Global.currentApplicationId, origin, this.gateID.value, args),
    //   'user does not meet gate requirements'
    // )
    assert // user does not meet gate requirements

enter_after_if_else@3:
    // smart_contracts/pool/contract.algo.ts:844
    // (this.entryID.value + 1) < this.maxEntries.value ||
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:844
    // (this.entryID.value + 1) < this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:844
    // (this.entryID.value + 1) < this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    <
    // smart_contracts/pool/contract.algo.ts:844-845
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_true@5
    // smart_contracts/pool/contract.algo.ts:845
    // this.maxEntries.value === 0,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:845
    // this.maxEntries.value === 0,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:844-845
    // (this.entryID.value + 1) < this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz enter_bool_false@6

enter_bool_true@5:
    intc_1 // 1

enter_bool_merge@7:
    // smart_contracts/pool/contract.algo.ts:843-847
    // assert(
    //   (this.entryID.value + 1) < this.maxEntries.value ||
    //   this.maxEntries.value === 0,
    //   'pool has reached maximum entries'
    // )
    assert // pool has reached maximum entries
    // smart_contracts/pool/contract.algo.ts:851
    // let total: uint64 = entryMBR * entries.length
    dig 1
    intc_0 // 0
    extract_uint16
    dup
    bury 9
    pushint 50600 // 50600
    *
    // smart_contracts/pool/contract.algo.ts:155
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    pushbytes "u"
    // smart_contracts/pool/contract.algo.ts:852
    // if (!this.uniques(Txn.sender).exists) {
    txn Sender
    // smart_contracts/pool/contract.algo.ts:155
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    concat
    // smart_contracts/pool/contract.algo.ts:852
    // if (!this.uniques(Txn.sender).exists) {
    box_len
    bury 1
    bnz enter_after_if_else@9
    // smart_contracts/pool/contract.algo.ts:853
    // total += PoolUniquesMBR
    pushint 18900 // 18900
    +

enter_after_if_else@9:
    // smart_contracts/pool/contract.algo.ts:856-863
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 3
    dup
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:859
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:856-863
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:865
    // const { address, name } = this.stakeKey.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:130
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 19 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:865
    // const { address, name } = this.stakeKey.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    extract 0 32
    bury 13
    dup
    pushint 32 // 32
    extract_uint16
    dig 1
    len
    substring3
    bury 11
    // smart_contracts/pool/contract.algo.ts:867
    // for (let i: uint64 = 0; i < entries.length; i++) {
    intc_0 // 0
    bury 6

enter_while_top@10:
    // smart_contracts/pool/contract.algo.ts:867
    // for (let i: uint64 = 0; i < entries.length; i++) {
    dig 5
    dig 8
    <
    bz enter_after_while@23
    // smart_contracts/pool/contract.algo.ts:868
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    dig 1
    extract 2 0
    dig 6
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    bury 9
    dig 10
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    bury 11
    intc_2 // 8
    extract_uint64
    dup
    bury 6
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:132
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 24 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:868
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    app_global_get_ex
    assert // check GlobalState exists
    >=
    assert // quantity is less than minimum stake amount
    // smart_contracts/pool/contract.algo.ts:870
    // if (address.native !== Global.zeroAddress) {
    dig 11
    global ZeroAddress
    !=
    bz enter_after_if_else@14
    // smart_contracts/pool/contract.algo.ts:871-883
    // const verified = abiCall(
    //   MetaMerklesInterface.prototype.verify,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).metaMerkles,
    //     args: [
    //       address,
    //       name,
    //       sha256(sha256(itob(entries[i].asset))),
    //       entries[i].proof,
    //       MERKLE_TREE_TYPE_ASSET,
    //     ],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:874
    // appId: getAkitaAppList(Global.currentApplicationId).metaMerkles,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:874
    // appId: getAkitaAppList(Global.currentApplicationId).metaMerkles,
    pushint 72 // 72
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:878
    // sha256(sha256(itob(entries[i].asset))),
    dig 10
    dup
    extract 0 8
    sha256
    sha256
    // smart_contracts/pool/contract.algo.ts:879
    // entries[i].proof,
    dig 1
    pushint 16 // 16
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    // smart_contracts/pool/contract.algo.ts:880
    // MERKLE_TREE_TYPE_ASSET,
    intc_1 // 1
    itob
    // smart_contracts/pool/contract.algo.ts:871-883
    // const verified = abiCall(
    //   MetaMerklesInterface.prototype.verify,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).metaMerkles,
    //     args: [
    //       address,
    //       name,
    //       sha256(sha256(itob(entries[i].asset))),
    //       entries[i].proof,
    //       MERKLE_TREE_TYPE_ASSET,
    //     ],
    //   }
    // ).returnValue
    pushbytes 0x2bf3cc5a // method "verify(address,string,byte[32],byte[32][],uint64)bool"
    itxn_field ApplicationArgs
    dig 15
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:885
    // assert(verified, 'failed to verify stake requirements')
    assert // failed to verify stake requirements

enter_after_if_else@14:
    // smart_contracts/pool/contract.algo.ts:890
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:890
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    ==
    // smart_contracts/pool/contract.algo.ts:890-891
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bnz enter_if_body@16
    // smart_contracts/pool/contract.algo.ts:891
    // this.type.value === POOL_STAKING_TYPE_SOFT
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:891
    // this.type.value === POOL_STAKING_TYPE_SOFT
    app_global_get_ex
    assert // check GlobalState exists
    bytec 10 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:890-891
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bz enter_after_if_else@21

enter_if_body@16:
    // smart_contracts/pool/contract.algo.ts:893
    // const [balance, optedIn] = AssetHolding.assetBalance(Txn.sender, entries[i].asset)
    txn Sender
    dig 10
    intc_0 // 0
    extract_uint64
    asset_holding_get AssetBalance
    swap
    bury 8
    // smart_contracts/pool/contract.algo.ts:894
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    bz enter_bool_false@19
    dig 6
    dig 5
    >=
    bz enter_bool_false@19
    intc_1 // 1

enter_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:894
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    assert // user does not have min balance

enter_after_if_else@21:
    // smart_contracts/pool/contract.algo.ts:897-909
    // const stakeInfo = abiCall(
    //   StakingInterface.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [
    //       new Address(Txn.sender),
    //       {
    //         asset: entries[i].asset,
    //         type: this.stakingType(),
    //       },
    //     ],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:900
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:900
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:902
    // new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:905
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:903-906
    // {
    //   asset: entries[i].asset,
    //   type: this.stakingType(),
    // },
    dig 12
    extract 0 8
    dup
    uncover 2
    concat
    // smart_contracts/pool/contract.algo.ts:897-909
    // const stakeInfo = abiCall(
    //   StakingInterface.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [
    //       new Address(Txn.sender),
    //       {
    //         asset: entries[i].asset,
    //         type: this.stakingType(),
    //       },
    //     ],
    //   }
    // ).returnValue
    bytec 29 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 4 // 4
    // smart_contracts/pool/contract.algo.ts:911
    // assert(stakeInfo.amount >= entries[i].quantity, 'user does not have enough staked')
    extract_uint64
    dig 6
    dup
    cover 2
    >=
    assert // user does not have enough staked
    // smart_contracts/pool/contract.algo.ts:167
    // const id = this.entryID.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:167
    // const id = this.entryID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:168
    // this.entryID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:168
    // this.entryID.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:915
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:914-920
    // this.entries(entryID).value = {
    //   address: new Address(Txn.sender),
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(args),
    //   disqualified: false
    // }
    dig 3
    concat
    uncover 2
    itob
    concat
    pushbytes 0x003300
    concat
    dig 3
    concat
    // smart_contracts/pool/contract.algo.ts:914
    // this.entries(entryID).value = {
    swap
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    dig 1
    concat
    // smart_contracts/pool/contract.algo.ts:914-920
    // this.entries(entryID).value = {
    //   address: new Address(Txn.sender),
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(args),
    //   disqualified: false
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/pool/contract.algo.ts:923
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/pool/contract.algo.ts:922-925
    // const aKey = {
    //   address: new Address(Txn.sender),
    //   asset: entries[i].asset,
    // }
    uncover 2
    concat
    // smart_contracts/pool/contract.algo.ts:927
    // this.entriesByAddress(aKey).value = entryID
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/pool/contract.algo.ts:157
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:927
    // this.entriesByAddress(aKey).value = entryID
    swap
    box_put
    b enter_while_top@10

enter_bool_false@19:
    intc_0 // 0
    b enter_bool_merge@20

enter_after_while@23:
    // smart_contracts/pool/contract.algo.ts:830
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[], args: GateArgs): void {
    intc_1 // 1
    return

enter_bool_false@6:
    intc_0 // 0
    b enter_bool_merge@7

enter_after_if_else@30:
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:145
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 30 // "controlled_address"
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:128
    // return originOr(walletID, Txn.sender)
    b enter_after_inlined_smart_contracts/utils/functions.ts::originOr@31


// smart_contracts/pool/contract.algo.ts::Pool.startDisbursement[routing]() -> void:
startDisbursement:
    // smart_contracts/pool/contract.algo.ts:931
    // startDisbursement(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:932
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    assert // the pool is not live
    // smart_contracts/pool/contract.algo.ts:933
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:159
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 17 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:933
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:935
    // const { phase, interval, lastDisbursementTimestamp, expiration } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 116 // 116
    intc_2 // 8
    box_extract
    btoi
    cover 3
    uncover 2
    pushint 17 // 17
    intc_2 // 8
    box_extract
    btoi
    cover 2
    // smart_contracts/pool/contract.algo.ts:937
    // assert(phase === DisbursementPhaseIdle, 'reward is already in a disbursement phase')
    swap
    bytec_2 // 0x00
    ==
    assert // reward is already in a disbursement phase
    // smart_contracts/pool/contract.algo.ts:514
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    global LatestTimestamp
    dup
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 16 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:514
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    app_global_get_ex
    assert // check GlobalState exists
    -
    uncover 2
    %
    -
    dup
    // smart_contracts/pool/contract.algo.ts:519
    // return latestWindowStart !== Global.latestTimestamp && last < latestWindowStart
    global LatestTimestamp
    !=
    bz startDisbursement_bool_false@4
    dig 2
    dig 1
    <
    bz startDisbursement_bool_false@4
    intc_1 // 1

startDisbursement_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:938
    // assert(this.validWindow(interval, lastDisbursementTimestamp), 'distribution window is not open')
    assert // distribution window is not open
    // smart_contracts/pool/contract.algo.ts:941
    // `${this.title.value} - Rewards`,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:107
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 23 // "title"
    // smart_contracts/pool/contract.algo.ts:941
    // `${this.title.value} - Rewards`,
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes " - Rewards"
    concat
    // smart_contracts/pool/contract.algo.ts:942
    // Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/pool/contract.algo.ts:943
    // Global.latestTimestamp + expiration
    dup
    dig 4
    +
    // smart_contracts/pool/contract.algo.ts:549
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:549
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:550
    // const rewardMBR: uint64 = MinDisbursementsMBR + (BoxCostPerByte * Bytes(title).length)
    dig 3
    len
    intc 6 // 400
    dig 1
    *
    pushint 35300 // 35300
    +
    // smart_contracts/pool/contract.algo.ts:553
    // receiver: rewardsApp.address,
    dig 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:557-569
    // return abiCall(
    //   RewardsInterface.prototype.createDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       mbrPayment,
    //       title,
    //       timeToUnlock,
    //       expiration,
    //       '',
    //     ],
    //   }
    // ).returnValue
    itxn_begin
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/pool/contract.algo.ts:552-555
    // const mbrPayment = itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: rewardMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:557-569
    // return abiCall(
    //   RewardsInterface.prototype.createDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       mbrPayment,
    //       title,
    //       timeToUnlock,
    //       expiration,
    //       '',
    //     ],
    //   }
    // ).returnValue
    itxn_next
    // smart_contracts/pool/contract.algo.ts:563
    // title,
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/pool/contract.algo.ts:564
    // timeToUnlock,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:565
    // expiration,
    uncover 3
    itob
    // smart_contracts/pool/contract.algo.ts:566
    // '',
    intc_0 // 0
    itob
    // smart_contracts/pool/contract.algo.ts:557-569
    // return abiCall(
    //   RewardsInterface.prototype.createDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       mbrPayment,
    //       title,
    //       timeToUnlock,
    //       expiration,
    //       '',
    //     ],
    //   }
    // ).returnValue
    pushbytes 0x1c9ebbdb // method "createDisbursement(pay,string,uint64,uint64,string)uint64"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:566
    // '',
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:557-569
    // return abiCall(
    //   RewardsInterface.prototype.createDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       mbrPayment,
    //       title,
    //       timeToUnlock,
    //       expiration,
    //       '',
    //     ],
    //   }
    // ).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/pool/contract.algo.ts:946
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 5
    dup
    pushint 33 // 33
    dig 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:947
    // this.rewards(rewardID).value.qualifiedStake = 0
    dup
    pushint 41 // 41
    dig 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:948
    // this.rewards(rewardID).value.phase = DisbursementPhasePreparation
    dup
    pushint 91 // 91
    bytec 5 // 0x0a
    box_replace
    // smart_contracts/pool/contract.algo.ts:949
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    uncover 4
    box_replace
    // smart_contracts/pool/contract.algo.ts:950
    // this.rewards(rewardID).value.activeDisbursementID = disbursementID
    dup
    pushint 100 // 100
    uncover 3
    box_replace
    // smart_contracts/pool/contract.algo.ts:951
    // this.rewards(rewardID).value.activeDisbursementRoundStart = Global.round
    global Round
    itob
    dig 1
    pushint 108 // 108
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:952
    // this.rewards(rewardID).value.lastDisbursementTimestamp = Global.latestTimestamp
    global LatestTimestamp
    itob
    pushint 116 // 116
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:931
    // startDisbursement(rewardID: uint64): void {
    intc_1 // 1
    return

startDisbursement_bool_false@4:
    intc_0 // 0
    b startDisbursement_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.raffle[routing]() -> void:
raffle:
    // smart_contracts/pool/contract.algo.ts:955
    // raffle(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/pool/contract.algo.ts::Pool.raffle
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.disburseRewards[routing]() -> void:
disburseRewards:
    intc_0 // 0
    dupn 7
    pushbytes ""
    dupn 25
    // smart_contracts/pool/contract.algo.ts:998
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/pool/contract.algo.ts:1000
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:159
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 17 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:1000
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:1002
    // const { phase, distribution, winningTickets } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dup
    uncover 2
    intc_2 // 8
    intc_1 // 1
    box_extract
    swap
    // smart_contracts/pool/contract.algo.ts:1005
    // phase === DisbursementPhasePreparation ||
    bytec 5 // 0x0a
    ==
    dup
    // smart_contracts/pool/contract.algo.ts:1005-1006
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bnz disburseRewards_bool_true@3
    // smart_contracts/pool/contract.algo.ts:1006
    // phase === DisbursementPhaseAllocation,
    dig 2
    bytec 10 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:1005-1006
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bz disburseRewards_bool_false@4

disburseRewards_bool_true@3:
    intc_1 // 1

disburseRewards_bool_merge@5:
    // smart_contracts/pool/contract.algo.ts:1004-1008
    // assert(
    //   phase === DisbursementPhasePreparation ||
    //   phase === DisbursementPhaseAllocation,
    //   ERR_NOT_READY_TO_DISBURSE
    // )
    assert // Not ready to disburse
    // smart_contracts/pool/contract.algo.ts:1010
    // if (phase === DisbursementPhasePreparation) {
    dup
    bz disburseRewards_else_body@7
    // smart_contracts/pool/contract.algo.ts:210
    // const { disbursementCursor, distribution, rate, asset } = this.rewards(rewardID).value
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    bury 4
    dup
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 15
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 28
    // smart_contracts/pool/contract.algo.ts:211
    // let count: uint64 = 0
    intc_0 // 0
    bury 26
    // smart_contracts/pool/contract.algo.ts:212
    // let total: uint64 = 0
    intc_0 // 0
    bury 10
    // smart_contracts/pool/contract.algo.ts:214
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:214
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@91
    // smart_contracts/pool/contract.algo.ts:215
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:215
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@91:
    dig 19
    bury 17

disburseRewards_while_top@92:
    // smart_contracts/pool/contract.algo.ts:218
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@109
    // smart_contracts/pool/contract.algo.ts:219
    // const { disqualified, address, gateArgs, quantity } = clone(this.entries(id).value)
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    dup
    bury 35
    // smart_contracts/pool/contract.algo.ts:219
    // const { disqualified, address, gateArgs, quantity } = clone(this.entries(id).value)
    dup
    box_get
    assert // Box must have value
    dig 1
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 2
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 43
    dig 1
    pushint 48 // 48
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    bury 35
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 15
    // smart_contracts/pool/contract.algo.ts:220
    // if (disqualified) {
    bnz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:528
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:528
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    ==
    bz disburseRewards_else_body@97
    // smart_contracts/pool/contract.algo.ts:529
    // return { valid: true, balance: 0 }
    pushbytes 0x800000000000000000

disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100:
    // smart_contracts/pool/contract.algo.ts:225
    // const { valid } = this.getStakeValue(id)
    intc_0 // 0
    getbit
    // smart_contracts/pool/contract.algo.ts:226
    // if (!valid) {
    bz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:230
    // if (this.gateID.value !== 0) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:230
    // if (this.gateID.value !== 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz disburseRewards_after_if_else@107
    // smart_contracts/pool/contract.algo.ts:231
    // const wallet = getWalletIDUsingAkitaDAO(Global.currentApplicationId, address.native)
    global CurrentApplicationID
    dig 40
    callsub getWalletIDUsingAkitaDAO
    dup
    bury 9
    // smart_contracts/utils/functions.ts:121
    // if (walletID.id === 0) {
    bnz disburseRewards_after_if_else@127
    dig 39

disburseRewards_after_inlined_smart_contracts/utils/functions.ts::originOr@128:
    // smart_contracts/pool/contract.algo.ts:234
    // const passes = gateCall(Global.currentApplicationId, origin, this.gateID.value, gateArgs)
    global CurrentApplicationID
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:234
    // const passes = gateCall(Global.currentApplicationId, origin, this.gateID.value, gateArgs)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    cover 2
    dig 35
    callsub gateCall
    pop
    // smart_contracts/pool/contract.algo.ts:235
    // if (!passes) {
    bnz disburseRewards_after_if_else@107
    // smart_contracts/pool/contract.algo.ts:236
    // if (this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:236
    // if (this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    !=
    bz disburseRewards_block@108
    // smart_contracts/pool/contract.algo.ts:237
    // this.entries(id).value.disqualified = true
    dig 33
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace

disburseRewards_block@108:
    // smart_contracts/pool/contract.algo.ts:218
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@92

disburseRewards_after_if_else@107:
    // smart_contracts/pool/contract.algo.ts:243
    // count += 1
    dig 24
    intc_1 // 1
    +
    bury 25
    // smart_contracts/pool/contract.algo.ts:244
    // total += quantity
    dig 8
    dig 14
    +
    bury 9
    b disburseRewards_block@108

disburseRewards_after_if_else@127:
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 7
    // smart_contracts/utils/functions.ts:145
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 30 // "controlled_address"
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:232
    // const origin = originOr(wallet, address.native)
    b disburseRewards_after_inlined_smart_contracts/utils/functions.ts::originOr@128

disburseRewards_else_body@97:
    // smart_contracts/pool/contract.algo.ts:530
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:530
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    ==
    bz disburseRewards_after_if_else@99
    // smart_contracts/pool/contract.algo.ts:531
    // const { address, asset } = this.entries(id).value
    dig 33
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    swap
    pushint 32 // 32
    intc_2 // 8
    box_extract
    // smart_contracts/pool/contract.algo.ts:533-539
    // const avg = abiCall(
    //   StakingInterface.prototype.getHeartbeatAverage,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [address, asset, true],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:536
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:536
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:533-539
    // const avg = abiCall(
    //   StakingInterface.prototype.getHeartbeatAverage,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [address, asset, true],
    //   }
    // ).returnValue
    pushbytes 0xc6fd0ca5 // method "getHeartbeatAverage(address,uint64,bool)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/pool/contract.algo.ts:537
    // args: [address, asset, true],
    bytec 22 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/pool/contract.algo.ts:533-539
    // const avg = abiCall(
    //   StakingInterface.prototype.getHeartbeatAverage,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [address, asset, true],
    //   }
    // ).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/pool/contract.algo.ts:541
    // return { valid: true, balance: avg }
    itob
    bytec 22 // 0x80
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:225
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100

disburseRewards_after_if_else@99:
    // smart_contracts/pool/contract.algo.ts:544
    // return this.checkByID(id)
    dig 16
    callsub checkByID
    // smart_contracts/pool/contract.algo.ts:225
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue@100

disburseRewards_after_while@109:
    // smart_contracts/pool/contract.algo.ts:247
    // this.rewards(rewardID).value.qualifiedStakers += count
    dig 3
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 26
    +
    itob
    dig 1
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:248
    // this.rewards(rewardID).value.qualifiedStake += total
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    dig 10
    +
    itob
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:250
    // if (this.entryID.value === disbursementCursor) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:250
    // if (this.entryID.value === disbursementCursor) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    ==
    bz disburseRewards_else_body@116
    // smart_contracts/pool/contract.algo.ts:252
    // this.rewards(rewardID).value.phase = DisbursementPhaseAllocation
    dig 3
    dup
    pushint 91 // 91
    bytec 10 // 0x14
    box_replace
    // smart_contracts/pool/contract.algo.ts:253
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_0 // 0
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:255
    // this.payAkitaRoyalty(distribution, rate, asset, this.rewards(rewardID).value.qualifiedStakers)
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 15
    // smart_contracts/pool/contract.algo.ts:180
    // if (distribution === DistributionTypeFlat) {
    dig 1
    bytec 10 // 0x14
    ==
    bz disburseRewards_else_body@112
    // smart_contracts/pool/contract.algo.ts:181
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    dig 14
    dig 13
    *
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:144
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 20 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:181
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:83
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:84
    // return op.divw(...op.mulw(a, p), DIVISOR)
    mulw
    intc 4 // 100000
    divw
    bury 28

disburseRewards_after_if_else@113:
    // smart_contracts/pool/contract.algo.ts:146
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 18 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:186
    // this.akitaRoyaltyAmount.value = amount
    dig 28
    app_global_put
    // smart_contracts/pool/contract.algo.ts:189
    // if (asset === 0) {
    dig 26
    bnz disburseRewards_else_body@115
    // smart_contracts/pool/contract.algo.ts:190-195
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:192
    // receiver: Global.zeroAddress,
    global ZeroAddress
    dig 28
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:190-194
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:190-195
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_submit

disburseRewards_after_if_else@30:
    // smart_contracts/pool/contract.algo.ts:998
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    intc_1 // 1
    return

disburseRewards_else_body@115:
    // smart_contracts/pool/contract.algo.ts:197
    // assert(Global.zeroAddress.isOptedIn(Asset(asset)), ERR_DAO_NOT_OPTED_IN)
    global ZeroAddress
    dig 27
    dup
    cover 2
    asset_holding_get AssetBalance
    bury 1
    assert // DAO not opted in to the asset
    // smart_contracts/pool/contract.algo.ts:199-205
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:201
    // assetReceiver: Global.zeroAddress,
    global ZeroAddress
    swap
    itxn_field XferAsset
    dig 28
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:199-204
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:199-205
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    b disburseRewards_after_if_else@30

disburseRewards_else_body@112:
    // smart_contracts/pool/contract.algo.ts:183
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:144
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 20 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:183
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:83
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:84
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 13
    mulw
    intc 4 // 100000
    divw
    bury 28
    b disburseRewards_after_if_else@113

disburseRewards_else_body@116:
    // smart_contracts/pool/contract.algo.ts:258
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    intc_3 // 92
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_else_body@7:
    // smart_contracts/pool/contract.algo.ts:1014
    // case DistributionTypePercentage: {
    dig 1
    bytec 5 // 0x0a
    ==
    // smart_contracts/pool/contract.algo.ts:1014-1017
    // case DistributionTypePercentage: {
    //   this.createPercentageDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@11
    // smart_contracts/pool/contract.algo.ts:269
    // } = this.rewards(rewardID).value
    dig 3
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 28
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 34
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    bury 18
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 29
    // smart_contracts/pool/contract.algo.ts:271
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:271
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@79
    // smart_contracts/pool/contract.algo.ts:272
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:272
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@79:
    // smart_contracts/pool/contract.algo.ts:275
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 18 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:275
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    dig 28
    swap
    -
    bury 31
    // smart_contracts/pool/contract.algo.ts:276
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 39
    bytec 7 // 0x0000
    bury 35
    // smart_contracts/pool/contract.algo.ts:277
    // let sum: uint64 = 0
    intc_0 // 0
    bury 11
    dig 19
    bury 17

disburseRewards_while_top@80:
    // smart_contracts/pool/contract.algo.ts:279
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@85
    // smart_contracts/pool/contract.algo.ts:280
    // const { disqualified, quantity, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:280
    // const { disqualified, quantity, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 16
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:281
    // if (disqualified) {
    bnz disburseRewards_block@84
    // smart_contracts/utils/functions.ts:88
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    dig 13
    dup
    dig 17
    dup
    cover 3
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:89
    // return op.divw(...op.mulw(a, DIVISOR), b)
    intc 4 // 100000
    mulw
    uncover 2
    divw
    // smart_contracts/utils/functions.ts:83
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:84
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 31
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/pool/contract.algo.ts:286
    // allocations.push({ address, amount: individualAmount })
    dup
    itob
    dig 41
    swap
    concat
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    // smart_contracts/pool/contract.algo.ts:287
    // sum += individualAmount
    dig 11
    +
    bury 11

disburseRewards_block@84:
    // smart_contracts/pool/contract.algo.ts:279
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@80

disburseRewards_after_while@85:
    // smart_contracts/pool/contract.algo.ts:290
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    dup
    cover 3
    +
    itob
    intc_3 // 92
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:292
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:294
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:294
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 21
    uncover 2
    +
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:295
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 12 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:296
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 40
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@11:
    // smart_contracts/pool/contract.algo.ts:1018
    // case DistributionTypeFlat: {
    dig 1
    bytec 10 // 0x14
    ==
    // smart_contracts/pool/contract.algo.ts:1018-1021
    // case DistributionTypeFlat: {
    //   this.createFlatDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:307
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    uncover 2
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 3
    bury 31
    // smart_contracts/pool/contract.algo.ts:309
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    swap
    dig 1
    *
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 18 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:309
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    -
    // smart_contracts/pool/contract.algo.ts:310
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:144
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 20 // "akita_royalty"
    // smart_contracts/pool/contract.algo.ts:310
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:83
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:84
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 2
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/pool/contract.algo.ts:311
    // const adjustedAmount: uint64 = amount - percentageAkitaFee
    uncover 2
    swap
    -
    bury 32
    // smart_contracts/pool/contract.algo.ts:312
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    uncover 2
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:314
    // assert(balance >= total, ERR_NOT_ENOUGH_FUNDS)
    <=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:316
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:316
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@67
    // smart_contracts/pool/contract.algo.ts:317
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:317
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@67:
    // smart_contracts/pool/contract.algo.ts:320
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 38
    bytec 7 // 0x0000
    bury 35
    // smart_contracts/pool/contract.algo.ts:321
    // let sum: uint64 = 0
    intc_0 // 0
    bury 11
    dig 19
    bury 17

disburseRewards_while_top@68:
    // smart_contracts/pool/contract.algo.ts:323
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@73
    // smart_contracts/pool/contract.algo.ts:324
    // const { disqualified, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:324
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:325
    // if (disqualified) {
    bnz disburseRewards_block@72
    // smart_contracts/pool/contract.algo.ts:329
    // allocations.push({ address, amount: adjustedAmount })
    dig 28
    dup
    itob
    dig 41
    swap
    concat
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    // smart_contracts/pool/contract.algo.ts:330
    // sum += adjustedAmount
    dig 11
    +
    bury 11

disburseRewards_block@72:
    // smart_contracts/pool/contract.algo.ts:323
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@68

disburseRewards_after_while@73:
    // smart_contracts/pool/contract.algo.ts:333
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 19
    dig 5
    +
    // smart_contracts/pool/contract.algo.ts:334
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:335
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:337
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:337
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:338
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 12 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:339
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 39
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:1022
    // case DistributionTypeEven: {
    dig 1
    bytec 12 // 0x1e
    ==
    // smart_contracts/pool/contract.algo.ts:1022-1025
    // case DistributionTypeEven: {
    //   this.createEvenDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@19
    // smart_contracts/pool/contract.algo.ts:350
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 17
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 30
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 14
    // smart_contracts/pool/contract.algo.ts:352
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:353
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 18 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:353
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 33
    // smart_contracts/pool/contract.algo.ts:354
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:356
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:356
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@55
    // smart_contracts/pool/contract.algo.ts:357
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:357
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@55:
    // smart_contracts/pool/contract.algo.ts:360
    // const amount: uint64 = actualSum / qualifiedStakers
    dig 29
    dig 15
    /
    bury 28
    // smart_contracts/pool/contract.algo.ts:361
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 37
    bytec 7 // 0x0000
    bury 35
    dig 19
    bury 17

disburseRewards_while_top@56:
    // smart_contracts/pool/contract.algo.ts:362
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    dig 5
    <
    bz disburseRewards_after_while@61
    // smart_contracts/pool/contract.algo.ts:363
    // const { disqualified, address } = this.entries(id).value
    dig 16
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:363
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    // smart_contracts/pool/contract.algo.ts:364
    // if (disqualified) {
    bnz disburseRewards_block@60
    // smart_contracts/pool/contract.algo.ts:368
    // allocations.push({ address, amount })
    dig 27
    itob
    dig 40
    swap
    concat
    dig 35
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 35

disburseRewards_block@60:
    // smart_contracts/pool/contract.algo.ts:362
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@56

disburseRewards_after_while@61:
    // smart_contracts/pool/contract.algo.ts:371
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 19
    dig 5
    +
    // smart_contracts/pool/contract.algo.ts:372
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:373
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 32
    dig 28
    dig 37
    dig 14
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:375
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:375
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/pool/contract.algo.ts:376
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 12 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:377
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 38
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@19:
    // smart_contracts/pool/contract.algo.ts:1026
    // case DistributionTypeShuffle: {
    dig 1
    pushbytes 0x28
    ==
    // smart_contracts/pool/contract.algo.ts:1026-1033
    // case DistributionTypeShuffle: {
    //   if (winningTickets.length === 0) {
    //     this.raffle(rewardID)
    //   } else {
    //     this.createShuffleDisbursement(rewardID, iterationAmount)
    //   }
    //   break
    // }
    assert // unknown reward rate type
    // smart_contracts/pool/contract.algo.ts:1027
    // if (winningTickets.length === 0) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    bnz disburseRewards_else_body@24
    // smart_contracts/pool/contract.algo.ts:1028
    // this.raffle(rewardID)
    dig 5
    callsub smart_contracts/pool/contract.algo.ts::Pool.raffle
    b disburseRewards_after_if_else@30

disburseRewards_else_body@24:
    // smart_contracts/pool/contract.algo.ts:390
    // } = clone(this.rewards(rewardID).value)
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 22
    dup
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    bury 9
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 30
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 14
    // smart_contracts/pool/contract.algo.ts:392
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/pool/contract.algo.ts:393
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:146
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 18 // "akita_royalty_amount"
    // smart_contracts/pool/contract.algo.ts:393
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 33
    // smart_contracts/pool/contract.algo.ts:394
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/pool/contract.algo.ts:396
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:396
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@33
    // smart_contracts/pool/contract.algo.ts:397
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:397
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    -
    bury 5

disburseRewards_after_if_else@33:
    // smart_contracts/pool/contract.algo.ts:401
    // if (winnerCount > 0) {
    dig 6
    bnz disburseRewards_if_body@34
    dig 29
    bury 28

disburseRewards_after_if_else@35:
    // smart_contracts/pool/contract.algo.ts:405
    // let { stake, ticket, disbursed } = raffleCursor
    dig 3
    dup
    pushints 59 24 // 59, 24
    box_extract
    dup
    intc_2 // 8
    extract_uint64
    dup
    cover 3
    bury 15
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    bury 14
    pushint 16 // 16
    extract_uint64
    bury 24
    // smart_contracts/pool/contract.algo.ts:406
    // let currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    intc_2 // 8
    box_extract
    btoi
    bury 23
    // smart_contracts/pool/contract.algo.ts:410
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 37
    bytec 7 // 0x0000
    bury 36
    bury 23
    dig 19
    bury 18

disburseRewards_while_top@36:
    // smart_contracts/pool/contract.algo.ts:411
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 17
    dig 5
    <
    bz disburseRewards_block@48
    // smart_contracts/pool/contract.algo.ts:412
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dig 17
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:412
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bury 20
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 41
    dup
    pushint 32 // 32
    intc_2 // 8
    box_extract
    btoi
    bury 27
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/pool/contract.algo.ts:414
    // currentRangeEnd = currentRangeStart + quantity
    dig 23
    dup
    uncover 2
    +
    bury 25
    // smart_contracts/pool/contract.algo.ts:415
    // if (currentTicket >= currentRangeStart && currentTicket <= currentRangeEnd) {
    dig 22
    <=
    bz disburseRewards_after_if_else@46
    dig 21
    dig 24
    <=
    bz disburseRewards_after_if_else@46
    // smart_contracts/pool/contract.algo.ts:416
    // if (!disqualified) {
    dig 18
    bnz disburseRewards_after_if_else@41
    // smart_contracts/pool/contract.algo.ts:417
    // allocations.push({ address, amount })
    dig 27
    itob
    dig 40
    swap
    concat
    dig 35
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 35
    // smart_contracts/pool/contract.algo.ts:418
    // disbursed++
    dig 20
    intc_1 // 1
    +
    bury 21

disburseRewards_after_if_else@41:
    // smart_contracts/pool/contract.algo.ts:421
    // if (ticket === tickets.length - 1) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    intc_1 // 1
    -
    dig 10
    ==
    bz disburseRewards_after_if_else@45
    // smart_contracts/pool/contract.algo.ts:423
    // if (winnerCount !== disbursed) {
    dig 6
    dig 21
    !=
    bz disburseRewards_block@48
    // smart_contracts/pool/contract.algo.ts:424
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 3
    dup
    intc_3 // 92
    dig 38
    box_replace
    // smart_contracts/pool/contract.algo.ts:425-429
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 31 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/pool/contract.algo.ts:430
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 7 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/pool/contract.algo.ts:431
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 26
    dig 36
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:1030
    // this.createShuffleDisbursement(rewardID, iterationAmount)
    b disburseRewards_after_if_else@30

disburseRewards_block@48:
    // smart_contracts/pool/contract.algo.ts:448
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 27
    dig 36
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/pool/contract.algo.ts:450
    // if (winnerCount === disbursed) {
    dig 6
    dig 21
    ==
    bz disburseRewards_else_body@50
    // smart_contracts/pool/contract.algo.ts:451
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 12 // 0x1e
    box_replace
    // smart_contracts/pool/contract.algo.ts:452
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    dig 38
    box_replace
    // smart_contracts/pool/contract.algo.ts:453-457
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 31 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/pool/contract.algo.ts:458
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 7 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    b disburseRewards_after_if_else@30

disburseRewards_else_body@50:
    // smart_contracts/pool/contract.algo.ts:460
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:461
    // this.rewards(rewardID).value.raffleCursor = { ticket, stake, disbursed }
    dig 10
    itob
    dig 13
    itob
    concat
    dig 22
    itob
    concat
    pushint 59 // 59
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@45:
    // smart_contracts/pool/contract.algo.ts:437
    // iterationAmount -= i
    dig 4
    dig 18
    -
    bury 5
    // smart_contracts/pool/contract.algo.ts:438
    // ticket++
    dig 9
    intc_1 // 1
    +
    dup
    bury 11
    // smart_contracts/pool/contract.algo.ts:439
    // currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    dig 4
    dup
    uncover 2
    intc_2 // 8
    box_extract
    btoi
    bury 23
    // smart_contracts/pool/contract.algo.ts:440
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 37
    box_replace
    // smart_contracts/pool/contract.algo.ts:441
    // i = 0
    intc_0 // 0
    bury 18
    // smart_contracts/pool/contract.algo.ts:442
    // stake = 0
    intc_0 // 0
    bury 12
    // smart_contracts/pool/contract.algo.ts:443
    // currentRangeEnd = 0
    intc_0 // 0
    bury 24

disburseRewards_after_if_else@46:
    // smart_contracts/pool/contract.algo.ts:445
    // currentRangeStart = currentRangeEnd + 1
    dig 23
    intc_1 // 1
    +
    bury 23
    // smart_contracts/pool/contract.algo.ts:411
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 17
    intc_1 // 1
    +
    bury 18
    b disburseRewards_while_top@36

disburseRewards_if_body@34:
    // smart_contracts/pool/contract.algo.ts:402
    // amount = actualSum / winnerCount
    dig 29
    dig 7
    /
    bury 28
    b disburseRewards_after_if_else@35

disburseRewards_bool_false@4:
    intc_0 // 0
    b disburseRewards_bool_merge@5


// smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution[routing]() -> void:
finalizeDistribution:
    // smart_contracts/pool/contract.algo.ts:1041
    // finalizeDistribution(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:1042
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/pool/contract.algo.ts:159
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 17 // "r"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1042
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    dup
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:1043
    // const { phase, activeDisbursementID } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 100 // 100
    intc_2 // 8
    box_extract
    dup
    btoi
    // smart_contracts/pool/contract.algo.ts:1044
    // assert(phase === DisbursementPhaseFinalization, ERR_DISBURSEMENT_NOT_READY_FOR_FINALIZATION)
    uncover 2
    bytec 12 // 0x1e
    ==
    assert // Disbursement not ready for finalization
    // smart_contracts/pool/contract.algo.ts:623
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:623
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:625-631
    // abiCall(
    //   RewardsInterface.prototype.finalizeDisbursement,
    //   {
    //     appId: rewardsApp,
    //     args: [disbursementID],
    //   }
    // )
    itxn_begin
    pushbytes 0x5424a591 // method "finalizeDisbursement(uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/pool/contract.algo.ts:1048
    // this.disbursements(activeDisbursementID).create()
    itob
    // smart_contracts/pool/contract.algo.ts:161
    // disbursements = BoxMap<uint64, bytes<0>>({ keyPrefix: PoolBoxPrefixDisbursements })
    pushbytes "d"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1048
    // this.disbursements(activeDisbursementID).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/pool/contract.algo.ts:1050
    // this.rewards(rewardID).value.phase = DisbursementPhaseIdle
    dup
    pushint 91 // 91
    bytec_2 // 0x00
    box_replace
    // smart_contracts/pool/contract.algo.ts:1051
    // this.rewards(rewardID).value.activeDisbursementID = 0
    intc_0 // 0
    itob
    dig 1
    pushint 100 // 100
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1052
    // this.rewards(rewardID).value.activeDisbursementRoundStart = 0
    dig 1
    pushint 108 // 108
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1053
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 1
    intc_3 // 92
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1054
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 1
    pushint 33 // 33
    dig 2
    box_replace
    // smart_contracts/pool/contract.algo.ts:1055
    // this.rewards(rewardID).value.qualifiedStake = 0
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:1041
    // finalizeDistribution(rewardID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.check[routing]() -> void:
check:
    // smart_contracts/pool/contract.algo.ts:1058
    // check(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/contract.algo.ts:1059
    // const key: EntryKey = { address, asset }
    itob
    concat
    // smart_contracts/pool/contract.algo.ts:157
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    pushbytes "a"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1060
    // const id = this.entriesByAddress(key).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/pool/contract.algo.ts:1061
    // return this.checkByID(id)
    callsub checkByID
    // smart_contracts/pool/contract.algo.ts:1058
    // check(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen[routing]() -> void:
signUpsOpen:
    // smart_contracts/pool/contract.algo.ts:1070
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1070
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    // smart_contracts/pool/contract.algo.ts:1070-1071
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/pool/contract.algo.ts:1071
    // Global.latestTimestamp > this.signupTimestamp.value &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:111
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 25 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:1071
    // Global.latestTimestamp > this.signupTimestamp.value &&
    app_global_get_ex
    assert // check GlobalState exists
    >
    // smart_contracts/pool/contract.algo.ts:1070-1071
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/pool/contract.algo.ts:1072
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 16 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1072
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    <
    bnz signUpsOpen_bool_true@5
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 21 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:1072
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    bz signUpsOpen_bool_false@6

signUpsOpen_bool_true@5:
    intc_1 // 1

signUpsOpen_bool_merge@7:
    // smart_contracts/pool/contract.algo.ts:1067
    // @abimethod({ readonly: true })
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

signUpsOpen_bool_false@6:
    intc_0 // 0
    b signUpsOpen_bool_merge@7


// smart_contracts/pool/contract.algo.ts::Pool.isLive[routing]() -> void:
isLive:
    // smart_contracts/pool/contract.algo.ts:1077
    // @abimethod({ readonly: true })
    callsub smart_contracts/pool/contract.algo.ts::Pool.isLive
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.isEntered[routing]() -> void:
isEntered:
    // smart_contracts/pool/contract.algo.ts:1087
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/pool/contract.algo.ts:155
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    pushbytes "u"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1089
    // return this.uniques(address.native).exists;
    box_len
    bury 1
    // smart_contracts/pool/contract.algo.ts:1087
    // @abimethod({ readonly: true })
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.getState[routing]() -> void:
getState:
    // smart_contracts/pool/contract.algo.ts:1095
    // status: this.status.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1095
    // status: this.status.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1096
    // title: this.title.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:107
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 23 // "title"
    // smart_contracts/pool/contract.algo.ts:1096
    // title: this.title.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1097
    // type: this.type.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:1097
    // type: this.type.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1098
    // signupTimestamp: this.signupTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:111
    // signupTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeySignupTimestamp })
    bytec 25 // "signup_timestamp"
    // smart_contracts/pool/contract.algo.ts:1098
    // signupTimestamp: this.signupTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1099
    // allowLateSignups: this.allowLateSignups.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:113
    // allowLateSignups = GlobalState<boolean>({ key: PoolGlobalStateKeyAllowLateSignups })
    bytec 21 // "allow_late_signups"
    // smart_contracts/pool/contract.algo.ts:1099
    // allowLateSignups: this.allowLateSignups.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1100
    // startTimestamp: this.startTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 16 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1100
    // startTimestamp: this.startTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1101
    // endTimestamp: this.endTimestamp.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1101
    // endTimestamp: this.endTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1102
    // maxEntries: this.maxEntries.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:1102
    // maxEntries: this.maxEntries.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1103
    // entryCount: (this.entryID.value + 1),
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:121
    // entryID = GlobalState<uint64>({ key: PoolGlobalStateKeyEntryCount })
    bytec_0 // "entry_count"
    // smart_contracts/pool/contract.algo.ts:1103
    // entryCount: (this.entryID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:1104
    // rewardCount: (this.rewardID.value + 1),
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 26 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:1104
    // rewardCount: (this.rewardID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:1105
    // totalStaked: this.totalStaked.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:125
    // totalStaked = GlobalState<uint64>({ key: PoolGlobalStateKeyTotalStaked })
    pushbytes "total_staked"
    // smart_contracts/pool/contract.algo.ts:1105
    // totalStaked: this.totalStaked.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1106
    // stakeKey: this.stakeKey.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:130
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 19 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:1106
    // stakeKey: this.stakeKey.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1107
    // minimumStakeAmount: this.minimumStakeAmount.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:132
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 24 // "minimum_stake_amount"
    // smart_contracts/pool/contract.algo.ts:1107
    // minimumStakeAmount: this.minimumStakeAmount.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1108
    // gateID: this.gateID.value,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:134
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 6 // "gate_id"
    // smart_contracts/pool/contract.algo.ts:1108
    // gateID: this.gateID.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1109
    // creator: new Address(this.creator.value),
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:1109
    // creator: new Address(this.creator.value),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:1094-1110
    // return {
    //   status: this.status.value,
    //   title: this.title.value,
    //   type: this.type.value,
    //   signupTimestamp: this.signupTimestamp.value,
    //   allowLateSignups: this.allowLateSignups.value,
    //   startTimestamp: this.startTimestamp.value,
    //   endTimestamp: this.endTimestamp.value,
    //   maxEntries: this.maxEntries.value,
    //   entryCount: (this.entryID.value + 1),
    //   rewardCount: (this.rewardID.value + 1),
    //   totalStaked: this.totalStaked.value,
    //   stakeKey: this.stakeKey.value,
    //   minimumStakeAmount: this.minimumStakeAmount.value,
    //   gateID: this.gateID.value,
    //   creator: new Address(this.creator.value),
    // }
    dig 13
    len
    itob
    extract 6 2
    uncover 14
    concat
    uncover 14
    pushbytes 0x006f
    concat
    dig 1
    len
    pushint 111 // 111
    +
    swap
    uncover 15
    concat
    uncover 14
    itob
    concat
    uncover 12
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 14
    setbit
    concat
    uncover 11
    itob
    concat
    uncover 10
    itob
    concat
    uncover 9
    itob
    concat
    uncover 8
    itob
    concat
    uncover 7
    itob
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:1092
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend[routing]() -> void:
optAkitaEscrowInAndSend:
    // smart_contracts/utils/base-contracts/escrow.ts:20
    // optAkitaEscrowInAndSend(name: string, asset: Asset, amount: uint64): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/escrow.ts:49
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/escrow.ts:51
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:51
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/escrow.ts:52
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:49
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/escrow.ts:57
    // updateAkitaDAO(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/escrow.ts:58
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:58
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:59
    // this.akitaDAO.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:57
    // updateAkitaDAO(app: uint64): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/escrow.ts:62
    // updateAkitaDAOEscrow(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/escrow.ts:63
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:63
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 27 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:64
    // this.akitaDAOEscrow.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/escrow.ts:62
    // updateAkitaDAOEscrow(app: uint64): void {
    intc_1 // 1
    return


// smart_contracts/pool/base.ts::BasePool.mbr[routing]() -> void:
mbr:
    // smart_contracts/pool/base.ts:13
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    pushbytes 0x00000000000062d400000000000049d400000000000062d4
    swap
    concat
    // smart_contracts/pool/base.ts:20
    // disbursements: PoolDisbursementSMBR
    pushint 6100 // 6100
    // smart_contracts/pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    concat
    // smart_contracts/pool/base.ts:13
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/pool/contract.algo.ts::Pool.checkByID(id: uint64) -> bytes:
checkByID:
    // smart_contracts/pool/contract.algo.ts:465
    // private checkByID(id: uint64): { valid: boolean, balance: uint64 } {
    proto 1 1
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 3
    // smart_contracts/pool/contract.algo.ts:467
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:467
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    bnz checkByID_bool_true@2
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:467
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec 5 // 0x0a
    !=
    bz checkByID_bool_false@3

checkByID_bool_true@2:
    intc_1 // 1

checkByID_bool_merge@4:
    // smart_contracts/pool/contract.algo.ts:466-469
    // assert(
    //   this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    //   ERR_INVALID_POOL_TYPE_FOR_CHECK
    // )
    assert // Invalid pool type for check
    // smart_contracts/pool/contract.algo.ts:471
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    frame_dig -1
    itob
    // smart_contracts/pool/contract.algo.ts:153
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 11 // "e"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/pool/contract.algo.ts:471
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    intc_0 // 0
    pushint 32 // 32
    box_extract
    frame_bury 0
    dig 1
    pushint 32 // 32
    intc_2 // 8
    box_extract
    dup
    frame_bury 1
    btoi
    frame_bury 3
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    frame_bury 4
    // smart_contracts/pool/contract.algo.ts:473
    // if (disqualified) {
    bz checkByID_after_if_else@6
    // smart_contracts/pool/contract.algo.ts:474
    // return { valid: false, balance: 0 }
    bytec 32 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_after_if_else@6:
    // smart_contracts/pool/contract.algo.ts:477
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:477
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 10 // 0x14
    ==
    bz checkByID_else_body@11
    // smart_contracts/pool/contract.algo.ts:478-484
    // const check = abiCall(
    //   StakingInterface.prototype.softCheck,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [address, asset],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:481
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:481
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:478-484
    // const check = abiCall(
    //   StakingInterface.prototype.softCheck,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [address, asset],
    //   }
    // ).returnValue
    pushbytes 0x48716f1a // method "softCheck(address,uint64)(bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 5 // 5
    // smart_contracts/pool/contract.algo.ts:486
    // if (check.balance >= quantity) {
    extract_uint64
    dup
    frame_bury 5
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:487
    // return { valid: true, balance: check.balance }
    frame_dig 5
    itob
    bytec 22 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:509
    // this.entries(id).value.disqualified = true
    frame_dig 2
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:510
    // return { valid: false, balance: 0 }
    bytec 32 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_else_body@11:
    // smart_contracts/pool/contract.algo.ts:490-502
    // const info = abiCall(
    //   StakingInterface.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [
    //       address,
    //       {
    //         asset: asset,
    //         type: this.stakingType(),
    //       },
    //     ],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:493
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:493
    // appId: getAkitaAppList(Global.currentApplicationId).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:498
    // type: this.stakingType(),
    callsub stakingType
    // smart_contracts/pool/contract.algo.ts:496-499
    // {
    //   asset: asset,
    //   type: this.stakingType(),
    // },
    frame_dig 3
    itob
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:490-502
    // const info = abiCall(
    //   StakingInterface.prototype.getInfo,
    //   {
    //     appId: getAkitaAppList(Global.currentApplicationId).staking,
    //     args: [
    //       address,
    //       {
    //         asset: asset,
    //         type: this.stakingType(),
    //       },
    //     ],
    //   }
    // ).returnValue
    bytec 29 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    pushint 4 // 4
    // smart_contracts/pool/contract.algo.ts:504
    // if (info.amount >= quantity) {
    extract_uint64
    dup
    frame_bury 6
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:505
    // return { valid: true, balance: info.amount }
    frame_dig 6
    itob
    bytec 22 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_bool_false@3:
    intc_0 // 0
    b checkByID_bool_merge@4


// smart_contracts/pool/contract.algo.ts::Pool.stakingType() -> bytes:
stakingType:
    // smart_contracts/pool/contract.algo.ts:523
    // assert(this.type.value !== POOL_STAKING_TYPE_NONE, 'pool staking type is not set')
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:109
    // type = GlobalState<PoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/pool/contract.algo.ts:523
    // assert(this.type.value !== POOL_STAKING_TYPE_NONE, 'pool staking type is not set')
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec_2 // 0x00
    !=
    assert // pool staking type is not set
    // smart_contracts/pool/contract.algo.ts:524
    // return new Uint8(this.type.value.native - 1)
    btoi
    intc_1 // 1
    -
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
createRewardAllocations:
    // smart_contracts/pool/contract.algo.ts:572-577
    // private createRewardAllocations(
    //   disbursementID: uint64,
    //   asset: uint64,
    //   allocations: UserAllocation[],
    //   sum: uint64
    // ): void {
    proto 4 1
    // smart_contracts/pool/contract.algo.ts:579
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_3 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:579
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:659
    // return 24_900 * allocations.length
    frame_dig -2
    intc_0 // 0
    extract_uint16
    pushint 24900 // 24900
    *
    swap
    // smart_contracts/pool/contract.algo.ts:582
    // if (asset === 0) {
    frame_dig -3
    bnz createRewardAllocations_else_body@6
    // smart_contracts/pool/contract.algo.ts:584-597
    // abiCall(
    //   RewardsInterface.prototype.createUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount + sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:590
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/pool/contract.algo.ts:591
    // amount: mbrAmount + sum,
    frame_dig 0
    frame_dig -1
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:589-592
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount + sum,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:584-597
    // abiCall(
    //   RewardsInterface.prototype.createUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount + sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    itxn_next
    // smart_contracts/pool/contract.algo.ts:593
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:584-597
    // abiCall(
    //   RewardsInterface.prototype.createUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount + sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    pushbytes 0x5656acf9 // method "createUserAllocations(pay,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

createRewardAllocations_after_if_else@10:
    frame_dig -2
    swap
    retsub

createRewardAllocations_else_body@6:
    // smart_contracts/pool/contract.algo.ts:600-618
    // abiCall(
    //   RewardsInterface.prototype.createAsaUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount,
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: rewardsApp.address,
    //         xferAsset: asset,
    //         assetAmount: sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:606
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/pool/contract.algo.ts:605-608
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:609-613
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    itxn_next
    // smart_contracts/pool/contract.algo.ts:610
    // assetReceiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/pool/contract.algo.ts:609-613
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/pool/contract.algo.ts:600-618
    // abiCall(
    //   RewardsInterface.prototype.createAsaUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount,
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: rewardsApp.address,
    //         xferAsset: asset,
    //         assetAmount: sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    itxn_next
    // smart_contracts/pool/contract.algo.ts:614
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/pool/contract.algo.ts:600-618
    // abiCall(
    //   RewardsInterface.prototype.createAsaUserAllocations,
    //   {
    //     appId: rewardsApp,
    //     args: [
    //       itxn.payment({
    //         receiver: rewardsApp.address,
    //         amount: mbrAmount,
    //       }),
    //       itxn.assetTransfer({
    //         assetReceiver: rewardsApp.address,
    //         xferAsset: asset,
    //         assetAmount: sum,
    //       }),
    //       disbursementID,
    //       allocations,
    //     ],
    //   }
    // )
    pushbytes 0x3c60dfa0 // method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b createRewardAllocations_after_if_else@10


// smart_contracts/pool/contract.algo.ts::Pool.addReward(payment: uint64, reward: bytes) -> bytes:
smart_contracts/pool/contract.algo.ts::Pool.addReward:
    // smart_contracts/pool/contract.algo.ts:763
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    proto 2 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/pool/contract.algo.ts:764
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:138
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 9 // "creator"
    // smart_contracts/pool/contract.algo.ts:764
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/pool/contract.algo.ts:765
    // assert(reward.asset === 0, ERR_NOT_ALGO)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    !
    assert // Must be an Algo asset
    // smart_contracts/pool/contract.algo.ts:641
    // this.stakeKey.value.address.native !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:130
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 19 // "stake_key"
    // smart_contracts/pool/contract.algo.ts:641
    // this.stakeKey.value.address.native !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    app_global_get_ex
    assert // check GlobalState exists
    extract 0 32
    global ZeroAddress
    !=
    bnz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@7
    frame_dig -1
    extract 8 1
    bytec 5 // 0x0a
    !=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@8

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@7:
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@9:
    // smart_contracts/pool/contract.algo.ts:640-643
    // assert(
    //   this.stakeKey.value.address.native !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    //   ERR_STAKE_KEY_REQUIRED
    // )
    assert // Stake key required
    // smart_contracts/pool/contract.algo.ts:646
    // if (reward.distribution === DistributionTypeShuffle) {
    frame_dig -1
    extract 8 1
    dup
    frame_bury 0
    pushbytes 0x28
    ==
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@15
    // smart_contracts/pool/contract.algo.ts:647
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    dup
    frame_bury 1
    >
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13
    frame_dig 1
    pushint 10 // 10
    <=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@14:
    // smart_contracts/pool/contract.algo.ts:647
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    assert // Rate must be greater than winner count

smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@15:
    // smart_contracts/pool/contract.algo.ts:651
    // if (reward.distribution === DistributionTypeEven) {
    frame_dig 0
    bytec 12 // 0x1e
    ==
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@21
    // smart_contracts/pool/contract.algo.ts:652
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:652
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@18
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:119
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 13 // "max_entries"
    // smart_contracts/pool/contract.algo.ts:652
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    <=
    bz smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@19

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_true@18:
    intc_1 // 1

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@20:
    // smart_contracts/pool/contract.algo.ts:652
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    assert // Max entries cannot be greater than rate

smart_contracts/pool/contract.algo.ts::Pool.addReward_after_if_else@21:
    // smart_contracts/pool/contract.algo.ts:655
    // assert(reward.rate > 0, ERR_RATE_MUST_BE_GREATER_THAN_ZERO)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    assert // Rate must be greater than zero
    // smart_contracts/pool/contract.algo.ts:769-778
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/pool/contract.algo.ts:772
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/pool/contract.algo.ts:769-778
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/pool/contract.algo.ts:774
    // greaterThanEq: this.rewardsMbr(reward.winnerCount)
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    // smart_contracts/pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/pool/contract.algo.ts:769-778
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    >=
    &&
    assert // Invalid payment
    // smart_contracts/pool/contract.algo.ts:173
    // const id = this.rewardID.value
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:123
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 26 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:173
    // const id = this.rewardID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/pool/contract.algo.ts:174
    // this.rewardID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/pool/contract.algo.ts:123
    // rewardID = GlobalState<uint64>({ key: PoolGlobalStateKeyRewardCount })
    bytec 26 // "reward_count"
    // smart_contracts/pool/contract.algo.ts:174
    // this.rewardID.value += 1
    swap
    app_global_put
    // smart_contracts/pool/contract.algo.ts:781
    // this.rewards(id).value = clone(reward)
    itob
    // smart_contracts/pool/contract.algo.ts:159
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 17 // "r"
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:781
    // this.rewards(id).value = clone(reward)
    dup
    box_del
    pop
    frame_dig -1
    box_put
    frame_dig -1
    frame_bury 0
    retsub

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@19:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@20

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@13:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@14

smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_false@8:
    intc_0 // 0
    b smart_contracts/pool/contract.algo.ts::Pool.addReward_bool_merge@9


// smart_contracts/pool/contract.algo.ts::Pool.raffle(rewardID: uint64) -> void:
smart_contracts/pool/contract.algo.ts::Pool.raffle:
    // smart_contracts/pool/contract.algo.ts:955
    // raffle(rewardID: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 7
    // smart_contracts/pool/contract.algo.ts:956
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    frame_dig -1
    itob
    // smart_contracts/pool/contract.algo.ts:159
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 17 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/pool/contract.algo.ts:956
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/pool/contract.algo.ts:963
    // } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 108 // 108
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    cover 4
    // smart_contracts/pool/contract.algo.ts:965
    // assert(phase === DisbursementPhaseAllocation, ERR_INVALID_DISBURSEMENT_PHASE)
    uncover 2
    bytec 10 // 0x14
    ==
    assert // Invalid disbursement phase
    // smart_contracts/pool/contract.algo.ts:966
    // assert(winningTickets.length === 0, ERR_WINNING_TICKETS_ALREADY_EXIST)
    uncover 2
    pushints 124 2 // 124, 2
    box_extract
    btoi
    !
    assert // Winning tickets already exist
    // smart_contracts/pool/contract.algo.ts:968
    // const roundToUse: uint64 = activeDisbursementRoundStart + 1 + (4 * vrfFailureCount)
    swap
    intc_1 // 1
    +
    pushint 4 // 4
    uncover 2
    *
    +
    // smart_contracts/pool/contract.algo.ts:970-976
    // const seed = abiCall(
    //   RandomnessBeacon.prototype.get,
    //   {
    //     appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //     args: [roundToUse, this.salt.value],
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/pool/contract.algo.ts:973
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:39
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/pool/contract.algo.ts:973
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    intc_0 // 0
    extract_uint64
    // smart_contracts/pool/contract.algo.ts:974
    // args: [roundToUse, this.salt.value],
    swap
    itob
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:148
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 28 // "salt"
    // smart_contracts/pool/contract.algo.ts:974
    // args: [roundToUse, this.salt.value],
    app_global_get_ex
    assert // check GlobalState exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/pool/contract.algo.ts:970-976
    // const seed = abiCall(
    //   RandomnessBeacon.prototype.get,
    //   {
    //     appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //     args: [roundToUse, this.salt.value],
    //   }
    // ).returnValue
    pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    dup
    // smart_contracts/pool/contract.algo.ts:978
    // if (seed.length === 0) {
    len
    dup
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@3
    // smart_contracts/pool/contract.algo.ts:979
    // this.rewards(rewardID).value.vrfFailureCount += 1
    frame_dig 12
    dup
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    pushint 83 // 83
    swap
    box_replace
    // smart_contracts/pool/contract.algo.ts:980
    // return
    retsub

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@3:
    // smart_contracts/pool/contract.algo.ts:984
    // const rngState = pcg64Init(seed.slice(0, 16))
    intc_0 // 0
    frame_dig 15
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig 14
    cover 2
    substring3
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:16
    // assert(seed.length === 16)
    dup
    len
    pushint 16 // 16
    ==
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:92
    // const state = __pcg32Step(0, incr)
    intc_0 // 0
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    dup
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    cover 2
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    uncover 2
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    swap
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:18-21
    // return [
    //     __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    //     __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    // ]
    swap
    itob
    swap
    itob
    concat
    frame_bury 2
    // smart_contracts/pool/contract.algo.ts:988
    // if (upperBound < MAX_UINT64) {
    frame_dig 13
    intc 10 // 18446744073709551615
    <
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_if_body@4
    frame_dig 13
    frame_bury 11

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@5:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:30
    // const result = new DynamicArray<arc4.Uint64>()
    intc_0 // 0
    itob
    frame_bury 0
    bytec 7 // 0x0000
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:42
    // if (upperBound !== 0) {
    frame_dig 11
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_else_body@14
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:43
    // assert(upperBound > 1)
    frame_dig 11
    dup
    intc_1 // 1
    >
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    intc_1 // 1
    -
    dup
    frame_bury 4
    // smart_contracts/pool/contract.algo.ts:992
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    >
    assert

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@15:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    frame_dig 4
    dup
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:53
    // const threshold: uint64 = __uint64Twos(absoluteBound) % absoluteBound
    swap
    %
    frame_bury 10
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    intc_0 // 0
    frame_bury 7
    frame_dig 2
    frame_bury 3

smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@16:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    // smart_contracts/pool/contract.algo.ts:992
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    pushint 15 // 15
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    <
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_while@22

smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@18:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    frame_dig 3
    dup
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 9
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    dup
    cover 2
    frame_bury 5
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    swap
    intc_2 // 8
    extract_uint64
    frame_bury 8
    bnz smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_false@26
    pushint 2885390081777926818 // 2885390081777926818

smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_merge@27:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    frame_dig 8
    dup
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:12
    // return [[newState1, newState2], op.shl(__pcg32Output(state[0]), 32) | __pcg32Output(state[1])]
    frame_dig 5
    itob
    swap
    itob
    concat
    frame_dig 9
    callsub __pcg32Output
    pushint 32 // 32
    shl
    uncover 2
    callsub __pcg32Output
    |
    itob
    concat
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:57
    // const [newState, candidate] = __pcg64UnboundedRandom(state)
    dup
    extract 0 16
    swap
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 6
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:59
    // if (candidate >= threshold) {
    frame_dig 10
    >=
    bz smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@20
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    frame_dig 6
    frame_dig 4
    %
    // smart_contracts/pool/contract.algo.ts:992
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    +
    itob
    frame_dig 1
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    frame_bury 3
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@16

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@20:
    frame_bury 3
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_while_top@18

smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_false@26:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    intc 8 // 1442695040888963409
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_ternary_merge@27

smart_contracts/pool/contract.algo.ts::Pool.raffle_after_while@22:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:67
    // return [state, result]
    frame_dig 3
    pushbytes 0x0012
    concat
    frame_dig 1
    concat
    // smart_contracts/pool/contract.algo.ts:994
    // this.rewards(rewardID).value.winningTickets = decodeArc4<uint64[]>(rngResult[1].bytes)
    dup
    pushint 16 // 16
    extract_uint16
    dig 1
    len
    substring3
    frame_dig 12
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    dig 1
    swap
    box_put
    // smart_contracts/pool/contract.algo.ts:995
    // this.rewards(rewardID).value.vrfFailureCount = 0
    pushint 83 // 83
    frame_dig 0
    box_replace
    retsub

smart_contracts/pool/contract.algo.ts::Pool.raffle_else_body@14:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:50
    // absoluteBound = op.btoi(Bytes(BigUint(2 ** 64) - BigUint(lowerBound)))
    intc 10 // 18446744073709551615
    frame_bury 4
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@15

smart_contracts/pool/contract.algo.ts::Pool.raffle_if_body@4:
    // smart_contracts/pool/contract.algo.ts:989
    // upperBound += 1
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 11
    b smart_contracts/pool/contract.algo.ts::Pool.raffle_after_if_else@5


// smart_contracts/pool/contract.algo.ts::Pool.isLive() -> uint64:
smart_contracts/pool/contract.algo.ts::Pool.isLive:
    // smart_contracts/pool/contract.algo.ts:1080
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:105
    // status = GlobalState<PoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 8 // "status"
    // smart_contracts/pool/contract.algo.ts:1080
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // 0x00
    !=
    // smart_contracts/pool/contract.algo.ts:1080-1081
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:1081
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:115
    // startTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyStartTimestamp })
    bytec 16 // "start_timestamp"
    // smart_contracts/pool/contract.algo.ts:1081
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    app_global_get_ex
    assert // check GlobalState exists
    >=
    // smart_contracts/pool/contract.algo.ts:1080-1081
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5
    // smart_contracts/pool/contract.algo.ts:1082
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1082
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    <=
    bnz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_true@4
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:117
    // endTimestamp = GlobalState<uint64>({ key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/pool/contract.algo.ts:1082
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    bnz smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5

smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_true@4:
    intc_1 // 1
    // smart_contracts/pool/contract.algo.ts:1079-1083
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub

smart_contracts/pool/contract.algo.ts::Pool.isLive_bool_false@5:
    intc_0 // 0
    // smart_contracts/pool/contract.algo.ts:1079-1083
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub


// smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend(name: bytes, asset: uint64, amount: uint64) -> void:
smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend:
    // smart_contracts/utils/base-contracts/escrow.ts:20
    // optAkitaEscrowInAndSend(name: string, asset: Asset, amount: uint64): void {
    proto 3 0
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    itxn_begin
    // smart_contracts/utils/base-contracts/escrow.ts:27
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 27 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:27
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/base-contracts/escrow.ts:28
    // amount: (Global.assetOptInMinBalance * 4),
    global AssetOptInMinBalance
    pushint 4 // 4
    *
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/base-contracts/escrow.ts:26-29
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: (Global.assetOptInMinBalance * 4),
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    itxn_next
    // smart_contracts/utils/base-contracts/escrow.ts:24
    // appId: this.akitaDAO.value,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 14 // "akita_dao"
    // smart_contracts/utils/base-contracts/escrow.ts:24
    // appId: this.akitaDAO.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/escrow.ts:30
    // name,
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    // smart_contracts/utils/base-contracts/escrow.ts:31
    // asset.id
    frame_dig -2
    itob
    // smart_contracts/utils/base-contracts/escrow.ts:21-34
    // abiCall(
    //   AkitaDAOInterface.prototype.optinReceiveEscrow,
    //   {
    //     appId: this.akitaDAO.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.akitaDAOEscrow.value.address,
    //         amount: (Global.assetOptInMinBalance * 4),
    //       }),
    //       name,
    //       asset.id
    //     ],
    //   },
    // )
    pushbytes 0x3cc3d0a4 // method "optinReceiveEscrow(pay,string,uint64)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/utils/base-contracts/escrow.ts:36
    // if (amount > 0) {
    frame_dig -1
    bz smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend_after_if_else@5
    // smart_contracts/utils/base-contracts/escrow.ts:37-43
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/escrow.ts:39
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/escrow.ts:16
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 27 // "akita_escrow"
    // smart_contracts/utils/base-contracts/escrow.ts:39
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/escrow.ts:37-42
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/escrow.ts:37-43
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit

smart_contracts/utils/base-contracts/escrow.ts::AkitaBaseEscrow.optAkitaEscrowInAndSend_after_if_else@5:
    retsub
