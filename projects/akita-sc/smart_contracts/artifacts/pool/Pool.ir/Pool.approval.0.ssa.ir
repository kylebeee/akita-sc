main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        let reinterpret_bool%0#0: bool = (txn ApplicationID)
        goto reinterpret_bool%0#0 ? block@2 : block@1
    block@1: // if_body_L1
        polytype/lib/polytype-module.d.ts::ClusteredContract<smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract,smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn,smart_contracts/pool/base.ts::BasePool>.constructor()
        goto block@2
    block@2: // after_if_else_L1
        let tmp%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__()
        return tmp%0#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__uint64Twos(value: uint64) -> uint64:
    block@0: // L7
        let tmp%0#0: uint64 = (~ value#0)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64) = (addw tmp%0#0 1u)
        let _#0: uint64 = tuple_assignment%0#0
        let addLow#0: uint64 = tuple_assignment%1#0
        return addLow#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__maskToUint32(value: uint64) -> uint64:
    block@0: // L12
        let tmp%0#0: uint64 = (shl 1u 32u)
        let tmp%1#0: uint64 = (- tmp%0#0 1u)
        let tmp%2#0: uint64 = (& value#0 tmp%1#0)
        return tmp%2#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Step(state: uint64, incr: uint64) -> uint64:
    block@0: // L16
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64) = (mulw state#0 6364136223846793005u)
        let _#0: uint64 = tuple_assignment%0#0
        let mulLow#0: uint64 = tuple_assignment%1#0
        let (tuple_assignment%2#0: uint64, tuple_assignment%3#0: uint64) = (addw mulLow#0 incr#0)
        let _₁#0: uint64 = tuple_assignment%2#0
        let addLow#0: uint64 = tuple_assignment%3#0
        return addLow#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
    block@0: // L23
        let tmp%0#0: uint64 = (shr state#0 18u)
        let tmp%1#0: uint64 = (^ tmp%0#0 state#0)
        let tmp%2#0: uint64 = (shr tmp%1#0 27u)
        let xorshifted#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__maskToUint32(tmp%2#0)
        let rot#0: uint64 = (shr state#0 59u)
        let tmp%3#0: uint64 = (shr xorshifted#0 rot#0)
        let tmp%4#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__uint64Twos(rot#0)
        let tmp%5#0: uint64 = (& tmp%4#0 31u)
        let tmp%6#0: uint64 = (shl xorshifted#0 tmp%5#0)
        let tmp%7#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__maskToUint32(tmp%6#0)
        let tmp%8#0: uint64 = (| tmp%3#0 tmp%7#0)
        return tmp%8#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Init(initialState: uint64, incr: uint64) -> uint64:
    block@0: // L91
        let state#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Step(0u, incr#0)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64) = (addw state#0 initialState#0)
        let _#0: uint64 = tuple_assignment%0#0
        let addLow#0: uint64 = tuple_assignment%1#0
        let tmp%0#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Step(addLow#0, incr#0)
        return tmp%0#0

subroutine smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::__pcg64UnboundedRandom(state.0: uint64, state.1: uint64) -> <uint64, uint64, uint64>:
    block@0: // L8
        let newState1#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Step(state.0#0, 1442695040888963407u)
        let tmp%0#0: bool = (== newState1#0 0u)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // ternary_true_L10
        let ternary_result%0#0: uint64 = (shl 1442695040888963409u 1u)
        goto block@3
    block@2: // ternary_false_L10
        let ternary_result%0#1: uint64 = 1442695040888963409u
        goto block@3
    block@3: // ternary_merge_L10
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let newState2#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Step(state.1#0, ternary_result%0#2)
        let tmp%1#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state.0#0)
        let tmp%2#0: uint64 = (shl tmp%1#0 32u)
        let tmp%3#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state.1#0)
        let tmp%4#0: uint64 = (| tmp%2#0 tmp%3#0)
        return newState1#0 newState2#0 tmp%4#0

subroutine smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::pcg64Init(seed: bytes) -> <uint64, uint64>:
    block@0: // L15
        let tmp%0#0: uint64 = (len seed#0)
        let tmp%1#0: bool = (== tmp%0#0 16u)
        (assert tmp%1#0)
        let tmp%2#0: uint64 = (extract_uint64 seed#0 0u)
        let tmp%3#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Init(tmp%2#0, 1442695040888963407u)
        let tmp%4#0: uint64 = (extract_uint64 seed#0 8u)
        let tmp%5#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Init(tmp%4#0, 1442695040888963409u)
        return tmp%3#0 tmp%5#0

subroutine smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::pcg64Random(state.0: uint64, state.1: uint64, lowerBound: uint64, upperBound: uint64, length: uint64) -> <uint64, uint64, bytes>:
    block@0: // L24
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let result#0: bytes = array_data%0#0
        let tmp%0#0: bool = (== lowerBound#0 0u)
        goto tmp%0#0 ? block@1 : block@6
    block@1: // and_contd_L34
        let tmp%1#0: bool = (== upperBound#0 0u)
        goto tmp%1#0 ? block@2 : block@6
    block@2: // if_body_L34
        let i#0: uint64 = 0u
        goto block@3
    block@3: // while_top_L35
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@4)
        let state.0#1: uint64 = φ(state.0#0 <- block@2, state.0#2 <- block@4)
        let state.1#1: uint64 = φ(state.1#0 <- block@2, state.1#2 <- block@4)
        let result#1: bytes = φ(result#0 <- block@2, result#2 <- block@4)
        let tmp%2#0: bool = (< i#1 length#0)
        goto tmp%2#0 ? block@4 : block@5
    block@4: // while_body_L35
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64, tuple_assignment%2#0: uint64) = smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::__pcg64UnboundedRandom(state.0#1, state.1#1)
        let (newState.0#0: uint64, newState.1#0: uint64) = (tuple_assignment%0#0, tuple_assignment%1#0)
        let n#0: uint64 = tuple_assignment%2#0
        let (state.0#2: uint64, state.1#2: uint64) = (newState.0#0, newState.1#0)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) result#1)
        let val_as_bytes%0#0: bytes[8] = (itob n#0)
        let encoded%0#0: bytes[8][] = encode<bytes[8]>(val_as_bytes%0#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let result#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@3
    block@5: // after_while_L35
        goto block@19
    block@6: // else_body_L41
        let tmp%3#0: bool = (!= upperBound#0 0u)
        goto tmp%3#0 ? block@7 : block@8
    block@7: // if_body_L42
        let tmp%4#0: bool = (> upperBound#0 1u)
        (assert tmp%4#0)
        let tmp%5#0: uint64 = (- upperBound#0 1u)
        let tmp%6#0: bool = (< lowerBound#0 tmp%5#0)
        (assert tmp%6#0)
        let absoluteBound#0: uint64 = (- upperBound#0 lowerBound#0)
        goto block@9
    block@8: // else_body_L47
        let tmp%7#0: bool = (< lowerBound#0 18446744073709551615u)
        (assert tmp%7#0)
        let reinterpret_biguint%0#0: biguint = (itob lowerBound#0)
        let tmp%8#0: biguint = (b- 18446744073709551616b reinterpret_biguint%0#0)
        let absoluteBound#1: uint64 = (btoi tmp%8#0)
        goto block@9
    block@9: // after_if_else_L42
        let absoluteBound#2: uint64 = φ(absoluteBound#0 <- block@7, absoluteBound#1 <- block@8)
        let tmp%9#0: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__uint64Twos(absoluteBound#2)
        let threshold#0: uint64 = (% tmp%9#0 absoluteBound#2)
        let i₁#0: uint64 = 0u
        goto block@10
    block@10: // while_top_L55
        let i₁#1: uint64 = φ(i₁#0 <- block@9, i₁#3 <- block@17)
        let state.0#5: uint64 = φ(state.0#0 <- block@9, state.0#8 <- block@17)
        let state.1#5: uint64 = φ(state.1#0 <- block@9, state.1#8 <- block@17)
        let result#5: bytes = φ(result#0 <- block@9, result#8 <- block@17)
        let tmp%10#0: bool = (< i₁#1 length#0)
        goto tmp%10#0 ? block@11 : block@18
    block@11: // while_body_L55
        goto block@12
    block@12: // while_top_L56
        let state.0#3: uint64 = φ(state.0#5 <- block@11, state.0#4 <- block@15)
        let state.1#3: uint64 = φ(state.1#5 <- block@11, state.1#4 <- block@15)
        goto 1u ? block@13 : block@16
    block@13: // while_body_L56
        let (tuple_assignment%3#0: uint64, tuple_assignment%4#0: uint64, tuple_assignment%5#0: uint64) = smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::__pcg64UnboundedRandom(state.0#3, state.1#3)
        let (newState₁.0#0: uint64, newState₁.1#0: uint64) = (tuple_assignment%3#0, tuple_assignment%4#0)
        let candidate#0: uint64 = tuple_assignment%5#0
        let (state.0#4: uint64, state.1#4: uint64) = (newState₁.0#0, newState₁.1#0)
        let tmp%11#0: bool = (>= candidate#0 threshold#0)
        goto tmp%11#0 ? block@14 : block@15
    block@14: // if_body_L59
        let expr_value_trimmed%1#0: bytes = ((extract 2 0) result#5)
        let tmp%12#0: uint64 = (% candidate#0 absoluteBound#2)
        let to_encode%0#0: uint64 = (+ tmp%12#0 lowerBound#0)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%0#0)
        let encoded%1#0: bytes[8][] = encode<bytes[8]>(val_as_bytes%1#0)
        let concatenated%1#0: bytes = (concat expr_value_trimmed%1#0 encoded%1#0)
        let byte_len%1#0: uint64 = (len concatenated%1#0)
        let len_%1#0: uint64 = (/ byte_len%1#0 8u)
        let as_bytes%1#0: bytes[8] = (itob len_%1#0)
        let len_16_bit%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let concat_result%1#0: bytes = (concat len_16_bit%1#0 concatenated%1#0)
        let result#4: bytes = concat_result%1#0
        goto block@17
    block@15: // after_if_else_L59
        goto block@12
    block@16: // after_while_L56
        goto block@17
    block@17: // L56
        let state.0#8: uint64 = φ(state.0#4 <- block@14, state.0#3 <- block@16)
        let state.1#8: uint64 = φ(state.1#4 <- block@14, state.1#3 <- block@16)
        let result#8: bytes = φ(result#4 <- block@14, result#5 <- block@16)
        let i₁#3: uint64 = (+ i₁#1 1u)
        goto block@10
    block@18: // after_while_L55
        goto block@19
    block@19: // after_if_else_L34
        let state.0#9: uint64 = φ(state.0#1 <- block@5, state.0#5 <- block@18)
        let state.1#9: uint64 = φ(state.1#1 <- block@5, state.1#5 <- block@18)
        let result#9: bytes = φ(result#1 <- block@5, result#5 <- block@18)
        let copy%0#0: bytes = result#9
        return state.0#9 state.1#9 copy%0#0

subroutine smart_contracts/utils/functions.ts::getAkitaAppList(akitaDAO: uint64) -> <uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64>:
    block@0: // L24
        let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let appListBytes#0: bytes = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let reinterpret_bytes[96]%0#0: bytes[96] = appListBytes#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 24u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 32u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item5%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 40u 8u) // on error: Index access is out of bounds
        let item5%1#0: uint64 = (btoi item5%0#0)
        let item6%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 48u 8u) // on error: Index access is out of bounds
        let item6%1#0: uint64 = (btoi item6%0#0)
        let item7%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 56u 8u) // on error: Index access is out of bounds
        let item7%1#0: uint64 = (btoi item7%0#0)
        let item8%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 64u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let item9%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 72u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let item10%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 80u 8u) // on error: Index access is out of bounds
        let item10%1#0: uint64 = (btoi item10%0#0)
        let item11%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 88u 8u) // on error: Index access is out of bounds
        let item11%1#0: uint64 = (btoi item11%0#0)
        return item0%1#0 item1%1#0 item2%1#0 item3%1#0 item4%1#0 item5%1#0 item6%1#0 item7%1#0 item8%1#0 item9%1#0 item10%1#0 item11%1#0

subroutine smart_contracts/utils/functions.ts::getOtherAppList(akitaDAO: uint64) -> <uint64, uint64, uint64>:
    block@0: // L34
        let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: bool) = (app_global_get_ex akitaDAO#0 "other_al")
        let otherAppListBytes#0: bytes = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let reinterpret_bytes[24]%0#0: bytes[24] = otherAppListBytes#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[24]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[24]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 reinterpret_bytes[24]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        return item0%1#0 item1%1#0 item2%1#0

subroutine smart_contracts/utils/functions.ts::calcPercent(a: uint64, p: uint64) -> uint64:
    block@0: // L69
        let tmp%0#0: bool = (<= p#0 100000u)
        (assert tmp%0#0) // Invalid percentage
        let (tmp%1#0: uint64, tmp%2#0: uint64) = (mulw a#0 p#0)
        let (tmp%3#0: uint64, tmp%4#0: uint64) = (mulw a#0 p#0)
        let tmp%5#0: uint64 = (divw tmp%1#0 tmp%4#0 100000u)
        return tmp%5#0

subroutine smart_contracts/utils/functions.ts::percentageOf(a: uint64, b: uint64) -> uint64:
    block@0: // L74
        let tmp%0#0: bool = (< a#0 b#0)
        (assert tmp%0#0) // Invalid percentage of args
        let (tmp%1#0: uint64, tmp%2#0: uint64) = (mulw a#0 100000u)
        let (tmp%3#0: uint64, tmp%4#0: uint64) = (mulw a#0 100000u)
        let tmp%5#0: uint64 = (divw tmp%1#0 tmp%4#0 b#0)
        return tmp%5#0

subroutine smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes[32], id: uint64, args: bytes[]) -> bool:
    block@0: // L130
        let tmp%0#0: bool = (== id#0 0u)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // if_body_L131
        return 1u
    block@2: // after_if_else_L131
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (tmp%1#0: uint64, tmp%2#0: uint64, tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64, tmp%12#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(akitaDAO#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%6#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob id#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "check(address,uint64,byte[][])bool"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = caller#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_3#0: bytes[] = args#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 4u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_3#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@3
    block@3: // next_txn_L135
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%13#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%14#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%15#0: bool = (== tmp%14#0 0x151f7c75)
        (assert tmp%15#0) // Bytes has valid prefix
        let reinterpret_bytes[1]%0#0: bytes[1] = tmp%13#0
        let tmp%16#0: bool = (getbit reinterpret_bytes[1]%0#0 0u)
        return tmp%16#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__() -> bool:
    block@0: // L99
        let tmp%0#0: uint64 = (txn NumAppArgs)
        let tmp%1#0: bool = (!= tmp%0#0 0u)
        goto tmp%1#0 ? block@1 : block@22
    block@1: // abi_routing_L99
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "create(string,uint8,(uint64,uint8,uint64,uint64,uint64),address,address,(address,string),uint64,uint64,uint64,uint64)void" => block@2, method "init()void" => block@3, method "deleteApplication(address)void" => block@4, method "finalize(uint64,uint64,uint64)void" => block@5, method "enter(pay,(uint64,uint64,byte[32][])[],byte[][])void" => block@6, method "withdraw()void" => block@7, method "startDisbursement()void" => block@8, method "raffle()void" => block@9, method "disburseRewards(uint64)void" => block@10, method "finalizeDistribution()void" => block@11, method "check(address,uint64)(bool,uint64)" => block@12, method "signUpsOpen()bool" => block@13, method "isLive()bool" => block@14, method "getState()(uint8,string,uint8,(uint64,uint8,uint64,uint64,uint64),uint64,uint64,bool,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)" => block@15, method "update(string)void" => block@16, method "updateAkitaDAO(uint64)void" => block@17, method "optin(pay,uint64)void" => block@18, method "mbr()(uint64,uint64,uint64)" => block@19, * => block@20}
    block@2: // create_route_L583
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (== tmp%3#0 NoOp)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (== tmp%5#0 0u)
        (assert tmp%6#0) // can only call when creating
        let tmp%7#0: bytes = (txna ApplicationArgs 1)
        let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        let reinterpret_bytes[33]%0#0: bytes[33] = (txna ApplicationArgs 3)
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 4)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 5)
        let tmp%9#0: bytes = (txna ApplicationArgs 6)
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%10#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 8)
        let tmp%11#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 9)
        let tmp%12#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 10)
        let tmp%13#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        smart_contracts/pool/contract.algo.ts::Pool.create(tmp%8#0, reinterpret_bytes[1]%0#0, reinterpret_bytes[33]%0#0, reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0, tmp%9#0, tmp%10#0, tmp%11#0, tmp%12#0, tmp%13#0)
        return 1u
    block@3: // init_route_L643
        let tmp%14#0: uint64 = (txn OnCompletion)
        let tmp%15#0: bool = (== tmp%14#0 NoOp)
        (assert tmp%15#0) // OnCompletion is not NoOp
        let tmp%16#0: uint64 = (txn ApplicationID)
        let tmp%17#0: bool = (!= tmp%16#0 0u)
        (assert tmp%17#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.init()
        return 1u
    block@4: // deleteApplication_route_L655
        let tmp%18#0: uint64 = (txn OnCompletion)
        let tmp%19#0: bool = (== tmp%18#0 DeleteApplication)
        (assert tmp%19#0) // OnCompletion is not DeleteApplication
        let tmp%20#0: uint64 = (txn ApplicationID)
        let tmp%21#0: bool = (!= tmp%20#0 0u)
        (assert tmp%21#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        smart_contracts/pool/contract.algo.ts::Pool.deleteApplication(reinterpret_bytes[32]%2#0)
        return 1u
    block@5: // finalize_route_L664
        let tmp%22#0: uint64 = (txn OnCompletion)
        let tmp%23#0: bool = (== tmp%22#0 NoOp)
        (assert tmp%23#0) // OnCompletion is not NoOp
        let tmp%24#0: uint64 = (txn ApplicationID)
        let tmp%25#0: bool = (!= tmp%24#0 0u)
        (assert tmp%25#0) // can only call when not creating
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%26#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%27#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%28#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        smart_contracts/pool/contract.algo.ts::Pool.finalize(tmp%26#0, tmp%27#0, tmp%28#0)
        return 1u
    block@6: // enter_route_L694
        let tmp%29#0: uint64 = (txn OnCompletion)
        let tmp%30#0: bool = (== tmp%29#0 NoOp)
        (assert tmp%30#0) // OnCompletion is not NoOp
        let tmp%31#0: uint64 = (txn ApplicationID)
        let tmp%32#0: bool = (!= tmp%31#0 0u)
        (assert tmp%32#0) // can only call when not creating
        let tmp%33#0: uint64 = (txn GroupIndex)
        let gtxn_idx%0#0: uint64 = (- tmp%33#0 1u)
        let gtxn_type%0#0: uint64 = ((gtxns TypeEnum) gtxn_idx%0#0)
        let gtxn_type_matches%0#0: bool = (== gtxn_type%0#0 pay)
        (assert gtxn_type_matches%0#0) // transaction type is pay
        let reinterpret_(encoded_uint64,encoded_uint64,bytes[32][])[]%0#0: (encoded_uint64,encoded_uint64,bytes[32][])[] = (txna ApplicationArgs 1)
        let reinterpret_bytes[]%0#0: bytes[] = (txna ApplicationArgs 2)
        smart_contracts/pool/contract.algo.ts::Pool.enter(gtxn_idx%0#0, reinterpret_(encoded_uint64,encoded_uint64,bytes[32][])[]%0#0, reinterpret_bytes[]%0#0)
        return 1u
    block@7: // withdraw_route_L774
        let tmp%34#0: uint64 = (txn OnCompletion)
        let tmp%35#0: bool = (== tmp%34#0 NoOp)
        (assert tmp%35#0) // OnCompletion is not NoOp
        let tmp%36#0: uint64 = (txn ApplicationID)
        let tmp%37#0: bool = (!= tmp%36#0 0u)
        (assert tmp%37#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.withdraw()
        return 1u
    block@8: // startDisbursement_route_L776
        let tmp%38#0: uint64 = (txn OnCompletion)
        let tmp%39#0: bool = (== tmp%38#0 NoOp)
        (assert tmp%39#0) // OnCompletion is not NoOp
        let tmp%40#0: uint64 = (txn ApplicationID)
        let tmp%41#0: bool = (!= tmp%40#0 0u)
        (assert tmp%41#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.startDisbursement()
        return 1u
    block@9: // raffle_route_L797
        let tmp%42#0: uint64 = (txn OnCompletion)
        let tmp%43#0: bool = (== tmp%42#0 NoOp)
        (assert tmp%43#0) // OnCompletion is not NoOp
        let tmp%44#0: uint64 = (txn ApplicationID)
        let tmp%45#0: bool = (!= tmp%44#0 0u)
        (assert tmp%45#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.raffle()
        return 1u
    block@10: // disburseRewards_route_L831
        let tmp%46#0: uint64 = (txn OnCompletion)
        let tmp%47#0: bool = (== tmp%46#0 NoOp)
        (assert tmp%47#0) // OnCompletion is not NoOp
        let tmp%48#0: uint64 = (txn ApplicationID)
        let tmp%49#0: bool = (!= tmp%48#0 0u)
        (assert tmp%49#0) // can only call when not creating
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%50#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        smart_contracts/pool/contract.algo.ts::Pool.disburseRewards(tmp%50#0)
        return 1u
    block@11: // finalizeDistribution_route_L862
        let tmp%51#0: uint64 = (txn OnCompletion)
        let tmp%52#0: bool = (== tmp%51#0 NoOp)
        (assert tmp%52#0) // OnCompletion is not NoOp
        let tmp%53#0: uint64 = (txn ApplicationID)
        let tmp%54#0: bool = (!= tmp%53#0 0u)
        (assert tmp%54#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution()
        return 1u
    block@12: // check_route_L877
        let tmp%55#0: uint64 = (txn OnCompletion)
        let tmp%56#0: bool = (== tmp%55#0 NoOp)
        (assert tmp%56#0) // OnCompletion is not NoOp
        let tmp%57#0: uint64 = (txn ApplicationID)
        let tmp%58#0: bool = (!= tmp%57#0 0u)
        (assert tmp%58#0) // can only call when not creating
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%59#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let (elements_to_encode%0#0: bool, elements_to_encode%1#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.check(reinterpret_bytes[32]%3#0, tmp%59#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u elements_to_encode%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob elements_to_encode%1#0)
        let current_tail_offset%0#0: uint64 = 9u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 encoded_bool%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let tmp%60#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%2#0)
        (log tmp%60#0)
        return 1u
    block@13: // signUpsOpen_route_L886
        let tmp%61#0: uint64 = (txn OnCompletion)
        let tmp%62#0: bool = (== tmp%61#0 NoOp)
        (assert tmp%62#0) // OnCompletion is not NoOp
        let tmp%63#0: uint64 = (txn ApplicationID)
        let tmp%64#0: bool = (!= tmp%63#0 0u)
        (assert tmp%64#0) // can only call when not creating
        let to_encode%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen()
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%65#0: bytes = (concat 0x151f7c75 encoded_bool%1#0)
        (log tmp%65#0)
        return 1u
    block@14: // isLive_route_L896
        let tmp%66#0: uint64 = (txn OnCompletion)
        let tmp%67#0: bool = (== tmp%66#0 NoOp)
        (assert tmp%67#0) // OnCompletion is not NoOp
        let tmp%68#0: uint64 = (txn ApplicationID)
        let tmp%69#0: bool = (!= tmp%68#0 0u)
        (assert tmp%69#0) // can only call when not creating
        let to_encode%1#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u to_encode%1#0)
        let tmp%70#0: bytes = (concat 0x151f7c75 encoded_bool%2#0)
        (log tmp%70#0)
        return 1u
    block@15: // getState_route_L905
        let tmp%71#0: uint64 = (txn OnCompletion)
        let tmp%72#0: bool = (== tmp%71#0 NoOp)
        (assert tmp%72#0) // OnCompletion is not NoOp
        let tmp%73#0: uint64 = (txn ApplicationID)
        let tmp%74#0: bool = (!= tmp%73#0 0u)
        (assert tmp%74#0) // can only call when not creating
        let (elements_to_encode%2#0: bytes[1], elements_to_encode%3#0: bytes, elements_to_encode%4#0: bytes[1], elements_to_encode%5#0: uint64, elements_to_encode%6#0: bytes[1], elements_to_encode%7#0: uint64, elements_to_encode%8#0: uint64, elements_to_encode%9#0: uint64, elements_to_encode%10#0: uint64, elements_to_encode%11#0: uint64, elements_to_encode%12#0: bool, elements_to_encode%13#0: uint64, elements_to_encode%14#0: uint64, elements_to_encode%15#0: uint64, elements_to_encode%16#0: uint64, elements_to_encode%17#0: bytes[32], elements_to_encode%18#0: bytes, elements_to_encode%19#0: uint64, elements_to_encode%20#0: uint64, elements_to_encode%21#0: bytes[32]) = smart_contracts/pool/contract.algo.ts::Pool.getState()
        let length%0#0: uint64 = (len elements_to_encode%3#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 elements_to_encode%3#0)
        let val_as_bytes%1#0: bytes[8] = (itob elements_to_encode%5#0)
        let val_as_bytes%2#0: bytes[8] = (itob elements_to_encode%7#0)
        let val_as_bytes%3#0: bytes[8] = (itob elements_to_encode%8#0)
        let val_as_bytes%4#0: bytes[8] = (itob elements_to_encode%9#0)
        let current_tail_offset%1#0: uint64 = 33u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 elements_to_encode%6#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%4#0)
        let val_as_bytes%5#0: bytes[8] = (itob elements_to_encode%10#0)
        let val_as_bytes%6#0: bytes[8] = (itob elements_to_encode%11#0)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u elements_to_encode%12#0)
        let val_as_bytes%7#0: bytes[8] = (itob elements_to_encode%13#0)
        let val_as_bytes%8#0: bytes[8] = (itob elements_to_encode%14#0)
        let val_as_bytes%9#0: bytes[8] = (itob elements_to_encode%15#0)
        let val_as_bytes%10#0: bytes[8] = (itob elements_to_encode%16#0)
        let length%1#0: uint64 = (len elements_to_encode%18#0)
        let as_bytes%1#0: bytes[8] = (itob length%1#0)
        let length_uint16%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_value%1#0: bytes = (concat length_uint16%1#0 elements_to_encode%18#0)
        let current_tail_offset%2#0: uint64 = 34u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 elements_to_encode%17#0)
        let as_bytes%2#0: bytes[8] = (itob current_tail_offset%2#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%2#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len encoded_value%1#0)
        let current_tail_offset%3#0: uint64 = (+ current_tail_offset%2#0 data_length%0#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 encoded_value%1#0)
        let val_as_bytes%11#0: bytes[8] = (itob elements_to_encode%19#0)
        let val_as_bytes%12#0: bytes[8] = (itob elements_to_encode%20#0)
        let current_tail_offset%4#0: uint64 = 136u
        let encoded_tuple_buffer%13#0: bytes[0] = 0x
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 elements_to_encode%2#0)
        let as_bytes%3#0: bytes[8] = (itob current_tail_offset%4#0)
        let offset_as_uint16%1#0: bytes = ((extract 6 2) as_bytes%3#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 offset_as_uint16%1#0)
        let data_length%1#0: uint64 = (len encoded_value%0#0)
        let current_tail_offset%5#0: uint64 = (+ current_tail_offset%4#0 data_length%1#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 elements_to_encode%4#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 encoded_tuple_buffer%8#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%20#0: bytes = (concat encoded_tuple_buffer%19#0 encoded_bool%3#0)
        let encoded_tuple_buffer%21#0: bytes = (concat encoded_tuple_buffer%20#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%22#0: bytes = (concat encoded_tuple_buffer%21#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%23#0: bytes = (concat encoded_tuple_buffer%22#0 val_as_bytes%9#0)
        let encoded_tuple_buffer%24#0: bytes = (concat encoded_tuple_buffer%23#0 val_as_bytes%10#0)
        let as_bytes%4#0: bytes[8] = (itob current_tail_offset%5#0)
        let offset_as_uint16%2#0: bytes = ((extract 6 2) as_bytes%4#0)
        let encoded_tuple_buffer%25#0: bytes = (concat encoded_tuple_buffer%24#0 offset_as_uint16%2#0)
        let data_length%2#0: uint64 = (len encoded_tuple_buffer%12#0)
        let current_tail_offset%6#0: uint64 = (+ current_tail_offset%5#0 data_length%2#0)
        let encoded_tuple_buffer%26#0: bytes = (concat encoded_tuple_buffer%25#0 val_as_bytes%11#0)
        let encoded_tuple_buffer%27#0: bytes = (concat encoded_tuple_buffer%26#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%28#0: bytes = (concat encoded_tuple_buffer%27#0 elements_to_encode%21#0)
        let encoded_tuple_buffer%29#0: bytes = (concat encoded_tuple_buffer%28#0 encoded_value%0#0)
        let encoded_tuple_buffer%30#0: bytes = (concat encoded_tuple_buffer%29#0 encoded_tuple_buffer%12#0)
        let tmp%75#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%30#0)
        (log tmp%75#0)
        return 1u
    block@16: // update_route_L19
        let tmp%76#0: uint64 = (txn OnCompletion)
        let tmp%77#0: bool = (== tmp%76#0 UpdateApplication)
        (assert tmp%77#0) // OnCompletion is not UpdateApplication
        let tmp%78#0: uint64 = (txn ApplicationID)
        let tmp%79#0: bool = (!= tmp%78#0 0u)
        (assert tmp%79#0) // can only call when not creating
        let tmp%80#0: bytes = (txna ApplicationArgs 1)
        let tmp%81#0: bytes = ((extract 2 0) tmp%80#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(tmp%81#0)
        return 1u
    block@17: // updateAkitaDAO_route_L27
        let tmp%82#0: uint64 = (txn OnCompletion)
        let tmp%83#0: bool = (== tmp%82#0 NoOp)
        (assert tmp%83#0) // OnCompletion is not NoOp
        let tmp%84#0: uint64 = (txn ApplicationID)
        let tmp%85#0: bool = (!= tmp%84#0 0u)
        (assert tmp%85#0) // can only call when not creating
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%86#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(tmp%86#0)
        return 1u
    block@18: // optin_route_L51
        let tmp%87#0: uint64 = (txn OnCompletion)
        let tmp%88#0: bool = (== tmp%87#0 NoOp)
        (assert tmp%88#0) // OnCompletion is not NoOp
        let tmp%89#0: uint64 = (txn ApplicationID)
        let tmp%90#0: bool = (!= tmp%89#0 0u)
        (assert tmp%90#0) // can only call when not creating
        let tmp%91#0: uint64 = (txn GroupIndex)
        let gtxn_idx%1#0: uint64 = (- tmp%91#0 1u)
        let gtxn_type%1#0: uint64 = ((gtxns TypeEnum) gtxn_idx%1#0)
        let gtxn_type_matches%1#0: bool = (== gtxn_type%1#0 pay)
        (assert gtxn_type_matches%1#0) // transaction type is pay
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%92#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn.optin(gtxn_idx%1#0, tmp%92#0)
        return 1u
    block@19: // mbr_route_L6
        let tmp%93#0: uint64 = (txn OnCompletion)
        let tmp%94#0: bool = (== tmp%93#0 NoOp)
        (assert tmp%94#0) // OnCompletion is not NoOp
        let tmp%95#0: uint64 = (txn ApplicationID)
        let tmp%96#0: bool = (!= tmp%95#0 0u)
        (assert tmp%96#0) // can only call when not creating
        let (elements_to_encode%22#0: uint64, elements_to_encode%23#0: uint64, elements_to_encode%24#0: uint64) = smart_contracts/pool/base.ts::BasePool.mbr()
        let val_as_bytes%13#0: bytes[8] = (itob elements_to_encode%22#0)
        let val_as_bytes%14#0: bytes[8] = (itob elements_to_encode%23#0)
        let val_as_bytes%15#0: bytes[8] = (itob elements_to_encode%24#0)
        let current_tail_offset%7#0: uint64 = 24u
        let encoded_tuple_buffer%31#0: bytes[0] = 0x
        let encoded_tuple_buffer%32#0: bytes = (concat encoded_tuple_buffer%31#0 val_as_bytes%13#0)
        let encoded_tuple_buffer%33#0: bytes = (concat encoded_tuple_buffer%32#0 val_as_bytes%14#0)
        let encoded_tuple_buffer%34#0: bytes = (concat encoded_tuple_buffer%33#0 val_as_bytes%15#0)
        let tmp%97#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%34#0)
        (log tmp%97#0)
        return 1u
    block@20: // switch_case_default_L99
        goto block@21
    block@21: // switch_case_next_L99
        goto block@23
    block@22: // bare_routing_L99
        goto block@23
    block@23: // after_if_else_L99
        return 0u

subroutine smart_contracts/pool/contract.algo.ts::Pool.newEntryID() -> uint64:
    block@0: // L182
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%0#0) // check GlobalState exists
        let id#0: uint64 = maybe_value%0#0
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%1#0 1u)
        (app_global_put "entry_count" materialized_values%0#0)
        return id#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.processPreparationPhase(iterationAmount: uint64) -> void:
    block@0: // L188
        let count#0: uint64 = 0u
        let total#0: uint64 = 0u
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: uint64 = (+ maybe_value%0#0 iterationAmount#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (> tmp%0#0 maybe_value%1#0)
        goto tmp%1#0 ? block@1 : block@2
    block@1: // if_body_L192
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#0) // check GlobalState exists
        let iterationAmount#1: uint64 = (- maybe_value%2#0 maybe_value%3#0)
        goto block@2
    block@2: // after_if_else_L192
        let iterationAmount#3: uint64 = φ(iterationAmount#0 <- block@0, iterationAmount#1 <- block@1)
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%4#0) // check GlobalState exists
        let id#0: uint64 = maybe_value%4#0
        goto block@3
    block@3: // while_top_L196
        let id#1: uint64 = φ(id#0 <- block@2, id#3 <- block@11)
        let count#1: uint64 = φ(count#0 <- block@2, count#4 <- block@11)
        let total#1: uint64 = φ(total#0 <- block@2, total#4 <- block@11)
        let tmp%2#0: bool = (< id#1 iterationAmount#3)
        goto tmp%2#0 ? block@4 : block@12
    block@4: // while_body_L196
        let encoded_value%0#0: bytes[8] = (itob id#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%5#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%5#0 0u 32u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%5#0 32u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%5#0 40u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%5#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%5#0)
        let item3%0#0: bytes = (substring3 maybe_value%5#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%5#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%0#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%0#0, item1%1#0, item2%1#0, item3%0#0, item4%0#0)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L198
        goto block@11
    block@6: // after_if_else_L198
        let (awst_tmp%0#0: bool, awst_tmp%1#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.getStakeValue(id#1)
        let valid#0: bool = awst_tmp%0#0
        let _#0: uint64 = awst_tmp%1#0
        goto valid#0 ? block@8 : block@7
    block@7: // if_body_L203
        goto block@11
    block@8: // after_if_else_L203
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%6#0) // check GlobalState exists
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%7#0) // check GlobalState exists
        let passes#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%6#0, entry.address#0, maybe_value%7#0, entry.gateArgs#0)
        goto passes#0 ? block@10 : block@9
    block@9: // if_body_L208
        goto block@11
    block@10: // after_if_else_L208
        let count#2: uint64 = (+ count#1 1u)
        let total#2: uint64 = (+ total#1 entry.quantity#0)
        goto block@11
    block@11: // L196
        let count#4: uint64 = φ(count#1 <- block@5, count#1 <- block@7, count#1 <- block@9, count#2 <- block@10)
        let total#4: uint64 = φ(total#1 <- block@5, total#1 <- block@7, total#1 <- block@9, total#2 <- block@10)
        let id#3: uint64 = (+ id#1 1u)
        goto block@3
    block@12: // after_while_L196
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%8#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%8#0 iterationAmount#3)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%9#0) // check GlobalState exists
        let materialized_values%1#0: uint64 = (+ maybe_value%9#0 count#1)
        (app_global_put "qualified_stake" materialized_values%1#0)
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%10#0) // check GlobalState exists
        let materialized_values%2#0: uint64 = (+ maybe_value%10#0 total#1)
        (app_global_put "qualified_stake" materialized_values%2#0)
        let (maybe_value%11#0: uint64, maybe_exists%11#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%11#0) // check GlobalState exists
        let (maybe_value%12#0: uint64, maybe_exists%12#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%12#0) // check GlobalState exists
        let tmp%3#0: bool = (== maybe_value%11#0 maybe_value%12#0)
        goto tmp%3#0 ? block@13 : block@14
    block@13: // if_body_L220
        (app_global_put "disbursement_phase" 0x14)
        (app_global_put "disbursement_cursor" 0u)
        goto block@14
    block@14: // after_if_else_L220
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.createPercentageDisbursement(iterationAmount: uint64, asset: uint64) -> void:
    block@0: // L226
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: uint64 = (+ maybe_value%0#0 iterationAmount#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (> tmp%0#0 maybe_value%1#0)
        goto tmp%1#0 ? block@1 : block@2
    block@1: // if_body_L228
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#0) // check GlobalState exists
        let iterationAmount#1: uint64 = (- maybe_value%2#0 maybe_value%3#0)
        goto block@2
    block@2: // after_if_else_L228
        let iterationAmount#3: uint64 = φ(iterationAmount#0 <- block@0, iterationAmount#1 <- block@1)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%4#0) // check GlobalState exists
        let reinterpret_bytes[33]%0#0: bytes[33] = maybe_value%4#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 8u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let (reward.asset#0: uint64, reward.distribution#0: bytes[1], reward.rate#0: uint64, reward.expiration#0: uint64, reward.winnerCount#0: uint64) = (item0%1#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let allocations#0: bytes = array_data%0#0
        let sum#0: uint64 = 0u
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#0) // check GlobalState exists
        let id#0: uint64 = maybe_value%5#0
        goto block@3
    block@3: // while_top_L236
        let id#1: uint64 = φ(id#0 <- block@2, id#3 <- block@7)
        let allocations#1: bytes = φ(allocations#0 <- block@2, allocations#3 <- block@7)
        let sum#1: uint64 = φ(sum#0 <- block@2, sum#3 <- block@7)
        let tmp%2#0: bool = (< id#1 iterationAmount#3)
        goto tmp%2#0 ? block@4 : block@8
    block@4: // while_body_L236
        let encoded_value%0#0: bytes[8] = (itob id#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%2#0: bytes = (extract3 maybe_value%6#0 0u 32u) // on error: Index access is out of bounds
        let item1%1#0: bytes = (extract3 maybe_value%6#0 32u 8u) // on error: Index access is out of bounds
        let item1%2#0: uint64 = (btoi item1%1#0)
        let item2%2#0: bytes = (extract3 maybe_value%6#0 40u 8u) // on error: Index access is out of bounds
        let item2%3#0: uint64 = (btoi item2%2#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%6#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%6#0)
        let item3%2#0: bytes = (substring3 maybe_value%6#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%6#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%2#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%2#0, item1%2#0, item2%3#0, item3%2#0, item4%2#0)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L238
        goto block@7
    block@6: // after_if_else_L238
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%7#0) // check GlobalState exists
        let tmp%3#0: uint64 = smart_contracts/utils/functions.ts::percentageOf(entry.quantity#0, maybe_value%7#0)
        let amount#0: uint64 = smart_contracts/utils/functions.ts::calcPercent(reward.rate#0, tmp%3#0)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) allocations#1)
        let val_as_bytes%0#0: bytes[8] = (itob amount#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 entry.address#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let encoded%0#0: bytes[40][] = encode<bytes[40]>(encoded_tuple_buffer%2#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 40u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let allocations#2: bytes = concat_result%0#0
        let sum#2: uint64 = (+ sum#1 amount#0)
        goto block@7
    block@7: // L236
        let allocations#3: bytes = φ(allocations#1 <- block@5, allocations#2 <- block@6)
        let sum#3: uint64 = φ(sum#1 <- block@5, sum#2 <- block@6)
        let id#3: uint64 = (+ id#1 1u)
        goto block@3
    block@8: // after_while_L236
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%8#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%8#0 iterationAmount#3)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%9#0) // check GlobalState exists
        let createRewardAllocations%0#0: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%9#0, asset#0, allocations#1, sum#1)
        let allocations#4: bytes = createRewardAllocations%0#0
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%10#0) // check GlobalState exists
        let (maybe_value%11#0: uint64, maybe_exists%11#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%11#0) // check GlobalState exists
        let tmp%4#0: bool = (== maybe_value%10#0 maybe_value%11#0)
        goto tmp%4#0 ? block@9 : block@10
    block@9: // if_body_L256
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@10
    block@10: // after_if_else_L256
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.createFlatDisbursement(iterationAmount: uint64, asset: uint64, amount: uint64) -> void:
    block@0: // L262
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%0#0) // check GlobalState exists
        let total#0: uint64 = (* maybe_value%0#0 amount#0)
        let tmp%0#0: bytes[32] = (global CurrentApplicationAddress)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: bool) = ((asset_holding_get AssetBalance) tmp%0#0 asset#0)
        let balance#0: uint64 = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let tmp%1#0: bool = (>= balance#0 total#0)
        (assert tmp%1#0) // Not enough funds
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: uint64 = (+ maybe_value%1#0 iterationAmount#0)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%3#0: bool = (> tmp%2#0 maybe_value%2#0)
        goto tmp%3#0 ? block@1 : block@2
    block@1: // if_body_L268
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%3#0) // check GlobalState exists
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%4#0) // check GlobalState exists
        let iterationAmount#1: uint64 = (- maybe_value%3#0 maybe_value%4#0)
        goto block@2
    block@2: // after_if_else_L268
        let iterationAmount#3: uint64 = φ(iterationAmount#0 <- block@0, iterationAmount#1 <- block@1)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let allocations#0: bytes = array_data%0#0
        let sum#0: uint64 = 0u
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#0) // check GlobalState exists
        let id#0: uint64 = maybe_value%5#0
        goto block@3
    block@3: // while_top_L275
        let id#1: uint64 = φ(id#0 <- block@2, id#3 <- block@7)
        let allocations#1: bytes = φ(allocations#0 <- block@2, allocations#3 <- block@7)
        let sum#1: uint64 = φ(sum#0 <- block@2, sum#3 <- block@7)
        let tmp%4#0: bool = (< id#1 iterationAmount#3)
        goto tmp%4#0 ? block@4 : block@8
    block@4: // while_body_L275
        let encoded_value%0#0: bytes[8] = (itob id#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%6#0 0u 32u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%6#0 32u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%6#0 40u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%6#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%6#0)
        let item3%0#0: bytes = (substring3 maybe_value%6#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%6#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%0#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%0#0, item1%1#0, item2%1#0, item3%0#0, item4%0#0)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L277
        goto block@7
    block@6: // after_if_else_L277
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) allocations#1)
        let val_as_bytes%0#0: bytes[8] = (itob amount#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 entry.address#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let encoded%0#0: bytes[40][] = encode<bytes[40]>(encoded_tuple_buffer%2#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 40u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let allocations#2: bytes = concat_result%0#0
        let sum#2: uint64 = (+ sum#1 amount#0)
        goto block@7
    block@7: // L275
        let allocations#3: bytes = φ(allocations#1 <- block@5, allocations#2 <- block@6)
        let sum#3: uint64 = φ(sum#1 <- block@5, sum#2 <- block@6)
        let id#3: uint64 = (+ id#1 1u)
        goto block@3
    block@8: // after_while_L275
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%7#0 iterationAmount#3)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%8#0) // check GlobalState exists
        let createRewardAllocations%0#0: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%8#0, asset#0, allocations#1, sum#1)
        let allocations#4: bytes = createRewardAllocations%0#0
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#0) // check GlobalState exists
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#0) // check GlobalState exists
        let tmp%5#0: bool = (== maybe_value%9#0 maybe_value%10#0)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L293
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@10
    block@10: // after_if_else_L293
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.createEvenDisbursement(iterationAmount: uint64, asset: uint64, sum: uint64) -> void:
    block@0: // L299
        let tmp%0#0: bytes[32] = (global CurrentApplicationAddress)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: bool) = ((asset_holding_get AssetBalance) tmp%0#0 asset#0)
        let balance#0: uint64 = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let tmp%1#0: bool = (>= balance#0 sum#0)
        (assert tmp%1#0) // Not enough funds
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: uint64 = (+ maybe_value%0#0 iterationAmount#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%3#0: bool = (> tmp%2#0 maybe_value%1#0)
        goto tmp%3#0 ? block@1 : block@2
    block@1: // if_body_L303
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#0) // check GlobalState exists
        let iterationAmount#1: uint64 = (- maybe_value%2#0 maybe_value%3#0)
        goto block@2
    block@2: // after_if_else_L303
        let iterationAmount#3: uint64 = φ(iterationAmount#0 <- block@0, iterationAmount#1 <- block@1)
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%4#0) // check GlobalState exists
        let amount#0: uint64 = (/ sum#0 maybe_value%4#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let allocations#0: bytes = array_data%0#0
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#0) // check GlobalState exists
        let id#0: uint64 = maybe_value%5#0
        goto block@3
    block@3: // while_top_L309
        let id#1: uint64 = φ(id#0 <- block@2, id#3 <- block@7)
        let allocations#1: bytes = φ(allocations#0 <- block@2, allocations#3 <- block@7)
        let tmp%4#0: bool = (< id#1 iterationAmount#3)
        goto tmp%4#0 ? block@4 : block@8
    block@4: // while_body_L309
        let encoded_value%0#0: bytes[8] = (itob id#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%6#0 0u 32u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%6#0 32u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%6#0 40u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%6#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%6#0)
        let item3%0#0: bytes = (substring3 maybe_value%6#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%6#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%0#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%0#0, item1%1#0, item2%1#0, item3%0#0, item4%0#0)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L311
        goto block@7
    block@6: // after_if_else_L311
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) allocations#1)
        let val_as_bytes%0#0: bytes[8] = (itob amount#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 entry.address#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let encoded%0#0: bytes[40][] = encode<bytes[40]>(encoded_tuple_buffer%2#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 40u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let allocations#2: bytes = concat_result%0#0
        goto block@7
    block@7: // L309
        let allocations#3: bytes = φ(allocations#1 <- block@5, allocations#2 <- block@6)
        let id#3: uint64 = (+ id#1 1u)
        goto block@3
    block@8: // after_while_L309
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%7#0 iterationAmount#3)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%8#0) // check GlobalState exists
        let createRewardAllocations%0#0: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%8#0, asset#0, allocations#1, sum#0)
        let allocations#4: bytes = createRewardAllocations%0#0
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#0) // check GlobalState exists
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#0) // check GlobalState exists
        let tmp%5#0: bool = (== maybe_value%9#0 maybe_value%10#0)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L326
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@10
    block@10: // after_if_else_L326
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.resetRaffleState() -> void:
    block@0: // L332
        let current_tail_offset%0#0: uint64 = 24u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 0x0000000000000000)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 0x0000000000000000)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 0x0000000000000000)
        (app_global_put "raffle_cursor" encoded_tuple_buffer%3#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        (app_global_put "wtickets" array_data%0#0)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.createShuffleDisbursement(iterationAmount: uint64, asset: uint64, sum: uint64) -> void:
    block@0: // L338
        let tmp%0#0: bytes[32] = (global CurrentApplicationAddress)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: bool) = ((asset_holding_get AssetBalance) tmp%0#0 asset#0)
        let balance#0: uint64 = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let tmp%1#0: bool = (>= balance#0 sum#0)
        (assert tmp%1#0) // Not enough funds
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: uint64 = (+ maybe_value%0#0 iterationAmount#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%3#0: bool = (> tmp%2#0 maybe_value%1#0)
        goto tmp%3#0 ? block@1 : block@2
    block@1: // if_body_L342
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#0) // check GlobalState exists
        let iterationAmount#1: uint64 = (- maybe_value%2#0 maybe_value%3#0)
        goto block@2
    block@2: // after_if_else_L342
        let iterationAmount#6: uint64 = φ(iterationAmount#0 <- block@0, iterationAmount#1 <- block@1)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%4#0) // check GlobalState exists
        let reinterpret_bytes[33]%0#0: bytes[33] = maybe_value%4#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 8u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let (reward.asset#0: uint64, reward.distribution#0: bytes[1], reward.rate#0: uint64, reward.expiration#0: uint64, reward.winnerCount#0: uint64) = (item0%1#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0)
        let amount#0: uint64 = reward.rate#0
        let tmp%4#0: bool = (> reward.winnerCount#0 0u)
        goto tmp%4#0 ? block@3 : block@4
    block@3: // if_body_L349
        let amount#1: uint64 = (/ reward.rate#0 reward.winnerCount#0)
        goto block@4
    block@4: // after_if_else_L349
        let amount#3: uint64 = φ(amount#0 <- block@2, amount#1 <- block@3)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tickets#0: encoded_uint64[] = maybe_value%5#0
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "raffle_cursor")
        (assert maybe_exists%6#0) // check GlobalState exists
        let reinterpret_bytes[24]%0#0: bytes[24] = maybe_value%6#0
        let item0%2#0: bytes = (extract3 reinterpret_bytes[24]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%3#0: uint64 = (btoi item0%2#0)
        let item1%1#0: bytes = (extract3 reinterpret_bytes[24]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%2#0: uint64 = (btoi item1%1#0)
        let item2%2#0: bytes = (extract3 reinterpret_bytes[24]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%3#0: uint64 = (btoi item2%2#0)
        let stake#0: uint64 = item1%2#0
        let ticket#0: uint64 = item0%3#0
        let disbursed#0: uint64 = item2%3#0
        let array_head_and_tail%0#0: bytes = ((extract 2 0) tickets#0)
        let item_offset%0#0: uint64 = (* ticket#0 8u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let currentTicket#0: uint64 = (btoi arc4_item%0#0)
        let currentRangeStart#0: uint64 = stake#0
        let currentRangeEnd#0: uint64 = 0u
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let allocations#0: bytes = array_data%0#0
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#0) // check GlobalState exists
        let i#0: uint64 = maybe_value%7#0
        goto block@5
    block@5: // while_top_L360
        let i#1: uint64 = φ(i#0 <- block@4, i#5 <- block@15)
        let iterationAmount#2: uint64 = φ(iterationAmount#6 <- block@4, iterationAmount#7 <- block@15)
        let currentRangeStart#1: uint64 = φ(currentRangeStart#0 <- block@4, currentRangeStart#2 <- block@15)
        let currentTicket#1: uint64 = φ(currentTicket#0 <- block@4, currentTicket#3 <- block@15)
        let allocations#1: bytes = φ(allocations#0 <- block@4, allocations#5 <- block@15)
        let disbursed#1: uint64 = φ(disbursed#0 <- block@4, disbursed#4 <- block@15)
        let ticket#2: uint64 = φ(ticket#0 <- block@4, ticket#4 <- block@15)
        let stake#4: uint64 = φ(stake#0 <- block@4, stake#5 <- block@15)
        let tmp%5#0: bool = (< i#1 iterationAmount#2)
        goto tmp%5#0 ? block@6 : block@16
    block@6: // while_body_L360
        let encoded_value%0#0: bytes[8] = (itob i#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%8#0) // Box must have value
        let item0%4#0: bytes = (extract3 maybe_value%8#0 0u 32u) // on error: Index access is out of bounds
        let item1%3#0: bytes = (extract3 maybe_value%8#0 32u 8u) // on error: Index access is out of bounds
        let item1%4#0: uint64 = (btoi item1%3#0)
        let item2%4#0: bytes = (extract3 maybe_value%8#0 40u 8u) // on error: Index access is out of bounds
        let item2%5#0: uint64 = (btoi item2%4#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%8#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%8#0)
        let item3%2#0: bytes = (substring3 maybe_value%8#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%8#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%2#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%4#0, item1%4#0, item2%5#0, item3%2#0, item4%2#0)
        let currentRangeEnd#1: uint64 = (+ currentRangeStart#1 entry.quantity#0)
        let tmp%6#0: bool = (>= currentTicket#1 currentRangeStart#1)
        goto tmp%6#0 ? block@7 : block@15
    block@7: // and_contd_L364
        let tmp%7#0: bool = (<= currentTicket#1 currentRangeEnd#1)
        goto tmp%7#0 ? block@8 : block@15
    block@8: // if_body_L364
        goto entry.disqualified#0 ? block@10 : block@9
    block@9: // if_body_L365
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) allocations#1)
        let val_as_bytes%0#0: bytes[8] = (itob amount#3)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 entry.address#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let encoded%0#0: bytes[40][] = encode<bytes[40]>(encoded_tuple_buffer%2#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 40u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let allocations#2: bytes = concat_result%0#0
        let disbursed#2: uint64 = (+ disbursed#1 1u)
        goto block@10
    block@10: // after_if_else_L365
        let disbursed#3: uint64 = φ(disbursed#1 <- block@8, disbursed#2 <- block@9)
        let allocations#3: bytes = φ(allocations#1 <- block@8, allocations#2 <- block@9)
        let tmp%8#0: uint64 = (extract_uint16 tickets#0 0u)
        let tmp%9#0: uint64 = (- tmp%8#0 1u)
        let tmp%10#0: bool = (== ticket#2 tmp%9#0)
        goto tmp%10#0 ? block@11 : block@14
    block@11: // if_body_L375
        let tmp%11#0: bool = (!= reward.winnerCount#0 disbursed#3)
        goto tmp%11#0 ? block@12 : block@13
    block@12: // if_body_L377
        (app_global_put "disbursement_cursor" 0u)
        let val_as_bytes%1#0: bytes[8] = (itob disbursed#3)
        let current_tail_offset%1#0: uint64 = 24u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 0x0000000000000000)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 0x0000000000000000)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%1#0)
        (app_global_put "raffle_cursor" encoded_tuple_buffer%6#0)
        let array_data%1#0: bytes = (concat 0x0000 0x)
        (app_global_put "wtickets" array_data%1#0)
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%9#0) // check GlobalState exists
        let createRewardAllocations%0#0: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%9#0, asset#0, allocations#3, sum#0)
        let allocations#4: bytes = createRewardAllocations%0#0
        return 
    block@13: // after_if_else_L377
        goto block@17
    block@14: // after_if_else_L375
        let iterationAmount#4: uint64 = (- iterationAmount#2 i#1)
        let ticket#3: uint64 = (+ ticket#2 1u)
        let array_head_and_tail%1#0: bytes = ((extract 2 0) tickets#0)
        let item_offset%1#0: uint64 = (* ticket#3 8u)
        let arc4_item%1#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 8u) // on error: Index access is out of bounds
        let currentTicket#2: uint64 = (btoi arc4_item%1#0)
        (app_global_put "disbursement_cursor" 0u)
        let i#3: uint64 = 0u
        let stake#1: uint64 = 0u
        let currentRangeEnd#2: uint64 = 0u
        goto block@15
    block@15: // after_if_else_L364
        let currentRangeEnd#3: uint64 = φ(currentRangeEnd#1 <- block@6, currentRangeEnd#1 <- block@7, currentRangeEnd#2 <- block@14)
        let i#4: uint64 = φ(i#1 <- block@6, i#1 <- block@7, i#3 <- block@14)
        let iterationAmount#7: uint64 = φ(iterationAmount#2 <- block@6, iterationAmount#2 <- block@7, iterationAmount#4 <- block@14)
        let currentTicket#3: uint64 = φ(currentTicket#1 <- block@6, currentTicket#1 <- block@7, currentTicket#2 <- block@14)
        let allocations#5: bytes = φ(allocations#1 <- block@6, allocations#1 <- block@7, allocations#3 <- block@14)
        let disbursed#4: uint64 = φ(disbursed#1 <- block@6, disbursed#1 <- block@7, disbursed#3 <- block@14)
        let ticket#4: uint64 = φ(ticket#2 <- block@6, ticket#2 <- block@7, ticket#3 <- block@14)
        let stake#5: uint64 = φ(stake#4 <- block@6, stake#4 <- block@7, stake#1 <- block@14)
        let currentRangeStart#2: uint64 = (+ currentRangeEnd#3 1u)
        let i#5: uint64 = (+ i#4 1u)
        goto block@5
    block@16: // after_while_L360
        goto block@17
    block@17: // L360
        let disbursed#5: uint64 = φ(disbursed#3 <- block@13, disbursed#1 <- block@16)
        let allocations#6: bytes = φ(allocations#3 <- block@13, allocations#1 <- block@16)
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%10#0 iterationAmount#2)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob ticket#2)
        let val_as_bytes%3#0: bytes[8] = (itob stake#4)
        let val_as_bytes%4#0: bytes[8] = (itob disbursed#5)
        let current_tail_offset%2#0: uint64 = 24u
        let encoded_tuple_buffer%7#0: bytes[0] = 0x
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        (app_global_put "raffle_cursor" encoded_tuple_buffer%10#0)
        let (maybe_value%11#0: uint64, maybe_exists%11#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%11#0) // check GlobalState exists
        let createRewardAllocations%1#0: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%11#0, asset#0, allocations#6, sum#0)
        let allocations#7: bytes = createRewardAllocations%1#0
        let tmp%12#0: bool = (== reward.winnerCount#0 disbursed#5)
        goto tmp%12#0 ? block@18 : block@19
    block@18: // if_body_L410
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        smart_contracts/pool/contract.algo.ts::Pool.resetRaffleState()
        goto block@19
    block@19: // after_if_else_L410
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.checkByID(id: uint64) -> <bool, uint64>:
    block@0: // L417
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L419
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (!= maybe_value%1#0 0x01)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L419
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L419
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L419
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Invalid pool type for check
        let encoded_value%0#0: bytes[8] = (itob id#0)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%2#0 0u 32u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%2#0 32u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%2#0 40u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%2#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%2#0)
        let item3%0#0: bytes = (substring3 maybe_value%2#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%2#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%0#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%0#0, item1%1#0, item2%1#0, item3%0#0, item4%0#0)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L425
        return 0u 0u
    block@6: // after_if_else_L425
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%3#0 0x02)
        goto tmp%2#0 ? block@7 : block@11
    block@7: // if_body_L429
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64, tmp%12#0: uint64, tmp%13#0: uint64, tmp%14#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%4#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%3#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob entry.asset#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "softCheck(address,uint64)(bool,uint64)"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = entry.address#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@8
    block@8: // next_txn_L430
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%15#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%16#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%17#0: bool = (== tmp%16#0 0x151f7c75)
        (assert tmp%17#0) // Bytes has valid prefix
        let reinterpret_bytes[9]%0#0: bytes[9] = tmp%15#0
        let is_true%1#0: uint64 = (getbit reinterpret_bytes[9]%0#0 0u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let item0%1#0: bool = (getbit encoded_bool%1#0 0u)
        let item1%2#0: bytes = (extract3 reinterpret_bytes[9]%0#0 1u 8u) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (btoi item1%2#0)
        let (check.valid#0: bool, check.balance#0: uint64) = (item0%1#0, item1%3#0)
        let tmp%18#0: bool = (>= check.balance#0 entry.quantity#0)
        goto tmp%18#0 ? block@9 : block@10
    block@9: // if_body_L436
        return 1u check.balance#0
    block@10: // after_if_else_L436
        goto block@15
    block@11: // else_body_L439
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (tmp%19#0: uint64, tmp%20#0: uint64, tmp%21#0: uint64, tmp%22#0: uint64, tmp%23#0: uint64, tmp%24#0: uint64, tmp%25#0: uint64, tmp%26#0: uint64, tmp%27#0: uint64, tmp%28#0: uint64, tmp%29#0: uint64, tmp%30#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%5#0)
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = tmp%19#0
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%1#0: bytes[8] = (itob entry.asset#0)
        let tmp%31#0: bytes[1] = smart_contracts/pool/contract.algo.ts::Pool.stakingType()
        let current_tail_offset%0#0: uint64 = 9u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%31#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_0#0: bytes[4] = method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[32] = entry.address#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_2#0: bytes = encoded_tuple_buffer%2#0
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@12
    block@12: // next_txn_L440
        itxn_submit
        let awst_tmp%1#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%32#0: bytes = ((extract 4 0) awst_tmp%1#0)
        let tmp%33#0: bytes = ((extract 0 4) awst_tmp%1#0)
        let tmp%34#0: bool = (== tmp%33#0 0x151f7c75)
        (assert tmp%34#0) // Bytes has valid prefix
        let reinterpret_bytes[24]%0#0: bytes[24] = tmp%32#0
        let item0%2#0: bytes = (extract3 reinterpret_bytes[24]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%3#0: uint64 = (btoi item0%2#0)
        let item1%4#0: bytes = (extract3 reinterpret_bytes[24]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%5#0: uint64 = (btoi item1%4#0)
        let item2%2#0: bytes = (extract3 reinterpret_bytes[24]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%3#0: uint64 = (btoi item2%2#0)
        let (info.amount#0: uint64, info.lastUpdate#0: uint64, info.expiration#0: uint64) = (item0%3#0, item1%5#0, item2%3#0)
        let tmp%35#0: bool = (>= info.amount#0 entry.quantity#0)
        goto tmp%35#0 ? block@13 : block@14
    block@13: // if_body_L452
        return 1u info.amount#0
    block@14: // after_if_else_L452
        goto block@15
    block@15: // after_if_else_L429
        let encoded_value%1#0: bytes[8] = (itob id#0)
        let box_prefixed_key%1#0: bytes = (concat "e" encoded_value%1#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%4#0: bytes = (extract3 maybe_value%6#0 0u 32u) // on error: Index access is out of bounds
        let item1%6#0: bytes = (extract3 maybe_value%6#0 32u 8u) // on error: Index access is out of bounds
        let item1%7#0: uint64 = (btoi item1%6#0)
        let item2%4#0: bytes = (extract3 maybe_value%6#0 40u 8u) // on error: Index access is out of bounds
        let item2%5#0: uint64 = (btoi item2%4#0)
        let item_start_offset%1#0: uint64 = (extract_uint16 maybe_value%6#0 48u)
        let item_end_offset%1#0: uint64 = (len maybe_value%6#0)
        let item3%1#0: bytes = (substring3 maybe_value%6#0 item_start_offset%1#0 item_end_offset%1#0)
        let is_true%2#0: uint64 = (getbit maybe_value%6#0 400u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item4%1#0: bool = (getbit encoded_bool%2#0 0u)
        let encoded_value%2#0: bytes[8] = (itob id#0)
        let box_prefixed_key%2#0: bytes = (concat "e" encoded_value%2#0)
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%7#0) // Box must have value
        let item0%5#0: bytes = (extract3 maybe_value%7#0 0u 32u) // on error: Index access is out of bounds
        let item1%8#0: bytes = (extract3 maybe_value%7#0 32u 8u) // on error: Index access is out of bounds
        let item1%9#0: uint64 = (btoi item1%8#0)
        let item2%6#0: bytes = (extract3 maybe_value%7#0 40u 8u) // on error: Index access is out of bounds
        let item2%7#0: uint64 = (btoi item2%6#0)
        let item_start_offset%2#0: uint64 = (extract_uint16 maybe_value%7#0 48u)
        let item_end_offset%2#0: uint64 = (len maybe_value%7#0)
        let item3%2#0: bytes = (substring3 maybe_value%7#0 item_start_offset%2#0 item_end_offset%2#0)
        let is_true%3#0: uint64 = (getbit maybe_value%7#0 400u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let item4%2#0: bool = (getbit encoded_bool%3#0 0u)
        let encoded_value%3#0: bytes[8] = (itob id#0)
        let box_prefixed_key%3#0: bytes = (concat "e" encoded_value%3#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%8#0) // Box must have value
        let item0%6#0: bytes = (extract3 maybe_value%8#0 0u 32u) // on error: Index access is out of bounds
        let item1%10#0: bytes = (extract3 maybe_value%8#0 32u 8u) // on error: Index access is out of bounds
        let item1%11#0: uint64 = (btoi item1%10#0)
        let item2%8#0: bytes = (extract3 maybe_value%8#0 40u 8u) // on error: Index access is out of bounds
        let item2%9#0: uint64 = (btoi item2%8#0)
        let item_start_offset%3#0: uint64 = (extract_uint16 maybe_value%8#0 48u)
        let item_end_offset%3#0: uint64 = (len maybe_value%8#0)
        let item3%3#0: bytes = (substring3 maybe_value%8#0 item_start_offset%3#0 item_end_offset%3#0)
        let is_true%4#0: uint64 = (getbit maybe_value%8#0 400u)
        let encoded_bool%4#0: bytes[1] = (setbit 0x00 0u is_true%4#0)
        let item4%3#0: bool = (getbit encoded_bool%4#0 0u)
        let encoded_value%4#0: bytes[8] = (itob id#0)
        let box_prefixed_key%4#0: bytes = (concat "e" encoded_value%4#0)
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%9#0) // Box must have value
        let item0%7#0: bytes = (extract3 maybe_value%9#0 0u 32u) // on error: Index access is out of bounds
        let item1%12#0: bytes = (extract3 maybe_value%9#0 32u 8u) // on error: Index access is out of bounds
        let item1%13#0: uint64 = (btoi item1%12#0)
        let item2%10#0: bytes = (extract3 maybe_value%9#0 40u 8u) // on error: Index access is out of bounds
        let item2%11#0: uint64 = (btoi item2%10#0)
        let item_start_offset%4#0: uint64 = (extract_uint16 maybe_value%9#0 48u)
        let item_end_offset%4#0: uint64 = (len maybe_value%9#0)
        let item3%4#0: bytes = (substring3 maybe_value%9#0 item_start_offset%4#0 item_end_offset%4#0)
        let is_true%5#0: uint64 = (getbit maybe_value%9#0 400u)
        let encoded_bool%5#0: bytes[1] = (setbit 0x00 0u is_true%5#0)
        let item4%4#0: bool = (getbit encoded_bool%5#0 0u)
        let encoded_value%5#0: bytes[8] = (itob id#0)
        let box_prefixed_key%5#0: bytes = (concat "e" encoded_value%5#0)
        (box_del box_prefixed_key%5#0)
        let val_as_bytes%2#0: bytes[8] = (itob item1%9#0)
        let val_as_bytes%3#0: bytes[8] = (itob item2%9#0)
        let encoded_bool%6#0: bytes[1] = (setbit 0x00 0u 1u)
        let current_tail_offset%1#0: uint64 = 51u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 item0%4#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let as_bytes%0#0: bytes[8] = (itob current_tail_offset%1#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len item3%4#0)
        let current_tail_offset%2#0: uint64 = (+ current_tail_offset%1#0 data_length%0#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 encoded_bool%6#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 item3%4#0)
        (box_put box_prefixed_key%5#0 encoded_tuple_buffer%9#0)
        return 0u 0u

subroutine smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart() -> uint64:
    block@0: // L464
        let tmp%0#0: uint64 = (global LatestTimestamp)
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: uint64 = (- tmp%1#0 maybe_value%0#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "reward_interval")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%3#0: uint64 = (% tmp%2#0 maybe_value%1#0)
        let tmp%4#0: uint64 = (- tmp%0#0 tmp%3#0)
        return tmp%4#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.validWindow() -> bool:
    block@0: // L468
        let latestWindowStart#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart()
        let tmp%0#0: uint64 = (global LatestTimestamp)
        let tmp%1#0: bool = (!= latestWindowStart#0 tmp%0#0)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L470
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "last_disbursement_timestamp")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: bool = (< maybe_value%0#0 latestWindowStart#0)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // bool_true_L470
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L470
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L470
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        return and_result%0#2

subroutine smart_contracts/pool/contract.algo.ts::Pool.stakingType() -> bytes[1]:
    block@0: // L473
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        (assert tmp%0#0) // pool staking type is not set
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: uint64 = (btoi maybe_value%1#0)
        let to_encode%0#0: uint64 = (- tmp%1#0 1u)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let bitlen%0#0: uint64 = (bitlen val_as_bytes%0#0)
        let no_overflow%0#0: bool = (<= bitlen%0#0 8u)
        (assert no_overflow%0#0) // overflow
        let uint8%0#0: bytes = (extract3 val_as_bytes%0#0 7u 1u)
        return uint8%0#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.getStakeValue(id: uint64) -> <bool, uint64>:
    block@0: // L478
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // if_body_L479
        return 1u 0u
    block@2: // else_body_L481
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (== maybe_value%1#0 0x01)
        goto tmp%1#0 ? block@3 : block@5
    block@3: // if_body_L481
        let encoded_value%0#0: bytes[8] = (itob id#0)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%2#0 0u 32u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%2#0 32u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%2#0 40u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%2#0 48u)
        let item_end_offset%0#0: uint64 = (len maybe_value%2#0)
        let item3%0#0: bytes = (substring3 maybe_value%2#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%0#0: uint64 = (getbit maybe_value%2#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item4%0#0: bool = (getbit encoded_bool%0#0 0u)
        let (entry.address#0: bytes[32], entry.asset#0: uint64, entry.quantity#0: uint64, entry.gateArgs#0: bytes[], entry.disqualified#0: bool) = (item0%0#0, item1%1#0, item2%1#0, item3%0#0, item4%0#0)
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%3#0) // check GlobalState exists
        let (tmp%2#0: uint64, tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64, tmp%12#0: uint64, tmp%13#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%3#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%2#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob entry.asset#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u 1u)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "getHeartbeatAverage(address,uint64,bool)uint64"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = entry.address#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_3#0: bytes[1] = encoded_bool%1#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 4u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_3#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@4
    block@4: // next_txn_L484
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%14#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%15#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%16#0: bool = (== tmp%15#0 0x151f7c75)
        (assert tmp%16#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%14#0
        let tmp%17#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let avg#0: uint64 = tmp%17#0
        return 1u avg#0
    block@5: // after_if_else_L481
        goto block@6
    block@6: // after_if_else_L479
        let (awst_tmp%1#0: bool, awst_tmp%2#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.checkByID(id#0)
        return awst_tmp%1#0 awst_tmp%2#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.createRewards(title: bytes, timeToUnlock: uint64, expiration: uint64) -> uint64:
    block@0: // L496
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (tmp%0#0: uint64, tmp%1#0: uint64, tmp%2#0: uint64, tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%0#0)
        let rewardsApp#0: uint64 = tmp%1#0
        let tmp%12#0: uint64 = (len title#0)
        let tmp%13#0: uint64 = (* 400u tmp%12#0)
        let rewardMBR#0: uint64 = (+ 35300u tmp%13#0)
        let mbrPayment#0: itxn_field_set = itxn_field_set(0)
        let mbrPayment%%param_Fee_idx_0#0: uint64 = 0u
        let mbrPayment%%Fee_length#0: uint64 = 1u
        let mbrPayment%%param_TypeEnum_idx_0#0: uint64 = 1u
        let mbrPayment%%TypeEnum_length#0: uint64 = 1u
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%0#0) // application exists
        let mbrPayment%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        let mbrPayment%%Receiver_length#0: uint64 = 1u
        let mbrPayment%%param_Amount_idx_0#0: uint64 = rewardMBR#0
        let mbrPayment%%Amount_length#0: uint64 = 1u
        let mbrPayment%%Sender_length#0: uint64 = 0u
        let mbrPayment%%Note_length#0: uint64 = 0u
        let mbrPayment%%CloseRemainderTo_length#0: uint64 = 0u
        let mbrPayment%%VotePK_length#0: uint64 = 0u
        let mbrPayment%%SelectionPK_length#0: uint64 = 0u
        let mbrPayment%%VoteFirst_length#0: uint64 = 0u
        let mbrPayment%%VoteLast_length#0: uint64 = 0u
        let mbrPayment%%VoteKeyDilution_length#0: uint64 = 0u
        let mbrPayment%%Type_length#0: uint64 = 0u
        let mbrPayment%%XferAsset_length#0: uint64 = 0u
        let mbrPayment%%AssetAmount_length#0: uint64 = 0u
        let mbrPayment%%AssetSender_length#0: uint64 = 0u
        let mbrPayment%%AssetReceiver_length#0: uint64 = 0u
        let mbrPayment%%AssetCloseTo_length#0: uint64 = 0u
        let mbrPayment%%ApplicationID_length#0: uint64 = 0u
        let mbrPayment%%OnCompletion_length#0: uint64 = 0u
        let mbrPayment%%ApprovalProgram_length#0: uint64 = 0u
        let mbrPayment%%ClearStateProgram_length#0: uint64 = 0u
        let mbrPayment%%RekeyTo_length#0: uint64 = 0u
        let mbrPayment%%ConfigAsset_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetTotal_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetDecimals_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetUnitName_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetName_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetURL_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetManager_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetReserve_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetFreeze_length#0: uint64 = 0u
        let mbrPayment%%ConfigAssetClawback_length#0: uint64 = 0u
        let mbrPayment%%FreezeAsset_length#0: uint64 = 0u
        let mbrPayment%%FreezeAssetAccount_length#0: uint64 = 0u
        let mbrPayment%%FreezeAssetFrozen_length#0: uint64 = 0u
        let mbrPayment%%GlobalNumUint_length#0: uint64 = 0u
        let mbrPayment%%GlobalNumByteSlice_length#0: uint64 = 0u
        let mbrPayment%%LocalNumUint_length#0: uint64 = 0u
        let mbrPayment%%LocalNumByteSlice_length#0: uint64 = 0u
        let mbrPayment%%ExtraProgramPages_length#0: uint64 = 0u
        let mbrPayment%%Nonparticipation_length#0: uint64 = 0u
        let mbrPayment%%StateProofPK_length#0: uint64 = 0u
        let mbrPayment%%ApplicationArgs_length#0: uint64 = 0u
        let mbrPayment%%Accounts_length#0: uint64 = 0u
        let mbrPayment%%Assets_length#0: uint64 = 0u
        let mbrPayment%%Applications_length#0: uint64 = 0u
        let mbrPayment%%ApprovalProgramPages_length#0: uint64 = 0u
        let mbrPayment%%ClearStateProgramPages_length#0: uint64 = 0u
        itxn_begin
        ((itxn_field Amount) mbrPayment%%param_Amount_idx_0#0)
        ((itxn_field Receiver) mbrPayment%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) mbrPayment%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) mbrPayment%%param_Fee_idx_0#0)
        goto block@1
    block@1: // next_txn_L510
        itxn_next
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = rewardsApp#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let length%0#0: uint64 = (len title#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 title#0)
        let val_as_bytes%0#0: bytes[8] = (itob timeToUnlock#0)
        let val_as_bytes%1#0: bytes[8] = (itob expiration#0)
        let length%1#0: uint64 = (len "")
        let as_bytes%1#0: bytes[8] = (itob length%1#0)
        let length_uint16%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_value%1#0: bytes = (concat length_uint16%1#0 "")
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "createDisbursement(pay,string,uint64,uint64,string)uint64"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes = encoded_value%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_3#0: bytes[8] = val_as_bytes%1#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_4#0: bytes = encoded_value%1#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 5u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_3#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_4#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@2
    block@2: // next_txn_L507
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(1)].LastLog
        let tmp%14#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%15#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%16#0: bool = (== tmp%15#0 0x151f7c75)
        (assert tmp%16#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%14#0
        let tmp%17#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        return tmp%17#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
    block@0: // L520
        let allocations%is_original#0: bool = 1u
        let allocations%out#0: bytes = allocations#0
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (tmp%0#0: uint64, tmp%1#0: uint64, tmp%2#0: uint64, tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%0#0)
        let rewardsApp#0: uint64 = tmp%1#0
        let (calculateAllocationMBR%0#0: uint64, calculateAllocationMBR%1#0: bytes) = smart_contracts/pool/contract.algo.ts::Pool.calculateAllocationMBR(allocations#0)
        let allocations#1: bytes = calculateAllocationMBR%1#0
        goto allocations%is_original#0 ? block@1 : block@2
    block@1: // if_body_L1
        let allocations%out#1: bytes = allocations#1
        goto block@2
    block@2: // after_if_else_L1
        let allocations%out#3: bytes = φ(allocations%out#0 <- block@0, allocations%out#1 <- block@1)
        let mbrAmount#0: uint64 = (calculateAllocationMBR%0#0)
        let tmp%12#0: bool = (== asset#0 0u)
        goto tmp%12#0 ? block@3 : block@6
    block@3: // if_body_L530
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%0#0) // application exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ mbrAmount#0 sum#0)
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@4
    block@4: // next_txn_L535
        itxn_next
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = rewardsApp#0
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob disbursementID#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_0#0: bytes[4] = method "createUserAllocations(pay,uint64,(address,uint64)[])void"
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_2#0: bytes = allocations#1
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@5
    block@5: // next_txn_L532
        itxn_submit
        goto block@10
    block@6: // else_body_L544
        itxn_begin
        let inner_txn_params%2#0: itxn_field_set = itxn_field_set(2)
        let inner_txn_params%2%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%2%%Fee_length#0: uint64 = 1u
        let inner_txn_params%2%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%2%%TypeEnum_length#0: uint64 = 1u
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%1#0) // application exists
        let inner_txn_params%2%%param_Receiver_idx_0#0: bytes[32] = value%1#0
        let inner_txn_params%2%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%2%%param_Amount_idx_0#0: uint64 = mbrAmount#0
        let inner_txn_params%2%%Amount_length#0: uint64 = 1u
        let inner_txn_params%2%%Sender_length#0: uint64 = 0u
        let inner_txn_params%2%%Note_length#0: uint64 = 0u
        let inner_txn_params%2%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%2%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%2%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%2%%Type_length#0: uint64 = 0u
        let inner_txn_params%2%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%2%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%2%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%2%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%2%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%2%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%2%%Assets_length#0: uint64 = 0u
        let inner_txn_params%2%%Applications_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%2%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%2%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%2%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%2%%param_Fee_idx_0#0)
        goto block@7
    block@7: // next_txn_L549
        itxn_next
        let inner_txn_params%3#0: itxn_field_set = itxn_field_set(3)
        let inner_txn_params%3%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%3%%Fee_length#0: uint64 = 1u
        let inner_txn_params%3%%param_TypeEnum_idx_0#0: uint64 = 4u
        let inner_txn_params%3%%TypeEnum_length#0: uint64 = 1u
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%2#0) // application exists
        let inner_txn_params%3%%param_AssetReceiver_idx_0#0: bytes[32] = value%2#0
        let inner_txn_params%3%%AssetReceiver_length#0: uint64 = 1u
        let inner_txn_params%3%%param_XferAsset_idx_0#0: uint64 = asset#0
        let inner_txn_params%3%%XferAsset_length#0: uint64 = 1u
        let inner_txn_params%3%%param_AssetAmount_idx_0#0: uint64 = sum#0
        let inner_txn_params%3%%AssetAmount_length#0: uint64 = 1u
        let inner_txn_params%3%%Sender_length#0: uint64 = 0u
        let inner_txn_params%3%%Note_length#0: uint64 = 0u
        let inner_txn_params%3%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%3%%Amount_length#0: uint64 = 0u
        let inner_txn_params%3%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%3%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%3%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%3%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%3%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%3%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%3%%Type_length#0: uint64 = 0u
        let inner_txn_params%3%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%3%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%3%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%3%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%3%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%3%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%3%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%3%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%3%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%3%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%3%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%3%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%3%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%3%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%3%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%3%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%3%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%3%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%3%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%3%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%3%%Assets_length#0: uint64 = 0u
        let inner_txn_params%3%%Applications_length#0: uint64 = 0u
        let inner_txn_params%3%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%3%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field AssetAmount) inner_txn_params%3%%param_AssetAmount_idx_0#0)
        ((itxn_field XferAsset) inner_txn_params%3%%param_XferAsset_idx_0#0)
        ((itxn_field AssetReceiver) inner_txn_params%3%%param_AssetReceiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%3%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%3%%param_Fee_idx_0#0)
        goto block@8
    block@8: // next_txn_L554
        itxn_next
        let inner_txn_params%4#0: itxn_field_set = itxn_field_set(4)
        let inner_txn_params%4%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%4%%Fee_length#0: uint64 = 1u
        let inner_txn_params%4%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%4%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%4%%param_ApplicationID_idx_0#0: uint64 = rewardsApp#0
        let inner_txn_params%4%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%1#0: bytes[8] = (itob disbursementID#0)
        let inner_txn_params%4%%param_ApplicationArgs_idx_0#0: bytes[4] = method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void"
        let inner_txn_params%4%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%1#0
        let inner_txn_params%4%%param_ApplicationArgs_idx_2#0: bytes = allocations#1
        let inner_txn_params%4%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%4%%Sender_length#0: uint64 = 0u
        let inner_txn_params%4%%Note_length#0: uint64 = 0u
        let inner_txn_params%4%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%4%%Amount_length#0: uint64 = 0u
        let inner_txn_params%4%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%4%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%4%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%4%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%4%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%4%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%4%%Type_length#0: uint64 = 0u
        let inner_txn_params%4%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%4%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%4%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%4%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%4%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%4%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%4%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%4%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%4%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%4%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%4%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%4%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%4%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%4%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%4%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%4%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%4%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%4%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%4%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%4%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%4%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%4%%Assets_length#0: uint64 = 0u
        let inner_txn_params%4%%Applications_length#0: uint64 = 0u
        let inner_txn_params%4%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%4%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%4%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%4%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%4%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%4%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%4%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%4%%param_Fee_idx_0#0)
        goto block@9
    block@9: // next_txn_L546
        itxn_submit
        goto block@10
    block@10: // after_if_else_L530
        return allocations%out#3

subroutine smart_contracts/pool/contract.algo.ts::Pool.finalizeRewards(disbursementID: uint64) -> void:
    block@0: // L567
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (tmp%0#0: uint64, tmp%1#0: uint64, tmp%2#0: uint64, tmp%3#0: uint64, tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%0#0)
        let rewardsApp#0: uint64 = tmp%1#0
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = rewardsApp#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob disbursementID#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "finalizeDisbursement(uint64)void"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@1
    block@1: // next_txn_L570
        itxn_submit
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.calculateAllocationMBR(allocations: bytes) -> <uint64, bytes>:
    block@0: // L577
        let allocations%is_original#0: bool = 1u
        let allocations%out#0: bytes = allocations#0
        let tmp%0#0: uint64 = (extract_uint16 allocations#0 0u)
        let tmp%1#0: uint64 = (* 24900u tmp%0#0)
        return tmp%1#0 allocations#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.create(title: bytes, type: bytes[1], reward: bytes[33], creator: bytes[32], marketplace: bytes[32], stakeKey: bytes, minimumStakeAmount: uint64, gateID: uint64, maxEntries: uint64, akitaDAO: uint64) -> void:
    block@0: // L583
        (app_global_put "status" 0x00)
        (app_global_put "title" title#0)
        (app_global_put "type" type#0)
        let copy%0#0: bytes[33] = reward#0
        (app_global_put "reward" copy%0#0)
        let item0%0#0: bytes = (extract3 reward#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reward#0 8u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 reward#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reward#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reward#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let (decodedReward.asset#0: uint64, decodedReward.distribution#0: bytes[1], decodedReward.rate#0: uint64, decodedReward.expiration#0: uint64, decodedReward.winnerCount#0: uint64) = (item0%1#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0)
        let tmp%0#0: bool = (> decodedReward.rate#0 0u)
        (assert tmp%0#0) // Rate must be greater than zero
        (app_global_put "creator" creator#0)
        (app_global_put "marketplace" marketplace#0)
        let tmp%1#0: bytes = (extract3 stakeKey#0 0u 32u) // on error: Index access is out of bounds
        let tmp%2#0: bytes[32] = (global ZeroAddress)
        let tmp%3#0: bool = (!= tmp%1#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@1
    block@1: // or_contd_L611
        let tmp%4#0: bytes = (extract3 reward#0 8u 1u) // on error: Index access is out of bounds
        let tmp%5#0: bool = (!= tmp%4#0 0x00)
        goto tmp%5#0 ? block@2 : block@3
    block@2: // bool_true_L611
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L611
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L611
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Stake key required
        let tmp%6#0: bytes = (extract3 reward#0 8u 1u) // on error: Index access is out of bounds
        let tmp%7#0: bool = (== tmp%6#0 0x03)
        goto tmp%7#0 ? block@5 : block@6
    block@5: // if_body_L616
        let tmp%8#0: bool = (> decodedReward.rate#0 decodedReward.winnerCount#0)
        (assert tmp%8#0) // Rate must be greater than winner count
        goto block@6
    block@6: // after_if_else_L616
        let tmp%9#0: bytes = (extract3 reward#0 8u 1u) // on error: Index access is out of bounds
        let tmp%10#0: bool = (== tmp%9#0 0x02)
        goto tmp%10#0 ? block@7 : block@10
    block@7: // if_body_L620
        let tmp%11#0: bool = (< maxEntries#0 decodedReward.rate#0)
        (assert tmp%11#0) // Max entries cannot be greater than rate
        let tmp%12#0: bool = (== maxEntries#0 0u)
        goto tmp%12#0 ? block@8 : block@9
    block@8: // if_body_L622
        let maxEntries#4: uint64 = decodedReward.rate#0
        goto block@9
    block@9: // after_if_else_L622
        let maxEntries#6: uint64 = φ(maxEntries#0 <- block@7, maxEntries#4 <- block@8)
        goto block@10
    block@10: // after_if_else_L620
        let maxEntries#5: uint64 = φ(maxEntries#0 <- block@6, maxEntries#6 <- block@9)
        let copy%1#0: bytes = stakeKey#0
        (app_global_put "stake_key" copy%1#0)
        (app_global_put "minimum_stake_amount" minimumStakeAmount#0)
        (app_global_put "gate_id" gateID#0)
        (app_global_put "max_entries" maxEntries#5)
        (app_global_put "akita_dao" akitaDAO#0)
        let materialized_values%0#0: bytes[32] = (txn TxID)
        (app_global_put "salt" materialized_values%0#0)
        (app_global_put "disbursement_phase" 0x00)
        (app_global_put "active_disbursement_id" 0u)
        (app_global_put "active_disbursement_window" 0u)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "qualified_stake" 0u)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        (app_global_put "wtickets" array_data%0#0)
        (app_global_put "vrf_failure_count" 0u)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.init() -> void:
    block@0: // L643
        let tmp%0#0: bytes[32] = (global CallerApplicationAddress)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0) // only the factory can init the pool
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%3#0: bool = (> maybe_value%0#0 0u)
        goto tmp%3#0 ? block@1 : block@3
    block@1: // if_body_L646
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (tmp%4#0: uint64, tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64, tmp%12#0: uint64, tmp%13#0: uint64, tmp%14#0: uint64, tmp%15#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%1#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%9#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%2#0) // check GlobalState exists
        let val_as_bytes%0#0: bytes[8] = (itob maybe_value%2#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "size(uint64)uint64"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@2
    block@2: // next_txn_L647
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%16#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%17#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%18#0: bool = (== tmp%17#0 0x151f7c75)
        (assert tmp%18#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%16#0
        let tmp%19#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        (app_global_put "gate_size" tmp%19#0)
        goto block@3
    block@3: // after_if_else_L646
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.deleteApplication(caller: bytes[32]) -> void:
    block@0: // L655
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0) // call must come from factory
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%3#0: bool = (== caller#0 maybe_value%0#0)
        (assert tmp%3#0) // only the creator can delete the pool
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%4#0: bool = (== maybe_value%1#0 0x00)
        goto tmp%4#0 ? block@2 : block@1
    block@1: // or_contd_L659
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%6#0: bool = (> tmp%5#0 maybe_value%2#0)
        goto tmp%6#0 ? block@2 : block@3
    block@2: // bool_true_L659
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L659
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L659
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // the pool must be in draft or ended
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) -> void:
    block@0: // L664
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // only the creator can finalize the pool
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%1#0 0x00)
        (assert tmp%2#0) // the pool must be in draft state to finalize
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let tmp%4#0: bool = (> signupTimestamp#0 tmp%3#0)
        goto tmp%4#0 ? block@3 : block@1
    block@1: // or_contd_L668
        let tmp%5#0: bool = (== signupTimestamp#0 0u)
        goto tmp%5#0 ? block@2 : block@4
    block@2: // and_contd_L668
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%2#0) // check GlobalState exists
        goto maybe_value%2#0 ? block@3 : block@4
    block@3: // bool_true_L668
        let or_result%0#0: bool = 1u
        goto block@5
    block@4: // bool_false_L668
        let or_result%0#1: bool = 0u
        goto block@5
    block@5: // bool_merge_L668
        let or_result%0#2: bool = φ(or_result%0#0 <- block@3, or_result%0#1 <- block@4)
        (assert or_result%0#2) // the signup round must be zero and late sign ups allowed or in the future
        let tmp%6#0: bool = (== startTimestamp#0 0u)
        goto tmp%6#0 ? block@7 : block@6
    block@6: // or_contd_L673
        let tmp%7#0: uint64 = (global LatestTimestamp)
        let tmp%8#0: bool = (> startTimestamp#0 tmp%7#0)
        goto tmp%8#0 ? block@7 : block@8
    block@7: // bool_true_L673
        let or_result%1#0: bool = 1u
        goto block@9
    block@8: // bool_false_L673
        let or_result%1#1: bool = 0u
        goto block@9
    block@9: // bool_merge_L673
        let or_result%1#2: bool = φ(or_result%1#0 <- block@7, or_result%1#1 <- block@8)
        (assert or_result%1#2) // the starting round must be zero or in the future
        let tmp%9#0: bool = (== startTimestamp#0 0u)
        goto tmp%9#0 ? block@10 : block@15
    block@10: // if_body_L678
        let tmp%10#0: bool = (== signupTimestamp#0 0u)
        goto tmp%10#0 ? block@11 : block@13
    block@11: // and_contd_L679
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%3#0) // check GlobalState exists
        goto maybe_value%3#0 ? block@12 : block@13
    block@12: // bool_true_L679
        let and_result%0#0: bool = 1u
        goto block@14
    block@13: // bool_false_L679
        let and_result%0#1: bool = 0u
        goto block@14
    block@14: // bool_merge_L679
        let and_result%0#2: bool = φ(and_result%0#0 <- block@12, and_result%0#1 <- block@13)
        (assert and_result%0#2) // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
        let startTimestamp#6: uint64 = (global LatestTimestamp)
        goto block@15
    block@15: // after_if_else_L678
        let startTimestamp#7: uint64 = φ(startTimestamp#0 <- block@9, startTimestamp#6 <- block@14)
        let tmp%11#0: bool = (== endTimestamp#0 0u)
        goto tmp%11#0 ? block@17 : block@16
    block@16: // or_contd_L684
        let tmp%12#0: uint64 = (+ startTimestamp#7 10u)
        let tmp%13#0: bool = (> endTimestamp#0 tmp%12#0)
        goto tmp%13#0 ? block@17 : block@18
    block@17: // bool_true_L684
        let or_result%2#0: bool = 1u
        goto block@19
    block@18: // bool_false_L684
        let or_result%2#1: bool = 0u
        goto block@19
    block@19: // bool_merge_L684
        let or_result%2#2: bool = φ(or_result%2#0 <- block@17, or_result%2#1 <- block@18)
        (assert or_result%2#2) // the ending round must be zero or after the starting round + 10
        (app_global_put "signup_timestamp" signupTimestamp#0)
        (app_global_put "start_timestamp" startTimestamp#7)
        (app_global_put "end_timestamp" endTimestamp#0)
        (app_global_put "status" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.enter(payment: uint64, entries: (encoded_uint64,encoded_uint64,bytes[32][])[], args: bytes[]) -> void:
    block@0: // L694
        let tmp%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        (assert tmp%0#0) // the pool is not live
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bytes[32] = (txn Sender)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%0#0, tmp%1#0, maybe_value%1#0, args#0)
        (assert tmp%2#0) // user does not meet gate requirements
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%3#0: uint64 = (+ maybe_value%2#0 1u)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: bool = (< tmp%3#0 maybe_value%3#0)
        goto tmp%4#0 ? block@2 : block@1
    block@1: // or_contd_L702
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%4#0) // check GlobalState exists
        let tmp%5#0: bool = (== maybe_value%4#0 0u)
        goto tmp%5#0 ? block@2 : block@3
    block@2: // bool_true_L702
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L702
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L702
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // pool has reached maximum entries
        let tmp%6#0: bytes[32] = ((gtxns Receiver) payment#0)
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (== tmp%6#0 tmp%7#0)
        (assert tmp%8#0) // Invalid payment receiver
        let (costs.entries#0: uint64, costs.entriesByAddress#0: uint64, costs.disbursements#0: uint64) = smart_contracts/pool/base.ts::BasePool.mbr()
        let entryMBR#0: uint64 = (+ costs.entries#0 costs.entriesByAddress#0)
        let tmp%9#0: uint64 = ((gtxns Amount) payment#0)
        let tmp%10#0: uint64 = (extract_uint16 entries#0 0u)
        let tmp%11#0: uint64 = (* entryMBR#0 tmp%10#0)
        let tmp%12#0: bool = (== tmp%9#0 tmp%11#0)
        (assert tmp%12#0) // Invalid payment amount
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L714
        let i#1: uint64 = φ(i#0 <- block@4, i#6 <- block@15)
        let tmp%13#0: uint64 = (extract_uint16 entries#0 0u)
        let tmp%14#0: bool = (< i#1 tmp%13#0)
        goto tmp%14#0 ? block@6 : block@16
    block@6: // while_body_L714
        let array_head_and_tail%0#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%0#0: uint64 = (* i#1 2u)
        let item_offset%0#0: uint64 = (extract_uint16 array_head_and_tail%0#0 item_offset_offset%0#0)
        let array_length%0#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%0#0: uint64 = (+ i#1 1u)
        let has_next%0#0: uint64 = (- array_length%0#0 next_index%0#0) // on error: Index access is out of bounds
        let end_of_array%0#0: uint64 = (len array_head_and_tail%0#0)
        let next_item_offset_offset%0#0: uint64 = (* next_index%0#0 2u)
        let next_item_offset%0#0: uint64 = (extract_uint16 array_head_and_tail%0#0 next_item_offset_offset%0#0)
        let end_offset%0#0: uint64 = (select end_of_array%0#0 next_item_offset%0#0 has_next%0#0)
        let arc4_item%0#0: bytes = (substring3 array_head_and_tail%0#0 item_offset%0#0 end_offset%0#0)
        let item0%0#0: bytes = (extract3 arc4_item%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 arc4_item%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 arc4_item%0#0 16u)
        let item_end_offset%0#0: uint64 = (len arc4_item%0#0)
        let item2%0#0: bytes = (substring3 arc4_item%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "minimum_stake_amount")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%15#0: bool = (>= item1%1#0 maybe_value%5#0)
        (assert tmp%15#0) // quantity is less than minimum stake amount
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%6#0) // check GlobalState exists
        let tmp%16#0: bool = (== maybe_value%6#0 0x01)
        goto tmp%16#0 ? block@8 : block@7
    block@7: // or_contd_L719
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%7#0) // check GlobalState exists
        let tmp%17#0: bool = (== maybe_value%7#0 0x02)
        goto tmp%17#0 ? block@8 : block@13
    block@8: // if_body_L721
        let tmp%18#0: bytes[32] = (txn Sender)
        let array_head_and_tail%1#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%1#0: uint64 = (* i#1 2u)
        let item_offset%1#0: uint64 = (extract_uint16 array_head_and_tail%1#0 item_offset_offset%1#0)
        let array_length%1#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%1#0: uint64 = (+ i#1 1u)
        let has_next%1#0: uint64 = (- array_length%1#0 next_index%1#0) // on error: Index access is out of bounds
        let end_of_array%1#0: uint64 = (len array_head_and_tail%1#0)
        let next_item_offset_offset%1#0: uint64 = (* next_index%1#0 2u)
        let next_item_offset%1#0: uint64 = (extract_uint16 array_head_and_tail%1#0 next_item_offset_offset%1#0)
        let end_offset%1#0: uint64 = (select end_of_array%1#0 next_item_offset%1#0 has_next%1#0)
        let arc4_item%1#0: bytes = (substring3 array_head_and_tail%1#0 item_offset%1#0 end_offset%1#0)
        let item0%2#0: bytes = (extract3 arc4_item%1#0 0u 8u) // on error: Index access is out of bounds
        let item0%3#0: uint64 = (btoi item0%2#0)
        let item1%2#0: bytes = (extract3 arc4_item%1#0 8u 8u) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (btoi item1%2#0)
        let item_start_offset%1#0: uint64 = (extract_uint16 arc4_item%1#0 16u)
        let item_end_offset%1#0: uint64 = (len arc4_item%1#0)
        let item2%1#0: bytes = (substring3 arc4_item%1#0 item_start_offset%1#0 item_end_offset%1#0)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: bool) = ((asset_holding_get AssetBalance) tmp%18#0 item0%3#0)
        let balance#0: uint64 = tuple_assignment%0#0
        let optedIn#0: bool = tuple_assignment%1#0
        goto optedIn#0 ? block@9 : block@11
    block@9: // and_contd_L723
        let array_head_and_tail%2#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%2#0: uint64 = (* i#1 2u)
        let item_offset%2#0: uint64 = (extract_uint16 array_head_and_tail%2#0 item_offset_offset%2#0)
        let array_length%2#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%2#0: uint64 = (+ i#1 1u)
        let has_next%2#0: uint64 = (- array_length%2#0 next_index%2#0) // on error: Index access is out of bounds
        let end_of_array%2#0: uint64 = (len array_head_and_tail%2#0)
        let next_item_offset_offset%2#0: uint64 = (* next_index%2#0 2u)
        let next_item_offset%2#0: uint64 = (extract_uint16 array_head_and_tail%2#0 next_item_offset_offset%2#0)
        let end_offset%2#0: uint64 = (select end_of_array%2#0 next_item_offset%2#0 has_next%2#0)
        let arc4_item%2#0: bytes = (substring3 array_head_and_tail%2#0 item_offset%2#0 end_offset%2#0)
        let item0%4#0: bytes = (extract3 arc4_item%2#0 0u 8u) // on error: Index access is out of bounds
        let item0%5#0: uint64 = (btoi item0%4#0)
        let item1%4#0: bytes = (extract3 arc4_item%2#0 8u 8u) // on error: Index access is out of bounds
        let item1%5#0: uint64 = (btoi item1%4#0)
        let item_start_offset%2#0: uint64 = (extract_uint16 arc4_item%2#0 16u)
        let item_end_offset%2#0: uint64 = (len arc4_item%2#0)
        let item2%2#0: bytes = (substring3 arc4_item%2#0 item_start_offset%2#0 item_end_offset%2#0)
        let tmp%19#0: bool = (>= balance#0 item1%5#0)
        goto tmp%19#0 ? block@10 : block@11
    block@10: // bool_true_L723
        let and_result%0#0: bool = 1u
        goto block@12
    block@11: // bool_false_L723
        let and_result%0#1: bool = 0u
        goto block@12
    block@12: // bool_merge_L723
        let and_result%0#2: bool = φ(and_result%0#0 <- block@10, and_result%0#1 <- block@11)
        (assert and_result%0#2) // user does not have min balance
        goto block@13
    block@13: // after_if_else_L718
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%8#0) // check GlobalState exists
        let (tmp%20#0: uint64, tmp%21#0: uint64, tmp%22#0: uint64, tmp%23#0: uint64, tmp%24#0: uint64, tmp%25#0: uint64, tmp%26#0: uint64, tmp%27#0: uint64, tmp%28#0: uint64, tmp%29#0: uint64, tmp%30#0: uint64, tmp%31#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%8#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%20#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let tmp%32#0: bytes[32] = (txn Sender)
        let array_head_and_tail%3#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%3#0: uint64 = (* i#1 2u)
        let item_offset%3#0: uint64 = (extract_uint16 array_head_and_tail%3#0 item_offset_offset%3#0)
        let array_length%3#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%3#0: uint64 = (+ i#1 1u)
        let has_next%3#0: uint64 = (- array_length%3#0 next_index%3#0) // on error: Index access is out of bounds
        let end_of_array%3#0: uint64 = (len array_head_and_tail%3#0)
        let next_item_offset_offset%3#0: uint64 = (* next_index%3#0 2u)
        let next_item_offset%3#0: uint64 = (extract_uint16 array_head_and_tail%3#0 next_item_offset_offset%3#0)
        let end_offset%3#0: uint64 = (select end_of_array%3#0 next_item_offset%3#0 has_next%3#0)
        let arc4_item%3#0: bytes = (substring3 array_head_and_tail%3#0 item_offset%3#0 end_offset%3#0)
        let item0%6#0: bytes = (extract3 arc4_item%3#0 0u 8u) // on error: Index access is out of bounds
        let item0%7#0: uint64 = (btoi item0%6#0)
        let item1%6#0: bytes = (extract3 arc4_item%3#0 8u 8u) // on error: Index access is out of bounds
        let item1%7#0: uint64 = (btoi item1%6#0)
        let item_start_offset%3#0: uint64 = (extract_uint16 arc4_item%3#0 16u)
        let item_end_offset%3#0: uint64 = (len arc4_item%3#0)
        let item2%3#0: bytes = (substring3 arc4_item%3#0 item_start_offset%3#0 item_end_offset%3#0)
        let val_as_bytes%0#0: bytes[8] = (itob item0%7#0)
        let tmp%33#0: bytes[1] = smart_contracts/pool/contract.algo.ts::Pool.stakingType()
        let current_tail_offset%0#0: uint64 = 9u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 tmp%33#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = tmp%32#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes = encoded_tuple_buffer%2#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@14
    block@14: // next_txn_L726
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%34#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%35#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%36#0: bool = (== tmp%35#0 0x151f7c75)
        (assert tmp%36#0) // Bytes has valid prefix
        let reinterpret_bytes[24]%0#0: bytes[24] = tmp%34#0
        let item0%8#0: bytes = (extract3 reinterpret_bytes[24]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%9#0: uint64 = (btoi item0%8#0)
        let item1%8#0: bytes = (extract3 reinterpret_bytes[24]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%9#0: uint64 = (btoi item1%8#0)
        let item2%4#0: bytes = (extract3 reinterpret_bytes[24]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%5#0: uint64 = (btoi item2%4#0)
        let (stakeInfo.amount#0: uint64, stakeInfo.lastUpdate#0: uint64, stakeInfo.expiration#0: uint64) = (item0%9#0, item1%9#0, item2%5#0)
        let array_head_and_tail%4#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%4#0: uint64 = (* i#1 2u)
        let item_offset%4#0: uint64 = (extract_uint16 array_head_and_tail%4#0 item_offset_offset%4#0)
        let array_length%4#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%4#0: uint64 = (+ i#1 1u)
        let has_next%4#0: uint64 = (- array_length%4#0 next_index%4#0) // on error: Index access is out of bounds
        let end_of_array%4#0: uint64 = (len array_head_and_tail%4#0)
        let next_item_offset_offset%4#0: uint64 = (* next_index%4#0 2u)
        let next_item_offset%4#0: uint64 = (extract_uint16 array_head_and_tail%4#0 next_item_offset_offset%4#0)
        let end_offset%4#0: uint64 = (select end_of_array%4#0 next_item_offset%4#0 has_next%4#0)
        let arc4_item%4#0: bytes = (substring3 array_head_and_tail%4#0 item_offset%4#0 end_offset%4#0)
        let item0%10#0: bytes = (extract3 arc4_item%4#0 0u 8u) // on error: Index access is out of bounds
        let item0%11#0: uint64 = (btoi item0%10#0)
        let item1%10#0: bytes = (extract3 arc4_item%4#0 8u 8u) // on error: Index access is out of bounds
        let item1%11#0: uint64 = (btoi item1%10#0)
        let item_start_offset%4#0: uint64 = (extract_uint16 arc4_item%4#0 16u)
        let item_end_offset%4#0: uint64 = (len arc4_item%4#0)
        let item2%6#0: bytes = (substring3 arc4_item%4#0 item_start_offset%4#0 item_end_offset%4#0)
        let tmp%37#0: bool = (>= stakeInfo.amount#0 item1%11#0)
        (assert tmp%37#0) // user does not have enough staked
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (app_global_get_ex 0u "stake_key")
        (assert maybe_exists%9#0) // check GlobalState exists
        let item0%12#0: bytes = (extract3 maybe_value%9#0 0u 32u) // on error: Index access is out of bounds
        let item_start_offset%5#0: uint64 = (extract_uint16 maybe_value%9#0 32u)
        let item_end_offset%5#0: uint64 = (len maybe_value%9#0)
        let item1%12#0: bytes = (substring3 maybe_value%9#0 item_start_offset%5#0 item_end_offset%5#0)
        let item1%13#0: bytes = ((extract 2 0) item1%12#0)
        let address#0: bytes[32] = item0%12#0
        let name#0: bytes = item1%13#0
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%10#0) // check GlobalState exists
        let (tmp%38#0: uint64, tmp%39#0: uint64, tmp%40#0: uint64, tmp%41#0: uint64, tmp%42#0: uint64, tmp%43#0: uint64, tmp%44#0: uint64, tmp%45#0: uint64, tmp%46#0: uint64, tmp%47#0: uint64, tmp%48#0: uint64, tmp%49#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%10#0)
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = tmp%47#0
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 1u
        let length%0#0: uint64 = (len name#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 name#0)
        let array_head_and_tail%5#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%5#0: uint64 = (* i#1 2u)
        let item_offset%5#0: uint64 = (extract_uint16 array_head_and_tail%5#0 item_offset_offset%5#0)
        let array_length%5#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%5#0: uint64 = (+ i#1 1u)
        let has_next%5#0: uint64 = (- array_length%5#0 next_index%5#0) // on error: Index access is out of bounds
        let end_of_array%5#0: uint64 = (len array_head_and_tail%5#0)
        let next_item_offset_offset%5#0: uint64 = (* next_index%5#0 2u)
        let next_item_offset%5#0: uint64 = (extract_uint16 array_head_and_tail%5#0 next_item_offset_offset%5#0)
        let end_offset%5#0: uint64 = (select end_of_array%5#0 next_item_offset%5#0 has_next%5#0)
        let arc4_item%5#0: bytes = (substring3 array_head_and_tail%5#0 item_offset%5#0 end_offset%5#0)
        let item0%13#0: bytes = (extract3 arc4_item%5#0 0u 8u) // on error: Index access is out of bounds
        let item0%14#0: uint64 = (btoi item0%13#0)
        let item1%14#0: bytes = (extract3 arc4_item%5#0 8u 8u) // on error: Index access is out of bounds
        let item1%15#0: uint64 = (btoi item1%14#0)
        let item_start_offset%6#0: uint64 = (extract_uint16 arc4_item%5#0 16u)
        let item_end_offset%6#0: uint64 = (len arc4_item%5#0)
        let item2%7#0: bytes = (substring3 arc4_item%5#0 item_start_offset%6#0 item_end_offset%6#0)
        let tmp%50#0: bytes[8] = (itob item0%14#0)
        let tmp%51#0: bytes[32] = (sha256 tmp%50#0)
        let to_encode%0#0: bytes[32] = (sha256 tmp%51#0)
        let length%1#0: uint64 = (len to_encode%0#0)
        let lengths_equal%0#0: bool = (== length%1#0 32u)
        (assert lengths_equal%0#0) // invalid size
        let array_head_and_tail%6#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%6#0: uint64 = (* i#1 2u)
        let item_offset%6#0: uint64 = (extract_uint16 array_head_and_tail%6#0 item_offset_offset%6#0)
        let array_length%6#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%6#0: uint64 = (+ i#1 1u)
        let has_next%6#0: uint64 = (- array_length%6#0 next_index%6#0) // on error: Index access is out of bounds
        let end_of_array%6#0: uint64 = (len array_head_and_tail%6#0)
        let next_item_offset_offset%6#0: uint64 = (* next_index%6#0 2u)
        let next_item_offset%6#0: uint64 = (extract_uint16 array_head_and_tail%6#0 next_item_offset_offset%6#0)
        let end_offset%6#0: uint64 = (select end_of_array%6#0 next_item_offset%6#0 has_next%6#0)
        let arc4_item%6#0: bytes = (substring3 array_head_and_tail%6#0 item_offset%6#0 end_offset%6#0)
        let item0%15#0: bytes = (extract3 arc4_item%6#0 0u 8u) // on error: Index access is out of bounds
        let item0%16#0: uint64 = (btoi item0%15#0)
        let item1%16#0: bytes = (extract3 arc4_item%6#0 8u 8u) // on error: Index access is out of bounds
        let item1%17#0: uint64 = (btoi item1%16#0)
        let item_start_offset%7#0: uint64 = (extract_uint16 arc4_item%6#0 16u)
        let item_end_offset%7#0: uint64 = (len arc4_item%6#0)
        let item2%8#0: bytes = (substring3 arc4_item%6#0 item_start_offset%7#0 item_end_offset%7#0)
        let val_as_bytes%1#0: bytes[8] = (itob 1u)
        let inner_txn_params%1%%param_ApplicationArgs_idx_0#0: bytes[4] = method "verify(address,string,byte[32],byte[32][],uint64)bool"
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[32] = address#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_2#0: bytes = encoded_value%0#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_3#0: bytes[32] = to_encode%0#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_4#0: bytes = item2%8#0
        let inner_txn_params%1%%param_ApplicationArgs_idx_5#0: bytes[8] = val_as_bytes%1#0
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 6u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_3#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_4#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_5#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@15
    block@15: // next_txn_L741
        itxn_submit
        let awst_tmp%1#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%52#0: bytes = ((extract 4 0) awst_tmp%1#0)
        let tmp%53#0: bytes = ((extract 0 4) awst_tmp%1#0)
        let tmp%54#0: bool = (== tmp%53#0 0x151f7c75)
        (assert tmp%54#0) // Bytes has valid prefix
        let reinterpret_bytes[1]%0#0: bytes[1] = tmp%52#0
        let tmp%55#0: bool = (getbit reinterpret_bytes[1]%0#0 0u)
        let verified#0: bool = tmp%55#0
        (assert verified#0) // failed to verify stake requirements
        let entryID#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.newEntryID()
        let tmp%56#0: bytes[32] = (txn Sender)
        let array_head_and_tail%7#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%7#0: uint64 = (* i#1 2u)
        let item_offset%7#0: uint64 = (extract_uint16 array_head_and_tail%7#0 item_offset_offset%7#0)
        let array_length%7#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%7#0: uint64 = (+ i#1 1u)
        let has_next%7#0: uint64 = (- array_length%7#0 next_index%7#0) // on error: Index access is out of bounds
        let end_of_array%7#0: uint64 = (len array_head_and_tail%7#0)
        let next_item_offset_offset%7#0: uint64 = (* next_index%7#0 2u)
        let next_item_offset%7#0: uint64 = (extract_uint16 array_head_and_tail%7#0 next_item_offset_offset%7#0)
        let end_offset%7#0: uint64 = (select end_of_array%7#0 next_item_offset%7#0 has_next%7#0)
        let arc4_item%7#0: bytes = (substring3 array_head_and_tail%7#0 item_offset%7#0 end_offset%7#0)
        let item0%17#0: bytes = (extract3 arc4_item%7#0 0u 8u) // on error: Index access is out of bounds
        let item0%18#0: uint64 = (btoi item0%17#0)
        let item1%18#0: bytes = (extract3 arc4_item%7#0 8u 8u) // on error: Index access is out of bounds
        let item1%19#0: uint64 = (btoi item1%18#0)
        let item_start_offset%8#0: uint64 = (extract_uint16 arc4_item%7#0 16u)
        let item_end_offset%8#0: uint64 = (len arc4_item%7#0)
        let item2%9#0: bytes = (substring3 arc4_item%7#0 item_start_offset%8#0 item_end_offset%8#0)
        let array_head_and_tail%8#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%8#0: uint64 = (* i#1 2u)
        let item_offset%8#0: uint64 = (extract_uint16 array_head_and_tail%8#0 item_offset_offset%8#0)
        let array_length%8#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%8#0: uint64 = (+ i#1 1u)
        let has_next%8#0: uint64 = (- array_length%8#0 next_index%8#0) // on error: Index access is out of bounds
        let end_of_array%8#0: uint64 = (len array_head_and_tail%8#0)
        let next_item_offset_offset%8#0: uint64 = (* next_index%8#0 2u)
        let next_item_offset%8#0: uint64 = (extract_uint16 array_head_and_tail%8#0 next_item_offset_offset%8#0)
        let end_offset%8#0: uint64 = (select end_of_array%8#0 next_item_offset%8#0 has_next%8#0)
        let arc4_item%8#0: bytes = (substring3 array_head_and_tail%8#0 item_offset%8#0 end_offset%8#0)
        let item0%19#0: bytes = (extract3 arc4_item%8#0 0u 8u) // on error: Index access is out of bounds
        let item0%20#0: uint64 = (btoi item0%19#0)
        let item1%20#0: bytes = (extract3 arc4_item%8#0 8u 8u) // on error: Index access is out of bounds
        let item1%21#0: uint64 = (btoi item1%20#0)
        let item_start_offset%9#0: uint64 = (extract_uint16 arc4_item%8#0 16u)
        let item_end_offset%9#0: uint64 = (len arc4_item%8#0)
        let item2%10#0: bytes = (substring3 arc4_item%8#0 item_start_offset%9#0 item_end_offset%9#0)
        let encoded_value%1#0: bytes[8] = (itob entryID#0)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%1#0)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob item0%18#0)
        let val_as_bytes%3#0: bytes[8] = (itob item1%21#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u 0u)
        let current_tail_offset%1#0: uint64 = 51u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 tmp%56#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let as_bytes%1#0: bytes[8] = (itob current_tail_offset%1#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len args#0)
        let current_tail_offset%2#0: uint64 = (+ current_tail_offset%1#0 data_length%0#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 encoded_bool%0#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 args#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%9#0)
        let tmp%57#0: bytes[32] = (txn Sender)
        let array_head_and_tail%9#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%9#0: uint64 = (* i#1 2u)
        let item_offset%9#0: uint64 = (extract_uint16 array_head_and_tail%9#0 item_offset_offset%9#0)
        let array_length%9#0: uint64 = (extract_uint16 entries#0 0u)
        let next_index%9#0: uint64 = (+ i#1 1u)
        let has_next%9#0: uint64 = (- array_length%9#0 next_index%9#0) // on error: Index access is out of bounds
        let end_of_array%9#0: uint64 = (len array_head_and_tail%9#0)
        let next_item_offset_offset%9#0: uint64 = (* next_index%9#0 2u)
        let next_item_offset%9#0: uint64 = (extract_uint16 array_head_and_tail%9#0 next_item_offset_offset%9#0)
        let end_offset%9#0: uint64 = (select end_of_array%9#0 next_item_offset%9#0 has_next%9#0)
        let arc4_item%9#0: bytes = (substring3 array_head_and_tail%9#0 item_offset%9#0 end_offset%9#0)
        let item0%21#0: bytes = (extract3 arc4_item%9#0 0u 8u) // on error: Index access is out of bounds
        let item0%22#0: uint64 = (btoi item0%21#0)
        let item1%22#0: bytes = (extract3 arc4_item%9#0 8u 8u) // on error: Index access is out of bounds
        let item1%23#0: uint64 = (btoi item1%22#0)
        let item_start_offset%10#0: uint64 = (extract_uint16 arc4_item%9#0 16u)
        let item_end_offset%10#0: uint64 = (len arc4_item%9#0)
        let item2%11#0: bytes = (substring3 arc4_item%9#0 item_start_offset%10#0 item_end_offset%10#0)
        let val_as_bytes%4#0: bytes[8] = (itob item0%22#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%10#0: bytes[0] = 0x
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 tmp%57#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%4#0)
        let aKey#0: bytes[40] = encoded_tuple_buffer%12#0
        let box_prefixed_key%1#0: bytes = (concat "a" aKey#0)
        let encoded_value%2#0: bytes[8] = (itob entryID#0)
        (box_put box_prefixed_key%1#0 encoded_value%2#0)
        let i#6: uint64 = (+ i#1 1u)
        goto block@5
    block@16: // after_while_L714
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.withdraw() -> void:
    block@0: // L774
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.startDisbursement() -> void:
    block@0: // L776
        let tmp%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        (assert tmp%0#0) // the pool is not live
        let tmp%1#0: bool = smart_contracts/pool/contract.algo.ts::Pool.validWindow()
        (assert tmp%1#0) // distribution window is not open
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%0#0 0x00)
        (assert tmp%2#0) // distribution already in progress
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "title")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%3#0: bytes = (concat "" maybe_value%1#0)
        let tmp%4#0: bytes = (concat tmp%3#0 " - Rewards")
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let tmp%6#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%7#0: bytes = (extract3 maybe_value%2#0 17u 8u) // on error: Index access is out of bounds
        let tmp%8#0: uint64 = (btoi tmp%7#0)
        let tmp%9#0: uint64 = (+ tmp%6#0 tmp%8#0)
        let disbursementID#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.createRewards(tmp%4#0, tmp%5#0, tmp%9#0)
        (app_global_put "status" 0x14)
        (app_global_put "active_disbursement_id" disbursementID#0)
        let materialized_values%0#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart()
        (app_global_put "active_disbursement_window" materialized_values%0#0)
        let materialized_values%1#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_disbursement_timestamp" materialized_values%1#0)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "disbursement_phase" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.raffle() -> void:
    block@0: // L797
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x14)
        (assert tmp%0#0) // Invalid disbursement phase
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: uint64 = (extract_uint16 maybe_value%1#0 0u)
        let tmp%2#0: bool = (== tmp%1#0 0u)
        (assert tmp%2#0) // Winning tickets already exist
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "active_disbursement_window")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%3#0: uint64 = (+ maybe_value%2#0 1u)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "vrf_failure_count")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: uint64 = (* 4u maybe_value%3#0)
        let roundToUse#0: uint64 = (+ tmp%3#0 tmp%4#0)
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64) = smart_contracts/utils/functions.ts::getOtherAppList(maybe_value%4#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%5#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%0#0: bytes[8] = (itob roundToUse#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "salt")
        (assert maybe_exists%5#0) // check GlobalState exists
        let length%0#0: uint64 = (len maybe_value%5#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 maybe_value%5#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "get(uint64,byte[])byte[]"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes = encoded_value%0#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@1
    block@1: // next_txn_L803
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%8#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%9#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%10#0: bool = (== tmp%9#0 0x151f7c75)
        (assert tmp%10#0) // Bytes has valid prefix
        let tmp%11#0: bytes = ((extract 2 0) tmp%8#0)
        let seed#0: bytes = tmp%11#0
        let tmp%12#0: uint64 = (len seed#0)
        let tmp%13#0: bool = (== tmp%12#0 0u)
        goto tmp%13#0 ? block@2 : block@3
    block@2: // if_body_L812
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "vrf_failure_count")
        (assert maybe_exists%6#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%6#0 1u)
        (app_global_put "vrf_failure_count" materialized_values%0#0)
        return 
    block@3: // after_if_else_L812
        let length%1#0: uint64 = (len seed#0)
        let is_out_of_bounds%0#0: bool = (>= 0u length%1#0)
        let bounded_index%0#0: uint64 = (select 0u length%1#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 16u length%1#0)
        let bounded_index%1#0: uint64 = (select 16u length%1#0 is_out_of_bounds%1#0)
        let tmp%14#0: bytes = (substring3 seed#0 bounded_index%0#0 bounded_index%1#0)
        let (rngState.0#0: uint64, rngState.1#0: uint64) = smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::pcg64Init(tmp%14#0)
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%7#0) // check GlobalState exists
        let upperBound#0: uint64 = maybe_value%7#0
        let tmp%15#0: bool = (< upperBound#0 18446744073709551615u)
        goto tmp%15#0 ? block@4 : block@5
    block@4: // if_body_L822
        let upperBound#1: uint64 = (+ upperBound#0 1u)
        goto block@5
    block@5: // after_if_else_L822
        let upperBound#2: uint64 = φ(upperBound#0 <- block@3, upperBound#1 <- block@4)
        let (rngResult.0.0#0: uint64, rngResult.0.1#0: uint64, rngResult.1#0: bytes) = smart_contracts/utils/types/lib_pcg/pcg64.algo.ts::pcg64Random(rngState.0#0, rngState.1#0, 1u, upperBound#2, 15u)
        let copy%0#0: bytes = rngResult.1#0
        (app_global_put "wtickets" copy%0#0)
        (app_global_put "vrf_failure_count" 0u)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.disburseRewards(iterationAmount: uint64) -> void:
    block@0: // L831
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x14)
        (assert tmp%0#0) // pool is not in disbursement phase
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (== maybe_value%1#0 0x0a)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L834
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%2#0 0x14)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // bool_true_L834
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L834
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L834
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Not ready to disburse
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%3#0) // check GlobalState exists
        let reinterpret_bytes[33]%0#0: bytes[33] = maybe_value%3#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 8u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let (reward.asset#0: uint64, reward.distribution#0: bytes[1], reward.rate#0: uint64, reward.expiration#0: uint64, reward.winnerCount#0: uint64) = (item0%1#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%4#0) // check GlobalState exists
        let tmp%3#0: bool = (== maybe_value%4#0 0x0a)
        goto tmp%3#0 ? block@5 : block@6
    block@5: // if_body_L841
        smart_contracts/pool/contract.algo.ts::Pool.processPreparationPhase(iterationAmount#0)
        goto block@22
    block@6: // else_body_L843
        let tmp%4#0: bool = (== reward.distribution#0 0x00)
        goto tmp%4#0 ? block@7 : block@8
    block@7: // if_body_L844
        smart_contracts/pool/contract.algo.ts::Pool.createPercentageDisbursement(iterationAmount#0, reward.asset#0)
        goto block@21
    block@8: // else_body_L846
        let tmp%5#0: bool = (== reward.distribution#0 0x01)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L846
        smart_contracts/pool/contract.algo.ts::Pool.createFlatDisbursement(iterationAmount#0, reward.asset#0, reward.rate#0)
        goto block@20
    block@10: // else_body_L848
        let tmp%6#0: bool = (== reward.distribution#0 0x02)
        goto tmp%6#0 ? block@11 : block@12
    block@11: // if_body_L848
        smart_contracts/pool/contract.algo.ts::Pool.createEvenDisbursement(iterationAmount#0, reward.asset#0, reward.rate#0)
        goto block@19
    block@12: // else_body_L850
        let tmp%7#0: bool = (== reward.distribution#0 0x03)
        goto tmp%7#0 ? block@13 : block@17
    block@13: // if_body_L850
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%8#0: uint64 = (extract_uint16 maybe_value%5#0 0u)
        let tmp%9#0: bool = (== tmp%8#0 0u)
        goto tmp%9#0 ? block@14 : block@15
    block@14: // if_body_L851
        smart_contracts/pool/contract.algo.ts::Pool.raffle()
        goto block@16
    block@15: // else_body_L853
        smart_contracts/pool/contract.algo.ts::Pool.createShuffleDisbursement(iterationAmount#0, reward.asset#0, reward.rate#0)
        goto block@16
    block@16: // after_if_else_L851
        goto block@18
    block@17: // else_body_L856
        fail // unknown reward rate type
    block@18: // after_if_else_L850
        goto block@19
    block@19: // after_if_else_L848
        goto block@20
    block@20: // after_if_else_L846
        goto block@21
    block@21: // after_if_else_L844
        goto block@22
    block@22: // after_if_else_L841
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution() -> void:
    block@0: // L862
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x1e)
        (assert tmp%0#0) // Disbursement not ready for finalization
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%1#0) // check GlobalState exists
        smart_contracts/pool/contract.algo.ts::Pool.finalizeRewards(maybe_value%1#0)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%2#0) // check GlobalState exists
        let encoded_value%0#0: bytes[8] = (itob maybe_value%2#0)
        let box_prefixed_key%0#0: bytes = (concat "d" encoded_value%0#0)
        (box_create box_prefixed_key%0#0 0u)
        (app_global_put "active_disbursement_id" 0u)
        (app_global_put "disbursement_phase" 0x00)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "status" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.check(address: bytes[32], asset: uint64) -> <bool, uint64>:
    block@0: // L877
        let val_as_bytes%0#0: bytes[8] = (itob asset#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 address#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let key#0: bytes[40] = encoded_tuple_buffer%2#0
        let box_prefixed_key%0#0: bytes = (concat "a" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let maybe_value_converted%0#0: uint64 = (btoi maybe_value%0#0)
        let id#0: uint64 = maybe_value_converted%0#0
        let (awst_tmp%0#0: bool, awst_tmp%1#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.checkByID(id#0)
        return awst_tmp%0#0 awst_tmp%1#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen() -> bool:
    block@0: // L886
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // and_contd_L889
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "signup_timestamp")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (> tmp%1#0 maybe_value%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // and_contd_L889
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%4#0: bool = (< tmp%3#0 maybe_value%2#0)
        goto tmp%4#0 ? block@4 : block@3
    block@3: // or_contd_L891
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%3#0) // check GlobalState exists
        goto maybe_value%3#0 ? block@4 : block@5
    block@4: // bool_true_L889
        let and_result%0#0: bool = 1u
        goto block@6
    block@5: // bool_false_L889
        let and_result%0#1: bool = 0u
        goto block@6
    block@6: // bool_merge_L889
        let and_result%0#2: bool = φ(and_result%0#0 <- block@4, and_result%0#1 <- block@5)
        return and_result%0#2

subroutine smart_contracts/pool/contract.algo.ts::Pool.isLive() -> bool:
    block@0: // L896
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // and_contd_L899
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (>= tmp%1#0 maybe_value%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // and_contd_L899
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%4#0: bool = (<= tmp%3#0 maybe_value%2#0)
        goto tmp%4#0 ? block@4 : block@3
    block@3: // or_contd_L901
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%5#0: bool = (== maybe_value%3#0 0u)
        goto tmp%5#0 ? block@4 : block@5
    block@4: // bool_true_L899
        let and_result%0#0: bool = 1u
        goto block@6
    block@5: // bool_false_L899
        let and_result%0#1: bool = 0u
        goto block@6
    block@6: // bool_merge_L899
        let and_result%0#2: bool = φ(and_result%0#0 <- block@4, and_result%0#1 <- block@5)
        return and_result%0#2

subroutine smart_contracts/pool/contract.algo.ts::Pool.getState() -> <bytes[1], bytes, bytes[1], uint64, bytes[1], uint64, uint64, uint64, uint64, uint64, bool, uint64, uint64, uint64, uint64, bytes[32], bytes, uint64, uint64, bytes[32]>:
    block@0: // L905
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "title")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%3#0) // check GlobalState exists
        let reinterpret_bytes[33]%0#0: bytes[33] = maybe_value%3#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 8u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[33]%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "signup_timestamp")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%6#0) // check GlobalState exists
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%7#0) // check GlobalState exists
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%8#0) // check GlobalState exists
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#0) // check GlobalState exists
        let tmp%0#0: uint64 = (+ maybe_value%9#0 1u)
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "total_staked")
        (assert maybe_exists%10#0) // check GlobalState exists
        let (maybe_value%11#0: bytes, maybe_exists%11#0: bool) = (app_global_get_ex 0u "stake_key")
        (assert maybe_exists%11#0) // check GlobalState exists
        let item0%2#0: bytes = (extract3 maybe_value%11#0 0u 32u) // on error: Index access is out of bounds
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%11#0 32u)
        let item_end_offset%0#0: uint64 = (len maybe_value%11#0)
        let item1%1#0: bytes = (substring3 maybe_value%11#0 item_start_offset%0#0 item_end_offset%0#0)
        let item1%2#0: bytes = ((extract 2 0) item1%1#0)
        let (maybe_value%12#0: uint64, maybe_exists%12#0: bool) = (app_global_get_ex 0u "minimum_stake_amount")
        (assert maybe_exists%12#0) // check GlobalState exists
        let (maybe_value%13#0: uint64, maybe_exists%13#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%13#0) // check GlobalState exists
        let (maybe_value%14#0: bytes, maybe_exists%14#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%14#0) // check GlobalState exists
        return maybe_value%0#0 maybe_value%1#0 maybe_value%2#0 item0%1#0 item1%0#0 item2%1#0 item3%1#0 item4%1#0 maybe_value%4#0 maybe_value%6#0 maybe_value%5#0 maybe_value%7#0 maybe_value%8#0 tmp%0#0 maybe_value%10#0 item0%2#0 item1%2#0 maybe_value%12#0 maybe_value%13#0 maybe_value%14#0

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
    block@0: // L19
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "version" newVersion#0)
        return 

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
    block@0: // L27
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "akita_dao" app#0)
        return 

subroutine smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn.optin(payment: uint64, asset: uint64) -> void:
    block@0: // L51
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0)
        let tmp%3#0: bytes[32] = ((gtxns Receiver) payment#0)
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (== tmp%3#0 tmp%4#0)
        goto tmp%5#0 ? block@1 : block@3
    block@1: // and_contd_L54
        let tmp%6#0: uint64 = ((gtxns Amount) payment#0)
        let tmp%7#0: uint64 = (global AssetOptInMinBalance)
        let tmp%8#0: bool = (== tmp%6#0 tmp%7#0)
        goto tmp%8#0 ? block@2 : block@3
    block@2: // bool_true_L54
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L54
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L54
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // Invalid payment
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 4u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%0%%param_AssetReceiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 1u
        let inner_txn_params%0%%param_AssetAmount_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 1u
        let inner_txn_params%0%%param_XferAsset_idx_0#0: uint64 = asset#0
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 1u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field XferAsset) inner_txn_params%0%%param_XferAsset_idx_0#0)
        ((itxn_field AssetAmount) inner_txn_params%0%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) inner_txn_params%0%%param_AssetReceiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@5
    block@5: // next_txn_L63
        itxn_submit
        return 

subroutine smart_contracts/pool/base.ts::BasePool.mbr() -> <uint64, uint64, uint64>:
    block@0: // L6
        return 25300u 25300u 6100u

subroutine polytype/lib/polytype-module.d.ts::ClusteredContract<smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract,smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn,smart_contracts/pool/base.ts::BasePool>.constructor() -> void:
    block@0: // L1
        @algorandfoundation/algorand-typescript/base-contract.d.ts::BaseContract.constructor()
        @algorandfoundation/algorand-typescript/base-contract.d.ts::BaseContract.constructor()
        @algorandfoundation/algorand-typescript/base-contract.d.ts::BaseContract.constructor()
        return 

subroutine @algorandfoundation/algorand-typescript/base-contract.d.ts::BaseContract.constructor() -> void:
    block@0: // L1
        return 