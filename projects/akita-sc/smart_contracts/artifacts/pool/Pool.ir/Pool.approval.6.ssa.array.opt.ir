main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        let tmp%0#1: uint64 = (txn NumAppArgs)
        goto tmp%0#1 ? block@4 : block@26
    block@4: // abi_routing_L99
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "create(string,uint8,(uint64,uint8,uint64,uint64,uint64),address,address,(address,string),uint64,uint64,uint64,uint64)void" => block@5, method "init()void" => block@6, method "deleteApplication(address)void" => block@7, method "finalize(uint64,uint64,uint64)void" => block@8, method "enter(pay,(uint64,uint64,byte[32][])[],byte[][])void" => block@9, method "withdraw()void" => block@10, method "startDisbursement()void" => block@11, method "raffle()void" => block@12, method "disburseRewards(uint64)void" => block@13, method "finalizeDistribution()void" => block@14, method "check(address,uint64)(bool,uint64)" => block@15, method "signUpsOpen()bool" => block@16, method "isLive()bool" => block@17, method "getState()(uint8,string,uint8,(uint64,uint8,uint64,uint64,uint64),uint64,uint64,bool,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)" => block@18, method "update(string)void" => block@19, method "updateAkitaDAO(uint64)void" => block@20, method "optin(pay,uint64)void" => block@21, method "mbr()(uint64,uint64,uint64)" => block@22, * => block@26}
    block@5: // create_route_L583
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (! tmp%5#0)
        (assert tmp%6#0) // can only call when creating
        let tmp%7#0: bytes = (txna ApplicationArgs 1)
        let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        let reinterpret_bytes[33]%0#0: bytes[33] = (txna ApplicationArgs 3)
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 4)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 5)
        let tmp%9#0: bytes = (txna ApplicationArgs 6)
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%10#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 8)
        let tmp%11#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 9)
        let tmp%12#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 10)
        let tmp%13#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        smart_contracts/pool/contract.algo.ts::Pool.create(tmp%8#0, reinterpret_bytes[1]%0#0, reinterpret_bytes[33]%0#0, reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0, tmp%9#0, tmp%10#0, tmp%11#0, tmp%12#0, tmp%13#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#0: bool = 1u
        goto block@27
    block@6: // init_route_L643
        let tmp%14#0: uint64 = (txn OnCompletion)
        let tmp%15#0: bool = (! tmp%14#0)
        (assert tmp%15#0) // OnCompletion is not NoOp
        let tmp%16#0: uint64 = (txn ApplicationID)
        (assert tmp%16#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.init()
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#1: bool = 1u
        goto block@27
    block@7: // deleteApplication_route_L655
        let tmp%18#0: uint64 = (txn OnCompletion)
        let tmp%19#0: bool = (== tmp%18#0 DeleteApplication)
        (assert tmp%19#0) // OnCompletion is not DeleteApplication
        let tmp%20#0: uint64 = (txn ApplicationID)
        (assert tmp%20#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        smart_contracts/pool/contract.algo.ts::Pool.deleteApplication(reinterpret_bytes[32]%2#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#2: bool = 1u
        goto block@27
    block@8: // finalize_route_L664
        let tmp%22#0: uint64 = (txn OnCompletion)
        let tmp%23#0: bool = (! tmp%22#0)
        (assert tmp%23#0) // OnCompletion is not NoOp
        let tmp%24#0: uint64 = (txn ApplicationID)
        (assert tmp%24#0) // can only call when not creating
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%26#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%27#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%28#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        smart_contracts/pool/contract.algo.ts::Pool.finalize(tmp%26#0, tmp%27#0, tmp%28#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#3: bool = 1u
        goto block@27
    block@9: // enter_route_L694
        let tmp%29#0: uint64 = (txn OnCompletion)
        let tmp%30#0: bool = (! tmp%29#0)
        (assert tmp%30#0) // OnCompletion is not NoOp
        let tmp%31#0: uint64 = (txn ApplicationID)
        (assert tmp%31#0) // can only call when not creating
        let tmp%33#0: uint64 = (txn GroupIndex)
        let gtxn_idx%0#0: uint64 = (- tmp%33#0 1u)
        let gtxn_type%0#0: uint64 = ((gtxns TypeEnum) gtxn_idx%0#0)
        let gtxn_type_matches%0#0: bool = (== gtxn_type%0#0 pay)
        (assert gtxn_type_matches%0#0) // transaction type is pay
        let reinterpret_(encoded_uint64,encoded_uint64,bytes[32][])[]%0#0: (encoded_uint64,encoded_uint64,bytes[32][])[] = (txna ApplicationArgs 1)
        let reinterpret_bytes[]%0#0: bytes[] = (txna ApplicationArgs 2)
        smart_contracts/pool/contract.algo.ts::Pool.enter(gtxn_idx%0#0, reinterpret_(encoded_uint64,encoded_uint64,bytes[32][])[]%0#0, reinterpret_bytes[]%0#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#4: bool = 1u
        goto block@27
    block@10: // withdraw_route_L774
        let tmp%34#0: uint64 = (txn OnCompletion)
        let tmp%35#0: bool = (! tmp%34#0)
        (assert tmp%35#0) // OnCompletion is not NoOp
        let tmp%36#0: uint64 = (txn ApplicationID)
        (assert tmp%36#0) // can only call when not creating
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#5: bool = 1u
        goto block@27
    block@11: // startDisbursement_route_L776
        let tmp%38#0: uint64 = (txn OnCompletion)
        let tmp%39#0: bool = (! tmp%38#0)
        (assert tmp%39#0) // OnCompletion is not NoOp
        let tmp%40#0: uint64 = (txn ApplicationID)
        (assert tmp%40#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.startDisbursement()
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#6: bool = 1u
        goto block@27
    block@12: // raffle_route_L797
        let tmp%42#0: uint64 = (txn OnCompletion)
        let tmp%43#0: bool = (! tmp%42#0)
        (assert tmp%43#0) // OnCompletion is not NoOp
        let tmp%44#0: uint64 = (txn ApplicationID)
        (assert tmp%44#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.raffle()
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#7: bool = 1u
        goto block@27
    block@13: // disburseRewards_route_L831
        let tmp%46#0: uint64 = (txn OnCompletion)
        let tmp%47#0: bool = (! tmp%46#0)
        (assert tmp%47#0) // OnCompletion is not NoOp
        let tmp%48#0: uint64 = (txn ApplicationID)
        (assert tmp%48#0) // can only call when not creating
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%50#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        smart_contracts/pool/contract.algo.ts::Pool.disburseRewards(tmp%50#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#8: bool = 1u
        goto block@27
    block@14: // finalizeDistribution_route_L862
        let tmp%51#0: uint64 = (txn OnCompletion)
        let tmp%52#0: bool = (! tmp%51#0)
        (assert tmp%52#0) // OnCompletion is not NoOp
        let tmp%53#0: uint64 = (txn ApplicationID)
        (assert tmp%53#0) // can only call when not creating
        smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution()
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#9: bool = 1u
        goto block@27
    block@15: // check_route_L877
        let tmp%55#0: uint64 = (txn OnCompletion)
        let tmp%56#0: bool = (! tmp%55#0)
        (assert tmp%56#0) // OnCompletion is not NoOp
        let tmp%57#0: uint64 = (txn ApplicationID)
        (assert tmp%57#0) // can only call when not creating
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%59#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let (elements_to_encode%0#0: bool, elements_to_encode%1#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.check(reinterpret_bytes[32]%3#0, tmp%59#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u elements_to_encode%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob elements_to_encode%1#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_bool%0#0 val_as_bytes%0#0)
        let tmp%60#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%2#0)
        (log tmp%60#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#10: bool = 1u
        goto block@27
    block@16: // signUpsOpen_route_L886
        let tmp%61#0: uint64 = (txn OnCompletion)
        let tmp%62#0: bool = (! tmp%61#0)
        (assert tmp%62#0) // OnCompletion is not NoOp
        let tmp%63#0: uint64 = (txn ApplicationID)
        (assert tmp%63#0) // can only call when not creating
        let to_encode%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen()
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%65#0: bytes = (concat 0x151f7c75 encoded_bool%1#0)
        (log tmp%65#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#11: bool = 1u
        goto block@27
    block@17: // isLive_route_L896
        let tmp%66#0: uint64 = (txn OnCompletion)
        let tmp%67#0: bool = (! tmp%66#0)
        (assert tmp%67#0) // OnCompletion is not NoOp
        let tmp%68#0: uint64 = (txn ApplicationID)
        (assert tmp%68#0) // can only call when not creating
        let to_encode%1#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u to_encode%1#0)
        let tmp%70#0: bytes = (concat 0x151f7c75 encoded_bool%2#0)
        (log tmp%70#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#12: bool = 1u
        goto block@27
    block@18: // getState_route_L905
        let tmp%71#0: uint64 = (txn OnCompletion)
        let tmp%72#0: bool = (! tmp%71#0)
        (assert tmp%72#0) // OnCompletion is not NoOp
        let tmp%73#0: uint64 = (txn ApplicationID)
        (assert tmp%73#0) // can only call when not creating
        let (elements_to_encode%2#0: bytes[1], elements_to_encode%3#0: bytes, elements_to_encode%4#0: bytes[1], elements_to_encode%5#0: uint64, elements_to_encode%6#0: bytes[1], elements_to_encode%7#0: uint64, elements_to_encode%8#0: uint64, elements_to_encode%9#0: uint64, elements_to_encode%10#0: uint64, elements_to_encode%11#0: uint64, elements_to_encode%12#0: bool, elements_to_encode%13#0: uint64, elements_to_encode%14#0: uint64, elements_to_encode%15#0: uint64, elements_to_encode%16#0: uint64, elements_to_encode%17#0: bytes[32], elements_to_encode%18#0: bytes, elements_to_encode%19#0: uint64, elements_to_encode%20#0: uint64, elements_to_encode%21#0: bytes[32]) = smart_contracts/pool/contract.algo.ts::Pool.getState()
        let length%0#0: uint64 = (len elements_to_encode%3#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 elements_to_encode%3#0)
        let val_as_bytes%1#0: bytes[8] = (itob elements_to_encode%5#0)
        let val_as_bytes%2#0: bytes[8] = (itob elements_to_encode%7#0)
        let val_as_bytes%3#0: bytes[8] = (itob elements_to_encode%8#0)
        let val_as_bytes%4#0: bytes[8] = (itob elements_to_encode%9#0)
        let encoded_tuple_buffer%5#0: bytes = (concat val_as_bytes%1#0 elements_to_encode%6#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%4#0)
        let val_as_bytes%5#0: bytes[8] = (itob elements_to_encode%10#0)
        let val_as_bytes%6#0: bytes[8] = (itob elements_to_encode%11#0)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u elements_to_encode%12#0)
        let val_as_bytes%7#0: bytes[8] = (itob elements_to_encode%13#0)
        let val_as_bytes%8#0: bytes[8] = (itob elements_to_encode%14#0)
        let val_as_bytes%9#0: bytes[8] = (itob elements_to_encode%15#0)
        let val_as_bytes%10#0: bytes[8] = (itob elements_to_encode%16#0)
        let length%1#0: uint64 = (len elements_to_encode%18#0)
        let as_bytes%1#0: bytes[8] = (itob length%1#0)
        let length_uint16%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_value%1#0: bytes = (concat length_uint16%1#0 elements_to_encode%18#0)
        let encoded_tuple_buffer%11#0: bytes = (concat elements_to_encode%17#0 0x0022)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 encoded_value%1#0)
        let val_as_bytes%11#0: bytes[8] = (itob elements_to_encode%19#0)
        let val_as_bytes%12#0: bytes[8] = (itob elements_to_encode%20#0)
        let encoded_tuple_buffer%15#0: bytes = (concat elements_to_encode%2#0 0x0088)
        let data_length%1#0: uint64 = (len encoded_value%0#0)
        let current_tail_offset%5#0: uint64 = (+ 136u data_length%1#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 elements_to_encode%4#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 encoded_tuple_buffer%8#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%20#0: bytes = (concat encoded_tuple_buffer%19#0 encoded_bool%3#0)
        let encoded_tuple_buffer%21#0: bytes = (concat encoded_tuple_buffer%20#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%22#0: bytes = (concat encoded_tuple_buffer%21#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%23#0: bytes = (concat encoded_tuple_buffer%22#0 val_as_bytes%9#0)
        let encoded_tuple_buffer%24#0: bytes = (concat encoded_tuple_buffer%23#0 val_as_bytes%10#0)
        let as_bytes%4#0: bytes[8] = (itob current_tail_offset%5#0)
        let offset_as_uint16%2#0: bytes = ((extract 6 2) as_bytes%4#0)
        let encoded_tuple_buffer%25#0: bytes = (concat encoded_tuple_buffer%24#0 offset_as_uint16%2#0)
        let encoded_tuple_buffer%26#0: bytes = (concat encoded_tuple_buffer%25#0 val_as_bytes%11#0)
        let encoded_tuple_buffer%27#0: bytes = (concat encoded_tuple_buffer%26#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%28#0: bytes = (concat encoded_tuple_buffer%27#0 elements_to_encode%21#0)
        let encoded_tuple_buffer%29#0: bytes = (concat encoded_tuple_buffer%28#0 encoded_value%0#0)
        let encoded_tuple_buffer%30#0: bytes = (concat encoded_tuple_buffer%29#0 encoded_tuple_buffer%12#0)
        let tmp%75#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%30#0)
        (log tmp%75#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#13: bool = 1u
        goto block@27
    block@19: // update_route_L19
        let tmp%76#0: uint64 = (txn OnCompletion)
        let tmp%77#0: bool = (== tmp%76#0 UpdateApplication)
        (assert tmp%77#0) // OnCompletion is not UpdateApplication
        let tmp%78#0: uint64 = (txn ApplicationID)
        (assert tmp%78#0) // can only call when not creating
        let tmp%80#0: bytes = (txna ApplicationArgs 1)
        let tmp%81#0: bytes = ((extract 2 0) tmp%80#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(tmp%81#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#14: bool = 1u
        goto block@27
    block@20: // updateAkitaDAO_route_L27
        let tmp%82#0: uint64 = (txn OnCompletion)
        let tmp%83#0: bool = (! tmp%82#0)
        (assert tmp%83#0) // OnCompletion is not NoOp
        let tmp%84#0: uint64 = (txn ApplicationID)
        (assert tmp%84#0) // can only call when not creating
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%86#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(tmp%86#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#15: bool = 1u
        goto block@27
    block@21: // optin_route_L51
        let tmp%87#0: uint64 = (txn OnCompletion)
        let tmp%88#0: bool = (! tmp%87#0)
        (assert tmp%88#0) // OnCompletion is not NoOp
        let tmp%89#0: uint64 = (txn ApplicationID)
        (assert tmp%89#0) // can only call when not creating
        let tmp%91#0: uint64 = (txn GroupIndex)
        let gtxn_idx%1#0: uint64 = (- tmp%91#0 1u)
        let gtxn_type%1#0: uint64 = ((gtxns TypeEnum) gtxn_idx%1#0)
        let gtxn_type_matches%1#0: bool = (== gtxn_type%1#0 pay)
        (assert gtxn_type_matches%1#0) // transaction type is pay
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%92#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn.optin(gtxn_idx%1#0, tmp%92#0)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#16: bool = 1u
        goto block@27
    block@22: // mbr_route_L6
        let tmp%93#0: uint64 = (txn OnCompletion)
        let tmp%94#0: bool = (! tmp%93#0)
        (assert tmp%94#0) // OnCompletion is not NoOp
        let tmp%95#0: uint64 = (txn ApplicationID)
        (assert tmp%95#0) // can only call when not creating
        (log 0x151f7c7500000000000062d400000000000062d400000000000017d4)
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#17: bool = 1u
        goto block@27
    block@26: // after_if_else_L99
        let smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#18: bool = 0u
        goto block@27
    block@27: // after_inlined_smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router___L1
        let tmp%0#0: bool = φ(smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#0 <- block@5, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#1 <- block@6, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#2 <- block@7, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#3 <- block@8, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#4 <- block@9, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#5 <- block@10, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#6 <- block@11, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#7 <- block@12, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#8 <- block@13, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#9 <- block@14, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#10 <- block@15, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#11 <- block@16, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#12 <- block@17, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#13 <- block@18, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#14 <- block@19, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#15 <- block@20, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#16 <- block@21, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#17 <- block@22, smart_contracts/pool/contract.algo.ts::Pool.__puya_arc4_router__%0#18 <- block@26)
        return tmp%0#0

subroutine smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
    block@0: // L23
        let tmp%0#0: uint64 = (shr state#0 18u)
        let tmp%1#0: uint64 = (^ tmp%0#0 state#0)
        let value#0: uint64 = (shr tmp%1#0 27u)
        let xorshifted#0: uint64 = (& value#0 4294967295u)
        let rot#0: uint64 = (shr state#0 59u)
        let tmp%3#0: uint64 = (shr xorshifted#0 rot#0)
        let tmp%0#1: uint64 = (~ rot#0)
        let (_#0: uint64, addLow#0: uint64) = (addw tmp%0#1 1u)
        let tmp%5#0: uint64 = (& addLow#0 31u)
        let value#2: uint64 = (shl xorshifted#0 tmp%5#0)
        let tmp%2#2: uint64 = (& value#2 4294967295u)
        let tmp%8#0: uint64 = (| tmp%3#0 tmp%2#2)
        return tmp%8#0

subroutine smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes[32], id: uint64, args: bytes[]) -> bool:
    block@0: // L130
        goto id#0 ? block@2 : block@1
    block@1: // if_body_L131
        return 1u
    block@2: // after_if_else_L131
        itxn_begin
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item5%1#0: uint64 = (extract_uint64 appListBytes#0 40u)
        let val_as_bytes%0#0: bytes[8] = (itob id#0)
        ((itxn_field ApplicationArgs) method "check(address,uint64,byte[][])bool")
        ((itxn_field ApplicationArgs) caller#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) args#0)
        ((itxn_field ApplicationID) item5%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%13#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%14#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%15#0: bool = (== tmp%14#0 0x151f7c75)
        (assert tmp%15#0) // Bytes has valid prefix
        let tmp%16#0: bool = (getbit tmp%13#0 0u)
        return tmp%16#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.checkByID(id: uint64) -> <bool, uint64>:
    block@0: // L417
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L419
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (!= maybe_value%1#0 0x01)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L419
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L419
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L419
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Invalid pool type for check
        let encoded_value%0#0: bytes[8] = (itob id#0)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let entry.address#0: bytes[32] = ((extract 0 32) maybe_value%2#0) // on error: Index access is out of bounds
        let entry.asset#0: uint64 = (extract_uint64 maybe_value%2#0 32u)
        let entry.quantity#0: uint64 = (extract_uint64 maybe_value%2#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%2#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let entry.disqualified#0: bool = (getbit encoded_bool%0#0 0u)
        goto entry.disqualified#0 ? block@5 : block@6
    block@5: // if_body_L425
        return 0u 0u
    block@6: // after_if_else_L425
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%3#0 0x02)
        goto tmp%2#0 ? block@7 : block@11
    block@7: // if_body_L429
        itxn_begin
        let (akitaDAO#1: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (appListBytes#1: bytes, _#1: bool) = (app_global_get_ex akitaDAO#1 "akita_al")
        let item0%1#1: uint64 = (extract_uint64 appListBytes#1 0u)
        let val_as_bytes%0#0: bytes[8] = (itob entry.asset#0)
        ((itxn_field ApplicationArgs) method "softCheck(address,uint64)(bool,uint64)")
        ((itxn_field ApplicationArgs) entry.address#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) item0%1#1)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%16#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%17#0: bool = (== tmp%16#0 0x151f7c75)
        (assert tmp%17#0) // Bytes has valid prefix
        let check.balance#0: uint64 = (extract_uint64 awst_tmp%0#0 5u)
        let tmp%18#0: bool = (>= check.balance#0 entry.quantity#0)
        goto tmp%18#0 ? block@9 : block@15
    block@9: // if_body_L436
        return 1u check.balance#0
    block@11: // else_body_L439
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item0%1#0: uint64 = (extract_uint64 appListBytes#0 0u)
        let val_as_bytes%1#0: bytes[8] = (itob entry.asset#0)
        let tmp%31#0: bytes[1] = smart_contracts/pool/contract.algo.ts::Pool.stakingType()
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%1#0 tmp%31#0)
        ((itxn_field ApplicationArgs) method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)")
        ((itxn_field ApplicationArgs) entry.address#0)
        ((itxn_field ApplicationArgs) encoded_tuple_buffer%2#0)
        ((itxn_field ApplicationID) item0%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%1#0: bytes = (itxn LastLog)
        let tmp%33#0: bytes = ((extract 0 4) awst_tmp%1#0)
        let tmp%34#0: bool = (== tmp%33#0 0x151f7c75)
        (assert tmp%34#0) // Bytes has valid prefix
        let info.amount#0: uint64 = (extract_uint64 awst_tmp%1#0 4u)
        let tmp%35#0: bool = (>= info.amount#0 entry.quantity#0)
        goto tmp%35#0 ? block@13 : block@15
    block@13: // if_body_L452
        return 1u info.amount#0
    block@15: // after_if_else_L429
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%4#0: bytes = ((extract 0 32) maybe_value%6#0) // on error: Index access is out of bounds
        let item1%9#0: uint64 = (extract_uint64 maybe_value%6#0 32u)
        let item2%9#0: uint64 = (extract_uint64 maybe_value%6#0 40u)
        let item_start_offset%4#0: uint64 = (extract_uint16 maybe_value%6#0 48u)
        let item_end_offset%4#0: uint64 = (len maybe_value%6#0)
        let item3%4#0: bytes = (substring3 maybe_value%6#0 item_start_offset%4#0 item_end_offset%4#0)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob item1%9#0)
        let val_as_bytes%3#0: bytes[8] = (itob item2%9#0)
        let encoded_tuple_buffer%5#0: bytes = (concat item0%4#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 0x0033)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 0x80)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 item3%4#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%9#0)
        return 0u 0u

subroutine smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart() -> uint64:
    block@0: // L464
        let tmp%0#0: uint64 = (global LatestTimestamp)
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: uint64 = (- tmp%1#0 maybe_value%0#0)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "reward_interval")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%3#0: uint64 = (% tmp%2#0 maybe_value%1#0)
        let tmp%4#0: uint64 = (- tmp%0#0 tmp%3#0)
        return tmp%4#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.stakingType() -> bytes[1]:
    block@0: // L473
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        (assert tmp%0#0) // pool staking type is not set
        let tmp%1#0: uint64 = (btoi maybe_value%0#0)
        let to_encode%0#0: uint64 = (- tmp%1#0 1u)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let bitlen%0#0: uint64 = (bitlen val_as_bytes%0#0)
        let no_overflow%0#0: bool = (<= bitlen%0#0 8u)
        (assert no_overflow%0#0) // overflow
        let uint8%0#0: bytes = ((extract 7 1) val_as_bytes%0#0)
        return uint8%0#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
    block@0: // L520
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let rewardsApp#0: uint64 = (extract_uint64 appListBytes#0 8u)
        let tmp%0#1: uint64 = (extract_uint16 allocations#0 0u)
        let mbrAmount#0: uint64 = (* 24900u tmp%0#1)
        goto asset#0 ? block@6 : block@3
    block@3: // if_body_L530
        itxn_begin
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%0#0) // application exists
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ mbrAmount#0 sum#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) value%0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let val_as_bytes%0#0: bytes[8] = (itob disbursementID#0)
        ((itxn_field ApplicationArgs) method "createUserAllocations(pay,uint64,(address,uint64)[])void")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) allocations#0)
        ((itxn_field ApplicationID) rewardsApp#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@10
    block@6: // else_body_L544
        itxn_begin
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%1#0) // application exists
        ((itxn_field Amount) mbrAmount#0)
        ((itxn_field Receiver) value%1#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%2#0) // application exists
        ((itxn_field AssetAmount) sum#0)
        ((itxn_field XferAsset) asset#0)
        ((itxn_field AssetReceiver) value%2#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_next
        let val_as_bytes%1#0: bytes[8] = (itob disbursementID#0)
        ((itxn_field ApplicationArgs) method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void")
        ((itxn_field ApplicationArgs) val_as_bytes%1#0)
        ((itxn_field ApplicationArgs) allocations#0)
        ((itxn_field ApplicationID) rewardsApp#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@10
    block@10: // after_if_else_L530
        return allocations#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.create(title: bytes, type: bytes[1], reward: bytes[33], creator: bytes[32], marketplace: bytes[32], stakeKey: bytes, minimumStakeAmount: uint64, gateID: uint64, maxEntries: uint64, akitaDAO: uint64) -> void:
    block@0: // L583
        (app_global_put "status" 0x00)
        (app_global_put "title" title#0)
        (app_global_put "type" type#0)
        (app_global_put "reward" reward#0)
        let decodedReward.rate#0: uint64 = (extract_uint64 reward#0 9u)
        let decodedReward.winnerCount#0: uint64 = (extract_uint64 reward#0 25u)
        (assert decodedReward.rate#0) // Rate must be greater than zero
        (app_global_put "creator" creator#0)
        (app_global_put "marketplace" marketplace#0)
        let tmp%1#0: bytes = ((extract 0 32) stakeKey#0) // on error: Index access is out of bounds
        let tmp%2#0: bytes[32] = (global ZeroAddress)
        let tmp%3#0: bool = (!= tmp%1#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@1
    block@1: // or_contd_L611
        let tmp%4#0: bytes = ((extract 8 1) reward#0) // on error: Index access is out of bounds
        let tmp%5#0: bool = (!= tmp%4#0 0x00)
        goto tmp%5#0 ? block@2 : block@3
    block@2: // bool_true_L611
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L611
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L611
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Stake key required
        let tmp%6#0: bytes = ((extract 8 1) reward#0) // on error: Index access is out of bounds
        let tmp%7#0: bool = (== tmp%6#0 0x03)
        goto tmp%7#0 ? block@5 : block@6
    block@5: // if_body_L616
        let tmp%8#0: bool = (> decodedReward.rate#0 decodedReward.winnerCount#0)
        (assert tmp%8#0) // Rate must be greater than winner count
        goto block@6
    block@6: // after_if_else_L616
        let tmp%10#0: bool = (== tmp%6#0 0x02)
        goto tmp%10#0 ? block@7 : block@10
    block@7: // if_body_L620
        let tmp%11#0: bool = (< maxEntries#0 decodedReward.rate#0)
        (assert tmp%11#0) // Max entries cannot be greater than rate
        goto maxEntries#0 ? block@9 : block@8
    block@8: // if_body_L622
        goto block@9
    block@9: // after_if_else_L622
        let maxEntries#6: uint64 = φ(maxEntries#0 <- block@7, decodedReward.rate#0 <- block@8)
        goto block@10
    block@10: // after_if_else_L620
        let maxEntries#5: uint64 = φ(maxEntries#0 <- block@6, maxEntries#6 <- block@9)
        (app_global_put "stake_key" stakeKey#0)
        (app_global_put "minimum_stake_amount" minimumStakeAmount#0)
        (app_global_put "gate_id" gateID#0)
        (app_global_put "max_entries" maxEntries#5)
        (app_global_put "akita_dao" akitaDAO#0)
        let materialized_values%0#0: bytes[32] = (txn TxID)
        (app_global_put "salt" materialized_values%0#0)
        (app_global_put "disbursement_phase" 0x00)
        (app_global_put "active_disbursement_id" 0u)
        (app_global_put "active_disbursement_window" 0u)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "wtickets" 0x0000)
        (app_global_put "vrf_failure_count" 0u)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.init() -> void:
    block@0: // L643
        let tmp%0#0: bytes[32] = (global CallerApplicationAddress)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0) // only the factory can init the pool
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%0#0) // check GlobalState exists
        goto maybe_value%0#0 ? block@1 : block@3
    block@1: // if_body_L646
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item5%1#0: uint64 = (extract_uint64 appListBytes#0 40u)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%2#0) // check GlobalState exists
        let val_as_bytes%0#0: bytes[8] = (itob maybe_value%2#0)
        ((itxn_field ApplicationArgs) method "size(uint64)uint64")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) item5%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%16#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%17#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%18#0: bool = (== tmp%17#0 0x151f7c75)
        (assert tmp%18#0) // Bytes has valid prefix
        let tmp%19#0: uint64 = (btoi tmp%16#0)
        (app_global_put "gate_size" tmp%19#0)
        goto block@3
    block@3: // after_if_else_L646
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.deleteApplication(caller: bytes[32]) -> void:
    block@0: // L655
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0) // call must come from factory
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%3#0: bool = (== caller#0 maybe_value%0#0)
        (assert tmp%3#0) // only the creator can delete the pool
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%4#0: bool = (== maybe_value%1#0 0x00)
        goto tmp%4#0 ? block@2 : block@1
    block@1: // or_contd_L659
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%6#0: bool = (> tmp%5#0 maybe_value%2#0)
        goto tmp%6#0 ? block@2 : block@3
    block@2: // bool_true_L659
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L659
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L659
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // the pool must be in draft or ended
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) -> void:
    block@0: // L664
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // only the creator can finalize the pool
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%1#0 0x00)
        (assert tmp%2#0) // the pool must be in draft state to finalize
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let tmp%4#0: bool = (> signupTimestamp#0 tmp%3#0)
        goto tmp%4#0 ? block@3 : block@1
    block@1: // or_contd_L668
        goto signupTimestamp#0 ? block@4 : block@2
    block@2: // and_contd_L668
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%2#0) // check GlobalState exists
        goto maybe_value%2#0 ? block@3 : block@4
    block@3: // bool_true_L668
        let or_result%0#0: bool = 1u
        goto block@5
    block@4: // bool_false_L668
        let or_result%0#1: bool = 0u
        goto block@5
    block@5: // bool_merge_L668
        let or_result%0#2: bool = φ(or_result%0#0 <- block@3, or_result%0#1 <- block@4)
        (assert or_result%0#2) // the signup round must be zero and late sign ups allowed or in the future
        goto startTimestamp#0 ? block@6 : block@7
    block@6: // or_contd_L673
        let tmp%7#0: uint64 = (global LatestTimestamp)
        let tmp%8#0: bool = (> startTimestamp#0 tmp%7#0)
        goto tmp%8#0 ? block@7 : block@8
    block@7: // bool_true_L673
        let or_result%1#0: bool = 1u
        goto block@9
    block@8: // bool_false_L673
        let or_result%1#1: bool = 0u
        goto block@9
    block@9: // bool_merge_L673
        let or_result%1#2: bool = φ(or_result%1#0 <- block@7, or_result%1#1 <- block@8)
        (assert or_result%1#2) // the starting round must be zero or in the future
        goto startTimestamp#0 ? block@15 : block@10
    block@10: // if_body_L678
        goto signupTimestamp#0 ? block@13 : block@11
    block@11: // and_contd_L679
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%3#0) // check GlobalState exists
        goto maybe_value%3#0 ? block@12 : block@13
    block@12: // bool_true_L679
        let and_result%0#0: bool = 1u
        goto block@14
    block@13: // bool_false_L679
        let and_result%0#1: bool = 0u
        goto block@14
    block@14: // bool_merge_L679
        let and_result%0#2: bool = φ(and_result%0#0 <- block@12, and_result%0#1 <- block@13)
        (assert and_result%0#2) // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
        let startTimestamp#6: uint64 = (global LatestTimestamp)
        goto block@15
    block@15: // after_if_else_L678
        let startTimestamp#7: uint64 = φ(startTimestamp#0 <- block@9, startTimestamp#6 <- block@14)
        goto endTimestamp#0 ? block@16 : block@17
    block@16: // or_contd_L684
        let tmp%12#0: uint64 = (+ startTimestamp#7 10u)
        let tmp%13#0: bool = (> endTimestamp#0 tmp%12#0)
        goto tmp%13#0 ? block@17 : block@18
    block@17: // bool_true_L684
        let or_result%2#0: bool = 1u
        goto block@19
    block@18: // bool_false_L684
        let or_result%2#1: bool = 0u
        goto block@19
    block@19: // bool_merge_L684
        let or_result%2#2: bool = φ(or_result%2#0 <- block@17, or_result%2#1 <- block@18)
        (assert or_result%2#2) // the ending round must be zero or after the starting round + 10
        (app_global_put "signup_timestamp" signupTimestamp#0)
        (app_global_put "start_timestamp" startTimestamp#7)
        (app_global_put "end_timestamp" endTimestamp#0)
        (app_global_put "status" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.enter(payment: uint64, entries: (encoded_uint64,encoded_uint64,bytes[32][])[], args: bytes[]) -> void:
    block@0: // L694
        let tmp%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        (assert tmp%0#0) // the pool is not live
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bytes[32] = (txn Sender)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%0#0, tmp%1#0, maybe_value%1#0, args#0)
        (assert tmp%2#0) // user does not meet gate requirements
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%3#0: uint64 = (+ maybe_value%2#0 1u)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: bool = (< tmp%3#0 maybe_value%3#0)
        goto tmp%4#0 ? block@2 : block@1
    block@1: // or_contd_L702
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%4#0) // check GlobalState exists
        goto maybe_value%4#0 ? block@3 : block@2
    block@2: // bool_true_L702
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L702
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L702
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // pool has reached maximum entries
        let tmp%6#0: bytes[32] = ((gtxns Receiver) payment#0)
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (== tmp%6#0 tmp%7#0)
        (assert tmp%8#0) // Invalid payment receiver
        let tmp%9#0: uint64 = ((gtxns Amount) payment#0)
        let tmp%10#0: uint64 = (extract_uint16 entries#0 0u)
        let tmp%11#0: uint64 = (* 50600u tmp%10#0)
        let tmp%12#0: bool = (== tmp%9#0 tmp%11#0)
        (assert tmp%12#0) // Invalid payment amount
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L714
        let i#1: uint64 = φ(i#0 <- block@4, i#6 <- block@13)
        let tmp%14#0: bool = (< i#1 tmp%10#0)
        goto tmp%14#0 ? block@6 : block@16
    block@6: // while_body_L714
        let array_head_and_tail%0#0: bytes = ((extract 2 0) entries#0)
        let item_offset_offset%0#0: uint64 = (* i#1 2u)
        let item_offset%0#0: uint64 = (extract_uint16 array_head_and_tail%0#0 item_offset_offset%0#0)
        let i#6: uint64 = (+ i#1 1u)
        let has_next%0#0: uint64 = (- tmp%10#0 i#6) // on error: Index access is out of bounds
        let end_of_array%0#0: uint64 = (len array_head_and_tail%0#0)
        let next_item_offset_offset%0#0: uint64 = (* i#6 2u)
        let next_item_offset%0#0: uint64 = (extract_uint16 array_head_and_tail%0#0 next_item_offset_offset%0#0)
        let end_offset%0#0: uint64 = (select end_of_array%0#0 next_item_offset%0#0 has_next%0#0)
        let arc4_item%0#0: bytes = (substring3 array_head_and_tail%0#0 item_offset%0#0 end_offset%0#0)
        let item1%1#0: uint64 = (extract_uint64 arc4_item%0#0 8u)
        let item_start_offset%0#0: uint64 = (extract_uint16 arc4_item%0#0 16u)
        let item_end_offset%0#0: uint64 = (len arc4_item%0#0)
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "minimum_stake_amount")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%15#0: bool = (>= item1%1#0 maybe_value%5#0)
        (assert tmp%15#0) // quantity is less than minimum stake amount
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%6#0) // check GlobalState exists
        let tmp%16#0: bool = (== maybe_value%6#0 0x01)
        goto tmp%16#0 ? block@8 : block@7
    block@7: // or_contd_L719
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%7#0) // check GlobalState exists
        let tmp%17#0: bool = (== maybe_value%7#0 0x02)
        goto tmp%17#0 ? block@8 : block@13
    block@8: // if_body_L721
        let tmp%18#0: bytes[32] = (txn Sender)
        let item0%3#0: uint64 = (extract_uint64 arc4_item%0#0 0u)
        let (balance#0: uint64, optedIn#0: bool) = ((asset_holding_get AssetBalance) tmp%18#0 item0%3#0)
        goto optedIn#0 ? block@9 : block@11
    block@9: // and_contd_L723
        let tmp%19#0: bool = (>= balance#0 item1%1#0)
        goto tmp%19#0 ? block@10 : block@11
    block@10: // bool_true_L723
        let and_result%0#0: bool = 1u
        goto block@12
    block@11: // bool_false_L723
        let and_result%0#1: bool = 0u
        goto block@12
    block@12: // bool_merge_L723
        let and_result%0#2: bool = φ(and_result%0#0 <- block@10, and_result%0#1 <- block@11)
        (assert and_result%0#2) // user does not have min balance
        goto block@13
    block@13: // after_if_else_L718
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%8#0) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item0%1#0: uint64 = (extract_uint64 appListBytes#0 0u)
        let tmp%32#0: bytes[32] = (txn Sender)
        let item0%7#0: uint64 = (extract_uint64 arc4_item%0#0 0u)
        let val_as_bytes%0#0: bytes[8] = (itob item0%7#0)
        let tmp%33#0: bytes[1] = smart_contracts/pool/contract.algo.ts::Pool.stakingType()
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 tmp%33#0)
        ((itxn_field ApplicationArgs) method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)")
        ((itxn_field ApplicationArgs) tmp%32#0)
        ((itxn_field ApplicationArgs) encoded_tuple_buffer%2#0)
        ((itxn_field ApplicationID) item0%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%35#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%36#0: bool = (== tmp%35#0 0x151f7c75)
        (assert tmp%36#0) // Bytes has valid prefix
        let stakeInfo.amount#0: uint64 = (extract_uint64 awst_tmp%0#0 4u)
        let tmp%37#0: bool = (>= stakeInfo.amount#0 item1%1#0)
        (assert tmp%37#0) // user does not have enough staked
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (app_global_get_ex 0u "stake_key")
        (assert maybe_exists%9#0) // check GlobalState exists
        let address#0: bytes[32] = ((extract 0 32) maybe_value%9#0) // on error: Index access is out of bounds
        let item_start_offset%5#0: uint64 = (extract_uint16 maybe_value%9#0 32u)
        let item_end_offset%5#0: uint64 = (len maybe_value%9#0)
        let item1%12#0: bytes = (substring3 maybe_value%9#0 item_start_offset%5#0 item_end_offset%5#0)
        let name#0: bytes = ((extract 2 0) item1%12#0)
        itxn_begin
        let (akitaDAO#1: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%10#0) // check GlobalState exists
        let (appListBytes#1: bytes, _#1: bool) = (app_global_get_ex akitaDAO#1 "akita_al")
        let item9%1#1: uint64 = (extract_uint64 appListBytes#1 72u)
        let length%0#0: uint64 = (len name#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 name#0)
        let tmp%51#0: bytes[32] = (sha256 val_as_bytes%0#0)
        let to_encode%0#0: bytes[32] = (sha256 tmp%51#0)
        let item2%8#0: bytes = (substring3 arc4_item%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let val_as_bytes%1#0: bytes[8] = (itob 1u)
        ((itxn_field ApplicationArgs) method "verify(address,string,byte[32],byte[32][],uint64)bool")
        ((itxn_field ApplicationArgs) address#0)
        ((itxn_field ApplicationArgs) encoded_value%0#0)
        ((itxn_field ApplicationArgs) to_encode%0#0)
        ((itxn_field ApplicationArgs) item2%8#0)
        ((itxn_field ApplicationArgs) val_as_bytes%1#0)
        ((itxn_field ApplicationID) item9%1#1)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%1#0: bytes = (itxn LastLog)
        let tmp%52#0: bytes = ((extract 4 0) awst_tmp%1#0)
        let tmp%53#0: bytes = ((extract 0 4) awst_tmp%1#0)
        let tmp%54#0: bool = (== tmp%53#0 0x151f7c75)
        (assert tmp%54#0) // Bytes has valid prefix
        let verified#0: bool = (getbit tmp%52#0 0u)
        (assert verified#0) // failed to verify stake requirements
        let (id#0: uint64, maybe_exists%0#1: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%0#1) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ id#0 1u)
        (app_global_put "entry_count" materialized_values%0#0)
        let tmp%56#0: bytes[32] = (txn Sender)
        let encoded_value%1#0: bytes[8] = (itob id#0)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%1#0)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%3#0: bytes[8] = (itob item1%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat tmp%56#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 0x0033)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 0x00)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 args#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%9#0)
        let tmp%57#0: bytes[32] = (txn Sender)
        let aKey#0: bytes[40] = (concat tmp%57#0 val_as_bytes%0#0)
        let box_prefixed_key%1#0: bytes = (concat "a" aKey#0)
        (box_put box_prefixed_key%1#0 encoded_value%1#0)
        goto block@5
    block@16: // after_while_L714
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.startDisbursement() -> void:
    block@0: // L776
        let tmp%0#0: bool = smart_contracts/pool/contract.algo.ts::Pool.isLive()
        (assert tmp%0#0) // the pool is not live
        let latestWindowStart#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart()
        let tmp%0#1: uint64 = (global LatestTimestamp)
        let tmp%1#1: bool = (!= latestWindowStart#0 tmp%0#1)
        goto tmp%1#1 ? block@2 : block@4
    block@2: // and_contd_L470
        let (maybe_value%0#1: uint64, maybe_exists%0#1: bool) = (app_global_get_ex 0u "last_disbursement_timestamp")
        (assert maybe_exists%0#1) // check GlobalState exists
        let tmp%2#1: bool = (< maybe_value%0#1 latestWindowStart#0)
        goto tmp%2#1 ? block@3 : block@4
    block@3: // bool_true_L470
        let and_result%0#0: bool = 1u
        goto block@5
    block@4: // bool_false_L470
        let and_result%0#1: bool = 0u
        goto block@5
    block@5: // bool_merge_L470
        let and_result%0#2: bool = φ(and_result%0#0 <- block@3, and_result%0#1 <- block@4)
        (assert and_result%0#2) // distribution window is not open
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%0#0 0x00)
        (assert tmp%2#0) // distribution already in progress
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "title")
        (assert maybe_exists%1#0) // check GlobalState exists
        let title#0: bytes = (concat maybe_value%1#0 " - Rewards")
        let timeToUnlock#0: uint64 = (global LatestTimestamp)
        let tmp%6#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%8#0: uint64 = (extract_uint64 maybe_value%2#0 17u)
        let expiration#0: uint64 = (+ tmp%6#0 tmp%8#0)
        let (akitaDAO#0: uint64, maybe_exists%0#2: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#2) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let rewardsApp#0: uint64 = (extract_uint64 appListBytes#0 8u)
        let tmp%12#0: uint64 = (len title#0)
        let tmp%13#0: uint64 = (* 400u tmp%12#0)
        let rewardMBR#0: uint64 = (+ 35300u tmp%13#0)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) rewardsApp#0)
        (assert check%0#0) // application exists
        itxn_begin
        ((itxn_field Amount) rewardMBR#0)
        ((itxn_field Receiver) value%0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let as_bytes%0#0: bytes[8] = (itob tmp%12#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 title#0)
        let val_as_bytes%0#0: bytes[8] = (itob timeToUnlock#0)
        let val_as_bytes%1#0: bytes[8] = (itob expiration#0)
        ((itxn_field ApplicationArgs) method "createDisbursement(pay,string,uint64,uint64,string)uint64")
        ((itxn_field ApplicationArgs) encoded_value%0#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) val_as_bytes%1#0)
        ((itxn_field ApplicationArgs) 0x0000)
        ((itxn_field ApplicationID) rewardsApp#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (gitxn 1 LastLog)
        let tmp%14#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%15#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%16#0: bool = (== tmp%15#0 0x151f7c75)
        (assert tmp%16#0) // Bytes has valid prefix
        let disbursementID#0: uint64 = (btoi tmp%14#0)
        (app_global_put "status" 0x14)
        (app_global_put "active_disbursement_id" disbursementID#0)
        let materialized_values%0#0: uint64 = smart_contracts/pool/contract.algo.ts::Pool.getLatestWindowStart()
        (app_global_put "active_disbursement_window" materialized_values%0#0)
        let materialized_values%1#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_disbursement_timestamp" materialized_values%1#0)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "disbursement_phase" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.raffle() -> void:
    block@0: // L797
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x14)
        (assert tmp%0#0) // Invalid disbursement phase
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: uint64 = (extract_uint16 maybe_value%1#0 0u)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // Winning tickets already exist
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "active_disbursement_window")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%3#0: uint64 = (+ maybe_value%2#0 1u)
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "vrf_failure_count")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: uint64 = (* 4u maybe_value%3#0)
        let roundToUse#0: uint64 = (+ tmp%3#0 tmp%4#0)
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (otherAppListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "other_al")
        let item0%1#0: uint64 = (extract_uint64 otherAppListBytes#0 0u)
        let val_as_bytes%0#0: bytes[8] = (itob roundToUse#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "salt")
        (assert maybe_exists%5#0) // check GlobalState exists
        let length%0#0: uint64 = (len maybe_value%5#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 maybe_value%5#0)
        ((itxn_field ApplicationArgs) method "get(uint64,byte[])byte[]")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) encoded_value%0#0)
        ((itxn_field ApplicationID) item0%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%9#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%10#0: bool = (== tmp%9#0 0x151f7c75)
        (assert tmp%10#0) // Bytes has valid prefix
        let seed#0: bytes = ((extract 6 0) awst_tmp%0#0)
        let tmp%12#0: uint64 = (len seed#0)
        goto tmp%12#0 ? block@3 : block@2
    block@2: // if_body_L812
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "vrf_failure_count")
        (assert maybe_exists%6#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%6#0 1u)
        (app_global_put "vrf_failure_count" materialized_values%0#0)
        return 
    block@3: // after_if_else_L812
        let is_out_of_bounds%0#0: bool = (>= 0u tmp%12#0)
        let bounded_index%0#0: uint64 = (select 0u tmp%12#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 16u tmp%12#0)
        let bounded_index%1#0: uint64 = (select 16u tmp%12#0 is_out_of_bounds%1#0)
        let seed#1: bytes = (substring3 seed#0 bounded_index%0#0 bounded_index%1#0)
        let tmp%0#2: uint64 = (len seed#1)
        let tmp%1#2: bool = (== tmp%0#2 16u)
        (assert tmp%1#2)
        let initialState#0: uint64 = (extract_uint64 seed#1 0u)
        let (_#5: uint64, mulLow#2: uint64) = (mulw 0u 6364136223846793005u)
        let (_₁#2: uint64, addLow#4: uint64) = (addw mulLow#2 1442695040888963407u)
        let (_#4: uint64, addLow#3: uint64) = (addw addLow#4 initialState#0)
        let (_#6: uint64, mulLow#3: uint64) = (mulw addLow#3 6364136223846793005u)
        let (_₁#3: uint64, addLow#5: uint64) = (addw mulLow#3 1442695040888963407u)
        let initialState#1: uint64 = (extract_uint64 seed#1 8u)
        let (_₁#4: uint64, addLow#7: uint64) = (addw mulLow#2 1442695040888963409u)
        let (_#7: uint64, addLow#6: uint64) = (addw addLow#7 initialState#1)
        let (_#9: uint64, mulLow#5: uint64) = (mulw addLow#6 6364136223846793005u)
        let (_₁#5: uint64, addLow#8: uint64) = (addw mulLow#5 1442695040888963409u)
        let (upperBound#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%7#0) // check GlobalState exists
        let tmp%15#0: bool = (< upperBound#0 18446744073709551615u)
        goto tmp%15#0 ? block@4 : block@5
    block@4: // if_body_L822
        let upperBound#1: uint64 = (+ upperBound#0 1u)
        goto block@5
    block@5: // after_if_else_L822
        let upperBound#2: uint64 = φ(upperBound#0 <- block@3, upperBound#1 <- block@4)
        let result#0: bytes = 0x0000
        goto upperBound#2 ? block@13 : block@14
    block@13: // if_body_L42
        let tmp%4#1: bool = (> upperBound#2 1u)
        (assert tmp%4#1)
        let absoluteBound#0: uint64 = (- upperBound#2 1u)
        let tmp%6#1: bool = (< 1u absoluteBound#0)
        (assert tmp%6#1)
        goto block@15
    block@14: // else_body_L47
        let absoluteBound#1: uint64 = 18446744073709551615u
        goto block@15
    block@15: // after_if_else_L42
        let absoluteBound#2: uint64 = φ(absoluteBound#0 <- block@13, absoluteBound#1 <- block@14)
        let tmp%0#3: uint64 = (~ absoluteBound#2)
        let (_#3: uint64, addLow#2: uint64) = (addw tmp%0#3 1u)
        let threshold#0: uint64 = (% addLow#2 absoluteBound#2)
        let i₁#0: uint64 = 0u
        goto block@16
    block@16: // while_top_L55
        let i₁#1: uint64 = φ(i₁#0 <- block@15, i₁#3 <- block@19)
        let state.0#5: uint64 = φ(addLow#5 <- block@15, addLow#1 <- block@19)
        let state.1#5: uint64 = φ(addLow#8 <- block@15, addLow#0 <- block@19)
        let result#5: bytes = φ(result#0 <- block@15, result#4 <- block@19)
        let tmp%10#1: bool = (< i₁#1 15u)
        goto tmp%10#1 ? block@17 : block@22
    block@17: // while_body_L55
        goto block@18
    block@18: // while_top_L56
        let state.0#3: uint64 = φ(state.0#5 <- block@17, addLow#1 <- block@20)
        let state.1#3: uint64 = φ(state.1#5 <- block@17, addLow#0 <- block@20)
        let (_#2: uint64, mulLow#1: uint64) = (mulw state.0#3 6364136223846793005u)
        let (_₁#1: uint64, addLow#1: uint64) = (addw mulLow#1 1442695040888963407u)
        goto addLow#1 ? block@26 : block@25
    block@25: // ternary_true_L10
        let ternary_result%0#0: uint64 = 2885390081777926818u
        goto block@27
    block@26: // ternary_false_L10
        let ternary_result%0#1: uint64 = 1442695040888963409u
        goto block@27
    block@27: // ternary_merge_L10
        let incr#0: uint64 = φ(ternary_result%0#0 <- block@25, ternary_result%0#1 <- block@26)
        let (_#1: uint64, mulLow#0: uint64) = (mulw state.1#3 6364136223846793005u)
        let (_₁#0: uint64, addLow#0: uint64) = (addw mulLow#0 incr#0)
        let tmp%1#3: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state.0#3)
        let tmp%2#3: uint64 = (shl tmp%1#3 32u)
        let tmp%3#1: uint64 = smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state.1#3)
        let candidate#0: uint64 = (| tmp%2#3 tmp%3#1)
        let tmp%11#1: bool = (>= candidate#0 threshold#0)
        goto tmp%11#1 ? block@19 : block@20
    block@19: // if_body_L59
        let expr_value_trimmed%1#0: bytes = ((extract 2 0) result#5)
        let tmp%12#1: uint64 = (% candidate#0 absoluteBound#2)
        let to_encode%0#0: uint64 = (+ tmp%12#1 1u)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%0#0)
        let array%encoded%0#1: bytes[8][] = val_as_bytes%1#0
        let array%data%0#1: bytes[8][] = val_as_bytes%1#0
        let concatenated%1#0: bytes = (concat expr_value_trimmed%1#0 val_as_bytes%1#0)
        let byte_len%1#0: uint64 = (len concatenated%1#0)
        let len_%1#0: uint64 = (/ byte_len%1#0 8u)
        let as_bytes%1#0: bytes[8] = (itob len_%1#0)
        let len_16_bit%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let result#4: bytes = (concat len_16_bit%1#0 concatenated%1#0)
        let i₁#3: uint64 = (+ i₁#1 1u)
        goto block@16
    block@20: // after_if_else_L59
        goto block@18
    block@22: // after_while_L55
        (app_global_put "wtickets" result#5)
        (app_global_put "vrf_failure_count" 0u)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.disburseRewards(iterationAmount: uint64) -> void:
    block@0: // L831
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x14)
        (assert tmp%0#0) // pool is not in disbursement phase
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%1#0: bool = (== maybe_value%1#0 0x0a)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L834
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%2#0: bool = (== maybe_value%2#0 0x14)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // bool_true_L834
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L834
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L834
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Not ready to disburse
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%3#0) // check GlobalState exists
        let reward.asset#0: uint64 = (extract_uint64 maybe_value%3#0 0u)
        let reward.distribution#0: bytes[1] = ((extract 8 1) maybe_value%3#0) // on error: Index access is out of bounds
        let reward.rate#0: uint64 = (extract_uint64 maybe_value%3#0 9u)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%4#0) // check GlobalState exists
        let tmp%3#0: bool = (== maybe_value%4#0 0x0a)
        goto tmp%3#0 ? block@5 : block@6
    block@5: // if_body_L841
        let count#0: uint64 = 0u
        let total#1: uint64 = 0u
        let (maybe_value%0#5: uint64, maybe_exists%0#5: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#5) // check GlobalState exists
        let tmp%0#7: uint64 = (+ maybe_value%0#5 iterationAmount#0)
        let (maybe_value%1#5: uint64, maybe_exists%1#5: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#5) // check GlobalState exists
        let tmp%1#7: bool = (> tmp%0#7 maybe_value%1#5)
        goto tmp%1#7 ? block@81 : block@82
    block@81: // if_body_L192
        let (maybe_value%2#5: uint64, maybe_exists%2#5: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#5) // check GlobalState exists
        let (maybe_value%3#5: uint64, maybe_exists%3#5: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#5) // check GlobalState exists
        let iterationAmount#22: uint64 = (- maybe_value%2#5 maybe_value%3#5)
        goto block@82
    block@82: // after_if_else_L192
        let iterationAmount#24: uint64 = φ(iterationAmount#0 <- block@5, iterationAmount#22 <- block@81)
        let (id#12: uint64, maybe_exists%4#5: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%4#5) // check GlobalState exists
        goto block@83
    block@83: // while_top_L196
        let id#13: uint64 = φ(id#12 <- block@82, id#15 <- block@96)
        let count#1: uint64 = φ(count#0 <- block@82, count#4 <- block@96)
        let total#2: uint64 = φ(total#1 <- block@82, total#5 <- block@96)
        let tmp%2#7: bool = (< id#13 iterationAmount#24)
        goto tmp%2#7 ? block@84 : block@97
    block@84: // while_body_L196
        let encoded_value%0#4: bytes[8] = (itob id#13)
        let box_prefixed_key%0#4: bytes = (concat "e" encoded_value%0#4)
        let (maybe_value%5#1: bytes, maybe_exists%5#5: bool) = (box_get box_prefixed_key%0#4)
        (assert maybe_exists%5#5) // Box must have value
        let entry.address#4: bytes[32] = ((extract 0 32) maybe_value%5#1) // on error: Index access is out of bounds
        let entry.quantity#2: uint64 = (extract_uint64 maybe_value%5#1 40u)
        let item_start_offset%0#4: uint64 = (extract_uint16 maybe_value%5#1 48u)
        let item_end_offset%0#4: uint64 = (len maybe_value%5#1)
        let entry.gateArgs#0: bytes[] = (substring3 maybe_value%5#1 item_start_offset%0#4 item_end_offset%0#4)
        let is_true%0#4: uint64 = (getbit maybe_value%5#1 400u)
        let encoded_bool%0#4: bytes[1] = (setbit 0x00 0u is_true%0#4)
        let entry.disqualified#4: bool = (getbit encoded_bool%0#4 0u)
        goto entry.disqualified#4 ? block@85 : block@86
    block@85: // if_body_L198
        goto block@96
    block@86: // after_if_else_L198
        let (maybe_value%0#6: bytes, maybe_exists%0#6: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%0#6) // check GlobalState exists
        let tmp%0#8: bool = (== maybe_value%0#6 0x00)
        goto tmp%0#8 ? block@87 : block@88
    block@87: // if_body_L479
        let smart_contracts/pool/contract.algo.ts::Pool.getStakeValue%0#0: bool = 1u
        goto block@91
    block@88: // else_body_L481
        let (maybe_value%1#6: bytes, maybe_exists%1#6: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%1#6) // check GlobalState exists
        let tmp%1#8: bool = (== maybe_value%1#6 0x01)
        goto tmp%1#8 ? block@89 : block@90
    block@89: // if_body_L481
        let (maybe_value%2#6: bytes, maybe_exists%2#6: bool) = (box_get box_prefixed_key%0#4)
        (assert maybe_exists%2#6) // Box must have value
        let entry.address#5: bytes[32] = ((extract 0 32) maybe_value%2#6) // on error: Index access is out of bounds
        let entry.asset#1: uint64 = (extract_uint64 maybe_value%2#6 32u)
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%3#6: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%3#6) // check GlobalState exists
        let (appListBytes#0: bytes, _#3: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item0%1#0: uint64 = (extract_uint64 appListBytes#0 0u)
        let val_as_bytes%0#4: bytes[8] = (itob entry.asset#1)
        ((itxn_field ApplicationArgs) method "getHeartbeatAverage(address,uint64,bool)uint64")
        ((itxn_field ApplicationArgs) entry.address#5)
        ((itxn_field ApplicationArgs) val_as_bytes%0#4)
        ((itxn_field ApplicationArgs) 0x80)
        ((itxn_field ApplicationID) item0%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#1: bytes = (itxn LastLog)
        let tmp%15#0: bytes = ((extract 0 4) awst_tmp%0#1)
        let tmp%16#0: bool = (== tmp%15#0 0x151f7c75)
        (assert tmp%16#0) // Bytes has valid prefix
        let smart_contracts/pool/contract.algo.ts::Pool.getStakeValue%0#1: bool = 1u
        goto block@91
    block@90: // after_if_else_L481
        let (awst_tmp%1#1: bool, awst_tmp%2#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.checkByID(id#13)
        goto block@91
    block@91: // after_inlined_smart_contracts/pool/contract.algo.ts::Pool.getStakeValue_L198
        let valid#0: bool = φ(smart_contracts/pool/contract.algo.ts::Pool.getStakeValue%0#0 <- block@87, smart_contracts/pool/contract.algo.ts::Pool.getStakeValue%0#1 <- block@89, awst_tmp%1#1 <- block@90)
        goto valid#0 ? block@93 : block@92
    block@92: // if_body_L203
        goto block@96
    block@93: // after_if_else_L203
        let (maybe_value%6#4: uint64, maybe_exists%6#4: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%6#4) // check GlobalState exists
        let (maybe_value%7#2: uint64, maybe_exists%7#4: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%7#4) // check GlobalState exists
        let passes#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%6#4, entry.address#4, maybe_value%7#2, entry.gateArgs#0)
        goto passes#0 ? block@95 : block@94
    block@94: // if_body_L208
        goto block@96
    block@95: // after_if_else_L208
        let count#2: uint64 = (+ count#1 1u)
        let total#3: uint64 = (+ total#2 entry.quantity#2)
        goto block@96
    block@96: // L196
        let count#4: uint64 = φ(count#1 <- block@85, count#1 <- block@92, count#1 <- block@94, count#2 <- block@95)
        let total#5: uint64 = φ(total#2 <- block@85, total#2 <- block@92, total#2 <- block@94, total#3 <- block@95)
        let id#15: uint64 = (+ id#13 1u)
        goto block@83
    block@97: // after_while_L196
        let (maybe_value%8#4: uint64, maybe_exists%8#4: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%8#4) // check GlobalState exists
        let materialized_values%0#4: uint64 = (+ maybe_value%8#4 iterationAmount#24)
        (app_global_put "disbursement_cursor" materialized_values%0#4)
        let (maybe_value%9#4: uint64, maybe_exists%9#4: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%9#4) // check GlobalState exists
        let materialized_values%1#0: uint64 = (+ maybe_value%9#4 count#1)
        let materialized_values%2#0: uint64 = (+ materialized_values%1#0 total#2)
        (app_global_put "qualified_stake" materialized_values%2#0)
        let (maybe_value%11#2: uint64, maybe_exists%11#2: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%11#2) // check GlobalState exists
        let (maybe_value%12#0: uint64, maybe_exists%12#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%12#0) // check GlobalState exists
        let tmp%3#4: bool = (== maybe_value%11#2 maybe_value%12#0)
        goto tmp%3#4 ? block@98 : block@22
    block@98: // if_body_L220
        (app_global_put "disbursement_phase" 0x14)
        (app_global_put "disbursement_cursor" 0u)
        goto block@22
    block@6: // else_body_L843
        let tmp%4#0: bool = (== reward.distribution#0 0x00)
        goto tmp%4#0 ? block@7 : block@8
    block@7: // if_body_L844
        let (maybe_value%0#4: uint64, maybe_exists%0#4: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#4) // check GlobalState exists
        let tmp%0#4: uint64 = (+ maybe_value%0#4 iterationAmount#0)
        let (maybe_value%1#4: uint64, maybe_exists%1#4: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#4) // check GlobalState exists
        let tmp%1#4: bool = (> tmp%0#4 maybe_value%1#4)
        goto tmp%1#4 ? block@69 : block@70
    block@69: // if_body_L228
        let (maybe_value%2#4: uint64, maybe_exists%2#4: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#4) // check GlobalState exists
        let (maybe_value%3#4: uint64, maybe_exists%3#4: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#4) // check GlobalState exists
        let iterationAmount#18: uint64 = (- maybe_value%2#4 maybe_value%3#4)
        goto block@70
    block@70: // after_if_else_L228
        let iterationAmount#20: uint64 = φ(iterationAmount#0 <- block@7, iterationAmount#18 <- block@69)
        let (maybe_value%4#4: bytes, maybe_exists%4#4: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%4#4) // check GlobalState exists
        let reward.rate#2: uint64 = (extract_uint64 maybe_value%4#4 9u)
        let allocations#18: bytes = 0x0000
        let sum#6: uint64 = 0u
        let (id#8: uint64, maybe_exists%5#4: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#4) // check GlobalState exists
        goto block@71
    block@71: // while_top_L236
        let id#9: uint64 = φ(id#8 <- block@70, id#11 <- block@75)
        let allocations#19: bytes = φ(allocations#18 <- block@70, allocations#21 <- block@75)
        let sum#7: uint64 = φ(sum#6 <- block@70, sum#9 <- block@75)
        let tmp%2#4: bool = (< id#9 iterationAmount#20)
        goto tmp%2#4 ? block@72 : block@76
    block@72: // while_body_L236
        let encoded_value%0#3: bytes[8] = (itob id#9)
        let box_prefixed_key%0#3: bytes = (concat "e" encoded_value%0#3)
        let (maybe_value%6#3: bytes, maybe_exists%6#3: bool) = (box_get box_prefixed_key%0#3)
        (assert maybe_exists%6#3) // Box must have value
        let entry.address#3: bytes[32] = ((extract 0 32) maybe_value%6#3) // on error: Index access is out of bounds
        let entry.quantity#1: uint64 = (extract_uint64 maybe_value%6#3 40u)
        let is_true%0#3: uint64 = (getbit maybe_value%6#3 400u)
        let encoded_bool%0#3: bytes[1] = (setbit 0x00 0u is_true%0#3)
        let entry.disqualified#3: bool = (getbit encoded_bool%0#3 0u)
        goto entry.disqualified#3 ? block@73 : block@74
    block@73: // if_body_L238
        goto block@75
    block@74: // after_if_else_L238
        let (b#0: uint64, maybe_exists%7#3: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%7#3) // check GlobalState exists
        let tmp%0#5: bool = (< entry.quantity#1 b#0)
        (assert tmp%0#5) // Invalid percentage of args
        let (tmp%1#5: uint64, tmp%2#5: uint64) = (mulw entry.quantity#1 100000u)
        let p#0: uint64 = (divw tmp%1#5 tmp%2#5 b#0)
        let tmp%0#6: bool = (<= p#0 100000u)
        (assert tmp%0#6) // Invalid percentage
        let (tmp%1#6: uint64, tmp%2#6: uint64) = (mulw reward.rate#2 p#0)
        let amount#6: uint64 = (divw tmp%1#6 tmp%2#6 100000u)
        let expr_value_trimmed%0#3: bytes = ((extract 2 0) allocations#19)
        let val_as_bytes%0#3: bytes[8] = (itob amount#6)
        let encoded_tuple_buffer%2#3: bytes = (concat entry.address#3 val_as_bytes%0#3)
        let array%encoded%0#1: bytes[40][] = encoded_tuple_buffer%2#3
        let array%data%0#1: bytes[40][] = encoded_tuple_buffer%2#3
        let concatenated%0#3: bytes = (concat expr_value_trimmed%0#3 encoded_tuple_buffer%2#3)
        let byte_len%0#3: uint64 = (len concatenated%0#3)
        let len_%0#3: uint64 = (/ byte_len%0#3 40u)
        let as_bytes%0#3: bytes[8] = (itob len_%0#3)
        let len_16_bit%0#3: bytes = ((extract 6 2) as_bytes%0#3)
        let allocations#20: bytes = (concat len_16_bit%0#3 concatenated%0#3)
        let sum#8: uint64 = (+ sum#7 amount#6)
        goto block@75
    block@75: // L236
        let allocations#21: bytes = φ(allocations#19 <- block@73, allocations#20 <- block@74)
        let sum#9: uint64 = φ(sum#7 <- block@73, sum#8 <- block@74)
        let id#11: uint64 = (+ id#9 1u)
        goto block@71
    block@76: // after_while_L236
        let (maybe_value%8#3: uint64, maybe_exists%8#3: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%8#3) // check GlobalState exists
        let materialized_values%0#3: uint64 = (+ maybe_value%8#3 iterationAmount#20)
        (app_global_put "disbursement_cursor" materialized_values%0#3)
        let (maybe_value%9#3: uint64, maybe_exists%9#3: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%9#3) // check GlobalState exists
        let allocations#22: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%9#3, reward.asset#0, allocations#19, sum#7)
        let (maybe_value%10#3: uint64, maybe_exists%10#3: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%10#3) // check GlobalState exists
        let (maybe_value%11#1: uint64, maybe_exists%11#1: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%11#1) // check GlobalState exists
        let tmp%4#4: bool = (== maybe_value%10#3 maybe_value%11#1)
        goto tmp%4#4 ? block@77 : block@22
    block@77: // if_body_L256
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@22
    block@8: // else_body_L846
        let tmp%5#0: bool = (== reward.distribution#0 0x01)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L846
        let (maybe_value%0#3: uint64, maybe_exists%0#3: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%0#3) // check GlobalState exists
        let total#0: uint64 = (* maybe_value%0#3 reward.rate#0)
        let tmp%0#3: bytes[32] = (global CurrentApplicationAddress)
        let (balance#2: uint64, _#2: bool) = ((asset_holding_get AssetBalance) tmp%0#3 reward.asset#0)
        let tmp%1#3: bool = (>= balance#2 total#0)
        (assert tmp%1#3) // Not enough funds
        let (maybe_value%1#3: uint64, maybe_exists%1#3: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%1#3) // check GlobalState exists
        let tmp%2#3: uint64 = (+ maybe_value%1#3 iterationAmount#0)
        let (maybe_value%2#3: uint64, maybe_exists%2#3: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#3) // check GlobalState exists
        let tmp%3#3: bool = (> tmp%2#3 maybe_value%2#3)
        goto tmp%3#3 ? block@57 : block@58
    block@57: // if_body_L268
        let (maybe_value%3#3: uint64, maybe_exists%3#3: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%3#3) // check GlobalState exists
        let (maybe_value%4#3: uint64, maybe_exists%4#3: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%4#3) // check GlobalState exists
        let iterationAmount#14: uint64 = (- maybe_value%3#3 maybe_value%4#3)
        goto block@58
    block@58: // after_if_else_L268
        let iterationAmount#16: uint64 = φ(iterationAmount#0 <- block@9, iterationAmount#14 <- block@57)
        let allocations#13: bytes = 0x0000
        let sum#2: uint64 = 0u
        let (id#4: uint64, maybe_exists%5#3: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#3) // check GlobalState exists
        goto block@59
    block@59: // while_top_L275
        let id#5: uint64 = φ(id#4 <- block@58, id#7 <- block@63)
        let allocations#14: bytes = φ(allocations#13 <- block@58, allocations#16 <- block@63)
        let sum#3: uint64 = φ(sum#2 <- block@58, sum#5 <- block@63)
        let tmp%4#3: bool = (< id#5 iterationAmount#16)
        goto tmp%4#3 ? block@60 : block@64
    block@60: // while_body_L275
        let encoded_value%0#2: bytes[8] = (itob id#5)
        let box_prefixed_key%0#2: bytes = (concat "e" encoded_value%0#2)
        let (maybe_value%6#2: bytes, maybe_exists%6#2: bool) = (box_get box_prefixed_key%0#2)
        (assert maybe_exists%6#2) // Box must have value
        let entry.address#2: bytes[32] = ((extract 0 32) maybe_value%6#2) // on error: Index access is out of bounds
        let is_true%0#2: uint64 = (getbit maybe_value%6#2 400u)
        let encoded_bool%0#2: bytes[1] = (setbit 0x00 0u is_true%0#2)
        let entry.disqualified#2: bool = (getbit encoded_bool%0#2 0u)
        goto entry.disqualified#2 ? block@61 : block@62
    block@61: // if_body_L277
        goto block@63
    block@62: // after_if_else_L277
        let expr_value_trimmed%0#2: bytes = ((extract 2 0) allocations#14)
        let val_as_bytes%0#2: bytes[8] = (itob reward.rate#0)
        let encoded_tuple_buffer%2#2: bytes = (concat entry.address#2 val_as_bytes%0#2)
        let array%encoded%1#1: bytes[40][] = encoded_tuple_buffer%2#2
        let array%data%1#1: bytes[40][] = encoded_tuple_buffer%2#2
        let concatenated%0#2: bytes = (concat expr_value_trimmed%0#2 encoded_tuple_buffer%2#2)
        let byte_len%0#2: uint64 = (len concatenated%0#2)
        let len_%0#2: uint64 = (/ byte_len%0#2 40u)
        let as_bytes%0#2: bytes[8] = (itob len_%0#2)
        let len_16_bit%0#2: bytes = ((extract 6 2) as_bytes%0#2)
        let allocations#15: bytes = (concat len_16_bit%0#2 concatenated%0#2)
        let sum#4: uint64 = (+ sum#3 reward.rate#0)
        goto block@63
    block@63: // L275
        let allocations#16: bytes = φ(allocations#14 <- block@61, allocations#15 <- block@62)
        let sum#5: uint64 = φ(sum#3 <- block@61, sum#4 <- block@62)
        let id#7: uint64 = (+ id#5 1u)
        goto block@59
    block@64: // after_while_L275
        let (maybe_value%7#1: uint64, maybe_exists%7#2: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#2) // check GlobalState exists
        let materialized_values%0#2: uint64 = (+ maybe_value%7#1 iterationAmount#16)
        (app_global_put "disbursement_cursor" materialized_values%0#2)
        let (maybe_value%8#2: uint64, maybe_exists%8#2: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%8#2) // check GlobalState exists
        let allocations#17: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%8#2, reward.asset#0, allocations#14, sum#3)
        let (maybe_value%9#2: uint64, maybe_exists%9#2: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#2) // check GlobalState exists
        let (maybe_value%10#2: uint64, maybe_exists%10#2: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#2) // check GlobalState exists
        let tmp%5#3: bool = (== maybe_value%9#2 maybe_value%10#2)
        goto tmp%5#3 ? block@65 : block@22
    block@65: // if_body_L293
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@22
    block@10: // else_body_L848
        let tmp%6#0: bool = (== reward.distribution#0 0x02)
        goto tmp%6#0 ? block@11 : block@12
    block@11: // if_body_L848
        let tmp%0#2: bytes[32] = (global CurrentApplicationAddress)
        let (balance#1: uint64, _#1: bool) = ((asset_holding_get AssetBalance) tmp%0#2 reward.asset#0)
        let tmp%1#2: bool = (>= balance#1 reward.rate#0)
        (assert tmp%1#2) // Not enough funds
        let (maybe_value%0#2: uint64, maybe_exists%0#2: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#2) // check GlobalState exists
        let tmp%2#2: uint64 = (+ maybe_value%0#2 iterationAmount#0)
        let (maybe_value%1#2: uint64, maybe_exists%1#2: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#2) // check GlobalState exists
        let tmp%3#2: bool = (> tmp%2#2 maybe_value%1#2)
        goto tmp%3#2 ? block@45 : block@46
    block@45: // if_body_L303
        let (maybe_value%2#2: uint64, maybe_exists%2#2: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#2) // check GlobalState exists
        let (maybe_value%3#2: uint64, maybe_exists%3#2: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#2) // check GlobalState exists
        let iterationAmount#10: uint64 = (- maybe_value%2#2 maybe_value%3#2)
        goto block@46
    block@46: // after_if_else_L303
        let iterationAmount#12: uint64 = φ(iterationAmount#0 <- block@11, iterationAmount#10 <- block@45)
        let (maybe_value%4#2: uint64, maybe_exists%4#2: bool) = (app_global_get_ex 0u "qualified_stake")
        (assert maybe_exists%4#2) // check GlobalState exists
        let amount#4: uint64 = (/ reward.rate#0 maybe_value%4#2)
        let allocations#8: bytes = 0x0000
        let (id#0: uint64, maybe_exists%5#2: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%5#2) // check GlobalState exists
        goto block@47
    block@47: // while_top_L309
        let id#1: uint64 = φ(id#0 <- block@46, id#3 <- block@51)
        let allocations#9: bytes = φ(allocations#8 <- block@46, allocations#11 <- block@51)
        let tmp%4#2: bool = (< id#1 iterationAmount#12)
        goto tmp%4#2 ? block@48 : block@52
    block@48: // while_body_L309
        let encoded_value%0#1: bytes[8] = (itob id#1)
        let box_prefixed_key%0#1: bytes = (concat "e" encoded_value%0#1)
        let (maybe_value%6#1: bytes, maybe_exists%6#1: bool) = (box_get box_prefixed_key%0#1)
        (assert maybe_exists%6#1) // Box must have value
        let entry.address#1: bytes[32] = ((extract 0 32) maybe_value%6#1) // on error: Index access is out of bounds
        let is_true%0#1: uint64 = (getbit maybe_value%6#1 400u)
        let encoded_bool%0#1: bytes[1] = (setbit 0x00 0u is_true%0#1)
        let entry.disqualified#1: bool = (getbit encoded_bool%0#1 0u)
        goto entry.disqualified#1 ? block@49 : block@50
    block@49: // if_body_L311
        goto block@51
    block@50: // after_if_else_L311
        let expr_value_trimmed%0#1: bytes = ((extract 2 0) allocations#9)
        let val_as_bytes%0#1: bytes[8] = (itob amount#4)
        let encoded_tuple_buffer%2#1: bytes = (concat entry.address#1 val_as_bytes%0#1)
        let array%encoded%2#1: bytes[40][] = encoded_tuple_buffer%2#1
        let array%data%2#1: bytes[40][] = encoded_tuple_buffer%2#1
        let concatenated%0#1: bytes = (concat expr_value_trimmed%0#1 encoded_tuple_buffer%2#1)
        let byte_len%0#1: uint64 = (len concatenated%0#1)
        let len_%0#1: uint64 = (/ byte_len%0#1 40u)
        let as_bytes%0#1: bytes[8] = (itob len_%0#1)
        let len_16_bit%0#1: bytes = ((extract 6 2) as_bytes%0#1)
        let allocations#10: bytes = (concat len_16_bit%0#1 concatenated%0#1)
        goto block@51
    block@51: // L309
        let allocations#11: bytes = φ(allocations#9 <- block@49, allocations#10 <- block@50)
        let id#3: uint64 = (+ id#1 1u)
        goto block@47
    block@52: // after_while_L309
        let (maybe_value%7#0: uint64, maybe_exists%7#1: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#1) // check GlobalState exists
        let materialized_values%0#1: uint64 = (+ maybe_value%7#0 iterationAmount#12)
        (app_global_put "disbursement_cursor" materialized_values%0#1)
        let (maybe_value%8#1: uint64, maybe_exists%8#1: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%8#1) // check GlobalState exists
        let allocations#12: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%8#1, reward.asset#0, allocations#9, reward.rate#0)
        let (maybe_value%9#1: uint64, maybe_exists%9#1: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#1) // check GlobalState exists
        let (maybe_value%10#1: uint64, maybe_exists%10#1: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#1) // check GlobalState exists
        let tmp%5#2: bool = (== maybe_value%9#1 maybe_value%10#1)
        goto tmp%5#2 ? block@53 : block@22
    block@53: // if_body_L326
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        goto block@22
    block@12: // else_body_L850
        let tmp%7#0: bool = (== reward.distribution#0 0x03)
        (assert tmp%7#0) // unknown reward rate type
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%8#0: uint64 = (extract_uint16 maybe_value%5#0 0u)
        goto tmp%8#0 ? block@15 : block@14
    block@14: // if_body_L851
        smart_contracts/pool/contract.algo.ts::Pool.raffle()
        goto block@22
    block@15: // else_body_L853
        let tmp%0#1: bytes[32] = (global CurrentApplicationAddress)
        let (balance#0: uint64, _#0: bool) = ((asset_holding_get AssetBalance) tmp%0#1 reward.asset#0)
        let tmp%1#1: bool = (>= balance#0 reward.rate#0)
        (assert tmp%1#1) // Not enough funds
        let (maybe_value%0#1: uint64, maybe_exists%0#1: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%0#1) // check GlobalState exists
        let tmp%2#1: uint64 = (+ maybe_value%0#1 iterationAmount#0)
        let (maybe_value%1#1: uint64, maybe_exists%1#1: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%1#1) // check GlobalState exists
        let tmp%3#1: bool = (> tmp%2#1 maybe_value%1#1)
        goto tmp%3#1 ? block@24 : block@25
    block@24: // if_body_L342
        let (maybe_value%2#1: uint64, maybe_exists%2#1: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%2#1) // check GlobalState exists
        let (maybe_value%3#1: uint64, maybe_exists%3#1: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%3#1) // check GlobalState exists
        let iterationAmount#2: uint64 = (- maybe_value%2#1 maybe_value%3#1)
        goto block@25
    block@25: // after_if_else_L342
        let iterationAmount#7: uint64 = φ(iterationAmount#0 <- block@15, iterationAmount#2 <- block@24)
        let (maybe_value%4#1: bytes, maybe_exists%4#1: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%4#1) // check GlobalState exists
        let reward.rate#1: uint64 = (extract_uint64 maybe_value%4#1 9u)
        let reward.winnerCount#1: uint64 = (extract_uint64 maybe_value%4#1 25u)
        goto reward.winnerCount#1 ? block@26 : block@27
    block@26: // if_body_L349
        let amount#1: uint64 = (/ reward.rate#1 reward.winnerCount#1)
        goto block@27
    block@27: // after_if_else_L349
        let amount#3: uint64 = φ(reward.rate#1 <- block@25, amount#1 <- block@26)
        let (tickets#0: encoded_uint64[], maybe_exists%5#1: bool) = (app_global_get_ex 0u "wtickets")
        (assert maybe_exists%5#1) // check GlobalState exists
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "raffle_cursor")
        (assert maybe_exists%6#0) // check GlobalState exists
        let ticket#0: uint64 = (extract_uint64 maybe_value%6#0 0u)
        let stake#0: uint64 = (extract_uint64 maybe_value%6#0 8u)
        let disbursed#0: uint64 = (extract_uint64 maybe_value%6#0 16u)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) tickets#0)
        let item_offset%0#0: uint64 = (* ticket#0 8u)
        let currentTicket#0: uint64 = (extract_uint64 array_head_and_tail%0#0 item_offset%0#0)
        let allocations#0: bytes = 0x0000
        let (i#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%7#0) // check GlobalState exists
        goto block@28
    block@28: // while_top_L360
        let i#1: uint64 = φ(i#0 <- block@27, i#5 <- block@38)
        let iterationAmount#3: uint64 = φ(iterationAmount#7 <- block@27, iterationAmount#8 <- block@38)
        let currentRangeStart#1: uint64 = φ(stake#0 <- block@27, currentRangeStart#2 <- block@38)
        let currentTicket#1: uint64 = φ(currentTicket#0 <- block@27, currentTicket#3 <- block@38)
        let allocations#1: bytes = φ(allocations#0 <- block@27, allocations#5 <- block@38)
        let disbursed#1: uint64 = φ(disbursed#0 <- block@27, disbursed#4 <- block@38)
        let ticket#2: uint64 = φ(ticket#0 <- block@27, ticket#4 <- block@38)
        let stake#4: uint64 = φ(stake#0 <- block@27, stake#5 <- block@38)
        let tmp%5#1: bool = (< i#1 iterationAmount#3)
        goto tmp%5#1 ? block@29 : block@39
    block@29: // while_body_L360
        let encoded_value%0#0: bytes[8] = (itob i#1)
        let box_prefixed_key%0#0: bytes = (concat "e" encoded_value%0#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%8#0) // Box must have value
        let entry.address#0: bytes[32] = ((extract 0 32) maybe_value%8#0) // on error: Index access is out of bounds
        let entry.quantity#0: uint64 = (extract_uint64 maybe_value%8#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%8#0 400u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let entry.disqualified#0: bool = (getbit encoded_bool%0#0 0u)
        let currentRangeEnd#1: uint64 = (+ currentRangeStart#1 entry.quantity#0)
        let tmp%6#1: bool = (>= currentTicket#1 currentRangeStart#1)
        goto tmp%6#1 ? block@30 : block@38
    block@30: // and_contd_L364
        let tmp%7#1: bool = (<= currentTicket#1 currentRangeEnd#1)
        goto tmp%7#1 ? block@31 : block@38
    block@31: // if_body_L364
        goto entry.disqualified#0 ? block@33 : block@32
    block@32: // if_body_L365
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) allocations#1)
        let val_as_bytes%0#0: bytes[8] = (itob amount#3)
        let encoded_tuple_buffer%2#0: bytes = (concat entry.address#0 val_as_bytes%0#0)
        let array%encoded%3#1: bytes[40][] = encoded_tuple_buffer%2#0
        let array%data%3#1: bytes[40][] = encoded_tuple_buffer%2#0
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded_tuple_buffer%2#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 40u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let allocations#2: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let disbursed#2: uint64 = (+ disbursed#1 1u)
        goto block@33
    block@33: // after_if_else_L365
        let disbursed#3: uint64 = φ(disbursed#1 <- block@31, disbursed#2 <- block@32)
        let allocations#3: bytes = φ(allocations#1 <- block@31, allocations#2 <- block@32)
        let tmp%8#1: uint64 = (extract_uint16 tickets#0 0u)
        let tmp%9#1: uint64 = (- tmp%8#1 1u)
        let tmp%10#0: bool = (== ticket#2 tmp%9#1)
        goto tmp%10#0 ? block@34 : block@37
    block@34: // if_body_L375
        let tmp%11#0: bool = (!= reward.winnerCount#1 disbursed#3)
        goto tmp%11#0 ? block@35 : block@36
    block@35: // if_body_L377
        (app_global_put "disbursement_cursor" 0u)
        let val_as_bytes%1#0: bytes[8] = (itob disbursed#3)
        let encoded_tuple_buffer%6#0: bytes = (concat 0x00000000000000000000000000000000 val_as_bytes%1#0)
        (app_global_put "raffle_cursor" encoded_tuple_buffer%6#0)
        (app_global_put "wtickets" 0x0000)
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%9#0) // check GlobalState exists
        let allocations#4: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%9#0, reward.asset#0, allocations#3, reward.rate#0)
        goto block@22
    block@36: // after_if_else_L377
        goto block@40
    block@37: // after_if_else_L375
        let iterationAmount#5: uint64 = (- iterationAmount#3 i#1)
        let ticket#3: uint64 = (+ ticket#2 1u)
        let item_offset%1#0: uint64 = (* ticket#3 8u)
        let currentTicket#2: uint64 = (extract_uint64 array_head_and_tail%0#0 item_offset%1#0)
        (app_global_put "disbursement_cursor" 0u)
        let i#3: uint64 = 0u
        let stake#1: uint64 = 0u
        let currentRangeEnd#2: uint64 = 0u
        goto block@38
    block@38: // after_if_else_L364
        let currentRangeEnd#3: uint64 = φ(currentRangeEnd#1 <- block@29, currentRangeEnd#1 <- block@30, currentRangeEnd#2 <- block@37)
        let i#4: uint64 = φ(i#1 <- block@29, i#1 <- block@30, i#3 <- block@37)
        let iterationAmount#8: uint64 = φ(iterationAmount#3 <- block@29, iterationAmount#3 <- block@30, iterationAmount#5 <- block@37)
        let currentTicket#3: uint64 = φ(currentTicket#1 <- block@29, currentTicket#1 <- block@30, currentTicket#2 <- block@37)
        let allocations#5: bytes = φ(allocations#1 <- block@29, allocations#1 <- block@30, allocations#3 <- block@37)
        let disbursed#4: uint64 = φ(disbursed#1 <- block@29, disbursed#1 <- block@30, disbursed#3 <- block@37)
        let ticket#4: uint64 = φ(ticket#2 <- block@29, ticket#2 <- block@30, ticket#3 <- block@37)
        let stake#5: uint64 = φ(stake#4 <- block@29, stake#4 <- block@30, stake#1 <- block@37)
        let currentRangeStart#2: uint64 = (+ currentRangeEnd#3 1u)
        let i#5: uint64 = (+ i#4 1u)
        goto block@28
    block@39: // after_while_L360
        goto block@40
    block@40: // L360
        let disbursed#5: uint64 = φ(disbursed#3 <- block@36, disbursed#1 <- block@39)
        let allocations#6: bytes = φ(allocations#3 <- block@36, allocations#1 <- block@39)
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "disbursement_cursor")
        (assert maybe_exists%10#0) // check GlobalState exists
        let materialized_values%0#0: uint64 = (+ maybe_value%10#0 iterationAmount#3)
        (app_global_put "disbursement_cursor" materialized_values%0#0)
        let val_as_bytes%2#0: bytes[8] = (itob ticket#2)
        let val_as_bytes%3#0: bytes[8] = (itob stake#4)
        let val_as_bytes%4#0: bytes[8] = (itob disbursed#5)
        let encoded_tuple_buffer%9#0: bytes = (concat val_as_bytes%2#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        (app_global_put "raffle_cursor" encoded_tuple_buffer%10#0)
        let (maybe_value%11#0: uint64, maybe_exists%11#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%11#0) // check GlobalState exists
        let allocations#7: bytes = smart_contracts/pool/contract.algo.ts::Pool.createRewardAllocations(maybe_value%11#0, reward.asset#0, allocations#6, reward.rate#0)
        let tmp%12#0: bool = (== reward.winnerCount#1 disbursed#5)
        goto tmp%12#0 ? block@41 : block@22
    block@41: // if_body_L410
        (app_global_put "disbursement_phase" 0x1e)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "raffle_cursor" 0x000000000000000000000000000000000000000000000000)
        (app_global_put "wtickets" 0x0000)
        goto block@22
    block@22: // after_if_else_L841
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.finalizeDistribution() -> void:
    block@0: // L862
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "disbursement_phase")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 0x1e)
        (assert tmp%0#0) // Disbursement not ready for finalization
        let (disbursementID#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "active_disbursement_id")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (akitaDAO#0: uint64, maybe_exists%0#1: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#1) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let rewardsApp#0: uint64 = (extract_uint64 appListBytes#0 8u)
        itxn_begin
        let val_as_bytes%0#0: bytes[8] = (itob disbursementID#0)
        ((itxn_field ApplicationArgs) method "finalizeDisbursement(uint64)void")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) rewardsApp#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let box_prefixed_key%0#0: bytes = (concat "d" val_as_bytes%0#0)
        (box_create box_prefixed_key%0#0 0u)
        (app_global_put "active_disbursement_id" 0u)
        (app_global_put "disbursement_phase" 0x00)
        (app_global_put "disbursement_cursor" 0u)
        (app_global_put "qualified_stake" 0u)
        (app_global_put "status" 0x0a)
        return 

subroutine smart_contracts/pool/contract.algo.ts::Pool.check(address: bytes[32], asset: uint64) -> <bool, uint64>:
    block@0: // L877
        let val_as_bytes%0#0: bytes[8] = (itob asset#0)
        let key#0: bytes[40] = (concat address#0 val_as_bytes%0#0)
        let box_prefixed_key%0#0: bytes = (concat "a" key#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let id#0: uint64 = (btoi maybe_value%0#0)
        let (awst_tmp%0#0: bool, awst_tmp%1#0: uint64) = smart_contracts/pool/contract.algo.ts::Pool.checkByID(id#0)
        return awst_tmp%0#0 awst_tmp%1#0

subroutine smart_contracts/pool/contract.algo.ts::Pool.signUpsOpen() -> bool:
    block@0: // L886
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // and_contd_L889
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "signup_timestamp")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (> tmp%1#0 maybe_value%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // and_contd_L889
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%4#0: bool = (< tmp%3#0 maybe_value%2#0)
        goto tmp%4#0 ? block@4 : block@3
    block@3: // or_contd_L891
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%3#0) // check GlobalState exists
        goto maybe_value%3#0 ? block@4 : block@5
    block@4: // bool_true_L889
        let and_result%0#0: bool = 1u
        goto block@6
    block@5: // bool_false_L889
        let and_result%0#1: bool = 0u
        goto block@6
    block@6: // bool_merge_L889
        let and_result%0#2: bool = φ(and_result%0#0 <- block@4, and_result%0#1 <- block@5)
        return and_result%0#2

subroutine smart_contracts/pool/contract.algo.ts::Pool.isLive() -> bool:
    block@0: // L896
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%0#0: bool = (!= maybe_value%0#0 0x00)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // and_contd_L899
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let (maybe_value%1#0: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%2#0: bool = (>= tmp%1#0 maybe_value%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // and_contd_L899
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%4#0: bool = (<= tmp%3#0 maybe_value%2#0)
        goto tmp%4#0 ? block@4 : block@3
    block@3: // or_contd_L901
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%3#0) // check GlobalState exists
        goto maybe_value%3#0 ? block@5 : block@4
    block@4: // bool_true_L899
        let and_result%0#0: bool = 1u
        goto block@6
    block@5: // bool_false_L899
        let and_result%0#1: bool = 0u
        goto block@6
    block@6: // bool_merge_L899
        let and_result%0#2: bool = φ(and_result%0#0 <- block@4, and_result%0#1 <- block@5)
        return and_result%0#2

subroutine smart_contracts/pool/contract.algo.ts::Pool.getState() -> <bytes[1], bytes, bytes[1], uint64, bytes[1], uint64, uint64, uint64, uint64, uint64, bool, uint64, uint64, uint64, uint64, bytes[32], bytes, uint64, uint64, bytes[32]>:
    block@0: // L905
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "status")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "title")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "type")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "reward")
        (assert maybe_exists%3#0) // check GlobalState exists
        let item0%1#0: uint64 = (extract_uint64 maybe_value%3#0 0u)
        let item1%0#0: bytes = ((extract 8 1) maybe_value%3#0) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (extract_uint64 maybe_value%3#0 9u)
        let item3%1#0: uint64 = (extract_uint64 maybe_value%3#0 17u)
        let item4%1#0: uint64 = (extract_uint64 maybe_value%3#0 25u)
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "signup_timestamp")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (maybe_value%5#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "allow_late_signups")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (maybe_value%6#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "start_timestamp")
        (assert maybe_exists%6#0) // check GlobalState exists
        let (maybe_value%7#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "end_timestamp")
        (assert maybe_exists%7#0) // check GlobalState exists
        let (maybe_value%8#0: uint64, maybe_exists%8#0: bool) = (app_global_get_ex 0u "max_entries")
        (assert maybe_exists%8#0) // check GlobalState exists
        let (maybe_value%9#0: uint64, maybe_exists%9#0: bool) = (app_global_get_ex 0u "entry_count")
        (assert maybe_exists%9#0) // check GlobalState exists
        let tmp%0#0: uint64 = (+ maybe_value%9#0 1u)
        let (maybe_value%10#0: uint64, maybe_exists%10#0: bool) = (app_global_get_ex 0u "total_staked")
        (assert maybe_exists%10#0) // check GlobalState exists
        let (maybe_value%11#0: bytes, maybe_exists%11#0: bool) = (app_global_get_ex 0u "stake_key")
        (assert maybe_exists%11#0) // check GlobalState exists
        let item0%2#0: bytes = ((extract 0 32) maybe_value%11#0) // on error: Index access is out of bounds
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%11#0 32u)
        let item_end_offset%0#0: uint64 = (len maybe_value%11#0)
        let item1%1#0: bytes = (substring3 maybe_value%11#0 item_start_offset%0#0 item_end_offset%0#0)
        let item1%2#0: bytes = ((extract 2 0) item1%1#0)
        let (maybe_value%12#0: uint64, maybe_exists%12#0: bool) = (app_global_get_ex 0u "minimum_stake_amount")
        (assert maybe_exists%12#0) // check GlobalState exists
        let (maybe_value%13#0: uint64, maybe_exists%13#0: bool) = (app_global_get_ex 0u "gate_id")
        (assert maybe_exists%13#0) // check GlobalState exists
        let (maybe_value%14#0: bytes, maybe_exists%14#0: bool) = (app_global_get_ex 0u "creator")
        (assert maybe_exists%14#0) // check GlobalState exists
        return maybe_value%0#0 maybe_value%1#0 maybe_value%2#0 item0%1#0 item1%0#0 item2%1#0 item3%1#0 item4%1#0 maybe_value%4#0 maybe_value%6#0 maybe_value%5#0 maybe_value%7#0 maybe_value%8#0 tmp%0#0 maybe_value%10#0 item0%2#0 item1%2#0 maybe_value%12#0 maybe_value%13#0 maybe_value%14#0

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
    block@0: // L19
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "version" newVersion#0)
        return 

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
    block@0: // L27
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "akita_dao" app#0)
        return 

subroutine smart_contracts/utils/base-contracts/optin.ts::ContractWithCreatorOnlyOptIn.optin(payment: uint64, asset: uint64) -> void:
    block@0: // L51
        let tmp%0#0: bytes[32] = (txn Sender)
        let tmp%1#0: bytes[32] = (global CreatorAddress)
        let tmp%2#0: bool = (== tmp%0#0 tmp%1#0)
        (assert tmp%2#0)
        let tmp%3#0: bytes[32] = ((gtxns Receiver) payment#0)
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (== tmp%3#0 tmp%4#0)
        goto tmp%5#0 ? block@1 : block@3
    block@1: // and_contd_L54
        let tmp%6#0: uint64 = ((gtxns Amount) payment#0)
        let tmp%7#0: uint64 = (global AssetOptInMinBalance)
        let tmp%8#0: bool = (== tmp%6#0 tmp%7#0)
        goto tmp%8#0 ? block@2 : block@3
    block@2: // bool_true_L54
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L54
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L54
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // Invalid payment
        itxn_begin
        let inner_txn_params%0%%param_AssetReceiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field XferAsset) asset#0)
        ((itxn_field AssetAmount) 0u)
        ((itxn_field AssetReceiver) inner_txn_params%0%%param_AssetReceiver_idx_0#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 