#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "akita_dao"
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    txn NumAppArgs
    bz main_bare_routing@8
    pushbytess 0xc385cfae 0x33e92c94 0x1ead20a9 // method "updateApplication(string,string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_updateApplication_route@3 main_updateAkitaDAO_route@4 main_updateAkitaDAOEscrow_route@5

main_after_if_else@12:
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    intc_0 // 0
    return

main_updateAkitaDAOEscrow_route@5:
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_1 // 1
    return

main_updateAkitaDAO_route@4:
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_updateApplication_route@3:
    // smart_contracts/utils/base-contracts/factory.ts:79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_1 // 1
    return

main_bare_routing@8:
    // smart_contracts/offer-box/factory.algo.ts:3
    // export class OfferBoxFactory extends ServiceFactoryContract {}
    txn OnCompletion
    bnz main_after_if_else@12
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateApplication(newVersion: bytes, newChildVersion: bytes) -> void:
updateApplication:
    // smart_contracts/utils/base-contracts/factory.ts:79-80
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(newVersion: string, newChildVersion: string): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    pushbytes "version"
    // smart_contracts/utils/base-contracts/factory.ts:82
    // this.version.value = newVersion
    frame_dig -2
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:19
    // export const BaseFactoryGlobalStateKeyChildContractVersion = 'child_contract_version'
    pushbytes "child_contract_version"
    // smart_contracts/utils/base-contracts/factory.ts:83
    // this.childContractVersion.value = newChildVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:89
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:89
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:90
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:94
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:94
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    pushbytes "akita_escrow"
    // smart_contracts/utils/base-contracts/factory.ts:95
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
