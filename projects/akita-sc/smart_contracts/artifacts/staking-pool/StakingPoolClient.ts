/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"StakingPool","structs":{"ObjectC3416591":[{"name":"valid","type":"bool"},{"name":"balance","type":"uint64"}],"RootKey":[{"name":"address","type":"address"},{"name":"name","type":"string"}],"EntryData":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"},{"name":"quantity","type":"uint64"},{"name":"gateArgs","type":"byte[][]"},{"name":"disqualified","type":"bool"}],"EntryKey":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"}],"RaffleCursor":[{"name":"ticket","type":"uint64"},{"name":"stake","type":"uint64"},{"name":"disbursed","type":"uint64"}],"Reward":[{"name":"asset","type":"uint64"},{"name":"distribution","type":"uint8"},{"name":"rate","type":"uint64"},{"name":"expiration","type":"uint64"},{"name":"interval","type":"uint64"},{"name":"qualifiedStakers","type":"uint64"},{"name":"qualifiedStake","type":"uint64"},{"name":"winnerCount","type":"uint64"},{"name":"winningTickets","type":"uint64[]"},{"name":"raffleCursor","type":"RaffleCursor"},{"name":"vrfFailureCount","type":"uint64"},{"name":"phase","type":"uint8"},{"name":"disbursementCursor","type":"uint64"},{"name":"activeDisbursementId","type":"uint64"},{"name":"activeDisbursementRoundStart","type":"uint64"},{"name":"lastDisbursementTimestamp","type":"uint64"}],"StakingPoolMBRData":[{"name":"entries","type":"uint64"},{"name":"uniques","type":"uint64"},{"name":"entriesByAddress","type":"uint64"},{"name":"rewards","type":"uint64"},{"name":"disbursements","type":"uint64"}],"StakingPoolState":[{"name":"status","type":"uint8"},{"name":"title","type":"string"},{"name":"type","type":"uint8"},{"name":"signupTimestamp","type":"uint64"},{"name":"startTimestamp","type":"uint64"},{"name":"allowLateSignups","type":"bool"},{"name":"endTimestamp","type":"uint64"},{"name":"maxEntries","type":"uint64"},{"name":"entryCount","type":"uint64"},{"name":"rewardCount","type":"uint64"},{"name":"totalStaked","type":"uint64"},{"name":"stakeKey","type":"RootKey"},{"name":"minimumStakeAmount","type":"uint64"},{"name":"gateId","type":"uint64"},{"name":"creator","type":"address"}],"FunderInfo":[{"name":"account","type":"address"},{"name":"amount","type":"uint64"}]},"methods":[{"name":"create","args":[{"type":"string","name":"title"},{"type":"uint8","name":"type"},{"type":"address","name":"creator"},{"type":"(address,uint64)","struct":"FunderInfo","name":"funder"},{"type":"address","name":"marketplace"},{"type":"(address,string)","struct":"RootKey","name":"stakeKey"},{"type":"uint64","name":"minimumStakeAmount"},{"type":"uint64","name":"gateID"},{"type":"uint64","name":"maxEntries"},{"type":"uint64","name":"akitaDAO"},{"type":"uint64","name":"akitaDAOEscrow"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"init","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"delete","args":[{"type":"address","name":"caller"}],"returns":{"type":"void"},"actions":{"create":[],"call":["DeleteApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"optIn","args":[{"type":"pay","name":"payment","desc":"The payment transaction"},{"type":"uint64","name":"asset","desc":"The asset to be opted into"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in","events":[],"recommendations":{}},{"name":"addReward","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"addRewardAsa","args":[{"type":"pay","name":"payment"},{"type":"axfer","name":"assetXfer"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalize","args":[{"type":"uint64","name":"signupTimestamp"},{"type":"uint64","name":"startTimestamp"},{"type":"uint64","name":"endTimestamp"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"enter","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint64,byte[32][])[]","name":"entries"},{"type":"byte[][]","name":"args"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"startDisbursement","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"raffle","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"disburseRewards","args":[{"type":"uint64","name":"rewardID"},{"type":"uint64","name":"iterationAmount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalizeDistribution","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"check","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(bool,uint64)","struct":"ObjectC3416591"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"signUpsOpen","args":[],"returns":{"type":"bool","desc":"a boolean of whether sign ups are open"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isLive","args":[],"returns":{"type":"bool","desc":"a boolean of whether the pool is live"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isEntered","args":[{"type":"address","name":"address"}],"returns":{"type":"bool","desc":"a boolean indicating if the address has entered the staking pool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getState","args":[],"returns":{"type":"(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)","struct":"StakingPoolState"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"updateAkitaDAOEscrow","args":[{"type":"uint64","name":"app"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"update","args":[{"type":"string","name":"newVersion"}],"returns":{"type":"void"},"actions":{"create":[],"call":["UpdateApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateAkitaDAO","args":[{"type":"uint64","name":"akitaDAO"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"opUp","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"mbr","args":[{"type":"uint64","name":"winningTickets"}],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","struct":"StakingPoolMBRData","desc":"the mbr created for each boxmap entry"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":16,"bytes":9},"local":{"ints":0,"bytes":0}},"keys":{"global":{"status":{"keyType":"AVMString","valueType":"uint8","key":"c3RhdHVz","desc":"the status the pool is in"},"title":{"keyType":"AVMString","valueType":"AVMString","key":"dGl0bGU=","desc":"title of the staking pool"},"type":{"keyType":"AVMString","valueType":"uint8","key":"dHlwZQ==","desc":"the method of staking to be used for the pool"},"signupTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c2lnbnVwX3RpbWVzdGFtcA==","desc":"the timestamp when sign ups for the pool are allowed"},"allowLateSignups":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWxsb3dfbGF0ZV9zaWdudXBz","desc":"whether signups are allowed after the staking pool begins"},"startTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c3RhcnRfdGltZXN0YW1w","desc":"the timestamp when the pool starts"},"endTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW5kX3RpbWVzdGFtcA==","desc":"the timestamp when the pool ends"},"maxEntries":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWF4X2VudHJpZXM=","desc":"the maximum entries allowed for the pool"},"entryID":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW50cnlfY291bnQ=","desc":"the number of entries in a pool"},"rewardID":{"keyType":"AVMString","valueType":"AVMUint64","key":"cmV3YXJkX2NvdW50","desc":"the number of rewards for the pool"},"totalStaked":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxfc3Rha2Vk","desc":"the total amount staked in the pool"},"stakeKey":{"keyType":"AVMString","valueType":"RootKey","key":"c3Rha2Vfa2V5","desc":"the name for the meta merkle asset group to validate staking\nstake key can be empty if distribution !== DistributionTypePercentage"},"minimumStakeAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWluaW11bV9zdGFrZV9hbW91bnQ=","desc":"minimum stake amount"},"gateID":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9pZA==","desc":"the gate id of the pool"},"gateSize":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9zaXpl","desc":"the size of the gate were using"},"creator":{"keyType":"AVMString","valueType":"address","key":"Y3JlYXRvcg==","desc":"the address of the creator of the staking pool"},"marketplace":{"keyType":"AVMString","valueType":"address","key":"bWFya2V0cGxhY2U=","desc":"marketplace is pool creation side marketplace"},"marketplaceRoyalties":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWFya2V0cGxhY2Vfcm95YWx0aWVz","desc":"the amount the marketplaces will get for the sale"},"akitaRoyalty":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eQ==","desc":"the akita royalty for the pool"},"akitaRoyaltyAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eV9hbW91bnQ=","desc":"the amount of royalties that were paid in a disbursement"},"salt":{"keyType":"AVMString","valueType":"AVMBytes","key":"c2FsdA==","desc":"salt for randomness"},"akitaDAOEscrow":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZXNjcm93","desc":"the app ID for the akita DAO escrow to use"},"version":{"keyType":"AVMString","valueType":"AVMString","key":"dmVyc2lvbg==","desc":"the current version of the contract"},"akitaDAO":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZGFv","desc":"the app ID of the Akita DAO"},"funder":{"keyType":"AVMString","valueType":"FunderInfo","key":"ZnVuZGVy"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"entries":{"keyType":"uint64","valueType":"EntryData","desc":"indexed entries for efficient iteration","prefix":"ZQ=="},"uniques":{"keyType":"address","valueType":"uint64","desc":"the number of unique asset entries by address","prefix":"dQ=="},"entriesByAddress":{"keyType":"EntryKey","valueType":"uint64","desc":"the entries in the pool","prefix":"YQ=="},"rewards":{"keyType":"uint64","valueType":"Reward","desc":"the rewards for this staking pool","prefix":"cg=="},"disbursements":{"keyType":"uint64","valueType":"AVMBytes","desc":"the disbursements this pool as created & finalized","prefix":"ZA=="}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[2837,4701,6297],"errorMessage":"Box must have value"},{"pc":[661,754,1077,1195,1449,2184,2298,2610,3082,5305,5404,5934],"errorMessage":"Bytes has valid prefix"},{"pc":[3239],"errorMessage":"DAO not opted in to the asset"},{"pc":[4592],"errorMessage":"Disbursement not ready for finalization"},{"pc":[1469],"errorMessage":"Escrow does not exist"},{"pc":[1307,5622],"errorMessage":"Forbidden"},{"pc":[5063],"errorMessage":"Invalid app upgrade"},{"pc":[5854],"errorMessage":"Invalid disbursement phase"},{"pc":[1345,2001,5757],"errorMessage":"Invalid payment"},{"pc":[3193,3272,3458,3632],"errorMessage":"Invalid percentage"},{"pc":[3447],"errorMessage":"Invalid percentage of args"},{"pc":[5190],"errorMessage":"Invalid pool type for check"},{"pc":[1677],"errorMessage":"Invalid transfer"},{"pc":[5729],"errorMessage":"Max entries cannot be greater than rate"},{"pc":[5628],"errorMessage":"Must be an Algo asset"},{"pc":[3653,3885,4133],"errorMessage":"Not enough funds"},{"pc":[2750],"errorMessage":"Not ready to disburse"},{"pc":[609],"errorMessage":"OnCompletion must be DeleteApplication && can only call when not creating"},{"pc":[426],"errorMessage":"OnCompletion must be NoOp"},{"pc":[597],"errorMessage":"OnCompletion must be UpdateApplication && can only call when not creating"},{"pc":[5011,5052,5100],"errorMessage":"Only the Akita DAO can call this function"},{"pc":[5697],"errorMessage":"Rate must be greater than winner count"},{"pc":[5735],"errorMessage":"Rate must be greater than zero"},{"pc":[5655],"errorMessage":"Stake key required"},{"pc":[5864],"errorMessage":"Winning tickets already exist"},{"pc":[1479],"errorMessage":"Wrong escrow for this operation"},{"pc":[1538,2535,5009,5048,5098,5490,5542,5559],"errorMessage":"application exists"},{"pc":[1231],"errorMessage":"call must come from factory"},{"pc":[996,1030,1035,1141,1149,1161,1236,1243,1255,1305,1369,1474,1720,1727,1760,1795,1891,1920,1935,1942,1951,2006,2091,2106,2197,2208,2243,2317,2463,2490,2799,2807,2884,2910,2935,2952,3011,3034,3141,3188,3267,3357,3365,3375,3536,3621,3627,3660,3668,3790,3876,3892,3900,4020,4124,4140,4148,4596,4716,4728,4739,4748,4814,4819,4824,4829,4834,4839,4844,4849,4853,4860,4879,4884,4889,4894,4899,5002,5040,5091,5172,5182,5248,5259,5356,5440,5464,5620,5633,5710,5718,5762,5889,6341,6353,6364,6373],"errorMessage":"check GlobalState exists"},{"pc":[2485],"errorMessage":"distribution window is not open"},{"pc":[2192],"errorMessage":"failed to verify stake requirements"},{"pc":[1800],"errorMessage":"if the starting round is zero, the signup round must be zero and allowLateSignups must be true"},{"pc":[2062],"errorMessage":"index access is out of bounds"},{"pc":[5310],"errorMessage":"invalid number of bytes for (bool1,uint64)"},{"pc":[1462],"errorMessage":"invalid number of bytes for (len+(uint64,bool1)[])"},{"pc":[671,5944],"errorMessage":"invalid number of bytes for (len+uint8[])"},{"pc":[823,5031],"errorMessage":"invalid number of bytes for (len+utf8[])"},{"pc":[2303,5409],"errorMessage":"invalid number of bytes for (uint64,uint64,uint64)"},{"pc":[852],"errorMessage":"invalid number of bytes for (uint8[32],uint64)"},{"pc":[759,2189],"errorMessage":"invalid number of bytes for bool8"},{"pc":[872,881,890,899,908,1082,1200,1297,1691,1701,1711,2405,2615,2677,2698,2708,3087,4562,4691,4995,5084,5113],"errorMessage":"invalid number of bytes for uint64"},{"pc":[834],"errorMessage":"invalid number of bytes for uint8"},{"pc":[843,861,1225,4683,4790],"errorMessage":"invalid number of bytes for uint8[32]"},{"pc":[3476,3734,3969,4299,6238],"errorMessage":"max array length exceeded"},{"pc":[1238],"errorMessage":"only the creator can delete the pool"},{"pc":[1722],"errorMessage":"only the creator can finalize the pool"},{"pc":[1136],"errorMessage":"only the factory can init the pool"},{"pc":[5453],"errorMessage":"overflow"},{"pc":[1956],"errorMessage":"pool has reached maximum entries"},{"pc":[5444],"errorMessage":"pool staking type is not set"},{"pc":[2093],"errorMessage":"quantity is less than minimum stake amount"},{"pc":[2421,2721,4573,5820],"errorMessage":"reward does not exist"},{"pc":[2455],"errorMessage":"reward is already in a disbursement phase"},{"pc":[1821],"errorMessage":"the ending round must be zero or after the starting round + 10"},{"pc":[1886,2410],"errorMessage":"the pool is not live"},{"pc":[1261],"errorMessage":"the pool must be in draft or ended"},{"pc":[1730],"errorMessage":"the pool must be in draft state to finalize"},{"pc":[1765],"errorMessage":"the signup round must be zero and late sign ups allowed or in the future"},{"pc":[1780],"errorMessage":"the starting round must be zero or in the future"},{"pc":[1651],"errorMessage":"transaction type is axfer"},{"pc":[1289,1620,1640,1876],"errorMessage":"transaction type is pay"},{"pc":[4046],"errorMessage":"unknown reward rate type"},{"pc":[2313],"errorMessage":"user does not have enough staked"},{"pc":[2238],"errorMessage":"user does not have min balance"},{"pc":[1931],"errorMessage":"user does not meet gate requirements"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggOTIgMTAwMDAwIDYzNjQxMzYyMjM4NDY3OTMwMDUgNDAwIDE0NDI2OTUwNDA4ODg5NjM0MDcgMTQ0MjY5NTA0MDg4ODk2MzQwOSA0Mjk0OTY3Mjk1IDE4NDQ2NzQ0MDczNzA5NTUxNjE1CiAgICBieXRlY2Jsb2NrIDB4MTUxZjdjNzUgImVudHJ5X2NvdW50IiAiYWtpdGFfZGFvIiAweDAwICJha2l0YV9hbCIgInR5cGUiIDB4MDAwMCAweDBhICJnYXRlX2lkIiAic3RhdHVzIiAiY3JlYXRvciIgMHgxNCAiZSIgMHgxZSAibWF4X2VudHJpZXMiICJhbGxvd19sYXRlX3NpZ251cHMiIDB4ODAgImVuZF90aW1lc3RhbXAiICJ3YWxsZXQiICJzdGFydF90aW1lc3RhbXAiICJyIiAiYWtpdGFfcm95YWx0eV9hbW91bnQiICJzdGFrZV9rZXkiICJha2l0YV9yb3lhbHR5IiAidGl0bGUiICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIgImFraXRhX2VzY3JvdyIgInNpZ251cF90aW1lc3RhbXAiICJyZXdhcmRfY291bnQiICJvdGhlcl9hbCIgInNhbHQiICJwbHVnbl9hbCIgMHhjOTA2ODgwOSAiY29udHJvbGxlZF9hZGRyZXNzIiAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNC0xMDgKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VTdGFraW5nUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QsCiAgICAvLyAgIENoaWxkQ29udHJhY3QKICAgIC8vICkgewogICAgcHVzaGJ5dGVzcyAweGFiOGIyMTNhIDB4ZWE5MTgwZGQgLy8gbWV0aG9kICJkZWxldGUoYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJ1cGRhdGUoc3RyaW5nKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2RlbGV0ZV9yb3V0ZUA0IG1haW5fdXBkYXRlX3JvdXRlQDUKCm1haW5fc3dpdGNoX2Nhc2VfbmV4dEA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNC0xMDgKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VTdGFraW5nUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QsCiAgICAvLyAgIENoaWxkQ29udHJhY3QKICAgIC8vICkgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDI4CiAgICBwdXNoYnl0ZXNzIDB4ODNmMTQ3NDggMHgzOTRlYWViMiAweDY0NWE3YmNjIDB4MGYyZmMzMTIgMHgxODFlODI5MSAweDY4NTU4YzcwIDB4YTk0MThkMzcgMHhmYzY5OWNiMyAweDZlNzZiMmNhIDB4Y2RiMGFjNmEgMHhiMjIzZDM1ZCAweDU5MmVlMzQxIDB4OGZhNGExNjAgMHhlMzM3NzM0MiAweDcxNzA0NjQ5IDB4MWVhZDIwYTkgMHgzM2U5MmM5NCAweDg1NGRlZGUwIDB4YTRiM2U3ODkgLy8gbWV0aG9kICJpbml0KCl2b2lkIiwgbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiLCBtZXRob2QgImFkZFJld2FyZChwYXksKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjRbXSwodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpKXZvaWQiLCBtZXRob2QgImFkZFJld2FyZEFzYShwYXksYXhmZXIsKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjRbXSwodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpKXZvaWQiLCBtZXRob2QgImZpbmFsaXplKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImVudGVyKHBheSwodWludDY0LHVpbnQ2NCxieXRlWzMyXVtdKVtdLGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgInN0YXJ0RGlzYnVyc2VtZW50KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJyYWZmbGUodWludDY0KXZvaWQiLCBtZXRob2QgImRpc2J1cnNlUmV3YXJkcyh1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImZpbmFsaXplRGlzdHJpYnV0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjaGVjayhhZGRyZXNzLHVpbnQ2NCkoYm9vbCx1aW50NjQpIiwgbWV0aG9kICJzaWduVXBzT3BlbigpYm9vbCIsIG1ldGhvZCAiaXNMaXZlKClib29sIiwgbWV0aG9kICJpc0VudGVyZWQoYWRkcmVzcylib29sIiwgbWV0aG9kICJnZXRTdGF0ZSgpKHVpbnQ4LHN0cmluZyx1aW50OCx1aW50NjQsdWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCwoYWRkcmVzcyxzdHJpbmcpLHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPRXNjcm93KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBTyh1aW50NjQpdm9pZCIsIG1ldGhvZCAib3BVcCgpdm9pZCIsIG1ldGhvZCAibWJyKHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBpbml0IG9wdEluIGFkZFJld2FyZCBhZGRSZXdhcmRBc2EgZmluYWxpemUgZW50ZXIgc3RhcnREaXNidXJzZW1lbnQgcmFmZmxlIGRpc2J1cnNlUmV3YXJkcyBmaW5hbGl6ZURpc3RyaWJ1dGlvbiBjaGVjayBzaWduVXBzT3BlbiBpc0xpdmUgaXNFbnRlcmVkIGdldFN0YXRlIHVwZGF0ZUFraXRhREFPRXNjcm93IHVwZGF0ZUFraXRhREFPIG1haW5fb3BVcF9yb3V0ZUAyNSBtYnIKICAgIGVycgoKbWFpbl9vcFVwX3JvdXRlQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDIKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMjg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0LTEwOAogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmdQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVN0YWtpbmdQb29sLAogICAgLy8gICBBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdCwKICAgIC8vICAgQ2hpbGRDb250cmFjdAogICAgLy8gKSB7CiAgICBwdXNoYnl0ZXMgMHg3NzdlYzNlNSAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDgsYWRkcmVzcywoYWRkcmVzcyx1aW50NjQpLGFkZHJlc3MsKGFkZHJlc3Msc3RyaW5nKSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKbWFpbl91cGRhdGVfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ3CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIFVwZGF0ZUFwcGxpY2F0aW9uICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgdXBkYXRlCgptYWluX2RlbGV0ZV9yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwMwogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgRGVsZXRlQXBwbGljYXRpb24gJiYgY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgYiBkZWxldGUKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oYWtpdGFEQU86IHVpbnQ2NCwgYWRkcmVzczogYnl0ZXMpIC0+IHVpbnQ2NDoKZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjQKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uLCBhZGRyZXNzOiBBY2NvdW50KTogQXBwbGljYXRpb24gewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ4CiAgICAvLyBjb25zdCBbb3RoZXJBcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzT3RoZXJBcHBMaXN0KSkKICAgIGZyYW1lX2RpZyAtMgogICAgYnl0ZWMgMjkgLy8gIm90aGVyX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1MwogICAgLy8gcmV0dXJuIGdldE90aGVyQXBwTGlzdChha2l0YURBTykuZXNjcm93CiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzAtMTczCiAgICAvLyBjb25zdCBkYXRhID0gYWJpQ2FsbDx0eXBlb2YgRXNjcm93RmFjdG9yeS5wcm90b3R5cGUuZ2V0Pih7CiAgICAvLyAgIGFwcElkOiBlc2Nyb3dGYWN0b3J5LAogICAgLy8gICBhcmdzOiBbYWRkcmVzc10KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHgzYzFhNmYzMyAvLyBtZXRob2QgImdldChhZGRyZXNzKWJ5dGVbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICBleHRyYWN0IDYgMAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE3NQogICAgLy8gaWYgKEJ5dGVzKGRhdGEpLmxlbmd0aCA9PT0gMCB8fCBCeXRlcyhkYXRhKS5sZW5ndGggIT09IDgpIHsKICAgIGxlbgogICAgZHVwCiAgICBieiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9faWZfYm9keUA2CiAgICBmcmFtZV9kaWcgMQogICAgaW50Y18yIC8vIDgKICAgICE9CiAgICBieiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaWZfZWxzZUA3CgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9faWZfYm9keUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzYKICAgIC8vIHJldHVybiAwCiAgICBpbnRjXzAgLy8gMAoKZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6Z2V0V2FsbGV0SURAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY2CiAgICAvLyByZXR1cm4gQXBwbGljYXRpb24oZ2V0V2FsbGV0SUQoZXNjcm93RmFjdG9yeSwgYWRkcmVzcykpCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTc5CiAgICAvLyByZXR1cm4gYnRvaShkYXRhKQogICAgZnJhbWVfZGlnIDAKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY2CiAgICAvLyByZXR1cm4gQXBwbGljYXRpb24oZ2V0V2FsbGV0SUQoZXNjcm93RmFjdG9yeSwgYWRkcmVzcykpCiAgICBiIGdldFdhbGxldElEVXNpbmdBa2l0YURBT19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdldFdhbGxldElEQDgKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnYXRlQ2FsbChha2l0YURBTzogdWludDY0LCBjYWxsZXI6IGJ5dGVzLCBpZDogdWludDY0LCBhcmdzOiBieXRlcykgLT4gdWludDY0LCBieXRlczoKZ2F0ZUNhbGw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE5MgogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIGdhdGVDYWxsKGFraXRhREFPOiBBcHBsaWNhdGlvbiwgY2FsbGVyOiBBY2NvdW50LCBpZDogdWludDY0LCBhcmdzOiBHYXRlQXJncyk6IGJvb2xlYW4gewogICAgcHJvdG8gNCAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE5My0yMDAKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBHYXRlLnByb3RvdHlwZS5jaGVjaz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgY2FsbGVyLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgZnJhbWVfZGlnIC00CiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTk0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTk3CiAgICAvLyBpZCwKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxOTMtMjAwCiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgR2F0ZS5wcm90b3R5cGUuY2hlY2s+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChha2l0YURBTykuZ2F0ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGNhbGxlciwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBhcmdzLAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDIwMGY3NDIxIC8vIG1ldGhvZCAiY2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGZyYW1lX2RpZyAtMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo6X19wY2czMk91dHB1dChzdGF0ZTogdWludDY0KSAtPiB1aW50NjQ6Cl9fcGNnMzJPdXRwdXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjIzCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gX19wY2czMk91dHB1dChzdGF0ZTogUENHMzJTVEFURSk6IHVpbnQ2NCB7CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjQKICAgIC8vIGNvbnN0IHhvcnNoaWZ0ZWQgPSBfX21hc2tUb1VpbnQzMihvcC5zaHIob3Auc2hyKHN0YXRlLCAxOCkgXiBzdGF0ZSwgMjcpKQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDE4IC8vIDE4CiAgICBzaHIKICAgIGZyYW1lX2RpZyAtMQogICAgXgogICAgcHVzaGludCAyNyAvLyAyNwogICAgc2hyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjEzCiAgICAvLyByZXR1cm4gdmFsdWUgJiAob3Auc2hsKDEsIDMyKSAtIDEpCiAgICBpbnRjIDkgLy8gNDI5NDk2NzI5NQogICAgJgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoyNQogICAgLy8gY29uc3Qgcm90ID0gb3Auc2hyKHN0YXRlLCA1OSkKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA1OSAvLyA1OQogICAgc2hyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI2CiAgICAvLyByZXR1cm4gb3Auc2hyKHhvcnNoaWZ0ZWQsIHJvdCkgfCBfX21hc2tUb1VpbnQzMihvcC5zaGwoeG9yc2hpZnRlZCwgX191aW50NjRUd29zKHJvdCkgJiAzMSkpCiAgICBkdXAyCiAgICBzaHIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcofnZhbHVlLCAxKQogICAgc3dhcAogICAgfgogICAgaW50Y18xIC8vIDEKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoyNgogICAgLy8gcmV0dXJuIG9wLnNocih4b3JzaGlmdGVkLCByb3QpIHwgX19tYXNrVG9VaW50MzIob3Auc2hsKHhvcnNoaWZ0ZWQsIF9fdWludDY0VHdvcyhyb3QpICYgMzEpKQogICAgcHVzaGludCAzMSAvLyAzMQogICAgJgogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICBzaGwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTMKICAgIC8vIHJldHVybiB2YWx1ZSAmIChvcC5zaGwoMSwgMzIpIC0gMSkKICAgIGludGMgOSAvLyA0Mjk0OTY3Mjk1CiAgICAmCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI2CiAgICAvLyByZXR1cm4gb3Auc2hyKHhvcnNoaWZ0ZWQsIHJvdCkgfCBfX21hc2tUb1VpbnQzMihvcC5zaGwoeG9yc2hpZnRlZCwgX191aW50NjRUd29zKHJvdCkgJiAzMSkpCiAgICB8CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjUxCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA0MCAvLyA0MAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ4WzMyXSx1aW50NjQpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDExCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjUKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlID0gUG9vbFN0YXR1c0RyYWZ0CiAgICBieXRlY18zIC8vIDB4MDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBieXRlYyAyNCAvLyAidGl0bGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY2CiAgICAvLyB0aGlzLnRpdGxlLnZhbHVlID0gdGl0bGUKICAgIHVuY292ZXIgMTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY3CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPSB0eXBlCiAgICB1bmNvdmVyIDEwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjgKICAgIC8vIHRoaXMuY3JlYXRvci52YWx1ZSA9IGNyZWF0b3IKICAgIHVuY292ZXIgOQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9jaGlsZC50czoxMQogICAgLy8gZnVuZGVyID0gR2xvYmFsU3RhdGU8RnVuZGVySW5mbz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5RnVuZGVyIH0pCiAgICBwdXNoYnl0ZXMgImZ1bmRlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjkKICAgIC8vIHRoaXMuZnVuZGVyLnZhbHVlID0gY2xvbmUoZnVuZGVyKQogICAgdW5jb3ZlciA4CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0OAogICAgLy8gbWFya2V0cGxhY2UgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWFya2V0cGxhY2UgfSkKICAgIHB1c2hieXRlcyAibWFya2V0cGxhY2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjcwCiAgICAvLyB0aGlzLm1hcmtldHBsYWNlLnZhbHVlID0gbWFya2V0cGxhY2UKICAgIHVuY292ZXIgNwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzgKICAgIC8vIHN0YWtlS2V5ID0gR2xvYmFsU3RhdGU8Um9vdEtleT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YWtlS2V5IH0pCiAgICBieXRlYyAyMiAvLyAic3Rha2Vfa2V5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3MgogICAgLy8gdGhpcy5zdGFrZUtleS52YWx1ZSA9IGNsb25lKHN0YWtlS2V5KQogICAgdW5jb3ZlciA2CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MAogICAgLy8gbWluaW11bVN0YWtlQW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWluaW11bVN0YWtlQW1vdW50IH0pCiAgICBieXRlYyAyNSAvLyAibWluaW11bV9zdGFrZV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjczCiAgICAvLyB0aGlzLm1pbmltdW1TdGFrZUFtb3VudC52YWx1ZSA9IG1pbmltdW1TdGFrZUFtb3VudAogICAgdW5jb3ZlciA1CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3NAogICAgLy8gdGhpcy5nYXRlSUQudmFsdWUgPSBnYXRlSUQKICAgIHVuY292ZXIgNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njc1CiAgICAvLyB0aGlzLm1heEVudHJpZXMudmFsdWUgPSBtYXhFbnRyaWVzCiAgICB1bmNvdmVyIDMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU2CiAgICAvLyBzYWx0ID0gR2xvYmFsU3RhdGU8Ynl0ZXM8MzI+Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U2FsdCB9KQogICAgYnl0ZWMgMzAgLy8gInNhbHQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njc3CiAgICAvLyB0aGlzLnNhbHQudmFsdWUgPSBUeG4udHhJZAogICAgdHhuIFR4SUQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NzgKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NTkKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBieXRlYyAyNiAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3OQogICAgLy8gdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZSA9IGFraXRhREFPRXNjcm93CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gYWxsb3dMYXRlU2lnbnVwcyA9IEdsb2JhbFN0YXRlPGJvb2xlYW4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBbGxvd0xhdGVTaWdudXBzIH0pCiAgICBieXRlYyAxNSAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4MAogICAgLy8gdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlID0gZmFsc2UgLy8gSW5pdGlhbGl6ZSB0byBmYWxzZSwgd2lsbCBiZSBzZXQgaW4gZmluYWxpemUgaWYgbmVlZGVkCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2ODIKICAgIC8vIGNvbnN0IGZlZXMgPSBnZXRTdGFraW5nRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4MgogICAgLy8gY29uc3QgZmVlcyA9IGdldFN0YWtpbmdGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo2NwogICAgLy8gY29uc3QgW3N0YWtpbmdGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzU3Rha2luZ0ZlZXMpKQogICAgZHVwCiAgICBwdXNoYnl0ZXMgInN0YWtpbmdfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4NQogICAgLy8gbGV0IGltcGFjdDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2ODYKICAgIC8vIGlmIChhcHBMaXN0LmltcGFjdCAhPT0gMCkgewogICAgcHVzaGludCAxMDQgLy8gMTA0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnogY3JlYXRlX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4NwogICAgLy8gaW1wYWN0ID0gZ2V0VXNlckltcGFjdCh0aGlzLmFraXRhREFPLnZhbHVlLCB0aGlzLmNyZWF0b3IudmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg3CiAgICAvLyBpbXBhY3QgPSBnZXRVc2VySW1wYWN0KHRoaXMuYWtpdGFEQU8udmFsdWUsIHRoaXMuY3JlYXRvci52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2ODcKICAgIC8vIGltcGFjdCA9IGdldFVzZXJJbXBhY3QodGhpcy5ha2l0YURBTy52YWx1ZSwgdGhpcy5jcmVhdG9yLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIwLTEyMwogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsSW1wYWN0LnByb3RvdHlwZS5nZXRVc2VySW1wYWN0Pih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoYWtpdGFEQU8pLmltcGFjdCwKICAgIC8vICAgYXJnczogW2FjY291bnRdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgc3dhcAogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEyMQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdChha2l0YURBTykuaW1wYWN0LAogICAgcHVzaGludCAxMDQgLy8gMTA0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjAtMTIzCiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxJbXBhY3QucHJvdG90eXBlLmdldFVzZXJJbXBhY3Q+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChha2l0YURBTykuaW1wYWN0LAogICAgLy8gICBhcmdzOiBbYWNjb3VudF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHhkNTc0YmIxMCAvLyBtZXRob2QgImdldFVzZXJJbXBhY3QoYWRkcmVzcyl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgYnVyeSAxCgpjcmVhdGVfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4OQogICAgLy8gdGhpcy5ha2l0YVJveWFsdHkudmFsdWUgPSBpbXBhY3RSYW5nZShpbXBhY3QsIGZlZXMuaW1wYWN0VGF4TWluLCBmZWVzLmltcGFjdFRheE1heCkKICAgIGRpZyAxCiAgICBkdXAKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSA0CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjExNQogICAgLy8gY29uc3QgbWluSW1wYWN0OiB1aW50NjQgPSAoaW1wYWN0ID4gMSkgPyBpbXBhY3QgLSAxIDogMQogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgPgogICAgYnogY3JlYXRlX3Rlcm5hcnlfZmFsc2VANgogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgLQoKY3JlYXRlX3Rlcm5hcnlfbWVyZ2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTE2CiAgICAvLyByZXR1cm4gbWF4IC0gKCgobWF4IC0gbWluKSAqIG1pbkltcGFjdCkgLyBJTVBBQ1RfRElWSVNPUikKICAgIGRpZyA0CiAgICBkdXAKICAgIGRpZyA1CiAgICAtCiAgICB1bmNvdmVyIDIKICAgICoKICAgIHB1c2hpbnQgMTAwMCAvLyAxMDAwCiAgICAvCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBha2l0YVJveWFsdHkgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHkgfSkKICAgIGJ5dGVjIDIzIC8vICJha2l0YV9yb3lhbHR5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4OQogICAgLy8gdGhpcy5ha2l0YVJveWFsdHkudmFsdWUgPSBpbXBhY3RSYW5nZShpbXBhY3QsIGZlZXMuaW1wYWN0VGF4TWluLCBmZWVzLmltcGFjdFRheE1heCkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjUxCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKY3JlYXRlX3Rlcm5hcnlfZmFsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTE1CiAgICAvLyBjb25zdCBtaW5JbXBhY3Q6IHVpbnQ2NCA9IChpbXBhY3QgPiAxKSA/IGltcGFjdCAtIDEgOiAxCiAgICBpbnRjXzEgLy8gMQogICAgYiBjcmVhdGVfdGVybmFyeV9tZXJnZUA3CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pbml0W3JvdXRpbmddKCkgLT4gdm9pZDoKaW5pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTMKICAgIC8vIGFzc2VydChHbG9iYWwuY2FsbGVyQXBwbGljYXRpb25BZGRyZXNzID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsICdvbmx5IHRoZSBmYWN0b3J5IGNhbiBpbml0IHRoZSBwb29sJykKICAgIGdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBvbmx5IHRoZSBmYWN0b3J5IGNhbiBpbml0IHRoZSBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk1CiAgICAvLyBpZiAodGhpcy5nYXRlSUQudmFsdWUgPiAwKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NQogICAgLy8gaWYgKHRoaXMuZ2F0ZUlELnZhbHVlID4gMCkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IGluaXRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk2LTY5OQogICAgLy8gdGhpcy5nYXRlU2l6ZS52YWx1ZSA9IGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLnNpemU+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlLAogICAgLy8gICBhcmdzOiBbdGhpcy5nYXRlSUQudmFsdWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZSwKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk4CiAgICAvLyBhcmdzOiBbdGhpcy5nYXRlSUQudmFsdWVdLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTgKICAgIC8vIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5Ni02OTkKICAgIC8vIHRoaXMuZ2F0ZVNpemUudmFsdWUgPSBhYmlDYWxsPHR5cGVvZiBHYXRlLnByb3RvdHlwZS5zaXplPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZSwKICAgIC8vICAgYXJnczogW3RoaXMuZ2F0ZUlELnZhbHVlXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHhkZjU2YjAxZSAvLyBtZXRob2QgInNpemUodWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ0CiAgICAvLyBnYXRlU2l6ZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVTaXplIH0pCiAgICBwdXNoYnl0ZXMgImdhdGVfc2l6ZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTYtNjk5CiAgICAvLyB0aGlzLmdhdGVTaXplLnZhbHVlID0gYWJpQ2FsbDx0eXBlb2YgR2F0ZS5wcm90b3R5cGUuc2l6ZT4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmdhdGUsCiAgICAvLyAgIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCmluaXRfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5MgogICAgLy8gaW5pdCgpIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmRlbGV0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MDMKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICdEZWxldGVBcHBsaWNhdGlvbicgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MDUKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsICdjYWxsIG11c3QgY29tZSBmcm9tIGZhY3RvcnknKQogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIGNhbGwgbXVzdCBjb21lIGZyb20gZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNgogICAgLy8gYXNzZXJ0KGNhbGxlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCAnb25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBwb29sJykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGJ5dGVjIDEwIC8vICJjcmVhdG9yIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNgogICAgLy8gYXNzZXJ0KGNhbGxlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCAnb25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBwb29sJykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgcG9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNwogICAgLy8gYXNzZXJ0KHRoaXMuc3RhdHVzLnZhbHVlID09PSBQb29sU3RhdHVzRHJhZnQgfHwgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBvciBlbmRlZCcpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MDcKICAgIC8vIGFzc2VydCh0aGlzLnN0YXR1cy52YWx1ZSA9PT0gUG9vbFN0YXR1c0RyYWZ0IHx8IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSwgJ3RoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgb3IgZW5kZWQnKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgPT0KICAgIGJueiBkZWxldGVfYm9vbF90cnVlQDMKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI1CiAgICAvLyBlbmRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbmRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE3IC8vICJlbmRfdGltZXN0YW1wIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNwogICAgLy8gYXNzZXJ0KHRoaXMuc3RhdHVzLnZhbHVlID09PSBQb29sU3RhdHVzRHJhZnQgfHwgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBvciBlbmRlZCcpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPgogICAgYnogZGVsZXRlX2Jvb2xfZmFsc2VANAoKZGVsZXRlX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCmRlbGV0ZV9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA3CiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkJykKICAgIGFzc2VydCAvLyB0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzExLTcxMwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7IGNsb3NlUmVtYWluZGVyVG86IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MTIKICAgIC8vIC5wYXltZW50KHsgY2xvc2VSZW1haW5kZXJUbzogR2xvYmFsLmNyZWF0b3JBZGRyZXNzIH0pCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcxMS03MTIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoeyBjbG9zZVJlbWFpbmRlclRvOiBHbG9iYWwuY3JlYXRvckFkZHJlc3MgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MTEtNzEzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsgY2xvc2VSZW1haW5kZXJUbzogR2xvYmFsLmNyZWF0b3JBZGRyZXNzIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MDMKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6ICdEZWxldGVBcHBsaWNhdGlvbicgfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmRlbGV0ZV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBkZWxldGVfYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5vcHRJbltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm9wdEluOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcyMwogICAgLy8gb3B0SW4ocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldDogdWludDY0KTogdm9pZCB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzI0CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCBFUlJfRk9SQklEREVOKQogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNyZWF0b3IgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5Q3JlYXRvciB9KQogICAgYnl0ZWMgMTAgLy8gImNyZWF0b3IiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzI0CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCBFUlJfRk9SQklEREVOKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gRm9yYmlkZGVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzI4CiAgICAvLyBjb25zdCBkYW9Fc2Nyb3dOZWVkc1RvT3B0SW4gPSAhR2xvYmFsLnplcm9BZGRyZXNzLmlzT3B0ZWRJbihBc3NldChhc3NldCkpCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGRpZyAxCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgIQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjczMgogICAgLy8gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogKAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzMzCiAgICAvLyBkYW9Fc2Nyb3dOZWVkc1RvT3B0SW4gPyA0IDogMQogICAgaW50Y18xIC8vIDEKICAgIHB1c2hpbnQgNCAvLyA0CiAgICB1bmNvdmVyIDMKICAgIHNlbGVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjczMi03MzQKICAgIC8vIEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqICgKICAgIC8vICAgZGFvRXNjcm93TmVlZHNUb09wdEluID8gNCA6IDEKICAgIC8vICkKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MzktNzQ2CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IG9wdGluTUJSICsgcmV3YXJkc01CUiwKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZGlnIDIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzQyCiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjczOS03NDYKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgdW5jb3ZlciAzCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDMKICAgIC8vIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzM3CiAgICAvLyBjb25zdCByZXdhcmRzTUJSOiB1aW50NjQgPSB0aGlzLnJld2FyZHNNYnIoV2lubmVyQ291bnRDYXApICogMgogICAgcHVzaGludCA4MDAwIC8vIDgwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDMKICAgIC8vIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjczOS03NDYKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgJiYKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDgtNzU0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NTAKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc1MQogICAgLy8gYXNzZXRBbW91bnQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzQ4LTc1MwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDgtNzU0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBieXRlYyAxOCAvLyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MwogICAgLy8gY29uc3QgW3BsdWdpbkFwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNQbHVnaW5BcHBMaXN0KSkKICAgIGR1cAogICAgYnl0ZWMgMzEgLy8gInBsdWduX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NzcKICAgIC8vIGNvbnN0IHsgcmV2ZW51ZU1hbmFnZXIgfSA9IGdldFBsdWdpbkFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGR1cAogICAgZXh0cmFjdCA4IDgKICAgIHN3YXAKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgdW5jb3ZlciAyCiAgICBieXRlYyAxOCAvLyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NjQtNjcKICAgIC8vIGNvbnN0IGVzY3JvdyA9IGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9nZXRFc2Nyb3dzPih7CiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbW25hbWVdXSwKICAgIC8vIH0pLnJldHVyblZhbHVlWzBdCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHhhMjQwM2RkZiAvLyBtZXRob2QgImFyYzU4X2dldEVzY3Jvd3Moc3RyaW5nW10pKHVpbnQ2NCxib29sKVtdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjY2CiAgICAvLyBhcmdzOiBbW25hbWVdXSwKICAgIHB1c2hieXRlcyAweDAwMDEwMDAyMDAwZDczNzQ2MTZiNjk2ZTY3NWY3MDZmNmY2YzczCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo2NC02NwogICAgLy8gY29uc3QgZXNjcm93ID0gYWJpQ2FsbDx0eXBlb2YgQWJzdHJhY3RlZEFjY291bnQucHJvdG90eXBlLmFyYzU4X2dldEVzY3Jvd3M+KHsKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtbbmFtZV1dLAogICAgLy8gfSkucmV0dXJuVmFsdWVbMF0KICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDkgLy8gOQogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbisodWludDY0LGJvb2wxKVtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NjkKICAgIC8vIGFzc2VydChlc2Nyb3cuaWQgIT09IDAsIEVSUl9FU0NST1dfRE9FU19OT1RfRVhJU1QpCiAgICBleHRyYWN0IDYgOQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGFzc2VydCAvLyBFc2Nyb3cgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjgwCiAgICAvLyBhc3NlcnQoaWQgPT09IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuaWQsIEVSUl9XUk9OR19FU0NST1dfRk9SX09QRVJBVElPTikKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1OQogICAgLy8gYWtpdGFEQU9Fc2Nyb3cgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFFc2Nyb3cgfSkKICAgIGJ5dGVjIDI2IC8vICJha2l0YV9lc2Nyb3ciCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4MAogICAgLy8gYXNzZXJ0KGlkID09PSB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmlkLCBFUlJfV1JPTkdfRVNDUk9XX0ZPUl9PUEVSQVRJT04pCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgc3dhcAogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgZXNjcm93IGZvciB0aGlzIG9wZXJhdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODItOTEKICAgIC8vIGl0eG5Db21wb3NlLmJlZ2luPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfcmVrZXlUb1BsdWdpbj4oewogICAgLy8gICBhcHBJZDogd2FsbGV0LAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgcmV2ZW51ZU1hbmFnZXIsCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIFtdLAogICAgLy8gICAgIFtdCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgcHVzaGJ5dGVzIDB4NTgyZmYzODIgLy8gbWV0aG9kICJhcmM1OF9yZWtleVRvUGx1Z2luKHVpbnQ2NCxib29sLHN0cmluZyx1aW50NjRbXSwodWludDY0LHVpbnQ2NClbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjg2CiAgICAvLyB0cnVlLAogICAgYnl0ZWMgMTYgLy8gMHg4MAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjg3CiAgICAvLyBuYW1lLAogICAgcHVzaGJ5dGVzIDB4MDAwZDczNzQ2MTZiNjk2ZTY3NWY3MDZmNmY2YzczCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODgKICAgIC8vIFtdLAogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4OQogICAgLy8gW10KICAgIGJ5dGVjIDYgLy8gMHgwMDAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODItOTEKICAgIC8vIGl0eG5Db21wb3NlLmJlZ2luPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfcmVrZXlUb1BsdWdpbj4oewogICAgLy8gICBhcHBJZDogd2FsbGV0LAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgcmV2ZW51ZU1hbmFnZXIsCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIFtdLAogICAgLy8gICAgIFtdCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTMtMTA0CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBSZXZlbnVlTWFuYWdlclBsdWdpblN0dWIucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIGFwcElkOiByZXZlbnVlTWFuYWdlciwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIHdhbGxldCwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIFthc3NldC5pZF0sCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vICAgICB9KQogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMDAKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMDEKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTktMTAyCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5My0xMDQKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFJldmVudWVNYW5hZ2VyUGx1Z2luU3R1Yi5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgYXBwSWQ6IHJldmVudWVNYW5hZ2VyLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgd2FsbGV0LAogICAgLy8gICAgIHRydWUsCiAgICAvLyAgICAgW2Fzc2V0LmlkXSwKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjk2CiAgICAvLyB3YWxsZXQsCiAgICBkaWcgMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTgKICAgIC8vIFthc3NldC5pZF0sCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIHB1c2hieXRlcyAweDAwMDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTMtMTA0CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBSZXZlbnVlTWFuYWdlclBsdWdpblN0dWIucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIGFwcElkOiByZXZlbnVlTWFuYWdlciwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIHdhbGxldCwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIFthc3NldC5pZF0sCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vICAgICB9KQogICAgLy8gICBdCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjgzNWUzYmMgLy8gbWV0aG9kICJvcHRJbih1aW50NjQsYm9vbCx1aW50NjRbXSxwYXkpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODYKICAgIC8vIHRydWUsCiAgICBieXRlYyAxNiAvLyAweDgwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTMtMTA0CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBSZXZlbnVlTWFuYWdlclBsdWdpblN0dWIucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIGFwcElkOiByZXZlbnVlTWFuYWdlciwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIHdhbGxldCwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIFthc3NldC5pZF0sCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vICAgICB9KQogICAgLy8gICBdCiAgICAvLyB9KQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTA2CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3M+KHsgYXBwSWQ6IHdhbGxldCB9KQogICAgaXR4bl9uZXh0CiAgICBwdXNoYnl0ZXMgMHg2Y2MzZjYwNiAvLyBtZXRob2QgImFyYzU4X3ZlcmlmeUF1dGhBZGRyZXNzKCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTE4CiAgICAvLyBpdHhuQ29tcG9zZS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MjMKICAgIC8vIG9wdEluKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXQ6IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkW3JvdXRpbmddKCkgLT4gdm9pZDoKYWRkUmV3YXJkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc2MwogICAgLy8gYWRkUmV3YXJkKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZAogICAgcG9wCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRBc2Fbcm91dGluZ10oKSAtPiB2b2lkOgphZGRSZXdhcmRBc2E6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0CiAgICAvLyBhZGRSZXdhcmRBc2EocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldFhmZXI6IGd0eG4uQXNzZXRUcmFuc2ZlclR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBwdXNoaW50IDIgLy8gMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBheGZlcgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4NS03OTUKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBhc3NldFhmZXIsCiAgICAvLyAgIHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IEFzc2V0KHJld2FyZC5hc3NldCksCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuOiAwCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9UUkFOU0ZFUgogICAgLy8gKQogICAgZGlnIDEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODgKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODUtNzk1CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgYXNzZXRYZmVyLAogICAgLy8gICB7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgeGZlckFzc2V0OiBBc3NldChyZXdhcmQuYXNzZXQpLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbjogMAogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfVFJBTlNGRVIKICAgIC8vICkKICAgID09CiAgICBkaWcgMgogICAgZ3R4bnMgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg5CiAgICAvLyB4ZmVyQXNzZXQ6IEFzc2V0KHJld2FyZC5hc3NldCksCiAgICBkaWcgMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg1LTc5NQogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIGFzc2V0WGZlciwKICAgIC8vICAgewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIC8vICAgICBhc3NldEFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW46IDAKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1RSQU5TRkVSCiAgICAvLyApCiAgICA9PQogICAgJiYKICAgIHVuY292ZXIgMgogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCB0cmFuc2ZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc5NwogICAgLy8gdGhpcy5hZGRSZXdhcmQocGF5bWVudCwgcmV3YXJkKQogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0CiAgICAvLyBhZGRSZXdhcmRBc2EocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldFhmZXI6IGd0eG4uQXNzZXRUcmFuc2ZlclR4biwgcmV3YXJkOiBSZXdhcmQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmZpbmFsaXplW3JvdXRpbmddKCkgLT4gdm9pZDoKZmluYWxpemU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAwCiAgICAvLyBmaW5hbGl6ZShzaWdudXBUaW1lc3RhbXA6IHVpbnQ2NCwgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwgZW5kVGltZXN0YW1wOiB1aW50NjQpIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgJ29ubHkgdGhlIGNyZWF0b3IgY2FuIGZpbmFsaXplIHRoZSBwb29sJykKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGJ5dGVjIDEwIC8vICJjcmVhdG9yIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRvci52YWx1ZSwgJ29ubHkgdGhlIGNyZWF0b3IgY2FuIGZpbmFsaXplIHRoZSBwb29sJykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3IgY2FuIGZpbmFsaXplIHRoZSBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAyCiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCwgJ3RoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgc3RhdGUgdG8gZmluYWxpemUnKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyA5IC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAyCiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCwgJ3RoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgc3RhdGUgdG8gZmluYWxpemUnKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgPT0KICAgIGFzc2VydCAvLyB0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IHN0YXRlIHRvIGZpbmFsaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA1CiAgICAvLyBpZiAoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHN0YXJ0VGltZXN0YW1wID09PSAwKSB7CiAgICBibnogZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUA0CiAgICBkaWcgMQogICAgYm56IGZpbmFsaXplX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gYWxsb3dMYXRlU2lnbnVwcyA9IEdsb2JhbFN0YXRlPGJvb2xlYW4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBbGxvd0xhdGVTaWdudXBzIH0pCiAgICBieXRlYyAxNSAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwNgogICAgLy8gdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlID0gdHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CgpmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODEwCiAgICAvLyBzaWdudXBUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIHx8IChzaWdudXBUaW1lc3RhbXAgPT09IDAgJiYgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKSwKICAgIGRpZyAyCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICA+CiAgICBibnogZmluYWxpemVfYm9vbF90cnVlQDcKICAgIGRpZyAyCiAgICBibnogZmluYWxpemVfYm9vbF9mYWxzZUA4CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gYWxsb3dMYXRlU2lnbnVwcyA9IEdsb2JhbFN0YXRlPGJvb2xlYW4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBbGxvd0xhdGVTaWdudXBzIH0pCiAgICBieXRlYyAxNSAvLyAiYWxsb3dfbGF0ZV9zaWdudXBzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxMAogICAgLy8gc2lnbnVwVGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCB8fCAoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUA4CgpmaW5hbGl6ZV9ib29sX3RydWVANzoKICAgIGludGNfMSAvLyAxCgpmaW5hbGl6ZV9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA5LTgxMgogICAgLy8gYXNzZXJ0KAogICAgLy8gICBzaWdudXBUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIHx8IChzaWdudXBUaW1lc3RhbXAgPT09IDAgJiYgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKSwKICAgIC8vICAgJ3RoZSBzaWdudXAgcm91bmQgbXVzdCBiZSB6ZXJvIGFuZCBsYXRlIHNpZ24gdXBzIGFsbG93ZWQgb3IgaW4gdGhlIGZ1dHVyZScKICAgIC8vICkKICAgIGFzc2VydCAvLyB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgbGF0ZSBzaWduIHVwcyBhbGxvd2VkIG9yIGluIHRoZSBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MTUtODE2CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9PT0gMCB8fAogICAgLy8gc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgZGlnIDEKICAgIGJ6IGZpbmFsaXplX2Jvb2xfdHJ1ZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxNgogICAgLy8gc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgZGlnIDEKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MTUtODE2CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9PT0gMCB8fAogICAgLy8gc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUAxMgoKZmluYWxpemVfYm9vbF90cnVlQDExOgogICAgaW50Y18xIC8vIDEKCmZpbmFsaXplX2Jvb2xfbWVyZ2VAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODE0LTgxOAogICAgLy8gYXNzZXJ0KAogICAgLy8gICBzdGFydFRpbWVzdGFtcCA9PT0gMCB8fAogICAgLy8gICBzdGFydFRpbWVzdGFtcCA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyAgICd0aGUgc3RhcnRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGluIHRoZSBmdXR1cmUnCiAgICAvLyApCiAgICBhc3NlcnQgLy8gdGhlIHN0YXJ0aW5nIHJvdW5kIG11c3QgYmUgemVybyBvciBpbiB0aGUgZnV0dXJlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODIwCiAgICAvLyBpZiAoc3RhcnRUaW1lc3RhbXAgPT09IDApIHsKICAgIGRpZyAxCiAgICBibnogZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyMQogICAgLy8gYXNzZXJ0KHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUsICdpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlJykKICAgIGRpZyAyCiAgICBibnogZmluYWxpemVfYm9vbF9mYWxzZUAxNwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGFsbG93TGF0ZVNpZ251cHMgPSBHbG9iYWxTdGF0ZTxib29sZWFuPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWxsb3dMYXRlU2lnbnVwcyB9KQogICAgYnl0ZWMgMTUgLy8gImFsbG93X2xhdGVfc2lnbnVwcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MjEKICAgIC8vIGFzc2VydChzaWdudXBUaW1lc3RhbXAgPT09IDAgJiYgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLCAnaWYgdGhlIHN0YXJ0aW5nIHJvdW5kIGlzIHplcm8sIHRoZSBzaWdudXAgcm91bmQgbXVzdCBiZSB6ZXJvIGFuZCBhbGxvd0xhdGVTaWdudXBzIG11c3QgYmUgdHJ1ZScpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUAxNwogICAgaW50Y18xIC8vIDEKCmZpbmFsaXplX2Jvb2xfbWVyZ2VAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODIxCiAgICAvLyBhc3NlcnQoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSwgJ2lmIHRoZSBzdGFydGluZyByb3VuZCBpcyB6ZXJvLCB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgYWxsb3dMYXRlU2lnbnVwcyBtdXN0IGJlIHRydWUnKQogICAgYXNzZXJ0IC8vIGlmIHRoZSBzdGFydGluZyByb3VuZCBpcyB6ZXJvLCB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgYWxsb3dMYXRlU2lnbnVwcyBtdXN0IGJlIHRydWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MjIKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYnVyeSAyCgpmaW5hbGl6ZV9hZnRlcl9pZl9lbHNlQDE5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyNgogICAgLy8gZW5kVGltZXN0YW1wID09PSAwIHx8IGVuZFRpbWVzdGFtcCA+IChzdGFydFRpbWVzdGFtcCArIDEwKSwKICAgIGR1cAogICAgYnogZmluYWxpemVfYm9vbF90cnVlQDIxCiAgICBkaWcgMQogICAgcHVzaGludCAxMCAvLyAxMAogICAgKwogICAgZGlnIDEKICAgIDwKICAgIGJ6IGZpbmFsaXplX2Jvb2xfZmFsc2VAMjIKCmZpbmFsaXplX2Jvb2xfdHJ1ZUAyMToKICAgIGludGNfMSAvLyAxCgpmaW5hbGl6ZV9ib29sX21lcmdlQDIzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyNS04MjgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgZW5kVGltZXN0YW1wID09PSAwIHx8IGVuZFRpbWVzdGFtcCA+IChzdGFydFRpbWVzdGFtcCArIDEwKSwKICAgIC8vICAgJ3RoZSBlbmRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGFmdGVyIHRoZSBzdGFydGluZyByb3VuZCArIDEwJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHRoZSBlbmRpbmcgcm91bmQgbXVzdCBiZSB6ZXJvIG9yIGFmdGVyIHRoZSBzdGFydGluZyByb3VuZCArIDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBzaWdudXBUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTaWdudXBUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDI3IC8vICJzaWdudXBfdGltZXN0YW1wIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzMAogICAgLy8gdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUgPSBzaWdudXBUaW1lc3RhbXAKICAgIGRpZyAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMwogICAgLy8gc3RhcnRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFydFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTkgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MzEKICAgIC8vIHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUgPSBzdGFydFRpbWVzdGFtcAogICAgZGlnIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI1CiAgICAvLyBlbmRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbmRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE3IC8vICJlbmRfdGltZXN0YW1wIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzMgogICAgLy8gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPSBlbmRUaW1lc3RhbXAKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MzMKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlID0gUG9vbFN0YXR1c0ZpbmFsCiAgICBieXRlYyA3IC8vIDB4MGEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAwCiAgICAvLyBmaW5hbGl6ZShzaWdudXBUaW1lc3RhbXA6IHVpbnQ2NCwgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwgZW5kVGltZXN0YW1wOiB1aW50NjQpIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmZpbmFsaXplX2Jvb2xfZmFsc2VAMjI6CiAgICBpbnRjXzAgLy8gMAogICAgYiBmaW5hbGl6ZV9ib29sX21lcmdlQDIzCgpmaW5hbGl6ZV9ib29sX2ZhbHNlQDE3OgogICAgaW50Y18wIC8vIDAKICAgIGIgZmluYWxpemVfYm9vbF9tZXJnZUAxOAoKZmluYWxpemVfYm9vbF9mYWxzZUAxMjoKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VAMTMKCmZpbmFsaXplX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZW50ZXJbcm91dGluZ10oKSAtPiB2b2lkOgplbnRlcjoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDMKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODM2CiAgICAvLyBlbnRlcihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGVudHJpZXM6IFN0YWtlRW50cnlbXSwgYXJnczogR2F0ZUFyZ3MpOiB2b2lkIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzOAogICAgLy8gYXNzZXJ0KHRoaXMuaXNMaXZlKCksICd0aGUgcG9vbCBpcyBub3QgbGl2ZScpCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlCiAgICBhc3NlcnQgLy8gdGhlIHBvb2wgaXMgbm90IGxpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDAKICAgIC8vIGlmICh0aGlzLmdhdGVJRC52YWx1ZSAhPT0gMCkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDAKICAgIC8vIGlmICh0aGlzLmdhdGVJRC52YWx1ZSAhPT0gMCkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IGVudGVyX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0MQogICAgLy8gY29uc3Qgd2FsbGV0ID0gZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgVHhuLnNlbmRlcikKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8KICAgIGR1cAogICAgYnVyeSA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzNAogICAgLy8gcmV0dXJuIG9yaWdpbk9yKHdhbGxldElELCBUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgYnVyeSAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjcKICAgIC8vIGlmICh3YWxsZXRJRC5pZCA9PT0gMCkgewogICAgYm56IGVudGVyX2FmdGVyX2lmX2Vsc2VAMzAKICAgIGRpZyA4CgplbnRlcl9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDMxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0NAogICAgLy8gZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBhcmdzKSwKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDQKICAgIC8vIGdhdGVDYWxsKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgb3JpZ2luLCB0aGlzLmdhdGVJRC52YWx1ZSwgYXJncyksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgc3dhcAogICAgY292ZXIgMgogICAgZGlnIDMKICAgIGNhbGxzdWIgZ2F0ZUNhbGwKICAgIGJ1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0My04NDYKICAgIC8vIGFzc2VydCgKICAgIC8vICAgZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBhcmdzKSwKICAgIC8vICAgJ3VzZXIgZG9lcyBub3QgbWVldCBnYXRlIHJlcXVpcmVtZW50cycKICAgIC8vICkKICAgIGFzc2VydCAvLyB1c2VyIGRvZXMgbm90IG1lZXQgZ2F0ZSByZXF1aXJlbWVudHMKCmVudGVyX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTAKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTAKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGJ5dGVjIDE0IC8vICJtYXhfZW50cmllcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTAKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIDwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTAtODUxCiAgICAvLyAodGhpcy5lbnRyeUlELnZhbHVlICsgMSkgPCB0aGlzLm1heEVudHJpZXMudmFsdWUgfHwKICAgIC8vIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIGJueiBlbnRlcl9ib29sX3RydWVANQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1MQogICAgLy8gdGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODUxCiAgICAvLyB0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1MC04NTEKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgLy8gdGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwLAogICAgYm56IGVudGVyX2Jvb2xfZmFsc2VANgoKZW50ZXJfYm9vbF90cnVlQDU6CiAgICBpbnRjXzEgLy8gMQoKZW50ZXJfYm9vbF9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0OS04NTMKICAgIC8vIGFzc2VydCgKICAgIC8vICAgKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpIDwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIHx8CiAgICAvLyAgIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIC8vICAgJ3Bvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHBvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODU3CiAgICAvLyBsZXQgdG90YWw6IHVpbnQ2NCA9IGVudHJ5TUJSICogZW50cmllcy5sZW5ndGgKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgYnVyeSA5CiAgICBwdXNoaW50IDUwNjAwIC8vIDUwNjAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyB1bmlxdWVzID0gQm94TWFwPEFjY291bnQsIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xHbG9iYWxTdGF0ZUtleVVuaXF1ZXMgfSkKICAgIHB1c2hieXRlcyAidSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTgKICAgIC8vIGlmICghdGhpcy51bmlxdWVzKFR4bi5zZW5kZXIpLmV4aXN0cykgewogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gdW5pcXVlcyA9IEJveE1hcDxBY2NvdW50LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sR2xvYmFsU3RhdGVLZXlVbmlxdWVzIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTgKICAgIC8vIGlmICghdGhpcy51bmlxdWVzKFR4bi5zZW5kZXIpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogZW50ZXJfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODU5CiAgICAvLyB0b3RhbCArPSBQb29sVW5pcXVlc01CUgogICAgcHVzaGludCAxODkwMCAvLyAxODkwMAogICAgKwoKZW50ZXJfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg2Mi04NjkKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdG90YWwsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGRpZyAzCiAgICBkdXAKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODY1CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg2Mi04NjkKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdG90YWwsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICBzd2FwCiAgICBndHhucyBBbW91bnQKICAgIHVuY292ZXIgMgogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODcxCiAgICAvLyBjb25zdCB7IGFkZHJlc3MsIG5hbWUgfSA9IHRoaXMuc3Rha2VLZXkudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBzdGFrZUtleSA9IEdsb2JhbFN0YXRlPFJvb3RLZXk+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFrZUtleSB9KQogICAgYnl0ZWMgMjIgLy8gInN0YWtlX2tleSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzEKICAgIC8vIGNvbnN0IHsgYWRkcmVzcywgbmFtZSB9ID0gdGhpcy5zdGFrZUtleS52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICBidXJ5IDEzCiAgICBkdXAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBidXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODczCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykgewogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgNgoKZW50ZXJfd2hpbGVfdG9wQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHsKICAgIGRpZyA1CiAgICBkaWcgOAogICAgPAogICAgYnogZW50ZXJfYWZ0ZXJfd2hpbGVAMjMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzQKICAgIC8vIGFzc2VydChlbnRyaWVzW2ldLnF1YW50aXR5ID49IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLCAncXVhbnRpdHkgaXMgbGVzcyB0aGFuIG1pbmltdW0gc3Rha2UgYW1vdW50JykKICAgIGRpZyAxCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgcHVzaGludCAyIC8vIDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgdW5jb3ZlciAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZHVwCiAgICBidXJ5IDkKICAgIGRpZyAxMAogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICBkdXAKICAgIGJ1cnkgMTEKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBidXJ5IDYKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyBtaW5pbXVtU3Rha2VBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNaW5pbXVtU3Rha2VBbW91bnQgfSkKICAgIGJ5dGVjIDI1IC8vICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzQKICAgIC8vIGFzc2VydChlbnRyaWVzW2ldLnF1YW50aXR5ID49IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLCAncXVhbnRpdHkgaXMgbGVzcyB0aGFuIG1pbmltdW0gc3Rha2UgYW1vdW50JykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+PQogICAgYXNzZXJ0IC8vIHF1YW50aXR5IGlzIGxlc3MgdGhhbiBtaW5pbXVtIHN0YWtlIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3NgogICAgLy8gaWYgKGFkZHJlc3MgIT09IEdsb2JhbC56ZXJvQWRkcmVzcykgewogICAgZGlnIDExCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODc3LTg4NgogICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhYmlDYWxsPHR5cGVvZiBNZXRhTWVya2xlcy5wcm90b3R5cGUudmVyaWZ5Pih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgc2hhMjU2KHNoYTI1NihpdG9iKGVudHJpZXNbaV0uYXNzZXQpKSksCiAgICAvLyAgICAgZW50cmllc1tpXS5wcm9vZiwKICAgIC8vICAgICBNRVJLTEVfVFJFRV9UWVBFX0FTU0VULAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzgKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODc4CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLm1ldGFNZXJrbGVzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3OAogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5tZXRhTWVya2xlcywKICAgIHB1c2hpbnQgNzIgLy8gNzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODgyCiAgICAvLyBzaGEyNTYoc2hhMjU2KGl0b2IoZW50cmllc1tpXS5hc3NldCkpKSwKICAgIGRpZyAxMAogICAgZHVwCiAgICBleHRyYWN0IDAgOAogICAgc2hhMjU2CiAgICBzaGEyNTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4ODMKICAgIC8vIGVudHJpZXNbaV0ucHJvb2YsCiAgICBkaWcgMQogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyCiAgICBsZW4KICAgIHVuY292ZXIgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4NAogICAgLy8gTUVSS0xFX1RSRUVfVFlQRV9BU1NFVCwKICAgIGludGNfMSAvLyAxCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODc3LTg4NgogICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhYmlDYWxsPHR5cGVvZiBNZXRhTWVya2xlcy5wcm90b3R5cGUudmVyaWZ5Pih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgc2hhMjU2KHNoYTI1NihpdG9iKGVudHJpZXNbaV0uYXNzZXQpKSksCiAgICAvLyAgICAgZW50cmllc1tpXS5wcm9vZiwKICAgIC8vICAgICBNRVJLTEVfVFJFRV9UWVBFX0FTU0VULAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDJiZjNjYzVhIC8vIG1ldGhvZCAidmVyaWZ5KGFkZHJlc3Msc3RyaW5nLGJ5dGVbMzJdLGJ5dGVbMzJdW10sdWludDY0KWJvb2wiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4OAogICAgLy8gYXNzZXJ0KHZlcmlmaWVkLCAnZmFpbGVkIHRvIHZlcmlmeSBzdGFrZSByZXF1aXJlbWVudHMnKQogICAgYXNzZXJ0IC8vIGZhaWxlZCB0byB2ZXJpZnkgc3Rha2UgcmVxdWlyZW1lbnRzCgplbnRlcl9hZnRlcl9pZl9lbHNlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5MwogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQgfHwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODkzCiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDcgLy8gMHgwYQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4OTMtODk0CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBibnogZW50ZXJfaWZfYm9keUAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5NAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5NAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4OTMtODk0CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDIxCgplbnRlcl9pZl9ib2R5QDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg5NgogICAgLy8gY29uc3QgW2JhbGFuY2UsIG9wdGVkSW5dID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShUeG4uc2VuZGVyLCBlbnRyaWVzW2ldLmFzc2V0KQogICAgdHhuIFNlbmRlcgogICAgZGlnIDEwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgc3dhcAogICAgYnVyeSA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk3CiAgICAvLyBhc3NlcnQob3B0ZWRJbiAmJiBiYWxhbmNlID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgbWluIGJhbGFuY2UnKQogICAgYnogZW50ZXJfYm9vbF9mYWxzZUAxOQogICAgZGlnIDYKICAgIGRpZyA1CiAgICA+PQogICAgYnogZW50ZXJfYm9vbF9mYWxzZUAxOQogICAgaW50Y18xIC8vIDEKCmVudGVyX2Jvb2xfbWVyZ2VAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk3CiAgICAvLyBhc3NlcnQob3B0ZWRJbiAmJiBiYWxhbmNlID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgbWluIGJhbGFuY2UnKQogICAgYXNzZXJ0IC8vIHVzZXIgZG9lcyBub3QgaGF2ZSBtaW4gYmFsYW5jZQoKZW50ZXJfYWZ0ZXJfaWZfZWxzZUAyMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MDAtOTA5CiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgfSwKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTAxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTAxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTAxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MDMKICAgIC8vIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTA2CiAgICAvLyB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICBjYWxsc3ViIHN0YWtpbmdUeXBlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTA0LTkwNwogICAgLy8gewogICAgLy8gICBhc3NldDogZW50cmllc1tpXS5hc3NldCwKICAgIC8vICAgdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgLy8gfSwKICAgIGRpZyAxMgogICAgZXh0cmFjdCAwIDgKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MDAtOTA5CiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgfSwKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBieXRlYyAzMiAvLyBtZXRob2QgImdldEluZm8oYWRkcmVzcywodWludDY0LHVpbnQ4KSkodWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCAyNCAvLyAyNAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgcHVzaGludCA0IC8vIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MTEKICAgIC8vIGFzc2VydChzdGFrZUluZm8uYW1vdW50ID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHN0YWtlZCcpCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgPj0KICAgIGFzc2VydCAvLyB1c2VyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHN0YWtlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE3NQogICAgLy8gY29uc3QgaWQgPSB0aGlzLmVudHJ5SUQudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc1CiAgICAvLyBjb25zdCBpZCA9IHRoaXMuZW50cnlJRC52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNzYKICAgIC8vIHRoaXMuZW50cnlJRC52YWx1ZSArPSAxCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc2CiAgICAvLyB0aGlzLmVudHJ5SUQudmFsdWUgKz0gMQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MTUKICAgIC8vIGFkZHJlc3M6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTE0LTkyMAogICAgLy8gdGhpcy5lbnRyaWVzKGVudHJ5SUQpLnZhbHVlID0gewogICAgLy8gICBhZGRyZXNzOiBUeG4uc2VuZGVyLAogICAgLy8gICBhc3NldDogZW50cmllc1tpXS5hc3NldCwKICAgIC8vICAgcXVhbnRpdHk6IGVudHJpZXNbaV0ucXVhbnRpdHksCiAgICAvLyAgIGdhdGVBcmdzOiBjbG9uZShhcmdzKSwKICAgIC8vICAgZGlzcXVhbGlmaWVkOiBmYWxzZQogICAgLy8gfQogICAgZGlnIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwMzMwMAogICAgY29uY2F0CiAgICBkaWcgMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTE0CiAgICAvLyB0aGlzLmVudHJpZXMoZW50cnlJRCkudmFsdWUgPSB7CiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkxNC05MjAKICAgIC8vIHRoaXMuZW50cmllcyhlbnRyeUlEKS52YWx1ZSA9IHsKICAgIC8vICAgYWRkcmVzczogVHhuLnNlbmRlciwKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgIHF1YW50aXR5OiBlbnRyaWVzW2ldLnF1YW50aXR5LAogICAgLy8gICBnYXRlQXJnczogY2xvbmUoYXJncyksCiAgICAvLyAgIGRpc3F1YWxpZmllZDogZmFsc2UKICAgIC8vIH0KICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICB1bmNvdmVyIDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MjMKICAgIC8vIGFkZHJlc3M6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTIyLTkyNQogICAgLy8gY29uc3QgYUtleSA9IHsKICAgIC8vICAgYWRkcmVzczogVHhuLnNlbmRlciwKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyB9CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkyNwogICAgLy8gdGhpcy5lbnRyaWVzQnlBZGRyZXNzKGFLZXkpLnZhbHVlID0gZW50cnlJRAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgOAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY1CiAgICAvLyBlbnRyaWVzQnlBZGRyZXNzID0gQm94TWFwPEVudHJ5S2V5LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllc0J5QWRkcmVzcyB9KQogICAgcHVzaGJ5dGVzICJhIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTI3CiAgICAvLyB0aGlzLmVudHJpZXNCeUFkZHJlc3MoYUtleSkudmFsdWUgPSBlbnRyeUlECiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIGVudGVyX3doaWxlX3RvcEAxMAoKZW50ZXJfYm9vbF9mYWxzZUAxOToKICAgIGludGNfMCAvLyAwCiAgICBiIGVudGVyX2Jvb2xfbWVyZ2VAMjAKCmVudGVyX2FmdGVyX3doaWxlQDIzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzNgogICAgLy8gZW50ZXIocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBlbnRyaWVzOiBTdGFrZUVudHJ5W10sIGFyZ3M6IEdhdGVBcmdzKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgplbnRlcl9ib29sX2ZhbHNlQDY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBlbnRlcl9ib29sX21lcmdlQDcKCmVudGVyX2FmdGVyX2lmX2Vsc2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE0OS0xNTIKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNTEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgMzMgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTQ5LTE1MgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTM0CiAgICAvLyByZXR1cm4gb3JpZ2luT3Iod2FsbGV0SUQsIFR4bi5zZW5kZXIpCiAgICBiIGVudGVyX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6b3JpZ2luT3JAMzEKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnN0YXJ0RGlzYnVyc2VtZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKc3RhcnREaXNidXJzZW1lbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTMxCiAgICAvLyBzdGFydERpc2J1cnNlbWVudChyZXdhcmRJRDogdWludDY0KTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzMgogICAgLy8gYXNzZXJ0KHRoaXMuaXNMaXZlKCksICd0aGUgcG9vbCBpcyBub3QgbGl2ZScpCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlCiAgICBhc3NlcnQgLy8gdGhlIHBvb2wgaXMgbm90IGxpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MzMKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDIwIC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MzMKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyByZXdhcmQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MzUKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGludGVydmFsLCBsYXN0RGlzYnVyc2VtZW50VGltZXN0YW1wLCBleHBpcmF0aW9uIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjUgLy8gMjUKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDIKICAgIHB1c2hpbnQgMTE2IC8vIDExNgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBjb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzNwogICAgLy8gYXNzZXJ0KHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZUlkbGUsICdyZXdhcmQgaXMgYWxyZWFkeSBpbiBhIGRpc2J1cnNlbWVudCBwaGFzZScpCiAgICBzd2FwCiAgICBieXRlY18zIC8vIDB4MDAKICAgID09CiAgICBhc3NlcnQgLy8gcmV3YXJkIGlzIGFscmVhZHkgaW4gYSBkaXNidXJzZW1lbnQgcGhhc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MTYKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gKChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJSBpbnRlcnZhbCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE5IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTE2CiAgICAvLyByZXR1cm4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtICgoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICUgaW50ZXJ2YWwpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLQogICAgdW5jb3ZlciAyCiAgICAlCiAgICAtCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MjEKICAgIC8vIHJldHVybiBsYXRlc3RXaW5kb3dTdGFydCAhPT0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAmJiBsYXN0IDwgbGF0ZXN0V2luZG93U3RhcnQKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgICE9CiAgICBieiBzdGFydERpc2J1cnNlbWVudF9ib29sX2ZhbHNlQDQKICAgIGRpZyAyCiAgICBkaWcgMQogICAgPAogICAgYnogc3RhcnREaXNidXJzZW1lbnRfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKc3RhcnREaXNidXJzZW1lbnRfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzOAogICAgLy8gYXNzZXJ0KHRoaXMudmFsaWRXaW5kb3coaW50ZXJ2YWwsIGxhc3REaXNidXJzZW1lbnRUaW1lc3RhbXApLCAnZGlzdHJpYnV0aW9uIHdpbmRvdyBpcyBub3Qgb3BlbicpCiAgICBhc3NlcnQgLy8gZGlzdHJpYnV0aW9uIHdpbmRvdyBpcyBub3Qgb3BlbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MQogICAgLy8gYCR7dGhpcy50aXRsZS52YWx1ZX0gLSBSZXdhcmRzYCwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBieXRlYyAyNCAvLyAidGl0bGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQxCiAgICAvLyBgJHt0aGlzLnRpdGxlLnZhbHVlfSAtIFJld2FyZHNgLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAiIC0gUmV3YXJkcyIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MgogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NDMKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgKyBleHBpcmF0aW9uCiAgICBkdXAKICAgIGRpZyA0CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ4CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ4CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU0OQogICAgLy8gY29uc3QgcmV3YXJkTUJSOiB1aW50NjQgPSBNaW5EaXNidXJzZW1lbnRzTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXModGl0bGUpLmxlbmd0aCkKICAgIGRpZyAzCiAgICBsZW4KICAgIGludGMgNiAvLyA0MDAKICAgIGRpZyAxCiAgICAqCiAgICBwdXNoaW50IDM1MzAwIC8vIDM1MzAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTUyCiAgICAvLyByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NTYtNTY1CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAnJywKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU1MS01NTQKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHJld2FyZE1CUiwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTU2LTU2NQogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZURpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgJycsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYwCiAgICAvLyB0aXRsZSwKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU2MQogICAgLy8gdGltZVRvVW5sb2NrLAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYyCiAgICAvLyBleHBpcmF0aW9uLAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYzCiAgICAvLyAnJywKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTU2LTU2NQogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZURpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgJycsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MWM5ZWJiZGIgLy8gbWV0aG9kICJjcmVhdGVEaXNidXJzZW1lbnQocGF5LHN0cmluZyx1aW50NjQsdWludDY0LHN0cmluZyl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NjMKICAgIC8vICcnLAogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NTYtNTY1CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAnJywKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTQ2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlcnMgPSAwCiAgICBkaWcgNQogICAgZHVwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBkaWcgNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NDcKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2UgPSAwCiAgICBkdXAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGRpZyA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24KICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgNyAvLyAweDBhCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0OQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgdW5jb3ZlciA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRJRCA9IGRpc2J1cnNlbWVudElECiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgdW5jb3ZlciAzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1MQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ID0gR2xvYmFsLnJvdW5kCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIGRpZyAxCiAgICBwdXNoaW50IDEwOCAvLyAxMDgKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NTIKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUubGFzdERpc2J1cnNlbWVudFRpbWVzdGFtcCA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIHB1c2hpbnQgMTE2IC8vIDExNgogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MzEKICAgIC8vIHN0YXJ0RGlzYnVyc2VtZW50KHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnN0YXJ0RGlzYnVyc2VtZW50X2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIHN0YXJ0RGlzYnVyc2VtZW50X2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKcmFmZmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1NQogICAgLy8gcmFmZmxlKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5kaXNidXJzZVJld2FyZHNbcm91dGluZ10oKSAtPiB2b2lkOgpkaXNidXJzZVJld2FyZHM6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA3CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTUKICAgIC8vIGRpc2J1cnNlUmV3YXJkcyhyZXdhcmRJRDogdWludDY0LCBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTcKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDIwIC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTcKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyByZXdhcmQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTkKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGRpc3RyaWJ1dGlvbiwgd2lubmluZ1RpY2tldHMgfSA9IGNsb25lKHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUpCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDAyCiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgYnl0ZWMgNyAvLyAweDBhCiAgICA9PQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwMi0xMDAzCiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYm9vbF90cnVlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDAzCiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLAogICAgZGlnIDIKICAgIGJ5dGVjIDExIC8vIDB4MTQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwMi0xMDAzCiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ib29sX2ZhbHNlQDQKCmRpc2J1cnNlUmV3YXJkc19ib29sX3RydWVAMzoKICAgIGludGNfMSAvLyAxCgpkaXNidXJzZVJld2FyZHNfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMDEtMTAwNQogICAgLy8gYXNzZXJ0KAogICAgLy8gICBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgLy8gICBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLAogICAgLy8gICBFUlJfTk9UX1JFQURZX1RPX0RJU0JVUlNFCiAgICAvLyApCiAgICBhc3NlcnQgLy8gTm90IHJlYWR5IHRvIGRpc2J1cnNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwNwogICAgLy8gaWYgKHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZVByZXBhcmF0aW9uKSB7CiAgICBkdXAKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIxOAogICAgLy8gY29uc3QgeyBkaXNidXJzZW1lbnRDdXJzb3IsIGRpc3RyaWJ1dGlvbiwgcmF0ZSwgYXNzZXQgfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGRpZyAzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMjIKICAgIGR1cAogICAgaW50Y18yIC8vIDgKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgYnVyeSA0CiAgICBkdXAKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMTUKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMjgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMTkKICAgIC8vIGxldCBjb3VudDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMjYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjAKICAgIC8vIGxldCB0b3RhbDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjIKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZGlnIDUKICAgICsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjIyCiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5MQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyMwogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyMwogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIwCiAgICAtCiAgICBidXJ5IDUKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDkxOgogICAgZGlnIDE5CiAgICBidXJ5IDE3CgpkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDkyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyNgogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBkaWcgMTYKICAgIGRpZyA1CiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVAMTA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI3CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgZ2F0ZUFyZ3MsIHF1YW50aXR5IH0gPSBjbG9uZSh0aGlzLmVudHJpZXMoaWQpLnZhbHVlKQogICAgZGlnIDE2CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjcKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzLCBnYXRlQXJncywgcXVhbnRpdHkgfSA9IGNsb25lKHRoaXMuZW50cmllcyhpZCkudmFsdWUpCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMQogICAgcHVzaGludCA1MCAvLyA1MAogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBkaWcgMgogICAgaW50Y18wIC8vIDAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICBidXJ5IDQzCiAgICBkaWcgMQogICAgcHVzaGludCA0OCAvLyA0OAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyCiAgICBsZW4KICAgIHVuY292ZXIgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgYnVyeSAzNQogICAgc3dhcAogICAgcHVzaGludCA0MCAvLyA0MAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI4CiAgICAvLyBpZiAoZGlzcXVhbGlmaWVkKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzMAogICAgLy8gaWYgKHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzAKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX05PTkUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vIDB4MDAKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDk3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTMxCiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogMCB9CiAgICBwdXNoYnl0ZXMgMHg4MDAwMDAwMDAwMDAwMDAwMDAKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZ2V0U3Rha2VWYWx1ZUAxMDA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjMzCiAgICAvLyBjb25zdCB7IHZhbGlkIH0gPSB0aGlzLmdldFN0YWtlVmFsdWUoaWQpCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjM0CiAgICAvLyBpZiAoIXZhbGlkKSB7CiAgICBieiBkaXNidXJzZVJld2FyZHNfYmxvY2tAMTA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjM4CiAgICAvLyBpZiAodGhpcy5nYXRlSUQudmFsdWUgIT09IDApIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGJ5dGVjIDggLy8gImdhdGVfaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjM4CiAgICAvLyBpZiAodGhpcy5nYXRlSUQudmFsdWUgIT09IDApIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMzkKICAgIC8vIGNvbnN0IHdhbGxldCA9IGdldFdhbGxldElEVXNpbmdBa2l0YURBTyhHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQsIGFkZHJlc3MpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGRpZyA0MAogICAgY2FsbHN1YiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8KICAgIGR1cAogICAgYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEyNwogICAgLy8gaWYgKHdhbGxldElELmlkID09PSAwKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTI3CiAgICBkaWcgMzkKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDEyODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDIKICAgIC8vIGNvbnN0IHBhc3NlcyA9IGdhdGVDYWxsKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgb3JpZ2luLCB0aGlzLmdhdGVJRC52YWx1ZSwgZ2F0ZUFyZ3MpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGJ5dGVjIDggLy8gImdhdGVfaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQyCiAgICAvLyBjb25zdCBwYXNzZXMgPSBnYXRlQ2FsbChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQsIG9yaWdpbiwgdGhpcy5nYXRlSUQudmFsdWUsIGdhdGVBcmdzKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGRpZyAzNQogICAgY2FsbHN1YiBnYXRlQ2FsbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQzCiAgICAvLyBpZiAoIXBhc3NlcykgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEwNwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gaWYgKHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gaWYgKHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWMgNyAvLyAweDBhCiAgICAhPQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0NQogICAgLy8gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZS5kaXNxdWFsaWZpZWQgPSB0cnVlCiAgICBkaWcgMzMKICAgIGR1cAogICAgcHVzaGludCA1MCAvLyA1MAogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18xIC8vIDEKICAgIHNldGJpdAogICAgcHVzaGludCA1MCAvLyA1MAogICAgc3dhcAogICAgYm94X3JlcGxhY2UKCmRpc2J1cnNlUmV3YXJkc19ibG9ja0AxMDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA5MgoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1MQogICAgLy8gY291bnQgKz0gMQogICAgZGlnIDI0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAyNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1MgogICAgLy8gdG90YWwgKz0gcXVhbnRpdHkKICAgIGRpZyA4CiAgICBkaWcgMTQKICAgICsKICAgIGJ1cnkgOQogICAgYiBkaXNidXJzZVJld2FyZHNfYmxvY2tAMTA4CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMjc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE0OS0xNTIKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNTEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgMzMgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTQ5LTE1MgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDAKICAgIC8vIGNvbnN0IG9yaWdpbiA9IG9yaWdpbk9yKHdhbGxldCwgYWRkcmVzcykKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6b3JpZ2luT3JAMTI4CgpkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDk3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzMgogICAgLy8gfSBlbHNlIGlmICh0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzIKICAgIC8vIH0gZWxzZSBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlYyA3IC8vIDB4MGEKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5OQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzMwogICAgLy8gY29uc3QgeyBhZGRyZXNzLCBhc3NldCB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZGlnIDMzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBib3hfZXh0cmFjdAogICAgc3dhcAogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTM1LTUzOAogICAgLy8gY29uc3QgYXZnID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuZ2V0SGVhcnRiZWF0QXZlcmFnZT4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzLCBhc3NldCwgdHJ1ZV0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTM1LTUzOAogICAgLy8gY29uc3QgYXZnID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuZ2V0SGVhcnRiZWF0QXZlcmFnZT4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzLCBhc3NldCwgdHJ1ZV0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4YzZmZDBjYTUgLy8gbWV0aG9kICJnZXRIZWFydGJlYXRBdmVyYWdlKGFkZHJlc3MsdWludDY0LGJvb2wpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTM3CiAgICAvLyBhcmdzOiBbYWRkcmVzcywgYXNzZXQsIHRydWVdLAogICAgYnl0ZWMgMTYgLy8gMHg4MAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNS01MzgKICAgIC8vIGNvbnN0IGF2ZyA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLmdldEhlYXJ0YmVhdEF2ZXJhZ2U+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXQsIHRydWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NDAKICAgIC8vIHJldHVybiB7IHZhbGlkOiB0cnVlLCBiYWxhbmNlOiBhdmcgfQogICAgaXRvYgogICAgYnl0ZWMgMTYgLy8gMHg4MAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjMzCiAgICAvLyBjb25zdCB7IHZhbGlkIH0gPSB0aGlzLmdldFN0YWtlVmFsdWUoaWQpCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZ2V0U3Rha2VWYWx1ZUAxMDAKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDk5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU0MwogICAgLy8gcmV0dXJuIHRoaXMuY2hlY2tCeUlEKGlkKQogICAgZGlnIDE2CiAgICBjYWxsc3ViIGNoZWNrQnlJRAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzMwogICAgLy8gY29uc3QgeyB2YWxpZCB9ID0gdGhpcy5nZXRTdGFrZVZhbHVlKGlkKQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmdldFN0YWtlVmFsdWVAMTAwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVAMTA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1NQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZXJzICs9IGNvdW50CiAgICBkaWcgMwogICAgZHVwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyAyNgogICAgKwogICAgaXRvYgogICAgZGlnIDEKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTYKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2UgKz0gdG90YWwKICAgIGR1cAogICAgcHVzaGludCA0MSAvLyA0MQogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMTAKICAgICsKICAgIGl0b2IKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjU4CiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSBkaXNidXJzZW1lbnRDdXJzb3IpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjU4CiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSBkaXNidXJzZW1lbnRDdXJzb3IpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMjAKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDExNgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI2MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjEKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGRpZyAxCiAgICBpbnRjXzMgLy8gOTIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjMKICAgIC8vIHRoaXMucGF5QWtpdGFSb3lhbHR5KGRpc3RyaWJ1dGlvbiwgcmF0ZSwgYXNzZXQsIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2VycykKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4OAogICAgLy8gaWYgKGRpc3RyaWJ1dGlvbiA9PT0gRGlzdHJpYnV0aW9uVHlwZUZsYXQpIHsKICAgIGRpZyAxCiAgICBieXRlYyAxMSAvLyAweDE0CiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODkKICAgIC8vIGFtb3VudCA9IGNhbGNQZXJjZW50KChxdWFsaWZpZWRTdGFrZXJzICogcmF0ZSksIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlKQogICAgZGlnIDE0CiAgICBkaWcgMTMKICAgICoKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBha2l0YVJveWFsdHkgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHkgfSkKICAgIGJ5dGVjIDIzIC8vICJha2l0YV9yb3lhbHR5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4OQogICAgLy8gYW1vdW50ID0gY2FsY1BlcmNlbnQoKHF1YWxpZmllZFN0YWtlcnMgKiByYXRlKSwgdGhpcy5ha2l0YVJveWFsdHkudmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5MgogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDAwMAogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTMKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBtdWx3CiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICBkaXZ3CiAgICBidXJ5IDI4CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5X2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxOTQKICAgIC8vIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlID0gYW1vdW50CiAgICBkaWcgMjgKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTk3CiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGRpZyAyNgogICAgYm56IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTk4LTIwMwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIwMAogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgZGlnIDI4CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5OC0yMDIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5OC0yMDMKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTUKICAgIC8vIGRpc2J1cnNlUmV3YXJkcyhyZXdhcmRJRDogdWludDY0LCBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA1CiAgICAvLyBhc3NlcnQoR2xvYmFsLnplcm9BZGRyZXNzLmlzT3B0ZWRJbihBc3NldChhc3NldCkpLCBFUlJfREFPX05PVF9PUFRFRF9JTikKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgZGlnIDI3CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gREFPIG5vdCBvcHRlZCBpbiB0byB0aGUgYXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMDctMjEzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMDkKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgc3dhcAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyAyOAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA3LTIxMgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMDctMjEzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDExMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIGFtb3VudCA9IGNhbGNQZXJjZW50KHJhdGUsIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTIKICAgIC8vIGFraXRhUm95YWx0eSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eSB9KQogICAgYnl0ZWMgMjMgLy8gImFraXRhX3JveWFsdHkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyBhbW91bnQgPSBjYWxjUGVyY2VudChyYXRlLCB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjkyCiAgICAvLyBhc3NlcnQocCA8PSBESVZJU09SLCBFUlJfSU5WQUxJRF9QRVJDRU5UQUdFKQogICAgZHVwCiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGVyY2VudGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5MwogICAgLy8gcmV0dXJuIG9wLmRpdncoLi4ub3AubXVsdyhhLCBwKSwgRElWSVNPUikKICAgIGRpZyAxMwogICAgbXVsdwogICAgaW50YyA0IC8vIDEwMDAwMAogICAgZGl2dwogICAgYnVyeSAyOAogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMTMKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI2NgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgKz0gaXRlcmF0aW9uQW1vdW50CiAgICBkaWcgMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDYKICAgICsKICAgIGl0b2IKICAgIGludGNfMyAvLyA5MgogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDExCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlOiB7CiAgICBkaWcgMQogICAgYnl0ZWMgNyAvLyAweDBhCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMTEtMTAxNAogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZTogewogICAgLy8gICB0aGlzLmNyZWF0ZVBlcmNlbnRhZ2VEaXNidXJzZW1lbnQocmV3YXJkSUQsIGl0ZXJhdGlvbkFtb3VudCkKICAgIC8vICAgYnJlYWsKICAgIC8vIH0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjc3CiAgICAvLyB9ID0gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZQogICAgZGlnIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAyOAogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIyCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDM0CiAgICBkdXAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAxOAogICAgcHVzaGludCA5IC8vIDkKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAyOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI3OQogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBkaWcgNQogICAgKwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNzkKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID4KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDc5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgwCiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgwCiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMjAKICAgIC0KICAgIGJ1cnkgNQoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANzk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgzCiAgICAvLyBjb25zdCBhY3R1YWxBbW91bnQ6IHVpbnQ2NCA9IGFtb3VudCAtIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NAogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBieXRlYyAyMSAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgzCiAgICAvLyBjb25zdCBhY3R1YWxBbW91bnQ6IHVpbnQ2NCA9IGFtb3VudCAtIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDI4CiAgICBzd2FwCiAgICAtCiAgICBidXJ5IDMxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg0CiAgICAvLyBsZXQgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10gPSBbXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGJ1cnkgMzkKICAgIGJ5dGVjIDYgLy8gMHgwMDAwCiAgICBidXJ5IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg1CiAgICAvLyBsZXQgc3VtOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxMQogICAgZGlnIDE5CiAgICBidXJ5IDE3CgpkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDgwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4NwogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBkaWcgMTYKICAgIGRpZyA1CiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVAODUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODgKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBxdWFudGl0eSwgYWRkcmVzcyB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZGlnIDE2CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg4CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgcXVhbnRpdHksIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGR1cAogICAgcHVzaGludCA1MCAvLyA1MAogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBkaWcgMQogICAgcHVzaGludCA0MCAvLyA0MAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDE2CiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgNDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODkKICAgIC8vIGlmIChkaXNxdWFsaWZpZWQpIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYmxvY2tAODQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTcKICAgIC8vIGFzc2VydChhIDwgYiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRV9PRl9BUkdTKQogICAgZGlnIDEzCiAgICBkdXAKICAgIGRpZyAxNwogICAgZHVwCiAgICBjb3ZlciAzCiAgICA8CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlIG9mIGFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTgKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgRElWSVNPUiksIGIpCiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICBtdWx3CiAgICB1bmNvdmVyIDIKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTIKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjkzCiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIHApLCBESVZJU09SKQogICAgZGlnIDMxCiAgICBtdWx3CiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICBkaXZ3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjk0CiAgICAvLyBhbGxvY2F0aW9ucy5wdXNoKHsgYWRkcmVzcywgYW1vdW50OiBpbmRpdmlkdWFsQW1vdW50IH0pCiAgICBkdXAKICAgIGl0b2IKICAgIGRpZyA0MQogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMzYKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBidXJ5IDM2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjk1CiAgICAvLyBzdW0gKz0gaW5kaXZpZHVhbEFtb3VudAogICAgZGlnIDExCiAgICArCiAgICBidXJ5IDExCgpkaXNidXJzZVJld2FyZHNfYmxvY2tAODQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg3CiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA4MAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDg1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI5OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgKz0gaXRlcmF0aW9uQW1vdW50CiAgICBkaWcgMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMwogICAgKwogICAgaXRvYgogICAgaW50Y18zIC8vIDkyCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMwMAogICAgLy8gdGhpcy5jcmVhdGVSZXdhcmRBbGxvY2F0aW9ucyhhY3RpdmVEaXNidXJzZW1lbnRJRCwgYXNzZXQsIGFsbG9jYXRpb25zLCBzdW0pCiAgICBkaWcgMzIKICAgIGRpZyAyOAogICAgZGlnIDM3CiAgICBkaWcgMTQKICAgIGNhbGxzdWIgY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMwMgogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzAyCiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSAoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAyMQogICAgdW5jb3ZlciAyCiAgICArCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMDMKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUZpbmFsaXphdGlvbgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgMTMgLy8gMHgxZQogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMDQKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgaW50Y18zIC8vIDkyCiAgICBkaWcgNDAKICAgIGJveF9yZXBsYWNlCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE1CiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVGbGF0OiB7CiAgICBkaWcgMQogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE1LTEwMTgKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZUZsYXQ6IHsKICAgIC8vICAgdGhpcy5jcmVhdGVGbGF0RGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICAvLyAgIGJyZWFrCiAgICAvLyB9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMxNQogICAgLy8gfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDMzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMjIKICAgIGR1cAogICAgcHVzaGludCAzMyAvLyAzMwogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMQogICAgcHVzaGludCA5IC8vIDkKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgdW5jb3ZlciAyCiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGJ1cnkgMzEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTcKICAgIC8vIGNvbnN0IHRvdGFsOiB1aW50NjQgPSAocXVhbGlmaWVkU3Rha2VycyAqIGFtb3VudCkgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgc3dhcAogICAgZGlnIDEKICAgICoKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5X2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTcKICAgIC8vIGNvbnN0IHRvdGFsOiB1aW50NjQgPSAocXVhbGlmaWVkU3Rha2VycyAqIGFtb3VudCkgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTgKICAgIC8vIGNvbnN0IHBlcmNlbnRhZ2VBa2l0YUZlZSA9IGNhbGNQZXJjZW50KGFtb3VudCwgdGhpcy5ha2l0YVJveWFsdHkudmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gYWtpdGFSb3lhbHR5ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5IH0pCiAgICBieXRlYyAyMyAvLyAiYWtpdGFfcm95YWx0eSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTgKICAgIC8vIGNvbnN0IHBlcmNlbnRhZ2VBa2l0YUZlZSA9IGNhbGNQZXJjZW50KGFtb3VudCwgdGhpcy5ha2l0YVJveWFsdHkudmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5MgogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDAwMAogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTMKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBkaWcgMgogICAgbXVsdwogICAgaW50YyA0IC8vIDEwMDAwMAogICAgZGl2dwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMxOQogICAgLy8gY29uc3QgYWRqdXN0ZWRBbW91bnQ6IHVpbnQ2NCA9IGFtb3VudCAtIHBlcmNlbnRhZ2VBa2l0YUZlZQogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICAtCiAgICBidXJ5IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzIwCiAgICAvLyBjb25zdCBbYmFsYW5jZV0gPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBhc3NldCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICB1bmNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzIyCiAgICAvLyBhc3NlcnQoYmFsYW5jZSA+PSB0b3RhbCwgRVJSX05PVF9FTk9VR0hfRlVORFMpCiAgICA8PQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggZnVuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMjQKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZGlnIDUKICAgICsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA2NwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyNQogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyNQogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIwCiAgICAtCiAgICBidXJ5IDUKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDY3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyOAogICAgLy8gbGV0IGFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbltdID0gW10KICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBidXJ5IDM4CiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgYnVyeSAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyOQogICAgLy8gbGV0IHN1bTogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMTEKICAgIGRpZyAxOQogICAgYnVyeSAxNwoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA2ODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMzEKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZGlnIDE2CiAgICBkaWcgNQogICAgPAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDczCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzMyCiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcyB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZGlnIDE2CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzMyCiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcyB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBib3hfZXh0cmFjdAogICAgYnVyeSA0MQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzMwogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A3MgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzNwogICAgLy8gYWxsb2NhdGlvbnMucHVzaCh7IGFkZHJlc3MsIGFtb3VudDogYWRqdXN0ZWRBbW91bnQgfSkKICAgIGRpZyAyOAogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgNDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDM2CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgYnVyeSAzNgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzOAogICAgLy8gc3VtICs9IGFkanVzdGVkQW1vdW50CiAgICBkaWcgMTEKICAgICsKICAgIGJ1cnkgMTEKCmRpc2J1cnNlUmV3YXJkc19ibG9ja0A3MjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMzEKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZGlnIDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxNwogICAgYiBkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDY4CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANzM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQxCiAgICAvLyBjb25zdCBuZXdDdXJzb3JWYWx1ZTogdWludDY0ID0gZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50CiAgICBkaWcgMTkKICAgIGRpZyA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQyCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IG5ld0N1cnNvclZhbHVlCiAgICBkdXAKICAgIGl0b2IKICAgIGRpZyA1CiAgICBpbnRjXzMgLy8gOTIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNDMKICAgIC8vIHRoaXMuY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMoYWN0aXZlRGlzYnVyc2VtZW50SUQsIGFzc2V0LCBhbGxvY2F0aW9ucywgc3VtKQogICAgZGlnIDMyCiAgICBkaWcgMjgKICAgIGRpZyAzNwogICAgZGlnIDE0CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNDUKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IG5ld0N1cnNvclZhbHVlKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM0NQogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gbmV3Q3Vyc29yVmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNDYKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUZpbmFsaXphdGlvbgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgMTMgLy8gMHgxZQogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNDcKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgaW50Y18zIC8vIDkyCiAgICBkaWcgMzkKICAgIGJveF9yZXBsYWNlCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE5CiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVFdmVuOiB7CiAgICBkaWcgMQogICAgYnl0ZWMgMTMgLy8gMHgxZQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE5LTEwMjIKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZUV2ZW46IHsKICAgIC8vICAgdGhpcy5jcmVhdGVFdmVuRGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICAvLyAgIGJyZWFrCiAgICAvLyB9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM1OAogICAgLy8gfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDMzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMjIKICAgIGR1cAogICAgcHVzaGludCAzMyAvLyAzMwogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDE3CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAzMAogICAgcHVzaGludCA5IC8vIDkKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzYwCiAgICAvLyBjb25zdCBiYWxhbmNlID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgYXNzZXQpWzBdCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNjEKICAgIC8vIGNvbnN0IGFjdHVhbFN1bTogdWludDY0ID0gc3VtIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGJ5dGVjIDIxIC8vICJha2l0YV9yb3lhbHR5X2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNjEKICAgIC8vIGNvbnN0IGFjdHVhbFN1bTogdWludDY0ID0gc3VtIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIGR1cAogICAgYnVyeSAzMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2MgogICAgLy8gYXNzZXJ0KGJhbGFuY2UgPj0gYWN0dWFsU3VtLCBFUlJfTk9UX0VOT1VHSF9GVU5EUykKICAgID49CiAgICBhc3NlcnQgLy8gTm90IGVub3VnaCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2NAogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBkaWcgNQogICAgKwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNjQKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID4KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzY1CiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzY1CiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMjAKICAgIC0KICAgIGJ1cnkgNQoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzY4CiAgICAvLyBjb25zdCBhbW91bnQ6IHVpbnQ2NCA9IGFjdHVhbFN1bSAvIHF1YWxpZmllZFN0YWtlcnMKICAgIGRpZyAyOQogICAgZGlnIDE1CiAgICAvCiAgICBidXJ5IDI4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzY5CiAgICAvLyBsZXQgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10gPSBbXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGJ1cnkgMzcKICAgIGJ5dGVjIDYgLy8gMHgwMDAwCiAgICBidXJ5IDM1CiAgICBkaWcgMTkKICAgIGJ1cnkgMTcKCmRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BANTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzcwCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgZGlnIDUKICAgIDwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl93aGlsZUA2MQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3MQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGRpZyAxNgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3MQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGR1cAogICAgcHVzaGludCA1MCAvLyA1MAogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgNDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNzIKICAgIC8vIGlmIChkaXNxdWFsaWZpZWQpIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYmxvY2tANjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNzYKICAgIC8vIGFsbG9jYXRpb25zLnB1c2goeyBhZGRyZXNzLCBhbW91bnQgfSkKICAgIGRpZyAyNwogICAgaXRvYgogICAgZGlnIDQwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyAzNQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMzUKCmRpc2J1cnNlUmV3YXJkc19ibG9ja0A2MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNzAKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZGlnIDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxNwogICAgYiBkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDU2CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANjE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzc5CiAgICAvLyBjb25zdCBuZXdDdXJzb3JWYWx1ZTogdWludDY0ID0gZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50CiAgICBkaWcgMTkKICAgIGRpZyA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzgwCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IG5ld0N1cnNvclZhbHVlCiAgICBkdXAKICAgIGl0b2IKICAgIGRpZyA1CiAgICBpbnRjXzMgLy8gOTIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozODEKICAgIC8vIHRoaXMuY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMoYWN0aXZlRGlzYnVyc2VtZW50SUQsIGFzc2V0LCBhbGxvY2F0aW9ucywgc3VtKQogICAgZGlnIDMyCiAgICBkaWcgMjgKICAgIGRpZyAzNwogICAgZGlnIDE0CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozODMKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IG5ld0N1cnNvclZhbHVlKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM4MwogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gbmV3Q3Vyc29yVmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozODQKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUZpbmFsaXphdGlvbgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgMTMgLy8gMHgxZQogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozODUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgaW50Y18zIC8vIDkyCiAgICBkaWcgMzgKICAgIGJveF9yZXBsYWNlCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDIzCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVTaHVmZmxlOiB7CiAgICBkaWcgMQogICAgcHVzaGJ5dGVzIDB4MjgKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyMy0xMDMwCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVTaHVmZmxlOiB7CiAgICAvLyAgIGlmICh3aW5uaW5nVGlja2V0cy5sZW5ndGggPT09IDApIHsKICAgIC8vICAgICB0aGlzLnJhZmZsZShyZXdhcmRJRCkKICAgIC8vICAgfSBlbHNlIHsKICAgIC8vICAgICB0aGlzLmNyZWF0ZVNodWZmbGVEaXNidXJzZW1lbnQocmV3YXJkSUQsIGl0ZXJhdGlvbkFtb3VudCkKICAgIC8vICAgfQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYXNzZXJ0IC8vIHVua25vd24gcmV3YXJkIHJhdGUgdHlwZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMjQKICAgIC8vIGlmICh3aW5uaW5nVGlja2V0cy5sZW5ndGggPT09IDApIHsKICAgIGRpZyAzCiAgICBwdXNoaW50cyAxMjQgMiAvLyAxMjQsIDIKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAyNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMjUKICAgIC8vIHRoaXMucmFmZmxlKHJld2FyZElEKQogICAgZGlnIDUKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGUKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMjQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzk4CiAgICAvLyB9ID0gY2xvbmUodGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZSkKICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDMzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMjIKICAgIGR1cAogICAgcHVzaGludCA0OSAvLyA0OQogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDkKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDMwCiAgICBwdXNoaW50IDkgLy8gOQogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIGNvbnN0IGJhbGFuY2UgPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBhc3NldClbMF0KICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQwMQogICAgLy8gY29uc3QgYWN0dWFsU3VtOiB1aW50NjQgPSBzdW0gLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTQKICAgIC8vIGFraXRhUm95YWx0eUFtb3VudCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eUFtb3VudCB9KQogICAgYnl0ZWMgMjEgLy8gImFraXRhX3JveWFsdHlfYW1vdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQwMQogICAgLy8gY29uc3QgYWN0dWFsU3VtOiB1aW50NjQgPSBzdW0gLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgLQogICAgZHVwCiAgICBidXJ5IDMzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDAyCiAgICAvLyBhc3NlcnQoYmFsYW5jZSA+PSBhY3R1YWxTdW0sIEVSUl9OT1RfRU5PVUdIX0ZVTkRTKQogICAgPj0KICAgIGFzc2VydCAvLyBOb3QgZW5vdWdoIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDA0CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGRpZyA1CiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQwNAogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPgogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDUKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDUKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAyMAogICAgLQogICAgYnVyeSA1CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDkKICAgIC8vIGlmICh3aW5uZXJDb3VudCA+IDApIHsKICAgIGRpZyA2CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2lmX2JvZHlAMzQKICAgIGRpZyAyOQogICAgYnVyeSAyOAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDEzCiAgICAvLyBsZXQgeyBzdGFrZSwgdGlja2V0LCBkaXNidXJzZWQgfSA9IHJhZmZsZUN1cnNvcgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludHMgNTkgMjQgLy8gNTksIDI0CiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMwogICAgYnVyeSAxNQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxNAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGJ1cnkgMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MTQKICAgIC8vIGxldCBjdXJyZW50VGlja2V0ID0gdGlja2V0c1t0aWNrZXRdCiAgICBpbnRjXzIgLy8gOAogICAgKgogICAgcHVzaGludCAxMjYgLy8gMTI2CiAgICArCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMjMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MTgKICAgIC8vIGxldCBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgYnVyeSAzNwogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGJ1cnkgMzYKICAgIGJ1cnkgMjMKICAgIGRpZyAxOQogICAgYnVyeSAxOAoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEAzNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MTkKICAgIC8vIGZvciAobGV0IGkgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGkgPCBpdGVyYXRpb25BbW91bnQ7IGkrKykgewogICAgZGlnIDE3CiAgICBkaWcgNQogICAgPAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDIwCiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgYXNzZXQsIHF1YW50aXR5IH0gPSB0aGlzLmVudHJpZXMoaSkudmFsdWUKICAgIGRpZyAxNwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyMAogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGFzc2V0LCBxdWFudGl0eSB9ID0gdGhpcy5lbnRyaWVzKGkpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnVyeSAyMAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgNDEKICAgIGR1cAogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDI3CiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MjIKICAgIC8vIGN1cnJlbnRSYW5nZUVuZCA9IGN1cnJlbnRSYW5nZVN0YXJ0ICsgcXVhbnRpdHkKICAgIGRpZyAyMwogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgICsKICAgIGJ1cnkgMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MjMKICAgIC8vIGlmIChjdXJyZW50VGlja2V0ID49IGN1cnJlbnRSYW5nZVN0YXJ0ICYmIGN1cnJlbnRUaWNrZXQgPD0gY3VycmVudFJhbmdlRW5kKSB7CiAgICBkaWcgMjIKICAgIDw9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA0NgogICAgZGlnIDIxCiAgICBkaWcgMjQKICAgIDw9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA0NgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyNAogICAgLy8gaWYgKCFkaXNxdWFsaWZpZWQpIHsKICAgIGRpZyAxOAogICAgYm56IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDI1CiAgICAvLyBhbGxvY2F0aW9ucy5wdXNoKHsgYWRkcmVzcywgYW1vdW50IH0pCiAgICBkaWcgMjcKICAgIGl0b2IKICAgIGRpZyA0MAogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMzUKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBidXJ5IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDI2CiAgICAvLyBkaXNidXJzZWQrKwogICAgZGlnIDIwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAyMQoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDI5CiAgICAvLyBpZiAodGlja2V0ID09PSB0aWNrZXRzLmxlbmd0aCAtIDEpIHsKICAgIGRpZyAzCiAgICBwdXNoaW50cyAxMjQgMiAvLyAxMjQsIDIKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZGlnIDEwCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MzEKICAgIC8vIGlmICh3aW5uZXJDb3VudCAhPT0gZGlzYnVyc2VkKSB7CiAgICBkaWcgNgogICAgZGlnIDIxCiAgICAhPQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDMyCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGRpZyAzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDM4CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzMy00MzcKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucmFmZmxlQ3Vyc29yID0gewogICAgLy8gICB0aWNrZXQ6IDAsCiAgICAvLyAgIHN0YWtlOiAwLAogICAgLy8gICBkaXNidXJzZWQ6IDAsCiAgICAvLyB9CiAgICBkdXAKICAgIHB1c2hpbnQgNTkgLy8gNTkKICAgIGJ5dGVjIDM0IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzOAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS53aW5uaW5nVGlja2V0cyA9IFtdCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgZHVwCiAgICBwdXNoaW50IDU3IC8vIDU3CiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIGV4dHJhY3QzCiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgY29uY2F0CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDM5CiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGRpZyAzMQogICAgZGlnIDI2CiAgICBkaWcgMzYKICAgIGRpZyAxMwogICAgY2FsbHN1YiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAyNwogICAgLy8gdGhpcy5jcmVhdGVTaHVmZmxlRGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfYmxvY2tANDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDU2CiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGRpZyAzMQogICAgZGlnIDI3CiAgICBkaWcgMzYKICAgIGRpZyAxMwogICAgY2FsbHN1YiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDU4CiAgICAvLyBpZiAod2lubmVyQ291bnQgPT09IGRpc2J1cnNlZCkgewogICAgZGlnIDYKICAgIGRpZyAyMQogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NTkKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUZpbmFsaXphdGlvbgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgMTMgLy8gMHgxZQogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NjAKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGRpZyAzOAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NjEtNDY1CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnJhZmZsZUN1cnNvciA9IHsKICAgIC8vICAgdGlja2V0OiAwLAogICAgLy8gICBzdGFrZTogMCwKICAgIC8vICAgZGlzYnVyc2VkOiAwLAogICAgLy8gfQogICAgZHVwCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBieXRlYyAzNCAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NjYKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUud2lubmluZ1RpY2tldHMgPSBbXQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGR1cAogICAgcHVzaGludCA1NyAvLyA1NwogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICBleHRyYWN0MwogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGNvbmNhdAogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA1MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NjgKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yICs9IGl0ZXJhdGlvbkFtb3VudAogICAgZGlnIDMKICAgIGR1cAogICAgaW50Y18zIC8vIDkyCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyA2CiAgICArCiAgICBpdG9iCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDkyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDY5CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnJhZmZsZUN1cnNvciA9IHsgdGlja2V0LCBzdGFrZSwgZGlzYnVyc2VkIH0KICAgIGRpZyAxMAogICAgaXRvYgogICAgZGlnIDEzCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGRpZyAyMgogICAgaXRvYgogICAgY29uY2F0CiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDQ1CiAgICAvLyBpdGVyYXRpb25BbW91bnQgLT0gaQogICAgZGlnIDQKICAgIGRpZyAxOAogICAgLQogICAgYnVyeSA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDQ2CiAgICAvLyB0aWNrZXQrKwogICAgZGlnIDkKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBkdXAKICAgIGJ1cnkgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NDcKICAgIC8vIGN1cnJlbnRUaWNrZXQgPSB0aWNrZXRzW3RpY2tldF0KICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBwdXNoaW50IDEyNiAvLyAxMjYKICAgICsKICAgIGRpZyA0CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDQ4CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDM3CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ0OQogICAgLy8gaSA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDUwCiAgICAvLyBzdGFrZSA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDUxCiAgICAvLyBjdXJyZW50UmFuZ2VFbmQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAyNAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDUzCiAgICAvLyBjdXJyZW50UmFuZ2VTdGFydCA9IGN1cnJlbnRSYW5nZUVuZCArIDEKICAgIGRpZyAyMwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMjMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MTkKICAgIC8vIGZvciAobGV0IGkgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGkgPCBpdGVyYXRpb25BbW91bnQ7IGkrKykgewogICAgZGlnIDE3CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxOAogICAgYiBkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDM2CgpkaXNidXJzZVJld2FyZHNfaWZfYm9keUAzNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MTAKICAgIC8vIGFtb3VudCA9IGFjdHVhbFN1bSAvIHdpbm5lckNvdW50CiAgICBkaWcgMjkKICAgIGRpZyA3CiAgICAvCiAgICBidXJ5IDI4CiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDM1CgpkaXNidXJzZVJld2FyZHNfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZmluYWxpemVEaXN0cmlidXRpb25bcm91dGluZ10oKSAtPiB2b2lkOgpmaW5hbGl6ZURpc3RyaWJ1dGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDM4CiAgICAvLyBmaW5hbGl6ZURpc3RyaWJ1dGlvbihyZXdhcmRJRDogdWludDY0KTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMzkKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDIwIC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAzOQogICAgLy8gYXNzZXJ0KHRoaXMucmV3YXJkcyhyZXdhcmRJRCkuZXhpc3RzLCAncmV3YXJkIGRvZXMgbm90IGV4aXN0JykKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gcmV3YXJkIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0MAogICAgLy8gY29uc3QgeyBwaGFzZSwgYWN0aXZlRGlzYnVyc2VtZW50SUQgfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBkaWcgMQogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGR1cAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDEKICAgIC8vIGFzc2VydChwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24sIEVSUl9ESVNCVVJTRU1FTlRfTk9UX1JFQURZX0ZPUl9GSU5BTElaQVRJT04pCiAgICB1bmNvdmVyIDIKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgID09CiAgICBhc3NlcnQgLy8gRGlzYnVyc2VtZW50IG5vdCByZWFkeSBmb3IgZmluYWxpemF0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjEzCiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjEzCiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjEzCiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MTUtNjE4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5maW5hbGl6ZURpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogW2Rpc2J1cnNlbWVudElEXSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHg1NDI0YTU5MSAvLyBtZXRob2QgImZpbmFsaXplRGlzYnVyc2VtZW50KHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDQ1CiAgICAvLyB0aGlzLmRpc2J1cnNlbWVudHMoYWN0aXZlRGlzYnVyc2VtZW50SUQpLmNyZWF0ZSgpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY5CiAgICAvLyBkaXNidXJzZW1lbnRzID0gQm94TWFwPHVpbnQ2NCwgYnl0ZXM8MD4+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RGlzYnVyc2VtZW50cyB9KQogICAgcHVzaGJ5dGVzICJkIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0NQogICAgLy8gdGhpcy5kaXNidXJzZW1lbnRzKGFjdGl2ZURpc2J1cnNlbWVudElEKS5jcmVhdGUoKQogICAgaW50Y18wIC8vIDAKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDcKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUlkbGUKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWNfMyAvLyAweDAwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDgKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuYWN0aXZlRGlzYnVyc2VtZW50SUQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgZGlnIDEKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgZGlnIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0OQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ID0gMAogICAgZGlnIDEKICAgIHB1c2hpbnQgMTA4IC8vIDEwOAogICAgZGlnIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDkyCiAgICBkaWcgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDUxCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlcnMgPSAwCiAgICBkaWcgMQogICAgcHVzaGludCAzMyAvLyAzMwogICAgZGlnIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZSA9IDAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAzOAogICAgLy8gZmluYWxpemVEaXN0cmlidXRpb24ocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuY2hlY2tbcm91dGluZ10oKSAtPiB2b2lkOgpjaGVjazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDU1CiAgICAvLyBjaGVjayhhZGRyZXNzOiBBY2NvdW50LCBhc3NldDogdWludDY0KTogeyB2YWxpZDogYm9vbGVhbiwgYmFsYW5jZTogdWludDY0IH0gewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDU2CiAgICAvLyBjb25zdCBrZXk6IEVudHJ5S2V5ID0geyBhZGRyZXNzLCBhc3NldCB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjUKICAgIC8vIGVudHJpZXNCeUFkZHJlc3MgPSBCb3hNYXA8RW50cnlLZXksIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzQnlBZGRyZXNzIH0pCiAgICBwdXNoYnl0ZXMgImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDU3CiAgICAvLyBjb25zdCBpZCA9IHRoaXMuZW50cmllc0J5QWRkcmVzcyhrZXkpLnZhbHVlCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNTgKICAgIC8vIHJldHVybiB0aGlzLmNoZWNrQnlJRChpZCkKICAgIGNhbGxzdWIgY2hlY2tCeUlECiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1NQogICAgLy8gY2hlY2soYWRkcmVzczogQWNjb3VudCwgYXNzZXQ6IHVpbnQ2NCk6IHsgdmFsaWQ6IGJvb2xlYW4sIGJhbGFuY2U6IHVpbnQ2NCB9IHsKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnNpZ25VcHNPcGVuW3JvdXRpbmddKCkgLT4gdm9pZDoKc2lnblVwc09wZW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2NwogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyA5IC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2NwogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY3LTEwNjgKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSAmJgogICAgYnogc2lnblVwc09wZW5fYm9vbF9mYWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2OAogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gc2lnbnVwVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U2lnbnVwVGltZXN0YW1wIH0pCiAgICBieXRlYyAyNyAvLyAic2lnbnVwX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY4CiAgICAvLyBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUgJiYKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2Ny0xMDY4CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUgJiYKICAgIGJ6IHNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjkKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMwogICAgLy8gc3RhcnRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFydFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTkgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY5CiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIDwKICAgIGJueiBzaWduVXBzT3Blbl9ib29sX3RydWVANQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGFsbG93TGF0ZVNpZ251cHMgPSBHbG9iYWxTdGF0ZTxib29sZWFuPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWxsb3dMYXRlU2lnbnVwcyB9KQogICAgYnl0ZWMgMTUgLy8gImFsbG93X2xhdGVfc2lnbnVwcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY5CiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IHNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANgoKc2lnblVwc09wZW5fYm9vbF90cnVlQDU6CiAgICBpbnRjXzEgLy8gMQoKc2lnblVwc09wZW5fYm9vbF9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjQKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMyAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANjoKICAgIGludGNfMCAvLyAwCiAgICBiIHNpZ25VcHNPcGVuX2Jvb2xfbWVyZ2VANwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlW3JvdXRpbmddKCkgLT4gdm9pZDoKaXNMaXZlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzQKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZQogICAgYnl0ZWNfMyAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzRW50ZXJlZFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmlzRW50ZXJlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDg0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHVuaXF1ZXMgPSBCb3hNYXA8QWNjb3VudCwgdWludDY0Pih7IGtleVByZWZpeDogUG9vbEdsb2JhbFN0YXRlS2V5VW5pcXVlcyB9KQogICAgcHVzaGJ5dGVzICJ1IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4NgogICAgLy8gcmV0dXJuIHRoaXMudW5pcXVlcyhhZGRyZXNzKS5leGlzdHM7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDg0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5nZXRTdGF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldFN0YXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTIKICAgIC8vIHN0YXR1czogdGhpcy5zdGF0dXMudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDkyCiAgICAvLyBzdGF0dXM6IHRoaXMuc3RhdHVzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDkzCiAgICAvLyB0aXRsZTogdGhpcy50aXRsZS52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBieXRlYyAyNCAvLyAidGl0bGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5MwogICAgLy8gdGl0bGU6IHRoaXMudGl0bGUudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTQKICAgIC8vIHR5cGU6IHRoaXMudHlwZS52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NAogICAgLy8gdHlwZTogdGhpcy50eXBlLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk1CiAgICAvLyBzaWdudXBUaW1lc3RhbXA6IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVNpZ251cFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMjcgLy8gInNpZ251cF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NQogICAgLy8gc2lnbnVwVGltZXN0YW1wOiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NgogICAgLy8gYWxsb3dMYXRlU2lnbnVwczogdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGFsbG93TGF0ZVNpZ251cHMgPSBHbG9iYWxTdGF0ZTxib29sZWFuPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWxsb3dMYXRlU2lnbnVwcyB9KQogICAgYnl0ZWMgMTUgLy8gImFsbG93X2xhdGVfc2lnbnVwcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk2CiAgICAvLyBhbGxvd0xhdGVTaWdudXBzOiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTcKICAgIC8vIHN0YXJ0VGltZXN0YW1wOiB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE5IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NwogICAgLy8gc3RhcnRUaW1lc3RhbXA6IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTgKICAgIC8vIGVuZFRpbWVzdGFtcDogdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBieXRlYyAxNyAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk4CiAgICAvLyBlbmRUaW1lc3RhbXA6IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk5CiAgICAvLyBtYXhFbnRyaWVzOiB0aGlzLm1heEVudHJpZXMudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGJ5dGVjIDE0IC8vICJtYXhfZW50cmllcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk5CiAgICAvLyBtYXhFbnRyaWVzOiB0aGlzLm1heEVudHJpZXMudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMDAKICAgIC8vIGVudHJ5Q291bnQ6ICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEwMAogICAgLy8gZW50cnlDb3VudDogKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEwMQogICAgLy8gcmV3YXJkQ291bnQ6ICh0aGlzLnJld2FyZElELnZhbHVlICsgMSksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzMQogICAgLy8gcmV3YXJkSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlSZXdhcmRDb3VudCB9KQogICAgYnl0ZWMgMjggLy8gInJld2FyZF9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTAxCiAgICAvLyByZXdhcmRDb3VudDogKHRoaXMucmV3YXJkSUQudmFsdWUgKyAxKSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMDIKICAgIC8vIHRvdGFsU3Rha2VkOiB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzMKICAgIC8vIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VG90YWxTdGFrZWQgfSkKICAgIHB1c2hieXRlcyAidG90YWxfc3Rha2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMDIKICAgIC8vIHRvdGFsU3Rha2VkOiB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTAzCiAgICAvLyBzdGFrZUtleTogdGhpcy5zdGFrZUtleS52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBzdGFrZUtleSA9IEdsb2JhbFN0YXRlPFJvb3RLZXk+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFrZUtleSB9KQogICAgYnl0ZWMgMjIgLy8gInN0YWtlX2tleSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTAzCiAgICAvLyBzdGFrZUtleTogdGhpcy5zdGFrZUtleS52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEwNAogICAgLy8gbWluaW11bVN0YWtlQW1vdW50OiB0aGlzLm1pbmltdW1TdGFrZUFtb3VudC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyBtaW5pbXVtU3Rha2VBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNaW5pbXVtU3Rha2VBbW91bnQgfSkKICAgIGJ5dGVjIDI1IC8vICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTA0CiAgICAvLyBtaW5pbXVtU3Rha2VBbW91bnQ6IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTA1CiAgICAvLyBnYXRlSUQ6IHRoaXMuZ2F0ZUlELnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTA1CiAgICAvLyBnYXRlSUQ6IHRoaXMuZ2F0ZUlELnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTA2CiAgICAvLyBjcmVhdG9yOiB0aGlzLmNyZWF0b3IudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTA2CiAgICAvLyBjcmVhdG9yOiB0aGlzLmNyZWF0b3IudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTEtMTEwNwogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgc3RhdHVzOiB0aGlzLnN0YXR1cy52YWx1ZSwKICAgIC8vICAgdGl0bGU6IHRoaXMudGl0bGUudmFsdWUsCiAgICAvLyAgIHR5cGU6IHRoaXMudHlwZS52YWx1ZSwKICAgIC8vICAgc2lnbnVwVGltZXN0YW1wOiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgYWxsb3dMYXRlU2lnbnVwczogdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLAogICAgLy8gICBzdGFydFRpbWVzdGFtcDogdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgZW5kVGltZXN0YW1wOiB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSwKICAgIC8vICAgbWF4RW50cmllczogdGhpcy5tYXhFbnRyaWVzLnZhbHVlLAogICAgLy8gICBlbnRyeUNvdW50OiAodGhpcy5lbnRyeUlELnZhbHVlICsgMSksCiAgICAvLyAgIHJld2FyZENvdW50OiAodGhpcy5yZXdhcmRJRC52YWx1ZSArIDEpLAogICAgLy8gICB0b3RhbFN0YWtlZDogdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIC8vICAgc3Rha2VLZXk6IHRoaXMuc3Rha2VLZXkudmFsdWUsCiAgICAvLyAgIG1pbmltdW1TdGFrZUFtb3VudDogdGhpcy5taW5pbXVtU3Rha2VBbW91bnQudmFsdWUsCiAgICAvLyAgIGdhdGVJRDogdGhpcy5nYXRlSUQudmFsdWUsCiAgICAvLyAgIGNyZWF0b3I6IHRoaXMuY3JlYXRvci52YWx1ZSwKICAgIC8vIH0KICAgIGRpZyAxMwogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciAxNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDE0CiAgICBwdXNoYnl0ZXMgMHgwMDZmCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBsZW4KICAgIHB1c2hpbnQgMTExIC8vIDExMQogICAgKwogICAgc3dhcAogICAgdW5jb3ZlciAxNQogICAgY29uY2F0CiAgICB1bmNvdmVyIDE0CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMTIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWNfMyAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAxNAogICAgc2V0Yml0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMTEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxMAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDkKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciA4CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgNwogICAgaXRvYgogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgY29uY2F0CiAgICB1bmNvdmVyIDQKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODkKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdC51cGRhdGVBa2l0YURBT0VzY3Jvd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPRXNjcm93OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTIxCiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTIyCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE4IC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMjIKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1OQogICAgLy8gYWtpdGFEQU9Fc2Nyb3cgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFFc2Nyb3cgfSkKICAgIGJ5dGVjIDI2IC8vICJha2l0YV9lc2Nyb3ciCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMjMKICAgIC8vIHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUgPSBhcHAKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMjEKICAgIC8vIHVwZGF0ZUFraXRhREFPRXNjcm93KGFwcDogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6VXBncmFkZWFibGVBa2l0YUJhc2VDb250cmFjdC51cGRhdGVbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0NwogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogWydVcGRhdGVBcHBsaWNhdGlvbiddIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYnl0ZWMgMTggLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQzCiAgICAvLyBjb25zdCBbcGx1Z2luQXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1BsdWdpbkFwcExpc3QpKQogICAgYnl0ZWMgMzEgLy8gInBsdWduX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NTAKICAgIC8vIGNvbnN0IHVwZGF0ZVBsdWdpbiA9IGdldFBsdWdpbkFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkudXBkYXRlCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NTEKICAgIC8vIGFzc2VydChHbG9iYWwuY2FsbGVyQXBwbGljYXRpb25JZCA9PT0gdXBkYXRlUGx1Z2luLCBFUlJfSU5WQUxJRF9VUEdSQURFKQogICAgZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uSUQKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBhcHAgdXBncmFkZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjYKICAgIC8vIHZlcnNpb24gPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVZlcnNpb24gfSkKICAgIHB1c2hieXRlcyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjUyCiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSBuZXdWZXJzaW9uCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDcKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VDb250cmFjdC51cGRhdGVBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzcKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzEKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE4IC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM3CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6OkJhc2VTdGFraW5nUG9vbC5tYnJbcm91dGluZ10oKSAtPiB2b2lkOgptYnI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6MTMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czo5CiAgICAvLyByZXR1cm4gTWluUG9vbFJld2FyZHNNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiB3aW5uaW5nVGlja2V0cykKICAgIGludGMgNiAvLyA0MDAKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czoxNS0yMQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgZW50cmllczogUG9vbEVudHJpZXNNQlIsCiAgICAvLyAgIHVuaXF1ZXM6IFBvb2xVbmlxdWVzTUJSLAogICAgLy8gICBlbnRyaWVzQnlBZGRyZXNzOiBQb29sRW50cmllc0J5QWRkcmVzc01CUiwKICAgIC8vICAgcmV3YXJkczogdGhpcy5yZXdhcmRzTWJyKHdpbm5pbmdUaWNrZXRzKSwKICAgIC8vICAgZGlzYnVyc2VtZW50czogUG9vbERpc2J1cnNlbWVudFNNQlIKICAgIC8vIH0KICAgIGl0b2IKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDYyZDQwMDAwMDAwMDAwMDA0OWQ0MDAwMDAwMDAwMDAwNjJkNAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6MjAKICAgIC8vIGRpc2J1cnNlbWVudHM6IFBvb2xEaXNidXJzZW1lbnRTTUJSCiAgICBwdXNoaW50IDYxMDAgLy8gNjEwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjE1LTIxCiAgICAvLyByZXR1cm4gewogICAgLy8gICBlbnRyaWVzOiBQb29sRW50cmllc01CUiwKICAgIC8vICAgdW5pcXVlczogUG9vbFVuaXF1ZXNNQlIsCiAgICAvLyAgIGVudHJpZXNCeUFkZHJlc3M6IFBvb2xFbnRyaWVzQnlBZGRyZXNzTUJSLAogICAgLy8gICByZXdhcmRzOiB0aGlzLnJld2FyZHNNYnIod2lubmluZ1RpY2tldHMpLAogICAgLy8gICBkaXNidXJzZW1lbnRzOiBQb29sRGlzYnVyc2VtZW50U01CUgogICAgLy8gfQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6MTMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuY2hlY2tCeUlEKGlkOiB1aW50NjQpIC0+IGJ5dGVzOgpjaGVja0J5SUQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDczCiAgICAvLyBwcml2YXRlIGNoZWNrQnlJRChpZDogdWludDY0KTogeyB2YWxpZDogYm9vbGVhbiwgYmFsYW5jZTogdWludDY0IH0gewogICAgcHJvdG8gMSAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAyCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3NQogICAgLy8gdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NzUKICAgIC8vIHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSB8fCB0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vIDB4MDAKICAgICE9CiAgICBibnogY2hlY2tCeUlEX2Jvb2xfdHJ1ZUAyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3NQogICAgLy8gdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDcgLy8gMHgwYQogICAgIT0KICAgIGJ6IGNoZWNrQnlJRF9ib29sX2ZhbHNlQDMKCmNoZWNrQnlJRF9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpjaGVja0J5SURfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3NC00NzcKICAgIC8vIGFzc2VydCgKICAgIC8vICAgdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FIHx8IHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFULAogICAgLy8gICBFUlJfSU5WQUxJRF9QT09MX1RZUEVfRk9SX0NIRUNLCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwb29sIHR5cGUgZm9yIGNoZWNrCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDc5CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgYXNzZXQsIHF1YW50aXR5IH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjEKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgMTIgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDc5CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgYXNzZXQsIHF1YW50aXR5IH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIGludGNfMCAvLyAwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBib3hfZXh0cmFjdAogICAgZnJhbWVfYnVyeSAwCiAgICBkaWcgMQogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgYnRvaQogICAgZnJhbWVfYnVyeSAzCiAgICBzd2FwCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4MQogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYnogY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4MgogICAgLy8gcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBiYWxhbmNlOiAwIH0KICAgIGJ5dGVjIDM1IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODUKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX1NPRlQpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDg1CiAgICAvLyBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIGJ6IGNoZWNrQnlJRF9lbHNlX2JvZHlAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODYtNDg5CiAgICAvLyBjb25zdCBjaGVjayA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLnNvZnRDaGVjaz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzLCBhc3NldF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4NwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4NwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4NwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDg2LTQ4OQogICAgLy8gY29uc3QgY2hlY2sgPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5zb2Z0Q2hlY2s+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXRdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDQ4NzE2ZjFhIC8vIG1ldGhvZCAic29mdENoZWNrKGFkZHJlc3MsdWludDY0KShib29sLHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDkgLy8gOQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGJvb2wxLHVpbnQ2NCkKICAgIHB1c2hpbnQgNSAvLyA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDkxCiAgICAvLyBpZiAoY2hlY2suYmFsYW5jZSA+PSBxdWFudGl0eSkgewogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA1CiAgICBmcmFtZV9kaWcgNAogICAgPj0KICAgIGJ6IGNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDkyCiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogY2hlY2suYmFsYW5jZSB9CiAgICBmcmFtZV9kaWcgNQogICAgaXRvYgogICAgYnl0ZWMgMTYgLy8gMHg4MAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTExCiAgICAvLyB0aGlzLmVudHJpZXMoaWQpLnZhbHVlLmRpc3F1YWxpZmllZCA9IHRydWUKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGludGNfMSAvLyAxCiAgICBzZXRiaXQKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTEyCiAgICAvLyByZXR1cm4geyB2YWxpZDogZmFsc2UsIGJhbGFuY2U6IDAgfQogICAgYnl0ZWMgMzUgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjaGVja0J5SURfZWxzZV9ib2R5QDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5NS01MDQKICAgIC8vIGNvbnN0IGluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGFkZHJlc3MsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgLy8gICAgIH0sCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTAxCiAgICAvLyB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICBjYWxsc3ViIHN0YWtpbmdUeXBlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDk5LTUwMgogICAgLy8gewogICAgLy8gICBhc3NldDogYXNzZXQsCiAgICAvLyAgIHR5cGU6IHRoaXMuc3Rha2luZ1R5cGUoKSwKICAgIC8vIH0sCiAgICBmcmFtZV9kaWcgMwogICAgaXRvYgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDk1LTUwNAogICAgLy8gY29uc3QgaW5mbyA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLmdldEluZm8+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgYWRkcmVzcywKICAgIC8vICAgICB7CiAgICAvLyAgICAgICBhc3NldDogYXNzZXQsCiAgICAvLyAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgfSwKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBieXRlYyAzMiAvLyBtZXRob2QgImdldEluZm8oYWRkcmVzcywodWludDY0LHVpbnQ4KSkodWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAodWludDY0LHVpbnQ2NCx1aW50NjQpCiAgICBwdXNoaW50IDQgLy8gNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUwNgogICAgLy8gaWYgKGluZm8uYW1vdW50ID49IHF1YW50aXR5KSB7CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDYKICAgIGZyYW1lX2RpZyA0CiAgICA+PQogICAgYnogY2hlY2tCeUlEX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MDcKICAgIC8vIHJldHVybiB7IHZhbGlkOiB0cnVlLCBiYWxhbmNlOiBpbmZvLmFtb3VudCB9CiAgICBmcmFtZV9kaWcgNgogICAgaXRvYgogICAgYnl0ZWMgMTYgLy8gMHg4MAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2hlY2tCeUlEX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIGNoZWNrQnlJRF9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnN0YWtpbmdUeXBlKCkgLT4gYnl0ZXM6CnN0YWtpbmdUeXBlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUyNQogICAgLy8gYXNzZXJ0KHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSwgJ3Bvb2wgc3Rha2luZyB0eXBlIGlzIG5vdCBzZXQnKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MjUKICAgIC8vIGFzc2VydCh0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX05PTkUsICdwb29sIHN0YWtpbmcgdHlwZSBpcyBub3Qgc2V0JykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgIT0KICAgIGFzc2VydCAvLyBwb29sIHN0YWtpbmcgdHlwZSBpcyBub3Qgc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTI2CiAgICAvLyByZXR1cm4gbmV3IFVpbnQ4KHRoaXMudHlwZS52YWx1ZS5hc1VpbnQ2NCgpIC0gMSkKICAgIGJ0b2kKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgaW50Y18yIC8vIDgKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNyAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGRpc2J1cnNlbWVudElEOiB1aW50NjQsIGFzc2V0OiB1aW50NjQsIGFsbG9jYXRpb25zOiBieXRlcywgc3VtOiB1aW50NjQpIC0+IGJ5dGVzOgpjcmVhdGVSZXdhcmRBbGxvY2F0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NjgtNTczCiAgICAvLyBwcml2YXRlIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKAogICAgLy8gICBkaXNidXJzZW1lbnRJRDogdWludDY0LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSwKICAgIC8vICAgc3VtOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgcHJvdG8gNCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTc1CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTc1CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTc1CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMpCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NDYKICAgIC8vIHJldHVybiAyNF85MDAgKiBhbGxvY2F0aW9ucy5sZW5ndGgKICAgIGZyYW1lX2RpZyAtMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDI0OTAwIC8vIDI0OTAwCiAgICAqCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTc4CiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGZyYW1lX2RpZyAtMwogICAgYm56IGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zX2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTgwLTU5MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCArIHN1bSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBkaXNidXJzZW1lbnRJRCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTg0CiAgICAvLyByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTg1CiAgICAvLyBhbW91bnQ6IG1ickFtb3VudCArIHN1bSwKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTgzLTU4NgogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1ODAtNTkwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4NwogICAgLy8gZGlzYnVyc2VtZW50SUQsCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1ODAtNTkwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDU2NTZhY2Y5IC8vIG1ldGhvZCAiY3JlYXRlVXNlckFsbG9jYXRpb25zKHBheSx1aW50NjQsKGFkZHJlc3MsdWludDY0KVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zX2FmdGVyX2lmX2Vsc2VAMTA6CiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIHJldHN1YgoKY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnNfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTkzLTYwOAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZGlzYnVyc2VtZW50SUQsCiAgICAvLyAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5NwogICAgLy8gcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTk2LTU5OQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MDAtNjA0CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYwMQogICAgLy8gYXNzZXRSZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYwMC02MDQKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vIH0pLAogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5My02MDgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucz4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYwNQogICAgLy8gZGlzYnVyc2VtZW50SUQsCiAgICBmcmFtZV9kaWcgLTQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1OTMtNjA4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBkaXNidXJzZW1lbnRJRCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgzYzYwZGZhMCAvLyBtZXRob2QgImNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucyhwYXksYXhmZXIsdWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zX2FmdGVyX2lmX2Vsc2VAMTAKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZChwYXltZW50OiB1aW50NjQsIHJld2FyZDogYnl0ZXMpIC0+IGJ5dGVzOgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjMKICAgIC8vIGFkZFJld2FyZChwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIHJld2FyZDogUmV3YXJkKTogdm9pZCB7CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjQKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjQKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBGb3JiaWRkZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjUKICAgIC8vIGFzc2VydChyZXdhcmQuYXNzZXQgPT09IDAsIEVSUl9OT1RfQUxHTykKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAhCiAgICBhc3NlcnQgLy8gTXVzdCBiZSBhbiBBbGdvIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjI4CiAgICAvLyB0aGlzLnN0YWtlS2V5LnZhbHVlLmFkZHJlc3MgIT09IEdsb2JhbC56ZXJvQWRkcmVzcyB8fCByZXdhcmQuZGlzdHJpYnV0aW9uICE9PSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBzdGFrZUtleSA9IEdsb2JhbFN0YXRlPFJvb3RLZXk+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFrZUtleSB9KQogICAgYnl0ZWMgMjIgLy8gInN0YWtlX2tleSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MjgKICAgIC8vIHRoaXMuc3Rha2VLZXkudmFsdWUuYWRkcmVzcyAhPT0gR2xvYmFsLnplcm9BZGRyZXNzIHx8IHJld2FyZC5kaXN0cmlidXRpb24gIT09IERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGV4dHJhY3QgMCAzMgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfdHJ1ZUA3CiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOCAxCiAgICBieXRlYyA3IC8vIDB4MGEKICAgICE9CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX2ZhbHNlQDgKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfdHJ1ZUA3OgogICAgaW50Y18xIC8vIDEKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MjctNjMwCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHRoaXMuc3Rha2VLZXkudmFsdWUuYWRkcmVzcyAhPT0gR2xvYmFsLnplcm9BZGRyZXNzIHx8IHJld2FyZC5kaXN0cmlidXRpb24gIT09IERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlLAogICAgLy8gICBFUlJfU1RBS0VfS0VZX1JFUVVJUkVECiAgICAvLyApCiAgICBhc3NlcnQgLy8gU3Rha2Uga2V5IHJlcXVpcmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjMzCiAgICAvLyBpZiAocmV3YXJkLmRpc3RyaWJ1dGlvbiA9PT0gRGlzdHJpYnV0aW9uVHlwZVNodWZmbGUpIHsKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCA4IDEKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBwdXNoYnl0ZXMgMHgyOAogICAgPT0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MzQKICAgIC8vIGFzc2VydChyZXdhcmQucmF0ZSA+IHJld2FyZC53aW5uZXJDb3VudCAmJiByZXdhcmQud2lubmVyQ291bnQgPD0gV2lubmVyQ291bnRDYXAsIEVSUl9SQVRFX01VU1RfQkVfR1JFQVRFUl9USEFOX1dJTk5FUl9DT1VOVCkKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA5IC8vIDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgNDkgLy8gNDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgPgogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUAxMwogICAgZnJhbWVfZGlnIDEKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgIDw9CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX2ZhbHNlQDEzCiAgICBpbnRjXzEgLy8gMQoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9tZXJnZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MzQKICAgIC8vIGFzc2VydChyZXdhcmQucmF0ZSA+IHJld2FyZC53aW5uZXJDb3VudCAmJiByZXdhcmQud2lubmVyQ291bnQgPD0gV2lubmVyQ291bnRDYXAsIEVSUl9SQVRFX01VU1RfQkVfR1JFQVRFUl9USEFOX1dJTk5FUl9DT1VOVCkKICAgIGFzc2VydCAvLyBSYXRlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHdpbm5lciBjb3VudAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MzgKICAgIC8vIGlmIChyZXdhcmQuZGlzdHJpYnV0aW9uID09PSBEaXN0cmlidXRpb25UeXBlRXZlbikgewogICAgZnJhbWVfZGlnIDAKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9hZnRlcl9pZl9lbHNlQDIxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM5CiAgICAvLyBhc3NlcnQodGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwIHx8IHRoaXMubWF4RW50cmllcy52YWx1ZSA8PSByZXdhcmQucmF0ZSwgRVJSX01BWF9FTlRSSUVTX0NBTk5PVF9CRV9HUkVBVEVSX1RIQU5fUkFURSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI3CiAgICAvLyBtYXhFbnRyaWVzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWF4RW50cmllcyB9KQogICAgYnl0ZWMgMTQgLy8gIm1heF9lbnRyaWVzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYzOQogICAgLy8gYXNzZXJ0KHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCB8fCB0aGlzLm1heEVudHJpZXMudmFsdWUgPD0gcmV3YXJkLnJhdGUsIEVSUl9NQVhfRU5UUklFU19DQU5OT1RfQkVfR1JFQVRFUl9USEFOX1JBVEUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF90cnVlQDE4CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGJ5dGVjIDE0IC8vICJtYXhfZW50cmllcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MzkKICAgIC8vIGFzc2VydCh0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAgfHwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIDw9IHJld2FyZC5yYXRlLCBFUlJfTUFYX0VOVFJJRVNfQ0FOTk9UX0JFX0dSRUFURVJfVEhBTl9SQVRFKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA5IC8vIDkKICAgIGV4dHJhY3RfdWludDY0CiAgICA8PQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUAxOQoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF90cnVlQDE4OgogICAgaW50Y18xIC8vIDEKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM5CiAgICAvLyBhc3NlcnQodGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwIHx8IHRoaXMubWF4RW50cmllcy52YWx1ZSA8PSByZXdhcmQucmF0ZSwgRVJSX01BWF9FTlRSSUVTX0NBTk5PVF9CRV9HUkVBVEVSX1RIQU5fUkFURSkKICAgIGFzc2VydCAvLyBNYXggZW50cmllcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHJhdGUKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2FmdGVyX2lmX2Vsc2VAMjE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjQyCiAgICAvLyBhc3NlcnQocmV3YXJkLnJhdGUgPiAwLCBFUlJfUkFURV9NVVNUX0JFX0dSRUFURVJfVEhBTl9aRVJPKQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDkgLy8gOQogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2VydCAvLyBSYXRlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjktNzc4CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuRXE6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzcyCiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc2OS03NzgKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW5FcTogdGhpcy5yZXdhcmRzTWJyKHJld2FyZC53aW5uZXJDb3VudCkKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc3NAogICAgLy8gZ3JlYXRlclRoYW5FcTogdGhpcy5yZXdhcmRzTWJyKHJld2FyZC53aW5uZXJDb3VudCkKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA0OSAvLyA0OQogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czo5CiAgICAvLyByZXR1cm4gTWluUG9vbFJld2FyZHNNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiB3aW5uaW5nVGlja2V0cykKICAgIGludGMgNiAvLyA0MDAKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjktNzc4CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuRXE6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA+PQogICAgJiYKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODEKICAgIC8vIGNvbnN0IGlkID0gdGhpcy5yZXdhcmRJRC52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzEKICAgIC8vIHJld2FyZElEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5UmV3YXJkQ291bnQgfSkKICAgIGJ5dGVjIDI4IC8vICJyZXdhcmRfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgxCiAgICAvLyBjb25zdCBpZCA9IHRoaXMucmV3YXJkSUQudmFsdWUKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyB0aGlzLnJld2FyZElELnZhbHVlICs9IDEKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzEKICAgIC8vIHJld2FyZElEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5UmV3YXJkQ291bnQgfSkKICAgIGJ5dGVjIDI4IC8vICJyZXdhcmRfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyB0aGlzLnJld2FyZElELnZhbHVlICs9IDEKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzgxCiAgICAvLyB0aGlzLnJld2FyZHMoaWQpLnZhbHVlID0gY2xvbmUocmV3YXJkKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2NwogICAgLy8gcmV3YXJkcyA9IEJveE1hcDx1aW50NjQsIFJld2FyZD4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhSZXdhcmRzIH0pCiAgICBieXRlYyAyMCAvLyAiciIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4MQogICAgLy8gdGhpcy5yZXdhcmRzKGlkKS52YWx1ZSA9IGNsb25lKHJld2FyZCkKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9wdXQKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfZmFsc2VAMTk6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX21lcmdlQDIwCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX2ZhbHNlQDEzOgogICAgaW50Y18wIC8vIDAKICAgIGIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9tZXJnZUAxNAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUA4OgogICAgaW50Y18wIC8vIDAKICAgIGIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9tZXJnZUA5CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGUocmV3YXJkSUQ6IHVpbnQ2NCkgLT4gdm9pZDoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU1CiAgICAvLyByYWZmbGUocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAzCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gNwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1NgogICAgLy8gYXNzZXJ0KHRoaXMucmV3YXJkcyhyZXdhcmRJRCkuZXhpc3RzLCAncmV3YXJkIGRvZXMgbm90IGV4aXN0JykKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2NwogICAgLy8gcmV3YXJkcyA9IEJveE1hcDx1aW50NjQsIFJld2FyZD4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhSZXdhcmRzIH0pCiAgICBieXRlYyAyMCAvLyAiciIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU2CiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRzKHJld2FyZElEKS5leGlzdHMsICdyZXdhcmQgZG9lcyBub3QgZXhpc3QnKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gcmV3YXJkIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTYzCiAgICAvLyB9ID0gY2xvbmUodGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZSkKICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBkaWcgMQogICAgcHVzaGludCAxMDggLy8gMTA4CiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyAyCiAgICBwdXNoaW50IDgzIC8vIDgzCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyAzCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjUKICAgIC8vIGFzc2VydChwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uLCBFUlJfSU5WQUxJRF9ESVNCVVJTRU1FTlRfUEhBU0UpCiAgICB1bmNvdmVyIDIKICAgIGJ5dGVjIDExIC8vIDB4MTQKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBkaXNidXJzZW1lbnQgcGhhc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjYKICAgIC8vIGFzc2VydCh3aW5uaW5nVGlja2V0cy5sZW5ndGggPT09IDAsIEVSUl9XSU5OSU5HX1RJQ0tFVFNfQUxSRUFEWV9FWElTVCkKICAgIHVuY292ZXIgMgogICAgcHVzaGludHMgMTI0IDIgLy8gMTI0LCAyCiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgIQogICAgYXNzZXJ0IC8vIFdpbm5pbmcgdGlja2V0cyBhbHJlYWR5IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTY4CiAgICAvLyBjb25zdCByb3VuZFRvVXNlOiB1aW50NjQgPSBhY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ICsgMSArICg0ICogdnJmRmFpbHVyZUNvdW50KQogICAgc3dhcAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIHB1c2hpbnQgNCAvLyA0CiAgICB1bmNvdmVyIDIKICAgICoKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NzAtOTczCiAgICAvLyBjb25zdCBzZWVkID0gYWJpQ2FsbDx0eXBlb2YgUmFuZG9tbmVzc0JlYWNvbi5wcm90b3R5cGUuZ2V0Pih7CiAgICAvLyAgIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICAvLyAgIGFyZ3M6IFtyb3VuZFRvVXNlLCB0aGlzLnNhbHQudmFsdWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NzEKICAgIC8vIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDgKICAgIC8vIGNvbnN0IFtvdGhlckFwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNPdGhlckFwcExpc3QpKQogICAgYnl0ZWMgMjkgLy8gIm90aGVyX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3MQogICAgLy8gYXBwSWQ6IGdldE90aGVyQXBwTGlzdChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQpLnZyZkJlYWNvbiwKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3MgogICAgLy8gYXJnczogW3JvdW5kVG9Vc2UsIHRoaXMuc2FsdC52YWx1ZV0sCiAgICBzd2FwCiAgICBpdG9iCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NgogICAgLy8gc2FsdCA9IEdsb2JhbFN0YXRlPGJ5dGVzPDMyPj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVNhbHQgfSkKICAgIGJ5dGVjIDMwIC8vICJzYWx0IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3MgogICAgLy8gYXJnczogW3JvdW5kVG9Vc2UsIHRoaXMuc2FsdC52YWx1ZV0sCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NzAtOTczCiAgICAvLyBjb25zdCBzZWVkID0gYWJpQ2FsbDx0eXBlb2YgUmFuZG9tbmVzc0JlYWNvbi5wcm90b3R5cGUuZ2V0Pih7CiAgICAvLyAgIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICAvLyAgIGFyZ3M6IFtyb3VuZFRvVXNlLCB0aGlzLnNhbHQudmFsdWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDE4OTM5MmM1IC8vIG1ldGhvZCAiZ2V0KHVpbnQ2NCxieXRlW10pYnl0ZVtdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBkaWcgMQogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFtdKQogICAgZXh0cmFjdCA2IDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3NQogICAgLy8gaWYgKHNlZWQubGVuZ3RoID09PSAwKSB7CiAgICBsZW4KICAgIGR1cAogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3NgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS52cmZGYWlsdXJlQ291bnQgKz0gMQogICAgZnJhbWVfZGlnIDEyCiAgICBkdXAKICAgIHB1c2hpbnQgODMgLy8gODMKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIHB1c2hpbnQgODMgLy8gODMKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTc3CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4MQogICAgLy8gY29uc3Qgcm5nU3RhdGUgPSBwY2c2NEluaXQoc2VlZC5zbGljZSgwLCAxNikpCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDE1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgID49CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBkaWcgMgogICAgPj0KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIGZyYW1lX2RpZyAxNAogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxNgogICAgLy8gYXNzZXJ0KHNlZWQubGVuZ3RoID09PSAxNikKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjE5CiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDApLCBwY2dGaXJzdEluY3JlbWVudCksCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo5MgogICAgLy8gY29uc3Qgc3RhdGUgPSBfX3BjZzMyU3RlcCgwLCBpbmNyKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTcKICAgIC8vIGNvbnN0IFssIG11bExvd10gPSBvcC5tdWx3KHN0YXRlLCBwY2dNdWx0aXBsaWVyKQogICAgaW50YyA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIG11bHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjE5CiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDApLCBwY2dGaXJzdEluY3JlbWVudCksCiAgICBpbnRjIDcgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjkzCiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhzdGF0ZSwgaW5pdGlhbFN0YXRlKQogICAgdW5jb3ZlciAyCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTcKICAgIC8vIGNvbnN0IFssIG11bExvd10gPSBvcC5tdWx3KHN0YXRlLCBwY2dNdWx0aXBsaWVyKQogICAgaW50YyA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIG11bHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxOQogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCAwKSwgcGNnRmlyc3RJbmNyZW1lbnQpLAogICAgaW50YyA3IC8vIDE0NDI2OTUwNDA4ODg5NjM0MDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGFkZHcKICAgIGNvdmVyIDIKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoyMAogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCA4KSwgcGNnU2Vjb25kSW5jcmVtZW50KSwKICAgIHVuY292ZXIgMgogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjIwCiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDgpLCBwY2dTZWNvbmRJbmNyZW1lbnQpLAogICAgaW50YyA4IC8vIDE0NDI2OTUwNDA4ODg5NjM0MDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo5MwogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcoc3RhdGUsIGluaXRpYWxTdGF0ZSkKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxNwogICAgLy8gY29uc3QgWywgbXVsTG93XSA9IG9wLm11bHcoc3RhdGUsIHBjZ011bHRpcGxpZXIpCiAgICBpbnRjIDUgLy8gNjM2NDEzNjIyMzg0Njc5MzAwNQogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjIwCiAgICAvLyBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDgpLCBwY2dTZWNvbmRJbmNyZW1lbnQpLAogICAgaW50YyA4IC8vIDE0NDI2OTUwNDA4ODg5NjM0MDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxOC0yMQogICAgLy8gcmV0dXJuIFsKICAgIC8vICAgICBfX3BjZzMySW5pdChvcC5leHRyYWN0VWludDY0KHNlZWQsIDApLCBwY2dGaXJzdEluY3JlbWVudCksCiAgICAvLyAgICAgX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCA4KSwgcGNnU2Vjb25kSW5jcmVtZW50KSwKICAgIC8vIF0KICAgIHN3YXAKICAgIGl0b2IKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTg1CiAgICAvLyBpZiAodXBwZXJCb3VuZCA8IE1BWF9VSU5UNjQpIHsKICAgIGZyYW1lX2RpZyAxMwogICAgaW50YyAxMCAvLyAxODQ0Njc0NDA3MzcwOTU1MTYxNQogICAgPAogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2lmX2JvZHlANAogICAgZnJhbWVfZGlnIDEzCiAgICBmcmFtZV9idXJ5IDExCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjMwCiAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgRHluYW1pY0FycmF5PGFyYzQuVWludDY0PigpCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgZnJhbWVfYnVyeSAwCiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjQyCiAgICAvLyBpZiAodXBwZXJCb3VuZCAhPT0gMCkgewogICAgZnJhbWVfZGlnIDExCiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9lbHNlX2JvZHlAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NDMKICAgIC8vIGFzc2VydCh1cHBlckJvdW5kID4gMSkKICAgIGZyYW1lX2RpZyAxMQogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgPgogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjQ0CiAgICAvLyBhc3NlcnQobG93ZXJCb3VuZCA8IHVwcGVyQm91bmQgLSAxKQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZnJhbWVfYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTg5CiAgICAvLyBjb25zdCBybmdSZXN1bHQgPSBwY2c2NFJhbmRvbShybmdTdGF0ZSwgMSwgdXBwZXJCb3VuZCwgTWF4R2xvYmFsU3RhdGVVaW50NjRBcnJheSkKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjQ0CiAgICAvLyBhc3NlcnQobG93ZXJCb3VuZCA8IHVwcGVyQm91bmQgLSAxKQogICAgPgogICAgYXNzZXJ0CgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyh+dmFsdWUsIDEpCiAgICBmcmFtZV9kaWcgNAogICAgZHVwCiAgICB+CiAgICBpbnRjXzEgLy8gMQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjUzCiAgICAvLyBjb25zdCB0aHJlc2hvbGQ6IHVpbnQ2NCA9IF9fdWludDY0VHdvcyhhYnNvbHV0ZUJvdW5kKSAlIGFic29sdXRlQm91bmQKICAgIHN3YXAKICAgICUKICAgIGZyYW1lX2J1cnkgMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTUKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNwogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2J1cnkgMwoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfd2hpbGVfdG9wQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1NQogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBmcmFtZV9kaWcgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4OQogICAgLy8gY29uc3Qgcm5nUmVzdWx0ID0gcGNnNjRSYW5kb20ocm5nU3RhdGUsIDEsIHVwcGVyQm91bmQsIE1heEdsb2JhbFN0YXRlVWludDY0QXJyYXkpCiAgICBwdXNoaW50IDE1IC8vIDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIDwKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX3doaWxlQDIyCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV93aGlsZV90b3BAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjkKICAgIC8vIGNvbnN0IG5ld1N0YXRlMSA9IF9fcGNnMzJTdGVwKHN0YXRlWzBdLCBwY2dGaXJzdEluY3JlbWVudCkKICAgIGZyYW1lX2RpZyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTcKICAgIC8vIGNvbnN0IFssIG11bExvd10gPSBvcC5tdWx3KHN0YXRlLCBwY2dNdWx0aXBsaWVyKQogICAgaW50YyA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIG11bHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo5CiAgICAvLyBjb25zdCBuZXdTdGF0ZTEgPSBfX3BjZzMyU3RlcChzdGF0ZVswXSwgcGNnRmlyc3RJbmNyZW1lbnQpCiAgICBpbnRjIDcgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgYWRkdwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9idXJ5IDUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxMAogICAgLy8gY29uc3QgbmV3U3RhdGUyID0gX19wY2czMlN0ZXAoc3RhdGVbMV0sIG5ld1N0YXRlMSA9PT0gMCA/IG9wLnNobChwY2dTZWNvbmRJbmNyZW1lbnQsIDEpIDogcGNnU2Vjb25kSW5jcmVtZW50KQogICAgc3dhcAogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDgKICAgIGJueiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV90ZXJuYXJ5X2ZhbHNlQDI2CiAgICBwdXNoaW50IDI4ODUzOTAwODE3Nzc5MjY4MTggLy8gMjg4NTM5MDA4MTc3NzkyNjgxOAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfdGVybmFyeV9tZXJnZUAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTcKICAgIC8vIGNvbnN0IFssIG11bExvd10gPSBvcC5tdWx3KHN0YXRlLCBwY2dNdWx0aXBsaWVyKQogICAgZnJhbWVfZGlnIDgKICAgIGR1cAogICAgaW50YyA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIG11bHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgdW5jb3ZlciAyCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTIKICAgIC8vIHJldHVybiBbW25ld1N0YXRlMSwgbmV3U3RhdGUyXSwgb3Auc2hsKF9fcGNnMzJPdXRwdXQoc3RhdGVbMF0pLCAzMikgfCBfX3BjZzMyT3V0cHV0KHN0YXRlWzFdKV0KICAgIGZyYW1lX2RpZyA1CiAgICBpdG9iCiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyA5CiAgICBjYWxsc3ViIF9fcGNnMzJPdXRwdXQKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIHNobAogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIF9fcGNnMzJPdXRwdXQKICAgIHwKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1NwogICAgLy8gY29uc3QgW25ld1N0YXRlLCBjYW5kaWRhdGVdID0gX19wY2c2NFVuYm91bmRlZFJhbmRvbShzdGF0ZSkKICAgIGR1cAogICAgZXh0cmFjdCAwIDE2CiAgICBzd2FwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTkKICAgIC8vIGlmIChjYW5kaWRhdGUgPj0gdGhyZXNob2xkKSB7CiAgICBmcmFtZV9kaWcgMTAKICAgID49CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjYwCiAgICAvLyByZXN1bHQucHVzaChuZXcgYXJjNC5VaW50NjQoKGNhbmRpZGF0ZSAlIGFic29sdXRlQm91bmQpICsgbG93ZXJCb3VuZCkpCiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDQKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5ODkKICAgIC8vIGNvbnN0IHJuZ1Jlc3VsdCA9IHBjZzY0UmFuZG9tKHJuZ1N0YXRlLCAxLCB1cHBlckJvdW5kLCBNYXhHbG9iYWxTdGF0ZVVpbnQ2NEFycmF5KQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NjAKICAgIC8vIHJlc3VsdC5wdXNoKG5ldyBhcmM0LlVpbnQ2NCgoY2FuZGlkYXRlICUgYWJzb2x1dGVCb3VuZCkgKyBsb3dlckJvdW5kKSkKICAgICsKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA3CiAgICBmcmFtZV9idXJ5IDMKICAgIGIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfd2hpbGVfdG9wQDE2CgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDIwOgogICAgZnJhbWVfYnVyeSAzCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3doaWxlX3RvcEAxOAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfdGVybmFyeV9mYWxzZUAyNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTAKICAgIC8vIGNvbnN0IG5ld1N0YXRlMiA9IF9fcGNnMzJTdGVwKHN0YXRlWzFdLCBuZXdTdGF0ZTEgPT09IDAgPyBvcC5zaGwocGNnU2Vjb25kSW5jcmVtZW50LCAxKSA6IHBjZ1NlY29uZEluY3JlbWVudCkKICAgIGludGMgOCAvLyAxNDQyNjk1MDQwODg4OTYzNDA5CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3Rlcm5hcnlfbWVyZ2VAMjcKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX3doaWxlQDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo2NwogICAgLy8gcmV0dXJuIFtzdGF0ZSwgcmVzdWx0XQogICAgZnJhbWVfZGlnIDMKICAgIHB1c2hieXRlcyAweDAwMTIKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5MQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS53aW5uaW5nVGlja2V0cyA9IGRlY29kZUFyYzQ8dWludDY0W10+KHJuZ1Jlc3VsdFsxXS5ieXRlcykKICAgIGR1cAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICBsZW4KICAgIHN1YnN0cmluZzMKICAgIGZyYW1lX2RpZyAxMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDU3IC8vIDU3CiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIGV4dHJhY3QzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGRpZyAxCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTkyCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnZyZkZhaWx1cmVDb3VudCA9IDAKICAgIHB1c2hpbnQgODMgLy8gODMKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfcmVwbGFjZQogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9lbHNlX2JvZHlAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjUwCiAgICAvLyBhYnNvbHV0ZUJvdW5kID0gb3AuYnRvaShCeXRlcyhCaWdVaW50KDIgKiogNjQpIC0gQmlnVWludChsb3dlckJvdW5kKSkpCiAgICBpbnRjIDEwIC8vIDE4NDQ2NzQ0MDczNzA5NTUxNjE1CiAgICBmcmFtZV9idXJ5IDQKICAgIGIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUAxNQoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfaWZfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4NgogICAgLy8gdXBwZXJCb3VuZCArPSAxCiAgICBmcmFtZV9kaWcgMTMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDExCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX2lmX2Vsc2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlKCkgLT4gdWludDY0OgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDc3CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDc3CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMyAvLyAweDAwCiAgICAhPQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzctMTA3OAogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlX2Jvb2xfZmFsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzgKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMwogICAgLy8gc3RhcnRUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFydFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTkgLy8gInN0YXJ0X3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDc4CiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlKSAmJgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3Ny0xMDc4CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlKSAmJgogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmVfYm9vbF9mYWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3OQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBieXRlYyAxNyAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDc5CiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8PSB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSA9PT0gMCkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA8PQogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlX2Jvb2xfdHJ1ZUA0CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBieXRlYyAxNyAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDc5CiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8PSB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSA9PT0gMCkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBibnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmVfYm9vbF9mYWxzZUA1CgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZV9ib29sX3RydWVANDoKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3Ni0xMDgwCiAgICAvLyByZXR1cm4gKAogICAgLy8gICB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICAvLyAgIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDw9IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID09PSAwKQogICAgLy8gKQogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZV9ib29sX2ZhbHNlQDU6CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzYtMTA4MAogICAgLy8gcmV0dXJuICgKICAgIC8vICAgdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gICAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlKSAmJgogICAgLy8gICAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8PSB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSA9PT0gMCkKICAgIC8vICkKICAgIHJldHN1Ygo=","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CyALAAEIXKCNBq3+1eTUhf2oWJADz4Keu+/v3oIU0YKeu+/v3oIU/////w////////////8BJiQEFR98dQtlbnRyeV9jb3VudAlha2l0YV9kYW8BAAhha2l0YV9hbAR0eXBlAgAAAQoHZ2F0ZV9pZAZzdGF0dXMHY3JlYXRvcgEUAWUBHgttYXhfZW50cmllcxJhbGxvd19sYXRlX3NpZ251cHMBgA1lbmRfdGltZXN0YW1wBndhbGxldA9zdGFydF90aW1lc3RhbXABchRha2l0YV9yb3lhbHR5X2Ftb3VudAlzdGFrZV9rZXkNYWtpdGFfcm95YWx0eQV0aXRsZRRtaW5pbXVtX3N0YWtlX2Ftb3VudAxha2l0YV9lc2Nyb3cQc2lnbnVwX3RpbWVzdGFtcAxyZXdhcmRfY291bnQIb3RoZXJfYWwEc2FsdAhwbHVnbl9hbATJBogJEmNvbnRyb2xsZWRfYWRkcmVzcxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAggIEq4shOgTqkYDdNhoAjgIAsgCmMRkURDEYQQCPghMEg/FHSAQ5Tq6yBGRae8wEDy/DEgQYHoKRBGhVjHAEqUGNNwT8aZyzBG52ssoEzbCsagSyI9NdBFku40EEj6ShYATjN3NCBHFwRkkEHq0gqQQz6SyUBIVN7eAEpLPniTYaAI4TAi8CxAQPBCIEWAUIByIIMghAD48QBxAsEGQQchCOEUARmQABEbYAI0OABHd+w+U2GgCOAQDbADEZgQQSMRgQREIRQTEZgQUSMRgQREICXIoCAYv+Jx1lSIEYW7GABDwabzOyGov/shqyGIEGshAisgGztD5JVwQASwFXAAQoEkRJIlmBAghMFRJEVwYASRVJQQAHiwEkE0EABCKMAImLABdC//eKBAKxi/wnBGVIgShbi/4WgAQgD3QhshqL/bIashqL/7IashiBBrIQIrIBs7Q+SVcEAExXAAQoEkRJFSMSRCJTi/+JigEBi/+BEpGL/xuBG5EhCRqL/4E7kUqRTBwjHkUBgR8aTwJMkCEJGhmJgABJNhoBSSJZgQIISwEVEkRXAgA2GgJJFSMSRDYaA0kVgSASRDYaBEkVgSgSRDYaBUkVgSASRDYaBjYaB0kVJBJEFzYaCEkVJBJEFzYaCUkVJBJEFzYaCkkVJBJEFzYaC0kVJBJEFycJK2cnGE8LZycFTwpnJwpPCWeABmZ1bmRlck8IZ4ALbWFya2V0cGxhY2VPB2cnFk8GZycZTwVnJwhPBGcnDk8DZyceMRdnKk8CZycaTGcnDyJnIiplREmADHN0YWtpbmdfZmVlc2VITCcEZUgiTIFoW0EAOyIqZUQiJwplRLFMJwRlSIFoW4AE1XS7ELIashiyGoEGshAisgGztD5JVwQATFcABCgSREkVJBJEF0UBSwFJJFtFBIEQW0UESSMNQQAXSSMJSwRJSwUJTwILgegHCgknF0xnI0MjQv/oMg4yCRJEIicIZURBAEaxIiplRCcEZUiBKFsiJwhlRBaABN9WsB6yGrIashiBBrIQIrIBs7Q+SVcEAExXAAQoEkRJFSQSRBeACWdhdGVfc2l6ZUxnI0M2GgFJFYEgEkQxADIJEkQiJwplRBJEIicJZUQrEkAACzIHIicRZUQNQQAQI0SxMgmyCSOyECKyAbMjQyJC/+0xFiMJSTgQIxJENhoBSRUkEkQXMQAiJwplRBJEMgNLAXAARQEUMhAjgQRPA00LSwI4BzIKEk8DOAhPAoHAPggSEESxMgpLAbIRIrISshSBBLIQIrIBsyIqZURJJxJlSExJJx9lSElXCAhMJFtPAicSZUixgASiQD3fshqAEwABAAIADXN0YWtpbmdfcG9vbHOyGrIYgQayECKyAbO0PklXBABLAVcABCgSREkiWYEJC4ECCEwVEkRXBgkiW0lEIicaZURMSwESRLGABFgv84KyGk8CshonELIagA8ADXN0YWtpbmdfcG9vbHOyGicGshonBrIaSwKyGIEGshAisgG2cghEMhCyCLIHI7IQIrIBtksBFk8DFoACAAFMUIAEaDXjvLIaTLIaJxCyGrIashiBBrIQIrIBtoAEbMP2BrIashiBBrIQIrIBsyNDMRYjCUk4ECMSRDYaAYgPjUgjQzEWgQIJSTgQIxJEMRYjCUk4EIEEEkQ2GgFLATgUMgoSSwI4EUsCIlsSEE8COBIQRIgPV0gjQzYaAUkVJBJEF0k2GgJJFSQSRBdMNhoDSRUkEkQXTDEAIicKZUQSRCInCWVEKxJEQAAJSwFAAAQnDyNnSwIyBw1AAA1LAkAAZCInD2VEQQBcI0RLAUEACEsBMgcNQQBJI0RLAUAAE0sCQAA5IicPZURBADEjRDIHRQJJQQALSwGBCghLAQxBABgjRCcbSwNnJxNLAmcnEUsBZycJJwdnI0MiQv/lIkL/zCJC/7QiQv+hIkcDgABHBDEWIwlJOBAjEkQ2GgE2GgKIEWNEIicIZURBACUyCDEAiPr3SUUFMQBFCkAB3UsIMggiJwhlRExOAksDiPsxRQJEIillRCMIIicOZUQMQAAIIicOZURAAa4jREsBIllJRQmBqIsDC4ABdTEAUL1FAUAABYHUkwEISwNJOAcyChJMOAhPAhIQRCInFmVESVcAIEUNSYEgWUsBFVJFCyJFBksFSwgMQQFdSwFXAgBLBklOAoECC0sBTFlPAiMISUUJSwpLAQlLAxVPAoECC0sETFlPAk1SSUULJFtJRQYiJxllRA9ESwsyAxNBAFuxIiplRCcEZUiBSFtLCklXAAgBAUsBgRBZSwIVTwNOAlIjFoAEK/PMWrIaSw+yGksOshpPArIaTLIashqyGIEGshAisgGztD5JVwQATFcABCgSREkVIxJEIlNEIicFZUQnBxJAAAsiJwVlRCcLEkEAGDEASwoiW3AATEUIQQCWSwZLBQ9BAI4jRLEiKmVEJwRlSCJbMQCIDG1LDFcACElPAlAnILIaTwKyGrIaTLIYgQayECKyAbO0PklXBABLAVcABCgSRBWBGBJEgQRbSwZJTgIPRCIpZURJIwgpTGcxAEsDUE8CFlCAAwAzAFBLA1BMFicMSwFQSbxITwK/MQBPAlBJVwAgTFcgCFCAAWFMUEy/Qv6fIkL/byNDIkL+T0sDJyFlSEL+HDYaAUkVJBJEF4gPV0QWJxRMUEcCvUUBREmBWyO6SwGBGSS6F0sCgXQkuhdOA08CgREkuhdOAkwrEkQyB0kiJxNlRAlPAhgJSTIHE0EAvksCSwEMQQC2I0QiJxhlRIAKIC0gUmV3YXJkc1AyB0lLBAgyCCcEZUgkW0sDFSEGSwELgeSTAghLAnIIRLGyB7III7IQIrIBthZXBgJPBFBPAxZPAxYiFoAEHJ6727IaTwOyGk8CshpMshonBrIaTLIYgQayECKyAbO3AT5JVwQATFcABCgSREkVJBJESwVJgSFLBLtJgSlLBLtJgVsnB7tJJU8Eu0mBZE8DuzIGFksBgWxPArsyBxaBdEy7I0MiQv9HNhoBSRUkEkQXiAwsI0MiRweAAEcZNhoBSRUkEkQXSTYaAkkVJBJEF0wWJxRMUEcCvUUBREmBWyO6SU8CJCO6TCcHEklAAAhLAicLEkEHCiNESUECIksDSSUkuhdJTgJFFkkkI7pFBEmBCSS6F0UPIiS6F0UcIkUaIkUKSwUIIillRA1BAAkiKWVESxQJRQVLE0URSxBLBQxBARhLEBYnDExQSUUjSb5ESwGBMiO6IlNLAiKBILpFK0sBgTBZSwIVTwNOAlJFI0yBKCS6F0UPQABdIicFZUQrEkEAdYAJgAAAAAAAAAAAIlNBAEMiJwhlREEARDIISyiI9vxJRQlAAEdLJzIIIicIZURMTgJLI4j3OkhAACIiJwVlRCcHE0EADkshSYEyI7oiI1SBMky7SxAjCEURQv9bSxgjCEUZSwhLDghFCUL/50sHJyFlSEL/siInBWVEJwcSQQBPSyFJIoEgukyBICS6sSIqZUQnBGVIIluABMb9DKWyGk8CshpMshonELIashiBBrIQIrIBs7Q+SVcEAExXAAQoEkRJFSQSRBcWJxBMUEL/PEsQiAgIQv80SwNJgSEkuhdLGggWSwGBIU8Cu0mBKSS6F0sKCBaBKUy7IillREsUEkEAiEsDSYFbJwu7IhZLASVPAruBISS6F0UPSwEnCxJBAFRLDksNCyInF2VESSEEDkQdIQSXRRwnFUscZ0saQAASsTIDSxyyCLIHI7IQIrIBsyNDMgNLG0lOAnAARQFEsTIDTLIRSxyyErIUgQSyECKyAbNC/9siJxdlREkhBA5ESw0dIQSXRRxC/6xLA0klJLoXSwYIFiVMu0L/tUsBJwcSQQD8SwNJIiS6F0UcSSUkuhdJTgJFFkmBZCS6F0UiSYEpJLoXRRKBCSS6F0UdSwUIIillRA1BAAkiKWVESxQJRQUiJxVlREscTAlFHyIWRScnBkUjIkULSxNFEUsQSwUMQQBjSxAWJwxMUEmBMiO6IlNLAYEoJLoXRRBMIoEgukUpQAA5Sw1JSxFJTgMMRCEEHU8Cl0khBA5ESx8dIQSXSRZLKUxQSyRJTwJQTCJZIwgWVwYCXABFJEsLCEULSxAjCEURQv+VSwNJJSS6F0sGSU4DCBYlTLtLIEscSyVLDogHhkgiKWVESxVPAggSQf7ASwNJgVsnDbslSyi7Qv6xSwEnCxJBAPFLA0mBZCS6F0UhSSUkuhdJTgJFFkmBISS6F0sBgQkkuhdPAiIkuhdJTgNFH0xLAQsiJxVlRAkiJxdlREkhBA5ESwIdIQSXTwJMCUUgMgpPAnAASA5ESwUIIillRA1BAAkiKWVESxQJRQUiFkUmJwZFIyJFC0sTRRFLEEsFDEEAQUsQFicMTFBJgTIjuiJTTCKBILpFKUAAIEscSRZLKUxQSyRJTwJQTCJZIwgWVwYCXABFJEsLCEULSxAjCEURQv+3SxNLBQhJFksFJU8Cu0sgSxxLJUsOiAaISCIpZUQSQf3HSwNJgVsnDbslSye7Qv24SwEnDRJBAN5LA0mBZCS6F0UhSSUkuhdJTgJFFkmBISS6F0URSSIkuhdJTgJFHoEJJLoXSU4CRQ4yCkxwAEgiJxVlRE8CTAlJRSEPREsFCCIpZUQNQQAJIillREsUCUUFSx1LDwpFHCIWRSUnBkUjSxNFEUsQSwUMQQA7SxAWJwxMUEmBMiO6IlNMIoEgukUpQAAaSxsWSyhMUEsjSU8CUEwiWSMIFlcGAlwARSNLECMIRRFC/71LE0sFCEkWSwUlTwK7SyBLHEslSw6IBaJIIillRBJB/OFLA0mBWycNuyVLJrtC/NJLAYABKBJESwODAnwCuhdAAAhLBYgGx0L8uEsDSYFkJLoXRSFJJSS6F0lOAkUWSYExJLoXRQlJIiS6F0lOAkUegQkkuhdJTgJFDjIKTHAASCInFWVETwJMCUlFIQ9ESwUIIillRA1BAAkiKWVESxQJRQVLBkABfksdRRxLA0mDAjsYukkkW0lOA0UPSSJbSU4CRQ6BEFtFGCQLgX4IJLoXRRciFkUlJwZFJEUXSxNFEksRSwUMQQClSxEWJwxMUEmBMiO6IlNFFEkigSC6RSlJgSAkuhdFG4EoJLoXSxdJTwIIRRlLFg5BAPxLFUsYDkEA9EsSQAAgSxsWSyhMUEsjSU8CUEwiWSMIFlcGAlwARSNLFCMIRRVLA4MCfAK6FyMJSwoSQQCVSwZLFRNBAC5LA0klSya7SYE7JyK7Sb5ISYE5WSJMWCcGUEsBvEi/Sx9LGkskSw2IBDFIQvt1Sx9LG0skSw2IBCJISwZLFRJBAChLA0mBWycNu0klSya7SYE7JyK7Sb5ISYE5WSJMWCcGUEsBvEi/Qvs5SwNJJSS6F0sGCBZLASVPArtLChZLDRZQSxYWUIE7TLtC+xZLBEsSCUUFSwkjCElFCyQLgX4ISwRJTwIkuhdFFyVLJbsiRRIiRQwiRRhLFyMIRRdLESMIRRJC/rtLHUsHCkUcQv58IkL48zYaAUkVJBJEFxYnFExQSb1FAURJgVsjuksBgWQkukkXTwInDRJEIiplRCcEZUgkW7GABFQkpZGyGk8CshqyGIEGshAisgGzFoABZExQIrlISYFbK7siFksBgWRLArtLAYFsSwK7SwElSwK7SwGBIUsCu4EpTLsjQzYaAUkVgSASRDYaAkkVJBJEFxZQgAFhTFC+RBeIAcQoTFCwI0MiJwllRCsTQQAqMgciJxtlRA1BAB8yByInE2VEDEAACCInD2VEQQAMIysiTwJUKExQsCNDIkL/8YgGHisiTwJUKExQsCNDNhoBSRWBIBJEgAF1TFC9RQErIk8CVChMULAjQyInCWVEIicYZUQiJwVlRCInG2VEIicPZUQiJxNlRCInEWVEIicOZUQiKWVEIwgiJxxlRCMIIoAMdG90YWxfc3Rha2VkZUQiJxZlRCInGWVEIicIZUQiJwplREsNFRZXBgJPDlBPDoACAG9QSwEVgW8ITE8PUE8OFlBPDBZQKyJPDlRQTwsWUE8KFlBPCRZQTwgWUE8HFlBMFlcGAlBPBBZQTwMWUE8CUExQTFAoTFCwI0M2GgFJFSQSRBcxACIqZUQnEmVIcghEEkQnGkxnI0M2GgFJIlmBAghLARUSRFcCADEAIiplREknEmVIcghETwISRCcfZUiBEFsyDRJEgAd2ZXJzaW9uTGcjQzYaAUkVJBJEFzEAIiplRCcSZUhyCEQSRCpMZyNDNhoBSRUkEkQXIQYLFoAYAAAAAAAAYtQAAAAAAABJ1AAAAAAAAGLUTFCB1C8WUChMULAjQ4oBASJHAoAARwMiJwVlRCsTQAALIicFZUQnBxNBAPMjRIv/FicMTFBJjAJJgTIjuiJTSwEigSC6jABLAYEgJLpJjAEXjANMgSgkuheMBEEABScjjACJIicFZUQnCxJBAGGxIiplRCcEZUgiW4AESHFvGrIaiwCyGosBshqyGIEGshAisgGztD5JVwQASwFXAAQoEkQVgQkSRIEFW0mMBYsED0EACosFFicQTFCMAImLAkmBMiO6IiNUgTJMuycjjACJsSIqZUQnBGVIIluIAEaLAxZMUCcgshqLALIashqyGIEGshAisgGztD5JVwQASwFXAAQoEkQVgRgSRIEEW0mMBosED0H/p4sGFicQTFCMAIkiQv8KIicFZURJKxNEFyMJFkmTJA5EVwcBiYoEASIqZUQnBGVIJFuL/iJZgcTCAQtMi/1AADSxSXIIRIsAi/8IsgiyByOyECKyAbaL/BaABFZWrPmyGrIai/6yGrIYgQayECKyAbOL/kyJsUlyCESLALIIsgcjshAisgG2SXIIRIv/shKL/bIRshSBBLIQIrIBtov8FoAEPGDfoLIashqL/rIashiBBrIQIrIBs0L/tooCASKAADEAIicKZUQSRIv/IlsURCInFmVEVwAgMgMTQAALi/9XCAEnBxNBAIwjRIv/VwgBSYwAgAEoEkEAG4v/gQlbi/+BMVtJjAENQQBmiwGBCg5BAF4jRIsAJw0SQQAYIicOZURBAA4iJw5lRIv/gQlbDkEAOiNEi/+BCVtEi/44BzIKEov+OAiL/4ExWyEGCw8QRCInHGVESSMIJxxMZxYnFExQSbxIi/+/i/+MAIkiQv/DIkL/nyJC/3GKAQAiRwOAAEcHi/8WJxRMUEcCvUUBREmBWyO6SwGBbCS6F0sCgVMkuhdLA4EpJLoXTgRPAicLEkRPAoMCfAK6FxRETCMIgQRPAgsIsTIIJx1lSCJbTBYiJx5lREkVFlcGAkxQgAQYk5LFshpMshqyGrIYgQayECKyAbO0PklXBABLAVcABCgSREkiWYECCEwVEkRXBgBJFUlAABCLDEmBUyS6FyMIFoFTTLuJIosPSU4CDyJLAk8CTYEQSwIPgRBPA08CTYsOTgJSSRWBEBJESSJbIiEFHUUBSSEHHkUBTwIeRQEhBR1FASEHHk4CSE8CJFtMIQgeRQEeRQEhBR1FASEIHkUBTBZMFlCMAosNIQoMQAD9iw2MCyIWjAAnBowBiwtBAOWLC0kjDUQjCUmMBCMNRIsESRwjHkUBTBiMCiKMB4sCjAOLB4EPDEEAjIsDSSJbSYwJIQUdRQEhBx5JTgKMBUhMJFuMCEAAaYGihbz23t+9hSiLCEkhBR1FAU8CHkUBiwUWTBZQiwmI6siBIJBPAojqwBkWUElXABBMgRBbSYwGiwoPQQAmiwaLBBgjCBaLAUlPAlBMIlkjCBZXBgJcAIwBiwcjCIwHjANC/3aMA0L/eSEIQv+ciwOAAgASUIsBUEmBEFlLARVSiwxJTgK+REmBOVkiTFhMUEsBvEhLAUy/gVOLALuJIQqMBEL/IosNIwiMC0L+/iInCWVEKxNBACAyByInE2VED0EAFTIHIicRZUQOQAAIIicRZURAAAIjiSKJ","clear":"C4EBQw=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type ObjectC3416591 = {
  valid: boolean,
  balance: bigint
}


/**
 * Converts the ABI tuple representation of a ObjectC3416591 to the struct representation
 */
export function ObjectC3416591FromTuple(abiTuple: [boolean, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ObjectC3416591, APP_SPEC.structs) as ObjectC3416591
}

export type RootKey = {
  address: string,
  name: string
}


/**
 * Converts the ABI tuple representation of a RootKey to the struct representation
 */
export function RootKeyFromTuple(abiTuple: [string, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RootKey, APP_SPEC.structs) as RootKey
}

export type EntryData = {
  address: string,
  asset: bigint,
  quantity: bigint,
  gateArgs: Uint8Array[],
  disqualified: boolean
}


/**
 * Converts the ABI tuple representation of a EntryData to the struct representation
 */
export function EntryDataFromTuple(abiTuple: [string, bigint, bigint, Uint8Array[], boolean]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryData, APP_SPEC.structs) as EntryData
}

export type EntryKey = {
  address: string,
  asset: bigint
}


/**
 * Converts the ABI tuple representation of a EntryKey to the struct representation
 */
export function EntryKeyFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryKey, APP_SPEC.structs) as EntryKey
}

export type RaffleCursor = {
  ticket: bigint,
  stake: bigint,
  disbursed: bigint
}


/**
 * Converts the ABI tuple representation of a RaffleCursor to the struct representation
 */
export function RaffleCursorFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RaffleCursor, APP_SPEC.structs) as RaffleCursor
}

export type Reward = {
  asset: bigint,
  distribution: number,
  rate: bigint,
  expiration: bigint,
  interval: bigint,
  qualifiedStakers: bigint,
  qualifiedStake: bigint,
  winnerCount: bigint,
  winningTickets: bigint[],
  raffleCursor: RaffleCursor,
  vrfFailureCount: bigint,
  phase: number,
  disbursementCursor: bigint,
  activeDisbursementId: bigint,
  activeDisbursementRoundStart: bigint,
  lastDisbursementTimestamp: bigint
}


/**
 * Converts the ABI tuple representation of a Reward to the struct representation
 */
export function RewardFromTuple(abiTuple: [bigint, number, bigint, bigint, bigint, bigint, bigint, bigint, bigint[], [bigint, bigint, bigint], bigint, number, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Reward, APP_SPEC.structs) as Reward
}

export type StakingPoolMbrData = {
  entries: bigint,
  uniques: bigint,
  entriesByAddress: bigint,
  rewards: bigint,
  disbursements: bigint
}


/**
 * Converts the ABI tuple representation of a StakingPoolMBRData to the struct representation
 */
export function StakingPoolMbrDataFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakingPoolMBRData, APP_SPEC.structs) as StakingPoolMbrData
}

export type StakingPoolState = {
  status: number,
  title: string,
  type: number,
  signupTimestamp: bigint,
  startTimestamp: bigint,
  allowLateSignups: boolean,
  endTimestamp: bigint,
  maxEntries: bigint,
  entryCount: bigint,
  rewardCount: bigint,
  totalStaked: bigint,
  stakeKey: RootKey,
  minimumStakeAmount: bigint,
  gateId: bigint,
  creator: string
}


/**
 * Converts the ABI tuple representation of a StakingPoolState to the struct representation
 */
export function StakingPoolStateFromTuple(abiTuple: [number, string, number, bigint, bigint, boolean, bigint, bigint, bigint, bigint, bigint, [string, string], bigint, bigint, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakingPoolState, APP_SPEC.structs) as StakingPoolState
}

export type FunderInfo = {
  account: string,
  amount: bigint
}


/**
 * Converts the ABI tuple representation of a FunderInfo to the struct representation
 */
export function FunderInfoFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.FunderInfo, APP_SPEC.structs) as FunderInfo
}

/**
 * The argument types for the StakingPool contract
 */
export type StakingPoolArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': {
      title: string
      type: bigint | number
      creator: string
      funder: FunderInfo
      marketplace: string
      stakeKey: RootKey
      minimumStakeAmount: bigint | number
      gateId: bigint | number
      maxEntries: bigint | number
      akitaDao: bigint | number
      akitaDaoEscrow: bigint | number
    }
    'init()void': Record<string, never>
    'delete(address)void': {
      caller: string
    }
    'optIn(pay,uint64)void': {
      /**
       * The payment transaction
       */
      payment: AppMethodCallTransactionArgument
      /**
       * The asset to be opted into
       */
      asset: bigint | number
    }
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      reward: Reward
    }
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      assetXfer: AppMethodCallTransactionArgument
      reward: Reward
    }
    'finalize(uint64,uint64,uint64)void': {
      signupTimestamp: bigint | number
      startTimestamp: bigint | number
      endTimestamp: bigint | number
    }
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': {
      payment: AppMethodCallTransactionArgument
      entries: [bigint | number, bigint | number, Uint8Array[]][]
      args: Uint8Array[]
    }
    'startDisbursement(uint64)void': {
      rewardId: bigint | number
    }
    'raffle(uint64)void': {
      rewardId: bigint | number
    }
    'disburseRewards(uint64,uint64)void': {
      rewardId: bigint | number
      iterationAmount: bigint | number
    }
    'finalizeDistribution(uint64)void': {
      rewardId: bigint | number
    }
    'check(address,uint64)(bool,uint64)': {
      address: string
      asset: bigint | number
    }
    'signUpsOpen()bool': Record<string, never>
    'isLive()bool': Record<string, never>
    'isEntered(address)bool': {
      address: string
    }
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': Record<string, never>
    'updateAkitaDAOEscrow(uint64)void': {
      app: bigint | number
    }
    'update(string)void': {
      newVersion: string
    }
    'updateAkitaDAO(uint64)void': {
      akitaDao: bigint | number
    }
    'opUp()void': Record<string, never>
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': {
      winningTickets: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': [title: string, type: bigint | number, creator: string, funder: FunderInfo, marketplace: string, stakeKey: RootKey, minimumStakeAmount: bigint | number, gateId: bigint | number, maxEntries: bigint | number, akitaDao: bigint | number, akitaDaoEscrow: bigint | number]
    'init()void': []
    'delete(address)void': [caller: string]
    'optIn(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number]
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, reward: Reward]
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, reward: Reward]
    'finalize(uint64,uint64,uint64)void': [signupTimestamp: bigint | number, startTimestamp: bigint | number, endTimestamp: bigint | number]
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': [payment: AppMethodCallTransactionArgument, entries: [bigint | number, bigint | number, Uint8Array[]][], args: Uint8Array[]]
    'startDisbursement(uint64)void': [rewardId: bigint | number]
    'raffle(uint64)void': [rewardId: bigint | number]
    'disburseRewards(uint64,uint64)void': [rewardId: bigint | number, iterationAmount: bigint | number]
    'finalizeDistribution(uint64)void': [rewardId: bigint | number]
    'check(address,uint64)(bool,uint64)': [address: string, asset: bigint | number]
    'signUpsOpen()bool': []
    'isLive()bool': []
    'isEntered(address)bool': [address: string]
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': []
    'updateAkitaDAOEscrow(uint64)void': [app: bigint | number]
    'update(string)void': [newVersion: string]
    'updateAkitaDAO(uint64)void': [akitaDao: bigint | number]
    'opUp()void': []
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': [winningTickets: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type StakingPoolReturns = {
  'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': void
  'init()void': void
  'delete(address)void': void
  'optIn(pay,uint64)void': void
  'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'finalize(uint64,uint64,uint64)void': void
  'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': void
  'startDisbursement(uint64)void': void
  'raffle(uint64)void': void
  'disburseRewards(uint64,uint64)void': void
  'finalizeDistribution(uint64)void': void
  'check(address,uint64)(bool,uint64)': ObjectC3416591
  'signUpsOpen()bool': boolean
  'isLive()bool': boolean
  'isEntered(address)bool': boolean
  'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': StakingPoolState
  'updateAkitaDAOEscrow(uint64)void': void
  'update(string)void': void
  'updateAkitaDAO(uint64)void': void
  'opUp()void': void
  'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': StakingPoolMbrData
}

/**
 * Defines the types of available calls and state of the StakingPool smart contract.
 */
export type StakingPoolTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void' | 'create', {
      argsObj: StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
      returns: StakingPoolReturns['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
    }>
    & Record<'init()void' | 'init', {
      argsObj: StakingPoolArgs['obj']['init()void']
      argsTuple: StakingPoolArgs['tuple']['init()void']
      returns: StakingPoolReturns['init()void']
    }>
    & Record<'delete(address)void' | 'delete', {
      argsObj: StakingPoolArgs['obj']['delete(address)void']
      argsTuple: StakingPoolArgs['tuple']['delete(address)void']
      returns: StakingPoolReturns['delete(address)void']
    }>
    & Record<'optIn(pay,uint64)void' | 'optIn', {
      argsObj: StakingPoolArgs['obj']['optIn(pay,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['optIn(pay,uint64)void']
      returns: StakingPoolReturns['optIn(pay,uint64)void']
    }>
    & Record<'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addReward', {
      argsObj: StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addRewardAsa', {
      argsObj: StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'finalize(uint64,uint64,uint64)void' | 'finalize', {
      argsObj: StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']
      returns: StakingPoolReturns['finalize(uint64,uint64,uint64)void']
    }>
    & Record<'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' | 'enter', {
      argsObj: StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      argsTuple: StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      returns: StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
    }>
    & Record<'startDisbursement(uint64)void' | 'startDisbursement', {
      argsObj: StakingPoolArgs['obj']['startDisbursement(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['startDisbursement(uint64)void']
      returns: StakingPoolReturns['startDisbursement(uint64)void']
    }>
    & Record<'raffle(uint64)void' | 'raffle', {
      argsObj: StakingPoolArgs['obj']['raffle(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['raffle(uint64)void']
      returns: StakingPoolReturns['raffle(uint64)void']
    }>
    & Record<'disburseRewards(uint64,uint64)void' | 'disburseRewards', {
      argsObj: StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']
      returns: StakingPoolReturns['disburseRewards(uint64,uint64)void']
    }>
    & Record<'finalizeDistribution(uint64)void' | 'finalizeDistribution', {
      argsObj: StakingPoolArgs['obj']['finalizeDistribution(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']
      returns: StakingPoolReturns['finalizeDistribution(uint64)void']
    }>
    & Record<'check(address,uint64)(bool,uint64)' | 'check', {
      argsObj: StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)']
      argsTuple: StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']
      returns: StakingPoolReturns['check(address,uint64)(bool,uint64)']
    }>
    & Record<'signUpsOpen()bool' | 'signUpsOpen', {
      argsObj: StakingPoolArgs['obj']['signUpsOpen()bool']
      argsTuple: StakingPoolArgs['tuple']['signUpsOpen()bool']
      /**
       * a boolean of whether sign ups are open
       */
      returns: StakingPoolReturns['signUpsOpen()bool']
    }>
    & Record<'isLive()bool' | 'isLive', {
      argsObj: StakingPoolArgs['obj']['isLive()bool']
      argsTuple: StakingPoolArgs['tuple']['isLive()bool']
      /**
       * a boolean of whether the pool is live
       */
      returns: StakingPoolReturns['isLive()bool']
    }>
    & Record<'isEntered(address)bool' | 'isEntered', {
      argsObj: StakingPoolArgs['obj']['isEntered(address)bool']
      argsTuple: StakingPoolArgs['tuple']['isEntered(address)bool']
      /**
       * a boolean indicating if the address has entered the staking pool
       */
      returns: StakingPoolReturns['isEntered(address)bool']
    }>
    & Record<'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' | 'getState', {
      argsObj: StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      argsTuple: StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      returns: StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
    }>
    & Record<'updateAkitaDAOEscrow(uint64)void' | 'updateAkitaDAOEscrow', {
      argsObj: StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']
      returns: StakingPoolReturns['updateAkitaDAOEscrow(uint64)void']
    }>
    & Record<'update(string)void' | 'update', {
      argsObj: StakingPoolArgs['obj']['update(string)void']
      argsTuple: StakingPoolArgs['tuple']['update(string)void']
      returns: StakingPoolReturns['update(string)void']
    }>
    & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
      argsObj: StakingPoolArgs['obj']['updateAkitaDAO(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']
      returns: StakingPoolReturns['updateAkitaDAO(uint64)void']
    }>
    & Record<'opUp()void' | 'opUp', {
      argsObj: StakingPoolArgs['obj']['opUp()void']
      argsTuple: StakingPoolArgs['tuple']['opUp()void']
      returns: StakingPoolReturns['opUp()void']
    }>
    & Record<'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' | 'mbr', {
      argsObj: StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      /**
       * the mbr created for each boxmap entry
       */
      returns: StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        /**
         * the status the pool is in
         */
        status: number
        /**
         * title of the staking pool
         */
        title: string
        /**
         * the method of staking to be used for the pool
         */
        type: number
        /**
         * the timestamp when sign ups for the pool are allowed
         */
        signupTimestamp: bigint
        /**
         * whether signups are allowed after the staking pool begins
         */
        allowLateSignups: bigint
        /**
         * the timestamp when the pool starts
         */
        startTimestamp: bigint
        /**
         * the timestamp when the pool ends
         */
        endTimestamp: bigint
        /**
         * the maximum entries allowed for the pool
         */
        maxEntries: bigint
        /**
         * the number of entries in a pool
         */
        entryId: bigint
        /**
         * the number of rewards for the pool
         */
        rewardId: bigint
        /**
         * the total amount staked in the pool
         */
        totalStaked: bigint
        /**
        * the name for the meta merkle asset group to validate staking
        stake key can be empty if distribution !== DistributionTypePercentage

         */
        stakeKey: RootKey
        /**
         * minimum stake amount
         */
        minimumStakeAmount: bigint
        /**
         * the gate id of the pool
         */
        gateId: bigint
        /**
         * the size of the gate were using
         */
        gateSize: bigint
        /**
         * the address of the creator of the staking pool
         */
        creator: string
        /**
         * marketplace is pool creation side marketplace
         */
        marketplace: string
        /**
         * the amount the marketplaces will get for the sale
         */
        marketplaceRoyalties: bigint
        /**
         * the akita royalty for the pool
         */
        akitaRoyalty: bigint
        /**
         * the amount of royalties that were paid in a disbursement
         */
        akitaRoyaltyAmount: bigint
        /**
         * salt for randomness
         */
        salt: BinaryState
        /**
         * the app ID for the akita DAO escrow to use
         */
        akitaDaoEscrow: bigint
        /**
         * the current version of the contract
         */
        version: string
        /**
         * the app ID of the Akita DAO
         */
        akitaDao: bigint
        funder: FunderInfo
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        /**
         * indexed entries for efficient iteration
         */
        entries: Map<bigint | number, EntryData>
        /**
         * the number of unique asset entries by address
         */
        uniques: Map<string, bigint>
        /**
         * the entries in the pool
         */
        entriesByAddress: Map<EntryKey, bigint>
        /**
         * the rewards for this staking pool
         */
        rewards: Map<bigint | number, Reward>
        /**
         * the disbursements this pool as created & finalized
         */
        disbursements: Map<bigint | number, Uint8Array>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type StakingPoolSignatures = keyof StakingPoolTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type StakingPoolNonVoidMethodSignatures = keyof StakingPoolTypes['methods'] extends infer T ? T extends keyof StakingPoolTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the StakingPool smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the StakingPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = StakingPoolTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = StakingPoolTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type StakingPoolCreateCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & {method: 'create'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & {method: 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type StakingPoolUpdateCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {method: 'update'}>
  | Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {method: 'update(string)void'}>
/**
 * Defines supported delete method params for this smart contract
 */
export type StakingPoolDeleteCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {method: 'delete'}>
  | Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {method: 'delete(address)void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type StakingPoolDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: StakingPoolCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: StakingPoolUpdateCallParams
  /**
   * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  deleteParams?: StakingPoolDeleteCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the StakingPool smart contract
 */
export abstract class StakingPoolParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends StakingPoolCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'create':
          case 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void':
            return StakingPoolParamsFactory.create.create(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.title, params.args.type, params.args.creator, params.args.funder, params.args.marketplace, params.args.stakeKey, params.args.minimumStakeAmount, params.args.gateId, params.args.maxEntries, params.args.akitaDao, params.args.akitaDaoEscrow],
        }
      },
    }
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends StakingPoolUpdateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'update':
          case 'update(string)void':
            return StakingPoolParamsFactory.update.update(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs update ABI call params for the StakingPool smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: 'update(string)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.newVersion],
        }
      },
    }
  }

  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod<TParams extends StakingPoolDeleteCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'delete':
          case 'delete(address)void':
            return StakingPoolParamsFactory.delete.delete(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs delete ABI call params for the StakingPool smart contract using the delete(address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      delete(params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'delete(address)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.caller],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the init()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static init(params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'init()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the optIn(pay,uint64)void ABI method
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optIn(params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'optIn(pay,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addReward(params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addRewardAsa(params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.assetXfer, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the finalize(uint64,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalize(params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalize(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.signupTimestamp, params.args.startTimestamp, params.args.endTimestamp],
    }
  }
  /**
   * Constructs a no op call for the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static enter(params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.entries, params.args.args],
    }
  }
  /**
   * Constructs a no op call for the startDisbursement(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static startDisbursement(params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'startDisbursement(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the raffle(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static raffle(params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'raffle(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the disburseRewards(uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static disburseRewards(params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'disburseRewards(uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId, params.args.iterationAmount],
    }
  }
  /**
   * Constructs a no op call for the finalizeDistribution(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeDistribution(params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalizeDistribution(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the check(address,uint64)(bool,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static check(params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'check(address,uint64)(bool,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the signUpsOpen()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'signUpsOpen()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isLive()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isLive()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isEntered(address)bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isEntered(address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address],
    }
  }
  /**
   * Constructs a no op call for the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoEscrow(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAOEscrow(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.app],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAO(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao],
    }
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'opUp()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.winningTickets],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the StakingPool smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class StakingPoolFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `StakingPoolFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new StakingPoolClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new StakingPoolClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the StakingPool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: StakingPoolDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? StakingPoolParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (StakingPoolCreateCallParams & { args: Uint8Array[] }) : undefined,
      updateParams: params.updateParams?.method ? StakingPoolParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams as (StakingPoolUpdateCallParams & { args: Uint8Array[] }) : undefined,
      deleteParams: params.deleteParams?.method ? StakingPoolParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams as (StakingPoolDeleteCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new StakingPoolClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(StakingPoolParamsFactory.create.create(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appFactory.params.deployUpdate(StakingPoolParamsFactory.update.update(params))
      },
    },

    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appFactory.params.deployDelete(StakingPoolParamsFactory.delete.delete(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(StakingPoolParamsFactory.create.create(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using an ABI method call using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(StakingPoolParamsFactory.create.create(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | StakingPoolReturns['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']) }, appClient: new StakingPoolClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the StakingPool smart contract
 */
export class StakingPoolClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param appClient An `AppClient` instance which has been created with the StakingPool app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends StakingPoolNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }

  /**
   * Returns a new `StakingPoolClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<StakingPoolClient> {
    return new StakingPoolClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `StakingPoolClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<StakingPoolClient> {
    return new StakingPoolClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.params.update(StakingPoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.params.delete(StakingPoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    init: (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optIn: (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.optIn(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addReward: (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addRewardAsa: (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalize: (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    enter: (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    startDisbursement: (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    raffle: (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    disburseRewards: (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeDistribution: (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    check: (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getState: (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.opUp(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.mbr(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.createTransaction.update(StakingPoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.createTransaction.delete(StakingPoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    init: (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optIn: (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.optIn(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addReward: (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addRewardAsa: (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalize: (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    enter: (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    startDisbursement: (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    raffle: (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    disburseRewards: (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeDistribution: (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    check: (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getState: (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.opUp(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.mbr(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams & SendParams) => {
        const result = await this.appClient.send.update(StakingPoolParamsFactory.update.update(params))
        return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['update(string)void'])}
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      delete: async (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & SendParams) => {
        const result = await this.appClient.send.delete(StakingPoolParamsFactory.delete.delete(params))
        return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['delete(address)void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    init: async (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.init(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['init()void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optIn: async (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.optIn(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['optIn(pay,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addReward: async (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.addReward(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addRewardAsa: async (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.addRewardAsa(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalize: async (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.finalize(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['finalize(uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    enter: async (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.enter(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    startDisbursement: async (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.startDisbursement(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['startDisbursement(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    raffle: async (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.raffle(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['raffle(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    disburseRewards: async (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.disburseRewards(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['disburseRewards(uint64,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeDistribution: async (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.finalizeDistribution(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['finalizeDistribution(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    check: async (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.check(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['check(address,uint64)(bool,uint64)'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether sign ups are open
     */
    signUpsOpen: async (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.signUpsOpen(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['signUpsOpen()bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether the pool is live
     */
    isLive: async (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.isLive(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['isLive()bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean indicating if the address has entered the staking pool
     */
    isEntered: async (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.isEntered(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['isEntered(address)bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getState: async (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.getState(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoEscrow: async (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.updateAkitaDao(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['updateAkitaDAO(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.opUp(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['opUp()void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: the mbr created for each boxmap entry
     */
    mbr: async (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.mbr(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new StakingPoolClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether sign ups are open
   */
  async signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.signUpsOpen(params))
    return result.return as unknown as StakingPoolReturns['signUpsOpen()bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `isLive()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether the pool is live
   */
  async isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.isLive(params))
    return result.return as unknown as StakingPoolReturns['isLive()bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean indicating if the address has entered the staking pool
   */
  async isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.isEntered(params))
    return result.return as unknown as StakingPoolReturns['isEntered(address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.getState(params))
    return result.return as unknown as StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: the mbr created for each boxmap entry
   */
  async mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.mbr(params))
    return result.return as unknown as StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Methods to access state for the current StakingPool app
   */
  state = {
    /**
     * Methods to access global state for the current StakingPool app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          status: result.status,
          title: result.title,
          type: result.type,
          signupTimestamp: result.signupTimestamp,
          allowLateSignups: result.allowLateSignups,
          startTimestamp: result.startTimestamp,
          endTimestamp: result.endTimestamp,
          maxEntries: result.maxEntries,
          entryId: result.entryID,
          rewardId: result.rewardID,
          totalStaked: result.totalStaked,
          stakeKey: result.stakeKey,
          minimumStakeAmount: result.minimumStakeAmount,
          gateId: result.gateID,
          gateSize: result.gateSize,
          creator: result.creator,
          marketplace: result.marketplace,
          marketplaceRoyalties: result.marketplaceRoyalties,
          akitaRoyalty: result.akitaRoyalty,
          akitaRoyaltyAmount: result.akitaRoyaltyAmount,
          salt: new BinaryStateValue(result.salt),
          akitaDaoEscrow: result.akitaDAOEscrow,
          version: result.version,
          akitaDao: result.akitaDAO,
          funder: result.funder,
        }
      },
      /**
       * Get the current value of the status key in global state
       */
      status: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("status")) as number | undefined },
      /**
       * Get the current value of the title key in global state
       */
      title: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("title")) as string | undefined },
      /**
       * Get the current value of the type key in global state
       */
      type: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("type")) as number | undefined },
      /**
       * Get the current value of the signupTimestamp key in global state
       */
      signupTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("signupTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the allowLateSignups key in global state
       */
      allowLateSignups: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("allowLateSignups")) as bigint | undefined },
      /**
       * Get the current value of the startTimestamp key in global state
       */
      startTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("startTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the endTimestamp key in global state
       */
      endTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("endTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the maxEntries key in global state
       */
      maxEntries: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("maxEntries")) as bigint | undefined },
      /**
       * Get the current value of the entryID key in global state
       */
      entryId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("entryID")) as bigint | undefined },
      /**
       * Get the current value of the rewardID key in global state
       */
      rewardId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("rewardID")) as bigint | undefined },
      /**
       * Get the current value of the totalStaked key in global state
       */
      totalStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("totalStaked")) as bigint | undefined },
      /**
       * Get the current value of the stakeKey key in global state
       */
      stakeKey: async (): Promise<RootKey | undefined> => { return (await this.appClient.state.global.getValue("stakeKey")) as RootKey | undefined },
      /**
       * Get the current value of the minimumStakeAmount key in global state
       */
      minimumStakeAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("minimumStakeAmount")) as bigint | undefined },
      /**
       * Get the current value of the gateID key in global state
       */
      gateId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateID")) as bigint | undefined },
      /**
       * Get the current value of the gateSize key in global state
       */
      gateSize: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateSize")) as bigint | undefined },
      /**
       * Get the current value of the creator key in global state
       */
      creator: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("creator")) as string | undefined },
      /**
       * Get the current value of the marketplace key in global state
       */
      marketplace: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("marketplace")) as string | undefined },
      /**
       * Get the current value of the marketplaceRoyalties key in global state
       */
      marketplaceRoyalties: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("marketplaceRoyalties")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyalty key in global state
       */
      akitaRoyalty: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyalty")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyaltyAmount key in global state
       */
      akitaRoyaltyAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyaltyAmount")) as bigint | undefined },
      /**
       * Get the current value of the salt key in global state
       */
      salt: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("salt")) as Uint8Array | undefined) },
      /**
       * Get the current value of the akitaDAOEscrow key in global state
       */
      akitaDaoEscrow: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAOEscrow")) as bigint | undefined },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("version")) as string | undefined },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAO")) as bigint | undefined },
      /**
       * Get the current value of the funder key in global state
       */
      funder: async (): Promise<FunderInfo | undefined> => { return (await this.appClient.state.global.getValue("funder")) as FunderInfo | undefined },
    },
    /**
     * Methods to access box state for the current StakingPool app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the entries map in box state
       */
      entries: {
        /**
         * Get all current values of the entries map in box state
         */
        getMap: async (): Promise<Map<bigint, EntryData>> => { return (await this.appClient.state.box.getMap("entries")) as Map<bigint, EntryData> },
        /**
         * Get a current value of the entries map by key from box state
         */
        value: async (key: bigint | number): Promise<EntryData | undefined> => { return await this.appClient.state.box.getMapValue("entries", key) as EntryData | undefined },
      },
      /**
       * Get values from the uniques map in box state
       */
      uniques: {
        /**
         * Get all current values of the uniques map in box state
         */
        getMap: async (): Promise<Map<string, bigint>> => { return (await this.appClient.state.box.getMap("uniques")) as Map<string, bigint> },
        /**
         * Get a current value of the uniques map by key from box state
         */
        value: async (key: string): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("uniques", key) as bigint | undefined },
      },
      /**
       * Get values from the entriesByAddress map in box state
       */
      entriesByAddress: {
        /**
         * Get all current values of the entriesByAddress map in box state
         */
        getMap: async (): Promise<Map<EntryKey, bigint>> => { return (await this.appClient.state.box.getMap("entriesByAddress")) as Map<EntryKey, bigint> },
        /**
         * Get a current value of the entriesByAddress map by key from box state
         */
        value: async (key: EntryKey): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("entriesByAddress", key) as bigint | undefined },
      },
      /**
       * Get values from the rewards map in box state
       */
      rewards: {
        /**
         * Get all current values of the rewards map in box state
         */
        getMap: async (): Promise<Map<bigint, Reward>> => { return (await this.appClient.state.box.getMap("rewards")) as Map<bigint, Reward> },
        /**
         * Get a current value of the rewards map by key from box state
         */
        value: async (key: bigint | number): Promise<Reward | undefined> => { return await this.appClient.state.box.getMapValue("rewards", key) as Reward | undefined },
      },
      /**
       * Get values from the disbursements map in box state
       */
      disbursements: {
        /**
         * Get all current values of the disbursements map in box state
         */
        getMap: async (): Promise<Map<bigint, Uint8Array>> => { return (await this.appClient.state.box.getMap("disbursements")) as Map<bigint, Uint8Array> },
        /**
         * Get a current value of the disbursements map by key from box state
         */
        value: async (key: bigint | number): Promise<Uint8Array | undefined> => { return await this.appClient.state.box.getMapValue("disbursements", key) as Uint8Array | undefined },
      },
    },
  }

  public newGroup(): StakingPoolComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a init()void method call against the StakingPool contract
       */
      init(params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.init(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a optIn(pay,uint64)void method call against the StakingPool contract
       */
      optIn(params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the StakingPool contract
       */
      addReward(params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addReward(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the StakingPool contract
       */
      addRewardAsa(params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addRewardAsa(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalize(uint64,uint64,uint64)void method call against the StakingPool contract
       */
      finalize(params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalize(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a enter(pay,(uint64,uint64,byte[32][])[],byte[][])void method call against the StakingPool contract
       */
      enter(params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.enter(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a startDisbursement(uint64)void method call against the StakingPool contract
       */
      startDisbursement(params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.startDisbursement(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a raffle(uint64)void method call against the StakingPool contract
       */
      raffle(params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.raffle(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a disburseRewards(uint64,uint64)void method call against the StakingPool contract
       */
      disburseRewards(params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.disburseRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalizeDistribution(uint64)void method call against the StakingPool contract
       */
      finalizeDistribution(params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeDistribution(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a check(address,uint64)(bool,uint64) method call against the StakingPool contract
       */
      check(params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.check(params)))
        resultMappers.push((v) => client.decodeReturnValue('check(address,uint64)(bool,uint64)', v))
        return this
      },
      /**
       * Add a signUpsOpen()bool method call against the StakingPool contract
       */
      signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.signUpsOpen(params)))
        resultMappers.push((v) => client.decodeReturnValue('signUpsOpen()bool', v))
        return this
      },
      /**
       * Add a isLive()bool method call against the StakingPool contract
       */
      isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isLive(params)))
        resultMappers.push((v) => client.decodeReturnValue('isLive()bool', v))
        return this
      },
      /**
       * Add a isEntered(address)bool method call against the StakingPool contract
       */
      isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isEntered(params)))
        resultMappers.push((v) => client.decodeReturnValue('isEntered(address)bool', v))
        return this
      },
      /**
       * Add a getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) method call against the StakingPool contract
       */
      getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getState(params)))
        resultMappers.push((v) => client.decodeReturnValue('getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)', v))
        return this
      },
      /**
       * Add a updateAkitaDAOEscrow(uint64)void method call against the StakingPool contract
       */
      updateAkitaDaoEscrow(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoEscrow(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the StakingPool contract
       */
      updateAkitaDao(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a opUp()void method call against the StakingPool contract
       */
      opUp(params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a mbr(uint64)(uint64,uint64,uint64,uint64,uint64) method call against the StakingPool contract
       */
      mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)))
        resultMappers.push((v) => client.decodeReturnValue('mbr(uint64)(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      get update() {
        return {
          update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      get delete() {
        return {
          delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.delete(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the StakingPool contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as StakingPoolComposer
  }
}
export type StakingPoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the init()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  init(params?: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['init()void'] | undefined]>

  /**
   * Calls the optIn(pay,uint64)void ABI method.
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  optIn(params?: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['optIn(pay,uint64)void'] | undefined]>

  /**
   * Calls the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addReward(params?: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addRewardAsa(params?: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the finalize(uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalize(params?: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalize(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  enter(params?: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | undefined]>

  /**
   * Calls the startDisbursement(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startDisbursement(params?: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['startDisbursement(uint64)void'] | undefined]>

  /**
   * Calls the raffle(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  raffle(params?: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['raffle(uint64)void'] | undefined]>

  /**
   * Calls the disburseRewards(uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  disburseRewards(params?: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['disburseRewards(uint64,uint64)void'] | undefined]>

  /**
   * Calls the finalizeDistribution(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalizeDistribution(params?: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalizeDistribution(uint64)void'] | undefined]>

  /**
   * Calls the check(address,uint64)(bool,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  check(params?: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['check(address,uint64)(bool,uint64)'] | undefined]>

  /**
   * Calls the signUpsOpen()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  signUpsOpen(params?: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['signUpsOpen()bool'] | undefined]>

  /**
   * Calls the isLive()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isLive(params?: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isLive()bool'] | undefined]>

  /**
   * Calls the isEntered(address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isEntered(params?: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isEntered(address)bool'] | undefined]>

  /**
   * Calls the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getState(params?: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | undefined]>

  /**
   * Calls the updateAkitaDAOEscrow(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDaoEscrow(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'] | undefined]>

  /**
   * Calls the updateAkitaDAO(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDao(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAO(uint64)void'] | undefined]>

  /**
   * Calls the opUp()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  opUp(params?: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['opUp()void'] | undefined]>

  /**
   * Calls the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mbr(params?: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    update(params?: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['update(string)void'] | undefined]>
  }

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    delete(params?: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['delete(address)void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): StakingPoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): StakingPoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<StakingPoolComposerResults<TReturns>>
}
export type StakingPoolComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

