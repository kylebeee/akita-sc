#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 92 100000 6364136223846793005 400 1442695040888963407 1442695040888963409 4294967295 50600 18900 18446744073709551615
    bytecblock "akita_dao" "entry_count" 0x151f7c75 0x00 "type" "aal" 0x0000 0x0a "e" "status" "creator" "akita_escrow" 0x14 0x1e "start_timestamp" "end_timestamp" "gate_id" "max_entries" 0x80 "allow_late_signups" "wallet" "r" "akita_royalty_amount" "u" "signup_timestamp" "reward_count" "stake_key" "akita_royalty" "title" "minimum_stake_amount" "a" "total_staked" "oal" "salt" "sal" "pal" "controlled_address" 0x000000000000000000000000000000000000000000000000 0x000000000000000000 0xc9068809
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking-pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeySignupTimestamp })
    bytec 24 // "signup_timestamp"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ initialValue: false, key: PoolGlobalStateKeyAllowLateSignups })
    bytec 19 // "allow_late_signups"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    intc_1 // 1
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyRewardCount })
    bytec 25 // "reward_count"
    intc_1 // 1
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:133
    // totalStaked = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyTotalStaked })
    bytec 31 // "total_staked"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking-pool/contract.algo.ts:104-108
    // export class StakingPool extends classes(
    //   BaseStakingPool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    pushbytess 0xab8b213a 0xea9180dd // method "delete(address)void", method "update(string)void"
    txna ApplicationArgs 0
    match main_delete_route@4 main_update_route@5

main_switch_case_next@6:
    // smart_contracts/staking-pool/contract.algo.ts:104-108
    // export class StakingPool extends classes(
    //   BaseStakingPool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@32
    pushbytess 0x83f14748 0x394eaeb2 0x645a7bcc 0x0f2fc312 0x181e8291 0xfdcfdff6 0xb82ed1b3 0xa9418d37 0xfc699cb3 0x6e76b2ca 0xcdb0ac6a 0xb223d35d 0xbc58ad09 0x8e082484 0x33f78808 0x592ee341 0x8fa4a160 0xe3377342 0x71704649 0x1ead20a9 0x33e92c94 0x854dede0 0xa4b3e789 // method "init()void", method "optIn(pay,uint64)void", method "addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void", method "finalize(uint64,uint64,uint64)void", method "gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void", method "enter(pay,(uint64,uint64,byte[32][])[])void", method "startDisbursement(uint64)void", method "raffle(uint64)void", method "disburseRewards(uint64,uint64)void", method "finalizeDistribution(uint64)void", method "check(address,uint64)(bool,uint64)", method "gateCheck(appl,address,uint64)void", method "enterCost(address,uint64)uint64", method "optInCost(uint64)uint64", method "signUpsOpen()bool", method "isLive()bool", method "isEntered(address)bool", method "getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)", method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void", method "mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match init optIn addReward addRewardAsa finalize gatedEnter enter startDisbursement raffle disburseRewards finalizeDistribution check smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing] enterCost optInCost signUpsOpen isLive isEntered getState updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@29 mbr
    err

main_opUp_route@29:
    // smart_contracts/utils/base-contracts/base.ts:43
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@32:
    // smart_contracts/staking-pool/contract.algo.ts:104-108
    // export class StakingPool extends classes(
    //   BaseStakingPool,
    //   AkitaBaseFeeGeneratorContract,
    //   ChildContract
    // ) {
    pushbytes 0x777ec3e5 // method "create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@5:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update

main_delete_route@4:
    // smart_contracts/staking-pool/contract.algo.ts:793
    // @abimethod({ allowActions: 'DeleteApplication' })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b delete


// smart_contracts/utils/types/lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
__pcg32Output:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:23
    // export function __pcg32Output(state: PCG32STATE): uint64 {
    proto 1 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:24
    // const xorshifted = __maskToUint32(op.shr(op.shr(state, 18) ^ state, 27))
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:25
    // const rot = op.shr(state, 59)
    frame_dig -1
    pushint 59 // 59
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    dup2
    shr
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:13
    // return value & (op.shl(1, 32) - 1)
    intc 9 // 4294967295
    &
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:26
    // return op.shr(xorshifted, rot) | __maskToUint32(op.shl(xorshifted, __uint64Twos(rot) & 31))
    |
    retsub


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:176
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:55
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig -2
    bytec 32 // "oal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:60
    // return getOtherAppList(akitaDAO).escrow
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:182-185
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:187
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:188
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:191
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:178
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:227
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:229
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:230
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:229-230
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:231
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    pushint 4 // 4
    ==
    // smart_contracts/utils/functions.ts:229-231
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:232
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x43922655 // method "mustCheck(address,uint64,byte[][])void"
    ==
    // smart_contracts/utils/functions.ts:229-232
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:233
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:229-233
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@7
    // smart_contracts/utils/functions.ts:234
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:229-234
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@7
    intc_1 // 1
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@7:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:228-235
    // return (
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   gateTxn.appArgs(0) === methodSelector<typeof Gate.prototype.mustCheck>() &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/utils/functions.ts::splitOptInCount(akitaDAO: uint64, escrow: bytes, asset: uint64) -> uint64:
splitOptInCount:
    // smart_contracts/utils/functions.ts:587
    // export function splitOptInCount(akitaDAO: Application, escrow: Account, asset: Asset): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:588
    // let count: uint64 = 0
    intc_0 // 0
    // smart_contracts/utils/functions.ts:590
    // if (!escrow.isOptedIn(asset)) {
    frame_dig -2
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    bnz splitOptInCount_after_if_else@2
    // smart_contracts/utils/functions.ts:99
    // const [splitsBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysRevenueSplits))
    frame_dig -3
    pushbytes "revenue_splits"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    intc_0 // 0
    extract_uint16
    // smart_contracts/utils/functions.ts:591
    // count += 1
    intc_1 // 1
    // smart_contracts/utils/functions.ts:594
    // count += splits.length
    +
    frame_bury 0

splitOptInCount_after_if_else@2:
    // smart_contracts/utils/functions.ts:597
    // return count
    frame_dig 0
    swap
    retsub


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.create[routing]() -> void:
create:
    pushbytes ""
    dup
    // smart_contracts/staking-pool/contract.algo.ts:741
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 10
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 11
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:755
    // this.status.value = PoolStatusDraft
    bytec_3 // 0x00
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 28 // "title"
    // smart_contracts/staking-pool/contract.algo.ts:756
    // this.title.value = title
    uncover 11
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:757
    // this.type.value = type
    uncover 10
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:758
    // this.creator.value = creator
    uncover 9
    app_global_put
    // smart_contracts/utils/base-contracts/child.ts:11
    // funder = GlobalState<FunderInfo>({ key: GlobalStateKeyFunder })
    pushbytes "funder"
    // smart_contracts/staking-pool/contract.algo.ts:759
    // this.funder.value = clone(funder)
    uncover 8
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:148
    // marketplace = GlobalState<Account>({ key: PoolGlobalStateKeyMarketplace })
    pushbytes "marketplace"
    // smart_contracts/staking-pool/contract.algo.ts:760
    // this.marketplace.value = marketplace
    uncover 7
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 26 // "stake_key"
    // smart_contracts/staking-pool/contract.algo.ts:762
    // this.stakeKey.value = clone(stakeKey)
    uncover 6
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 29 // "minimum_stake_amount"
    // smart_contracts/staking-pool/contract.algo.ts:763
    // this.minimumStakeAmount.value = minimumStakeAmount
    uncover 5
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:764
    // this.gateID.value = gateID
    uncover 4
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:765
    // this.maxEntries.value = maxEntries
    uncover 3
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:156
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 33 // "salt"
    // smart_contracts/staking-pool/contract.algo.ts:767
    // this.salt.value = Txn.txId
    txn TxID
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:768
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/staking-pool/contract.algo.ts:769
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:771
    // const fees = getStakingFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:771
    // const fees = getStakingFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:74
    // const [stakingFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysStakingFees))
    dup
    pushbytes "staking_fees"
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    bytec 34 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:773
    // const { impact: impactApp } = getAkitaSocialAppList(this.akitaDAO.value);
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:775
    // let impact: uint64 = 0;
    intc_0 // 0
    swap
    // smart_contracts/staking-pool/contract.algo.ts:776
    // if (impactApp !== 0) {
    bz create_after_if_else@3
    // smart_contracts/staking-pool/contract.algo.ts:777
    // impact = getUserImpact(this.akitaDAO.value, this.creator.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:777
    // impact = getUserImpact(this.akitaDAO.value, this.creator.value)
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:777
    // impact = getUserImpact(this.akitaDAO.value, this.creator.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:132-135
    // return abiCall<typeof AkitaSocialImpact.prototype.getUserImpact>({
    //   appId: getAkitaSocialAppList(akitaDAO).impact,
    //   args: [account]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:45
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaSocialAppList))
    swap
    bytec 34 // "sal"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:133
    // appId: getAkitaSocialAppList(akitaDAO).impact,
    pushint 16 // 16
    extract_uint64
    // smart_contracts/utils/functions.ts:132-135
    // return abiCall<typeof AkitaSocialImpact.prototype.getUserImpact>({
    //   appId: getAkitaSocialAppList(akitaDAO).impact,
    //   args: [account]
    // }).returnValue
    pushbytes 0xd574bb10 // method "getUserImpact(address)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 1

create_after_if_else@3:
    // smart_contracts/staking-pool/contract.algo.ts:779
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    dig 1
    dup
    intc_2 // 8
    extract_uint64
    bury 4
    pushint 16 // 16
    extract_uint64
    bury 4
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    dup
    intc_1 // 1
    >
    bz create_ternary_false@6
    dup
    intc_1 // 1
    -

create_ternary_merge@7:
    // smart_contracts/utils/functions.ts:128
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    dig 4
    dup
    dig 5
    -
    uncover 2
    *
    pushint 1000 // 1000
    /
    -
    // smart_contracts/staking-pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 27 // "akita_royalty"
    // smart_contracts/staking-pool/contract.algo.ts:779
    // this.akitaRoyalty.value = impactRange(impact, fees.impactTaxMin, fees.impactTaxMax)
    swap
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:741
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return

create_ternary_false@6:
    // smart_contracts/utils/functions.ts:127
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b create_ternary_merge@7


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.init[routing]() -> void:
init:
    // smart_contracts/staking-pool/contract.algo.ts:783
    // assert(Global.callerApplicationAddress === Global.creatorAddress, 'only the factory can init the pool')
    global CallerApplicationAddress
    global CreatorAddress
    ==
    assert // only the factory can init the pool
    // smart_contracts/staking-pool/contract.algo.ts:785
    // if (this.gateID.value > 0) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:785
    // if (this.gateID.value > 0) {
    app_global_get_ex
    assert // check GlobalState exists
    bz init_after_if_else@4
    // smart_contracts/staking-pool/contract.algo.ts:786-789
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:787
    // appId: getAkitaAppList(this.akitaDAO.value).gate,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:787
    // appId: getAkitaAppList(this.akitaDAO.value).gate,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:787
    // appId: getAkitaAppList(this.akitaDAO.value).gate,
    pushint 40 // 40
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:788
    // args: [this.gateID.value],
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:788
    // args: [this.gateID.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/staking-pool/contract.algo.ts:786-789
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    pushbytes 0xdf56b01e // method "size(uint64)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:144
    // gateSize = GlobalState<uint64>({ key: PoolGlobalStateKeyGateSize })
    pushbytes "gate_size"
    // smart_contracts/staking-pool/contract.algo.ts:786-789
    // this.gateSize.value = abiCall<typeof Gate.prototype.size>({
    //   appId: getAkitaAppList(this.akitaDAO.value).gate,
    //   args: [this.gateID.value],
    // }).returnValue
    swap
    app_global_put

init_after_if_else@4:
    // smart_contracts/staking-pool/contract.algo.ts:782
    // init() {
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.delete[routing]() -> void:
delete:
    // smart_contracts/staking-pool/contract.algo.ts:793
    // @abimethod({ allowActions: 'DeleteApplication' })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/staking-pool/contract.algo.ts:795
    // assert(Txn.sender === Global.creatorAddress, 'call must come from factory')
    txn Sender
    global CreatorAddress
    ==
    assert // call must come from factory
    // smart_contracts/staking-pool/contract.algo.ts:796
    // assert(caller === this.creator.value, 'only the creator can delete the pool')
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:796
    // assert(caller === this.creator.value, 'only the creator can delete the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can delete the pool
    // smart_contracts/staking-pool/contract.algo.ts:797
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:797
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    ==
    bnz delete_bool_true@3
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:797
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz delete_bool_false@4

delete_bool_true@3:
    intc_1 // 1

delete_bool_merge@5:
    // smart_contracts/staking-pool/contract.algo.ts:797
    // assert(this.status.value === PoolStatusDraft || Global.latestTimestamp > this.endTimestamp.value, 'the pool must be in draft or ended')
    assert // the pool must be in draft or ended
    // smart_contracts/staking-pool/contract.algo.ts:801-803
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    //   .submit()
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:802
    // .payment({ closeRemainderTo: Global.creatorAddress })
    global CreatorAddress
    itxn_field CloseRemainderTo
    // smart_contracts/staking-pool/contract.algo.ts:801-802
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:801-803
    // itxn
    //   .payment({ closeRemainderTo: Global.creatorAddress })
    //   .submit()
    itxn_submit
    // smart_contracts/staking-pool/contract.algo.ts:793
    // @abimethod({ allowActions: 'DeleteApplication' })
    intc_1 // 1
    return

delete_bool_false@4:
    intc_0 // 0
    b delete_bool_merge@5


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.optIn[routing]() -> void:
optIn:
    // smart_contracts/staking-pool/contract.algo.ts:813
    // optIn(payment: gtxn.PaymentTxn, asset: Asset): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    // smart_contracts/staking-pool/contract.algo.ts:814
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:814
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/staking-pool/contract.algo.ts:816
    // let optinMBR: uint64 = Global.assetOptInMinBalance
    global AssetOptInMinBalance
    swap
    // smart_contracts/staking-pool/contract.algo.ts:819
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(asset)) {
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/staking-pool/contract.algo.ts:819
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(asset)) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz optIn_after_if_else@3
    // smart_contracts/staking-pool/contract.algo.ts:820
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:820
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/staking-pool/contract.algo.ts:820
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 3
    callsub splitOptInCount
    // smart_contracts/staking-pool/contract.algo.ts:821
    // optinMBR += Global.assetOptInMinBalance * count
    global AssetOptInMinBalance
    *
    +

optIn_after_if_else@3:
    // smart_contracts/staking-pool/contract.algo.ts:826-833
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    dup
    gtxns Receiver
    // smart_contracts/staking-pool/contract.algo.ts:829
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking-pool/contract.algo.ts:826-833
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/staking-pool/contract.algo.ts:830
    // amount: optinMBR + rewardsMBR,
    uncover 2
    // smart_contracts/staking-pool/contract.algo.ts:824
    // const rewardsMBR: uint64 = this.rewardsMbr(WinnerCountCap) * 2
    pushint 8000 // 8000
    // smart_contracts/staking-pool/contract.algo.ts:830
    // amount: optinMBR + rewardsMBR,
    +
    // smart_contracts/staking-pool/contract.algo.ts:826-833
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: optinMBR + rewardsMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/staking-pool/contract.algo.ts:835-841
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:837
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 1
    dup
    cover 2
    itxn_field XferAsset
    // smart_contracts/staking-pool/contract.algo.ts:838
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking-pool/contract.algo.ts:835-840
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:835-841
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 20 // "wallet"
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dup
    bytec 35 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:78
    // const { revenueManager } = getPluginAppList(this.akitaDAO.value)
    dup
    extract 8 8
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    dig 2
    bytec 20 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:65-68
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    itxn_begin
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:67
    // args: [[name]],
    pushbytes 0x0001000200087265765f706f6f6c
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:65-68
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/utils/base-contracts/base.ts:70
    // assert(escrow.id !== 0, ERR_ESCROW_DOES_NOT_EXIST)
    extract 6 9
    intc_0 // 0
    extract_uint64
    dup
    assert // Escrow does not exist
    // smart_contracts/utils/base-contracts/base.ts:81
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:81
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Wrong escrow for this operation
    // smart_contracts/utils/base-contracts/base.ts:83-92
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    itxn_begin
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:87
    // true,
    bytec 18 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:88
    // name,
    pushbytes 0x00087265765f706f6f6c
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:89
    // [0], // all the akita escrows have method restrictions with optin being index 0
    pushbytes 0x00010000000000000000
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:90
    // []
    bytec 6 // 0x0000
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:83-92
    // itxnCompose.begin<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin>({
    //   appId: wallet,
    //   args: [
    //     revenueManager,
    //     true,
    //     name,
    //     [0], // all the akita escrows have method restrictions with optin being index 0
    //     []
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:96
    // this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/base-contracts/base.ts:94-98
    // const optInCount = splitOptInCount(
    //   this.akitaDAO.value,
    //   this.akitaDAOEscrow.value.address,
    //   asset
    // )
    uncover 2
    swap
    dig 4
    callsub splitOptInCount
    // smart_contracts/utils/base-contracts/base.ts:100
    // const mbrAmount: uint64 = Global.assetOptInMinBalance * optInCount
    global AssetOptInMinBalance
    *
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:109
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:109
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/utils/base-contracts/base.ts:108-111
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:105
    // wallet,
    dig 1
    itob
    // smart_contracts/utils/base-contracts/base.ts:107
    // [asset.id],
    uncover 3
    itob
    pushbytes 0x0001
    swap
    concat
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    pushbytes 0x6835e3bc // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:87
    // true,
    bytec 18 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:102-113
    // itxnCompose.next<typeof RevenueManagerPluginStub.prototype.optIn>({
    //   appId: revenueManager,
    //   args: [
    //     wallet,
    //     true,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: mbrAmount
    //     })
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:115
    // itxnCompose.next<typeof AbstractedAccount.prototype.arc58_verifyAuthAddress>({ appId: wallet })
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:127
    // itxnCompose.submit()
    itxn_submit
    // smart_contracts/staking-pool/contract.algo.ts:813
    // optIn(payment: gtxn.PaymentTxn, asset: Asset): void {
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward[routing]() -> void:
addReward:
    // smart_contracts/staking-pool/contract.algo.ts:850
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward
    pop
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.addRewardAsa[routing]() -> void:
addRewardAsa:
    // smart_contracts/staking-pool/contract.algo.ts:871
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/staking-pool/contract.algo.ts:872-882
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    dig 1
    gtxns AssetReceiver
    // smart_contracts/staking-pool/contract.algo.ts:875
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking-pool/contract.algo.ts:872-882
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    dig 2
    gtxns XferAsset
    // smart_contracts/staking-pool/contract.algo.ts:876
    // xferAsset: Asset(reward.asset),
    dig 2
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:872-882
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: Asset(reward.asset),
    //     assetAmount: {
    //       greaterThan: 0
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    &&
    uncover 2
    gtxns AssetAmount
    &&
    assert // Invalid transfer
    // smart_contracts/staking-pool/contract.algo.ts:884
    // this.addReward(payment, reward)
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward
    pop
    // smart_contracts/staking-pool/contract.algo.ts:871
    // addRewardAsa(payment: gtxn.PaymentTxn, assetXfer: gtxn.AssetTransferTxn, reward: Reward): void {
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.finalize[routing]() -> void:
finalize:
    // smart_contracts/staking-pool/contract.algo.ts:887
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/staking-pool/contract.algo.ts:888
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    txn Sender
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:888
    // assert(Txn.sender === this.creator.value, 'only the creator can finalize the pool')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // only the creator can finalize the pool
    // smart_contracts/staking-pool/contract.algo.ts:889
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:889
    // assert(this.status.value === PoolStatusDraft, 'the pool must be in draft state to finalize')
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    ==
    assert // the pool must be in draft state to finalize
    // smart_contracts/staking-pool/contract.algo.ts:891
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    global LatestTimestamp
    >
    bnz finalize_bool_true@4
    dig 2
    bnz finalize_bool_false@5
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ initialValue: false, key: PoolGlobalStateKeyAllowLateSignups })
    bytec 19 // "allow_late_signups"
    // smart_contracts/staking-pool/contract.algo.ts:891
    // signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@5

finalize_bool_true@4:
    intc_1 // 1

finalize_bool_merge@6:
    // smart_contracts/staking-pool/contract.algo.ts:890-893
    // assert(
    //   signupTimestamp > Global.latestTimestamp || (signupTimestamp === 0 && this.allowLateSignups.value),
    //   'the signup round must be zero and late sign ups allowed or in the future'
    // )
    assert // the signup round must be zero and late sign ups allowed or in the future
    // smart_contracts/staking-pool/contract.algo.ts:896-897
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    dig 1
    bz finalize_bool_true@8
    // smart_contracts/staking-pool/contract.algo.ts:897
    // startTimestamp > Global.latestTimestamp,
    dig 1
    global LatestTimestamp
    >
    // smart_contracts/staking-pool/contract.algo.ts:896-897
    // startTimestamp === 0 ||
    // startTimestamp > Global.latestTimestamp,
    bz finalize_bool_false@9

finalize_bool_true@8:
    intc_1 // 1

finalize_bool_merge@10:
    // smart_contracts/staking-pool/contract.algo.ts:895-899
    // assert(
    //   startTimestamp === 0 ||
    //   startTimestamp > Global.latestTimestamp,
    //   'the starting round must be zero or in the future'
    // )
    assert // the starting round must be zero or in the future
    // smart_contracts/staking-pool/contract.algo.ts:901
    // if (startTimestamp === 0) {
    dig 1
    bnz finalize_after_if_else@16
    // smart_contracts/staking-pool/contract.algo.ts:902
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    dig 2
    bnz finalize_bool_false@14
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ initialValue: false, key: PoolGlobalStateKeyAllowLateSignups })
    bytec 19 // "allow_late_signups"
    // smart_contracts/staking-pool/contract.algo.ts:902
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    app_global_get_ex
    assert // check GlobalState exists
    bz finalize_bool_false@14
    intc_1 // 1

finalize_bool_merge@15:
    // smart_contracts/staking-pool/contract.algo.ts:902
    // assert(signupTimestamp === 0 && this.allowLateSignups.value, 'if the starting round is zero, the signup round must be zero and allowLateSignups must be true')
    assert // if the starting round is zero, the signup round must be zero and allowLateSignups must be true
    // smart_contracts/staking-pool/contract.algo.ts:903
    // startTimestamp = Global.latestTimestamp
    global LatestTimestamp
    bury 2

finalize_after_if_else@16:
    // smart_contracts/staking-pool/contract.algo.ts:907
    // endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    dup
    bz finalize_bool_true@18
    dig 1
    pushint 10 // 10
    +
    dig 1
    <
    bz finalize_bool_false@19

finalize_bool_true@18:
    intc_1 // 1

finalize_bool_merge@20:
    // smart_contracts/staking-pool/contract.algo.ts:906-909
    // assert(
    //   endTimestamp === 0 || endTimestamp > (startTimestamp + 10),
    //   'the ending round must be zero or after the starting round + 10'
    // )
    assert // the ending round must be zero or after the starting round + 10
    // smart_contracts/staking-pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeySignupTimestamp })
    bytec 24 // "signup_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:911
    // this.signupTimestamp.value = signupTimestamp
    dig 3
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:912
    // this.startTimestamp.value = startTimestamp
    dig 2
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:913
    // this.endTimestamp.value = endTimestamp
    dig 1
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:914
    // this.status.value = PoolStatusFinal
    bytec 7 // 0x0a
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:887
    // finalize(signupTimestamp: uint64, startTimestamp: uint64, endTimestamp: uint64) {
    intc_1 // 1
    return

finalize_bool_false@19:
    intc_0 // 0
    b finalize_bool_merge@20

finalize_bool_false@14:
    intc_0 // 0
    b finalize_bool_merge@15

finalize_bool_false@9:
    intc_0 // 0
    b finalize_bool_merge@10

finalize_bool_false@5:
    intc_0 // 0
    b finalize_bool_merge@6


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.gatedEnter[routing]() -> void:
gatedEnter:
    // smart_contracts/staking-pool/contract.algo.ts:917-921
    // gatedEnter(
    //   payment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   entries: StakeEntry[],
    // ): void {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    // smart_contracts/staking-pool/contract.algo.ts:922
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:922
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    txn Sender
    swap
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz gatedEnter_after_if_else@3
    dup

gatedEnter_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/staking-pool/contract.algo.ts:925
    // assert(this.gateID.value !== 0, 'gate id is not set')
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:925
    // assert(this.gateID.value !== 0, 'gate id is not set')
    app_global_get_ex
    assert // check GlobalState exists
    dup
    assert // gate id is not set
    // smart_contracts/staking-pool/contract.algo.ts:926
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, this.gateID.value), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:926
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, this.gateID.value), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    dup
    uncover 2
    uncover 4
    uncover 4
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/utils/functions.ts:239
    // return decodeArc4<GateArgs>(gateTxn.appArgs(3))
    pushint 3 // 3
    gtxnsas ApplicationArgs
    // smart_contracts/staking-pool/contract.algo.ts:928
    // this.createPoolEntries(payment, entries, getGateArgs(gateTxn))
    dig 5
    dig 4
    uncover 2
    callsub createPoolEntries
    popn 2
    // smart_contracts/staking-pool/contract.algo.ts:917-921
    // gatedEnter(
    //   payment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   entries: StakeEntry[],
    // ): void {
    intc_1 // 1
    return

gatedEnter_after_if_else@3:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 1
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 36 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:146
    // return originOr(walletID, Txn.sender)
    b gatedEnter_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.enter[routing]() -> void:
enter:
    // smart_contracts/staking-pool/contract.algo.ts:931
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[]): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/staking-pool/contract.algo.ts:932
    // this.createPoolEntries(payment, entries, [])
    bytec 6 // 0x0000
    callsub createPoolEntries
    popn 2
    // smart_contracts/staking-pool/contract.algo.ts:931
    // enter(payment: gtxn.PaymentTxn, entries: StakeEntry[]): void {
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.startDisbursement[routing]() -> void:
startDisbursement:
    // smart_contracts/staking-pool/contract.algo.ts:935
    // startDisbursement(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:936
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive
    assert // the pool is not live
    // smart_contracts/staking-pool/contract.algo.ts:937
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/staking-pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 21 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/staking-pool/contract.algo.ts:937
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/staking-pool/contract.algo.ts:939
    // const { phase, interval, lastDisbursementTimestamp, expiration } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 116 // 116
    intc_2 // 8
    box_extract
    btoi
    cover 3
    uncover 2
    pushint 17 // 17
    intc_2 // 8
    box_extract
    btoi
    cover 2
    // smart_contracts/staking-pool/contract.algo.ts:941
    // assert(phase === DisbursementPhaseIdle, 'reward is already in a disbursement phase')
    swap
    bytec_3 // 0x00
    ==
    assert // reward is already in a disbursement phase
    // smart_contracts/staking-pool/contract.algo.ts:516
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    global LatestTimestamp
    dup
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:516
    // return Global.latestTimestamp - ((Global.latestTimestamp - this.startTimestamp.value) % interval)
    app_global_get_ex
    assert // check GlobalState exists
    -
    uncover 2
    %
    -
    dup
    // smart_contracts/staking-pool/contract.algo.ts:521
    // return latestWindowStart !== Global.latestTimestamp && last < latestWindowStart
    global LatestTimestamp
    !=
    bz startDisbursement_bool_false@4
    dig 2
    dig 1
    <
    bz startDisbursement_bool_false@4
    intc_1 // 1

startDisbursement_bool_merge@5:
    // smart_contracts/staking-pool/contract.algo.ts:942
    // assert(this.validWindow(interval, lastDisbursementTimestamp), 'distribution window is not open')
    assert // distribution window is not open
    // smart_contracts/staking-pool/contract.algo.ts:945
    // `${this.title.value} - Rewards`,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 28 // "title"
    // smart_contracts/staking-pool/contract.algo.ts:945
    // `${this.title.value} - Rewards`,
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes " - Rewards"
    concat
    // smart_contracts/staking-pool/contract.algo.ts:946
    // Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/staking-pool/contract.algo.ts:947
    // Global.latestTimestamp + expiration
    dup
    dig 4
    +
    // smart_contracts/staking-pool/contract.algo.ts:543
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:543
    // const rewardsApp = Application(getAkitaAppList(Global.currentApplicationId).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:544
    // const rewardMBR: uint64 = MinDisbursementsMBR + (BoxCostPerByte * Bytes(title).length)
    dig 3
    len
    intc 6 // 400
    dig 1
    *
    pushint 35300 // 35300
    +
    // smart_contracts/staking-pool/contract.algo.ts:547
    // receiver: rewardsApp.address,
    dig 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/staking-pool/contract.algo.ts:551-560
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    itxn_begin
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/staking-pool/contract.algo.ts:546-549
    // const mbrPayment = itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: rewardMBR,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:551-560
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    itxn_next
    // smart_contracts/staking-pool/contract.algo.ts:555
    // title,
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/staking-pool/contract.algo.ts:556
    // timeToUnlock,
    uncover 3
    itob
    // smart_contracts/staking-pool/contract.algo.ts:557
    // expiration,
    uncover 3
    itob
    // smart_contracts/staking-pool/contract.algo.ts:558
    // '',
    intc_0 // 0
    itob
    // smart_contracts/staking-pool/contract.algo.ts:551-560
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    pushbytes 0x1c9ebbdb // method "createDisbursement(pay,string,uint64,uint64,string)uint64"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/staking-pool/contract.algo.ts:558
    // '',
    bytec 6 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/staking-pool/contract.algo.ts:551-560
    // return abiCall<typeof Rewards.prototype.createDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     mbrPayment,
    //     title,
    //     timeToUnlock,
    //     expiration,
    //     '',
    //   ],
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/staking-pool/contract.algo.ts:950
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 5
    dup
    pushint 33 // 33
    dig 4
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:951
    // this.rewards(rewardID).value.qualifiedStake = 0
    dup
    pushint 41 // 41
    dig 4
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:952
    // this.rewards(rewardID).value.phase = DisbursementPhasePreparation
    dup
    pushint 91 // 91
    bytec 7 // 0x0a
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:953
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    uncover 4
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:954
    // this.rewards(rewardID).value.activeDisbursementID = disbursementID
    dup
    pushint 100 // 100
    uncover 3
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:955
    // this.rewards(rewardID).value.activeDisbursementRoundStart = Global.round
    global Round
    itob
    dig 1
    pushint 108 // 108
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:956
    // this.rewards(rewardID).value.lastDisbursementTimestamp = Global.latestTimestamp
    global LatestTimestamp
    itob
    pushint 116 // 116
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:935
    // startDisbursement(rewardID: uint64): void {
    intc_1 // 1
    return

startDisbursement_bool_false@4:
    intc_0 // 0
    b startDisbursement_bool_merge@5


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle[routing]() -> void:
raffle:
    // smart_contracts/staking-pool/contract.algo.ts:959
    // raffle(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.disburseRewards[routing]() -> void:
disburseRewards:
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 24
    // smart_contracts/staking-pool/contract.algo.ts:999
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/staking-pool/contract.algo.ts:1001
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/staking-pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 21 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/staking-pool/contract.algo.ts:1001
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/staking-pool/contract.algo.ts:1003
    // const { phase, distribution, winningTickets } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dup
    uncover 2
    intc_2 // 8
    intc_1 // 1
    box_extract
    swap
    // smart_contracts/staking-pool/contract.algo.ts:1006
    // phase === DisbursementPhasePreparation ||
    bytec 7 // 0x0a
    ==
    dup
    // smart_contracts/staking-pool/contract.algo.ts:1006-1007
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bnz disburseRewards_bool_true@3
    // smart_contracts/staking-pool/contract.algo.ts:1007
    // phase === DisbursementPhaseAllocation,
    dig 2
    bytec 12 // 0x14
    ==
    // smart_contracts/staking-pool/contract.algo.ts:1006-1007
    // phase === DisbursementPhasePreparation ||
    // phase === DisbursementPhaseAllocation,
    bz disburseRewards_bool_false@4

disburseRewards_bool_true@3:
    intc_1 // 1

disburseRewards_bool_merge@5:
    // smart_contracts/staking-pool/contract.algo.ts:1005-1009
    // assert(
    //   phase === DisbursementPhasePreparation ||
    //   phase === DisbursementPhaseAllocation,
    //   ERR_NOT_READY_TO_DISBURSE
    // )
    assert // Not ready to disburse
    // smart_contracts/staking-pool/contract.algo.ts:1011
    // if (phase === DisbursementPhasePreparation) {
    dup
    bz disburseRewards_else_body@7
    // smart_contracts/staking-pool/contract.algo.ts:218
    // const { disbursementCursor, distribution, rate, asset } = this.rewards(rewardID).value
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 21
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    bury 4
    dup
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 14
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 27
    // smart_contracts/staking-pool/contract.algo.ts:219
    // let count: uint64 = 0
    intc_0 // 0
    bury 25
    // smart_contracts/staking-pool/contract.algo.ts:220
    // let total: uint64 = 0
    intc_0 // 0
    bury 9
    // smart_contracts/staking-pool/contract.algo.ts:222
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:222
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@91
    // smart_contracts/staking-pool/contract.algo.ts:223
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:223
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    -
    bury 5

disburseRewards_after_if_else@91:
    dig 18
    bury 16

disburseRewards_while_top@92:
    // smart_contracts/staking-pool/contract.algo.ts:226
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    dig 5
    <
    bz disburseRewards_after_while@104
    // smart_contracts/staking-pool/contract.algo.ts:227
    // const { disqualified, quantity } = clone(this.entries(id).value)
    dig 15
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    dup
    bury 33
    // smart_contracts/staking-pool/contract.algo.ts:227
    // const { disqualified, quantity } = clone(this.entries(id).value)
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 14
    // smart_contracts/staking-pool/contract.algo.ts:228
    // if (disqualified) {
    bnz disburseRewards_block@103
    // smart_contracts/staking-pool/contract.algo.ts:525
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:525
    // if (this.type.value === POOL_STAKING_TYPE_NONE) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    ==
    bz disburseRewards_else_body@97
    // smart_contracts/staking-pool/contract.algo.ts:526
    // return { valid: true, balance: 0 }
    pushbytes 0x800000000000000000

disburseRewards_after_inlined_smart_contracts/staking-pool/contract.algo.ts::StakingPool.getStakeValue@100:
    // smart_contracts/staking-pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    intc_0 // 0
    getbit
    // smart_contracts/staking-pool/contract.algo.ts:234
    // if (!valid) {
    bz disburseRewards_block@103
    // smart_contracts/staking-pool/contract.algo.ts:251
    // count += 1
    dig 23
    intc_1 // 1
    +
    bury 24
    // smart_contracts/staking-pool/contract.algo.ts:252
    // total += quantity
    dig 7
    dig 13
    +
    bury 8

disburseRewards_block@103:
    // smart_contracts/staking-pool/contract.algo.ts:226
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    intc_1 // 1
    +
    bury 16
    b disburseRewards_while_top@92

disburseRewards_else_body@97:
    // smart_contracts/staking-pool/contract.algo.ts:527
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:527
    // } else if (this.type.value === POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 7 // 0x0a
    ==
    bz disburseRewards_after_if_else@99
    // smart_contracts/staking-pool/contract.algo.ts:528
    // const { address, asset } = this.entries(id).value
    dig 31
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    swap
    pushint 32 // 32
    intc_2 // 8
    box_extract
    // smart_contracts/staking-pool/contract.algo.ts:530-533
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [address, asset, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:531
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:531
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:531
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:530-533
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [address, asset, true],
    // }).returnValue
    pushbytes 0xc6fd0ca5 // method "getHeartbeatAverage(address,uint64,bool)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/staking-pool/contract.algo.ts:532
    // args: [address, asset, true],
    bytec 18 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/staking-pool/contract.algo.ts:530-533
    // const avg = abiCall<typeof Staking.prototype.getHeartbeatAverage>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [address, asset, true],
    // }).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:535
    // return { valid: true, balance: avg }
    itob
    bytec 18 // 0x80
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/staking-pool/contract.algo.ts::StakingPool.getStakeValue@100

disburseRewards_after_if_else@99:
    // smart_contracts/staking-pool/contract.algo.ts:538
    // return this.checkByID(id)
    dig 15
    callsub checkByID
    // smart_contracts/staking-pool/contract.algo.ts:233
    // const { valid } = this.getStakeValue(id)
    b disburseRewards_after_inlined_smart_contracts/staking-pool/contract.algo.ts::StakingPool.getStakeValue@100

disburseRewards_after_while@104:
    // smart_contracts/staking-pool/contract.algo.ts:255
    // this.rewards(rewardID).value.qualifiedStakers += count
    dig 3
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 25
    +
    itob
    dig 1
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:256
    // this.rewards(rewardID).value.qualifiedStake += total
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    dig 9
    +
    itob
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:258
    // if (this.entryID.value === disbursementCursor) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:258
    // if (this.entryID.value === disbursementCursor) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    ==
    bz disburseRewards_else_body@111
    // smart_contracts/staking-pool/contract.algo.ts:260
    // this.rewards(rewardID).value.phase = DisbursementPhaseAllocation
    dig 3
    dup
    pushint 91 // 91
    bytec 12 // 0x14
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:261
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_0 // 0
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:263
    // this.payAkitaRoyalty(distribution, rate, asset, this.rewards(rewardID).value.qualifiedStakers)
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 14
    // smart_contracts/staking-pool/contract.algo.ts:188
    // if (distribution === DistributionTypeFlat) {
    dig 1
    bytec 12 // 0x14
    ==
    bz disburseRewards_else_body@107
    // smart_contracts/staking-pool/contract.algo.ts:189
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    dig 13
    dig 12
    *
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 27 // "akita_royalty"
    // smart_contracts/staking-pool/contract.algo.ts:189
    // amount = calcPercent((qualifiedStakers * rate), this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    mulw
    intc 4 // 100000
    divw
    bury 27

disburseRewards_after_if_else@108:
    // smart_contracts/staking-pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 22 // "akita_royalty_amount"
    // smart_contracts/staking-pool/contract.algo.ts:194
    // this.akitaRoyaltyAmount.value = amount
    dig 27
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:197
    // if (asset === 0) {
    dig 25
    bnz disburseRewards_else_body@110
    // smart_contracts/staking-pool/contract.algo.ts:198-203
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:200
    // receiver: Global.zeroAddress,
    global ZeroAddress
    dig 27
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking-pool/contract.algo.ts:198-202
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:198-203
    // itxn
    //   .payment({
    //     receiver: Global.zeroAddress,
    //     amount,
    //   })
    //   .submit()
    itxn_submit

disburseRewards_after_if_else@30:
    // smart_contracts/staking-pool/contract.algo.ts:999
    // disburseRewards(rewardID: uint64, iterationAmount: uint64): void {
    intc_1 // 1
    return

disburseRewards_else_body@110:
    // smart_contracts/staking-pool/contract.algo.ts:205
    // assert(Global.zeroAddress.isOptedIn(Asset(asset)), ERR_DAO_NOT_OPTED_IN)
    global ZeroAddress
    dig 26
    dup
    cover 2
    asset_holding_get AssetBalance
    bury 1
    assert // DAO not opted in to the asset
    // smart_contracts/staking-pool/contract.algo.ts:207-213
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:209
    // assetReceiver: Global.zeroAddress,
    global ZeroAddress
    swap
    itxn_field XferAsset
    dig 27
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking-pool/contract.algo.ts:207-212
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:207-213
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.zeroAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    b disburseRewards_after_if_else@30

disburseRewards_else_body@107:
    // smart_contracts/staking-pool/contract.algo.ts:191
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 27 // "akita_royalty"
    // smart_contracts/staking-pool/contract.algo.ts:191
    // amount = calcPercent(rate, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 12
    mulw
    intc 4 // 100000
    divw
    bury 27
    b disburseRewards_after_if_else@108

disburseRewards_else_body@111:
    // smart_contracts/staking-pool/contract.algo.ts:266
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    intc_3 // 92
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_else_body@7:
    // smart_contracts/staking-pool/contract.algo.ts:1015
    // case DistributionTypePercentage: {
    dig 1
    bytec 7 // 0x0a
    ==
    // smart_contracts/staking-pool/contract.algo.ts:1015-1018
    // case DistributionTypePercentage: {
    //   this.createPercentageDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@11
    // smart_contracts/staking-pool/contract.algo.ts:277
    // } = this.rewards(rewardID).value
    dig 3
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    bury 27
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 21
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 33
    dup
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    bury 17
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    bury 28
    // smart_contracts/staking-pool/contract.algo.ts:279
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:279
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@79
    // smart_contracts/staking-pool/contract.algo.ts:280
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:280
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    -
    bury 5

disburseRewards_after_if_else@79:
    // smart_contracts/staking-pool/contract.algo.ts:283
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 22 // "akita_royalty_amount"
    // smart_contracts/staking-pool/contract.algo.ts:283
    // const actualAmount: uint64 = amount - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    dig 27
    swap
    -
    bury 30
    // smart_contracts/staking-pool/contract.algo.ts:284
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 37
    bytec 6 // 0x0000
    bury 33
    // smart_contracts/staking-pool/contract.algo.ts:285
    // let sum: uint64 = 0
    intc_0 // 0
    bury 10
    dig 18
    bury 16

disburseRewards_while_top@80:
    // smart_contracts/staking-pool/contract.algo.ts:287
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    dig 5
    <
    bz disburseRewards_after_while@85
    // smart_contracts/staking-pool/contract.algo.ts:288
    // const { disqualified, quantity, address } = this.entries(id).value
    dig 15
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:288
    // const { disqualified, quantity, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    bury 15
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 39
    // smart_contracts/staking-pool/contract.algo.ts:289
    // if (disqualified) {
    bnz disburseRewards_block@84
    // smart_contracts/utils/functions.ts:109
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    dig 12
    dup
    dig 16
    dup
    cover 3
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:110
    // return op.divw(...op.mulw(a, DIVISOR), b)
    intc 4 // 100000
    mulw
    uncover 2
    divw
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 30
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/staking-pool/contract.algo.ts:294
    // allocations.push({ address, amount: individualAmount })
    dup
    itob
    dig 39
    swap
    concat
    dig 34
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 34
    // smart_contracts/staking-pool/contract.algo.ts:295
    // sum += individualAmount
    dig 10
    +
    bury 10

disburseRewards_block@84:
    // smart_contracts/staking-pool/contract.algo.ts:287
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    intc_1 // 1
    +
    bury 16
    b disburseRewards_while_top@80

disburseRewards_after_while@85:
    // smart_contracts/staking-pool/contract.algo.ts:298
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    dup
    cover 3
    +
    itob
    intc_3 // 92
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:300
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 27
    dig 35
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/staking-pool/contract.algo.ts:302
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:302
    // if (this.entryID.value === (disbursementCursor + iterationAmount)) {
    app_global_get_ex
    assert // check GlobalState exists
    dig 20
    uncover 2
    +
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/staking-pool/contract.algo.ts:303
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:304
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 38
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@11:
    // smart_contracts/staking-pool/contract.algo.ts:1019
    // case DistributionTypeFlat: {
    dig 1
    bytec 12 // 0x14
    ==
    // smart_contracts/staking-pool/contract.algo.ts:1019-1022
    // case DistributionTypeFlat: {
    //   this.createFlatDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@15
    // smart_contracts/staking-pool/contract.algo.ts:315
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 32
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 21
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    uncover 2
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 3
    bury 30
    // smart_contracts/staking-pool/contract.algo.ts:317
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    swap
    dig 1
    *
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 22 // "akita_royalty_amount"
    // smart_contracts/staking-pool/contract.algo.ts:317
    // const total: uint64 = (qualifiedStakers * amount) - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    -
    // smart_contracts/staking-pool/contract.algo.ts:318
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:152
    // akitaRoyalty = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyalty })
    bytec 27 // "akita_royalty"
    // smart_contracts/staking-pool/contract.algo.ts:318
    // const percentageAkitaFee = calcPercent(amount, this.akitaRoyalty.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 2
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/staking-pool/contract.algo.ts:319
    // const adjustedAmount: uint64 = amount - percentageAkitaFee
    uncover 2
    swap
    -
    bury 31
    // smart_contracts/staking-pool/contract.algo.ts:320
    // const [balance] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    uncover 2
    asset_holding_get AssetBalance
    pop
    // smart_contracts/staking-pool/contract.algo.ts:322
    // assert(balance >= total, ERR_NOT_ENOUGH_FUNDS)
    <=
    assert // Not enough funds
    // smart_contracts/staking-pool/contract.algo.ts:324
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:324
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@67
    // smart_contracts/staking-pool/contract.algo.ts:325
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:325
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    -
    bury 5

disburseRewards_after_if_else@67:
    // smart_contracts/staking-pool/contract.algo.ts:328
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 36
    bytec 6 // 0x0000
    bury 33
    // smart_contracts/staking-pool/contract.algo.ts:329
    // let sum: uint64 = 0
    intc_0 // 0
    bury 10
    dig 18
    bury 16

disburseRewards_while_top@68:
    // smart_contracts/staking-pool/contract.algo.ts:331
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    dig 5
    <
    bz disburseRewards_after_while@73
    // smart_contracts/staking-pool/contract.algo.ts:332
    // const { disqualified, address } = this.entries(id).value
    dig 15
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:332
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 39
    // smart_contracts/staking-pool/contract.algo.ts:333
    // if (disqualified) {
    bnz disburseRewards_block@72
    // smart_contracts/staking-pool/contract.algo.ts:337
    // allocations.push({ address, amount: adjustedAmount })
    dig 27
    dup
    itob
    dig 39
    swap
    concat
    dig 34
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 34
    // smart_contracts/staking-pool/contract.algo.ts:338
    // sum += adjustedAmount
    dig 10
    +
    bury 10

disburseRewards_block@72:
    // smart_contracts/staking-pool/contract.algo.ts:331
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    intc_1 // 1
    +
    bury 16
    b disburseRewards_while_top@68

disburseRewards_after_while@73:
    // smart_contracts/staking-pool/contract.algo.ts:341
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 18
    dig 5
    +
    // smart_contracts/staking-pool/contract.algo.ts:342
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:343
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 27
    dig 35
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/staking-pool/contract.algo.ts:345
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:345
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/staking-pool/contract.algo.ts:346
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:347
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 37
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@15:
    // smart_contracts/staking-pool/contract.algo.ts:1023
    // case DistributionTypeEven: {
    dig 1
    bytec 13 // 0x1e
    ==
    // smart_contracts/staking-pool/contract.algo.ts:1023-1026
    // case DistributionTypeEven: {
    //   this.createEvenDisbursement(rewardID, iterationAmount)
    //   break
    // }
    bz disburseRewards_after_if_else@19
    // smart_contracts/staking-pool/contract.algo.ts:358
    // } = this.rewards(rewardID).value
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 32
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 21
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    bury 16
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 29
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 13
    // smart_contracts/staking-pool/contract.algo.ts:360
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/staking-pool/contract.algo.ts:361
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 22 // "akita_royalty_amount"
    // smart_contracts/staking-pool/contract.algo.ts:361
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 32
    // smart_contracts/staking-pool/contract.algo.ts:362
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/staking-pool/contract.algo.ts:364
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:364
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@55
    // smart_contracts/staking-pool/contract.algo.ts:365
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:365
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    -
    bury 5

disburseRewards_after_if_else@55:
    // smart_contracts/staking-pool/contract.algo.ts:368
    // const amount: uint64 = actualSum / qualifiedStakers
    dig 28
    dig 14
    /
    bury 27
    // smart_contracts/staking-pool/contract.algo.ts:369
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 35
    bytec 6 // 0x0000
    bury 33
    dig 18
    bury 16

disburseRewards_while_top@56:
    // smart_contracts/staking-pool/contract.algo.ts:370
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    dig 5
    <
    bz disburseRewards_after_while@61
    // smart_contracts/staking-pool/contract.algo.ts:371
    // const { disqualified, address } = this.entries(id).value
    dig 15
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:371
    // const { disqualified, address } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    swap
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 39
    // smart_contracts/staking-pool/contract.algo.ts:372
    // if (disqualified) {
    bnz disburseRewards_block@60
    // smart_contracts/staking-pool/contract.algo.ts:376
    // allocations.push({ address, amount })
    dig 26
    itob
    dig 38
    swap
    concat
    dig 33
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 33

disburseRewards_block@60:
    // smart_contracts/staking-pool/contract.algo.ts:370
    // for (let id = disbursementCursor; id < iterationAmount; id++) {
    dig 15
    intc_1 // 1
    +
    bury 16
    b disburseRewards_while_top@56

disburseRewards_after_while@61:
    // smart_contracts/staking-pool/contract.algo.ts:379
    // const newCursorValue: uint64 = disbursementCursor + iterationAmount
    dig 18
    dig 5
    +
    // smart_contracts/staking-pool/contract.algo.ts:380
    // this.rewards(rewardID).value.disbursementCursor = newCursorValue
    dup
    itob
    dig 5
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:381
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 31
    dig 27
    dig 35
    dig 13
    callsub createRewardAllocations
    pop
    // smart_contracts/staking-pool/contract.algo.ts:383
    // if (this.entryID.value === newCursorValue) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:383
    // if (this.entryID.value === newCursorValue) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz disburseRewards_after_if_else@30
    // smart_contracts/staking-pool/contract.algo.ts:384
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:385
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 36
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@19:
    // smart_contracts/staking-pool/contract.algo.ts:1027
    // case DistributionTypeShuffle: {
    dig 1
    pushbytes 0x28
    ==
    // smart_contracts/staking-pool/contract.algo.ts:1027-1034
    // case DistributionTypeShuffle: {
    //   if (winningTickets.length === 0) {
    //     this.raffle(rewardID)
    //   } else {
    //     this.createShuffleDisbursement(rewardID, iterationAmount)
    //   }
    //   break
    // }
    assert // unknown reward rate type
    // smart_contracts/staking-pool/contract.algo.ts:1028
    // if (winningTickets.length === 0) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    bnz disburseRewards_else_body@24
    // smart_contracts/staking-pool/contract.algo.ts:1029
    // this.raffle(rewardID)
    dig 5
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle
    b disburseRewards_after_if_else@30

disburseRewards_else_body@24:
    // smart_contracts/staking-pool/contract.algo.ts:398
    // } = clone(this.rewards(rewardID).value)
    dig 3
    dup
    pushint 100 // 100
    intc_2 // 8
    box_extract
    btoi
    bury 32
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 21
    dup
    pushint 49 // 49
    intc_2 // 8
    box_extract
    btoi
    bury 9
    dup
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 29
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    bury 13
    // smart_contracts/staking-pool/contract.algo.ts:400
    // const balance = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)[0]
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    pop
    // smart_contracts/staking-pool/contract.algo.ts:401
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:154
    // akitaRoyaltyAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyAkitaRoyaltyAmount })
    bytec 22 // "akita_royalty_amount"
    // smart_contracts/staking-pool/contract.algo.ts:401
    // const actualSum: uint64 = sum - this.akitaRoyaltyAmount.value
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    swap
    -
    dup
    bury 32
    // smart_contracts/staking-pool/contract.algo.ts:402
    // assert(balance >= actualSum, ERR_NOT_ENOUGH_FUNDS)
    >=
    assert // Not enough funds
    // smart_contracts/staking-pool/contract.algo.ts:404
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    dig 5
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:404
    // if ((disbursementCursor + iterationAmount) > this.entryID.value) {
    app_global_get_ex
    assert // check GlobalState exists
    >
    bz disburseRewards_after_if_else@33
    // smart_contracts/staking-pool/contract.algo.ts:405
    // iterationAmount = this.entryID.value - disbursementCursor
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:405
    // iterationAmount = this.entryID.value - disbursementCursor
    app_global_get_ex
    assert // check GlobalState exists
    dig 19
    -
    bury 5

disburseRewards_after_if_else@33:
    // smart_contracts/staking-pool/contract.algo.ts:409
    // if (winnerCount > 0) {
    dig 6
    bnz disburseRewards_if_body@34
    dig 28
    bury 27

disburseRewards_after_if_else@35:
    // smart_contracts/staking-pool/contract.algo.ts:413
    // let { stake, ticket, disbursed } = raffleCursor
    dig 3
    dup
    pushints 59 24 // 59, 24
    box_extract
    dup
    intc_2 // 8
    extract_uint64
    dup
    cover 3
    bury 14
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    bury 13
    pushint 16 // 16
    extract_uint64
    bury 23
    // smart_contracts/staking-pool/contract.algo.ts:414
    // let currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    intc_2 // 8
    box_extract
    btoi
    bury 22
    // smart_contracts/staking-pool/contract.algo.ts:418
    // let allocations: UserAllocation[] = []
    intc_0 // 0
    itob
    bury 35
    bytec 6 // 0x0000
    bury 34
    bury 22
    dig 18
    bury 17

disburseRewards_while_top@36:
    // smart_contracts/staking-pool/contract.algo.ts:419
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 16
    dig 5
    <
    bz disburseRewards_block@48
    // smart_contracts/staking-pool/contract.algo.ts:420
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dig 16
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:420
    // const { disqualified, address, asset, quantity } = this.entries(i).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bury 19
    dup
    intc_0 // 0
    pushint 32 // 32
    box_extract
    bury 39
    dup
    pushint 32 // 32
    intc_2 // 8
    box_extract
    btoi
    bury 26
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:422
    // currentRangeEnd = currentRangeStart + quantity
    dig 22
    dup
    uncover 2
    +
    bury 24
    // smart_contracts/staking-pool/contract.algo.ts:423
    // if (currentTicket >= currentRangeStart && currentTicket <= currentRangeEnd) {
    dig 21
    <=
    bz disburseRewards_after_if_else@46
    dig 20
    dig 23
    <=
    bz disburseRewards_after_if_else@46
    // smart_contracts/staking-pool/contract.algo.ts:424
    // if (!disqualified) {
    dig 17
    bnz disburseRewards_after_if_else@41
    // smart_contracts/staking-pool/contract.algo.ts:425
    // allocations.push({ address, amount })
    dig 26
    itob
    dig 38
    swap
    concat
    dig 33
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 33
    // smart_contracts/staking-pool/contract.algo.ts:426
    // disbursed++
    dig 19
    intc_1 // 1
    +
    bury 20

disburseRewards_after_if_else@41:
    // smart_contracts/staking-pool/contract.algo.ts:429
    // if (ticket === tickets.length - 1) {
    dig 3
    pushints 124 2 // 124, 2
    box_extract
    btoi
    intc_1 // 1
    -
    dig 9
    ==
    bz disburseRewards_after_if_else@45
    // smart_contracts/staking-pool/contract.algo.ts:431
    // if (winnerCount !== disbursed) {
    dig 6
    dig 20
    !=
    bz disburseRewards_block@48
    // smart_contracts/staking-pool/contract.algo.ts:432
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 3
    dup
    intc_3 // 92
    dig 36
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:433-437
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 37 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:438
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 6 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/staking-pool/contract.algo.ts:439
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 30
    dig 25
    dig 34
    dig 12
    callsub createRewardAllocations
    pop
    // smart_contracts/staking-pool/contract.algo.ts:1031
    // this.createShuffleDisbursement(rewardID, iterationAmount)
    b disburseRewards_after_if_else@30

disburseRewards_block@48:
    // smart_contracts/staking-pool/contract.algo.ts:456
    // this.createRewardAllocations(activeDisbursementID, asset, allocations, sum)
    dig 30
    dig 26
    dig 34
    dig 12
    callsub createRewardAllocations
    pop
    // smart_contracts/staking-pool/contract.algo.ts:458
    // if (winnerCount === disbursed) {
    dig 6
    dig 20
    ==
    bz disburseRewards_else_body@50
    // smart_contracts/staking-pool/contract.algo.ts:459
    // this.rewards(rewardID).value.phase = DisbursementPhaseFinalization
    dig 3
    dup
    pushint 91 // 91
    bytec 13 // 0x1e
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:460
    // this.rewards(rewardID).value.disbursementCursor = 0
    dup
    intc_3 // 92
    dig 36
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:461-465
    // this.rewards(rewardID).value.raffleCursor = {
    //   ticket: 0,
    //   stake: 0,
    //   disbursed: 0,
    // }
    dup
    pushint 59 // 59
    bytec 37 // 0x000000000000000000000000000000000000000000000000
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:466
    // this.rewards(rewardID).value.winningTickets = []
    dup
    box_get
    pop
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    bytec 6 // 0x0000
    concat
    dig 1
    box_del
    pop
    box_put
    b disburseRewards_after_if_else@30

disburseRewards_else_body@50:
    // smart_contracts/staking-pool/contract.algo.ts:468
    // this.rewards(rewardID).value.disbursementCursor += iterationAmount
    dig 3
    dup
    intc_3 // 92
    intc_2 // 8
    box_extract
    btoi
    dig 6
    +
    itob
    dig 1
    intc_3 // 92
    uncover 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:469
    // this.rewards(rewardID).value.raffleCursor = { ticket, stake, disbursed }
    dig 9
    itob
    dig 12
    itob
    concat
    dig 21
    itob
    concat
    pushint 59 // 59
    swap
    box_replace
    b disburseRewards_after_if_else@30

disburseRewards_after_if_else@45:
    // smart_contracts/staking-pool/contract.algo.ts:445
    // iterationAmount -= i
    dig 4
    dig 17
    -
    bury 5
    // smart_contracts/staking-pool/contract.algo.ts:446
    // ticket++
    dig 8
    intc_1 // 1
    +
    dup
    bury 10
    // smart_contracts/staking-pool/contract.algo.ts:447
    // currentTicket = tickets[ticket]
    intc_2 // 8
    *
    pushint 126 // 126
    +
    dig 4
    dup
    uncover 2
    intc_2 // 8
    box_extract
    btoi
    bury 22
    // smart_contracts/staking-pool/contract.algo.ts:448
    // this.rewards(rewardID).value.disbursementCursor = 0
    intc_3 // 92
    dig 35
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:449
    // i = 0
    intc_0 // 0
    bury 17
    // smart_contracts/staking-pool/contract.algo.ts:450
    // stake = 0
    intc_0 // 0
    bury 11
    // smart_contracts/staking-pool/contract.algo.ts:451
    // currentRangeEnd = 0
    intc_0 // 0
    bury 23

disburseRewards_after_if_else@46:
    // smart_contracts/staking-pool/contract.algo.ts:453
    // currentRangeStart = currentRangeEnd + 1
    dig 22
    intc_1 // 1
    +
    bury 22
    // smart_contracts/staking-pool/contract.algo.ts:419
    // for (let i = disbursementCursor; i < iterationAmount; i++) {
    dig 16
    intc_1 // 1
    +
    bury 17
    b disburseRewards_while_top@36

disburseRewards_if_body@34:
    // smart_contracts/staking-pool/contract.algo.ts:410
    // amount = actualSum / winnerCount
    dig 28
    dig 7
    /
    bury 27
    b disburseRewards_after_if_else@35

disburseRewards_bool_false@4:
    intc_0 // 0
    b disburseRewards_bool_merge@5


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.finalizeDistribution[routing]() -> void:
finalizeDistribution:
    // smart_contracts/staking-pool/contract.algo.ts:1042
    // finalizeDistribution(rewardID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1043
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    itob
    // smart_contracts/staking-pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 21 // "r"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1043
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    dup
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/staking-pool/contract.algo.ts:1044
    // const { phase, activeDisbursementID } = this.rewards(rewardID).value
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 100 // 100
    intc_2 // 8
    box_extract
    dup
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1045
    // assert(phase === DisbursementPhaseFinalization, ERR_DISBURSEMENT_NOT_READY_FOR_FINALIZATION)
    uncover 2
    bytec 13 // 0x1e
    ==
    assert // Disbursement not ready for finalization
    // smart_contracts/staking-pool/contract.algo.ts:608
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:608
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:608
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:610-613
    // abiCall<typeof Rewards.prototype.finalizeDisbursement>({
    //   appId: rewardsApp,
    //   args: [disbursementID],
    // })
    itxn_begin
    pushbytes 0x5424a591 // method "finalizeDisbursement(uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/staking-pool/contract.algo.ts:1049
    // this.disbursements(activeDisbursementID).create()
    itob
    // smart_contracts/staking-pool/contract.algo.ts:169
    // disbursements = BoxMap<uint64, bytes<0>>({ keyPrefix: PoolBoxPrefixDisbursements })
    pushbytes "d"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1049
    // this.disbursements(activeDisbursementID).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/staking-pool/contract.algo.ts:1051
    // this.rewards(rewardID).value.phase = DisbursementPhaseIdle
    dup
    pushint 91 // 91
    bytec_3 // 0x00
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1052
    // this.rewards(rewardID).value.activeDisbursementID = 0
    intc_0 // 0
    itob
    dig 1
    pushint 100 // 100
    dig 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1053
    // this.rewards(rewardID).value.activeDisbursementRoundStart = 0
    dig 1
    pushint 108 // 108
    dig 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1054
    // this.rewards(rewardID).value.disbursementCursor = 0
    dig 1
    intc_3 // 92
    dig 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1055
    // this.rewards(rewardID).value.qualifiedStakers = 0
    dig 1
    pushint 33 // 33
    dig 2
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1056
    // this.rewards(rewardID).value.qualifiedStake = 0
    pushint 41 // 41
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:1042
    // finalizeDistribution(rewardID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.check[routing]() -> void:
check:
    // smart_contracts/staking-pool/contract.algo.ts:1059
    // check(address: Account, asset: uint64): { valid: boolean, balance: uint64 } {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1060
    // const key: EntryKey = { address, asset }
    itob
    concat
    // smart_contracts/staking-pool/contract.algo.ts:165
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    bytec 30 // "a"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1061
    // const id = this.entriesByAddress(key).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1062
    // return this.checkByID(id)
    callsub checkByID
    // smart_contracts/staking-pool/contract.algo.ts:1059
    // check(address: Account, asset: uint64): { valid: boolean, balance: uint64 } {
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]() -> void:
smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]:
    // smart_contracts/staking-pool/contract.algo.ts:1065
    // gateCheck(gateTxn: gtxn.ApplicationCallTxn, address: Account, asset: uint64) {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dupn 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/staking-pool/contract.algo.ts:1066
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, address)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:1066
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, address)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:139
    // if (walletID.id === 0) {
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_if_else@7
    dig 2

smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_inlined_smart_contracts/utils/functions.ts::originOr@8:
    // smart_contracts/staking-pool/contract.algo.ts:1069
    // const passes = gateCheck(gateTxn, this.akitaDAO.value, origin, this.gateID.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:1069
    // const passes = gateCheck(gateTxn, this.akitaDAO.value, origin, this.gateID.value)
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:1069
    // const passes = gateCheck(gateTxn, this.akitaDAO.value, origin, this.gateID.value)
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    uncover 2
    uncover 3
    uncover 3
    callsub gateCheck
    // smart_contracts/staking-pool/contract.algo.ts:1070
    // if (!passes && this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_if_else@4
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:1070
    // if (!passes && this.type.value !== POOL_STAKING_TYPE_HEARTBEAT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 7 // 0x0a
    !=
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_if_else@4
    // smart_contracts/staking-pool/contract.algo.ts:1071
    // const key: EntryKey = { address, asset }
    dig 1
    itob
    dig 3
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:165
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    bytec 30 // "a"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1072
    // const id = this.entriesByAddress(key).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1073
    // this.entries(id).value.disqualified = true
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1073
    // this.entries(id).value.disqualified = true
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace

smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_if_else@4:
    // smart_contracts/staking-pool/contract.algo.ts:1065
    // gateCheck(gateTxn: gtxn.ApplicationCallTxn, address: Account, asset: uint64) {
    intc_1 // 1
    return

smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_if_else@7:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dup
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    bytec 36 // "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:1067
    // const origin = originOr(wallet, address)
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.gateCheck[routing]_after_inlined_smart_contracts/utils/functions.ts::originOr@8


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.enterCost[routing]() -> void:
enterCost:
    // smart_contracts/staking-pool/contract.algo.ts:1085
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1089
    // let boxMbr: uint64 = entryMBR * entryCount
    intc 10 // 50600
    *
    swap
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    bytec 23 // "u"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1092
    // if (!this.uniques(address).exists) {
    box_len
    bury 1
    bnz enterCost_after_if_else@3
    // smart_contracts/staking-pool/contract.algo.ts:1093
    // boxMbr += PoolUniquesMBR
    intc 11 // 18900
    +

enterCost_after_if_else@3:
    // smart_contracts/staking-pool/contract.algo.ts:1085
    // @abimethod({ readonly: true })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.optInCost[routing]() -> void:
optInCost:
    // smart_contracts/staking-pool/contract.algo.ts:1099
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/contract.algo.ts:1101
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:1101
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/staking-pool/contract.algo.ts:1101
    // const count = splitOptInCount(this.akitaDAO.value, this.akitaDAOEscrow.value.address, asset)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 2
    callsub splitOptInCount
    // smart_contracts/staking-pool/contract.algo.ts:1102
    // return (Global.assetOptInMinBalance * (1 + count)) + (this.rewardsMbr(WinnerCountCap) * 2)
    global AssetOptInMinBalance
    intc_1 // 1
    uncover 2
    +
    *
    pushint 8000 // 8000
    +
    // smart_contracts/staking-pool/contract.algo.ts:1099
    // @abimethod({ readonly: true })
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.signUpsOpen[routing]() -> void:
signUpsOpen:
    // smart_contracts/staking-pool/contract.algo.ts:1109
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:1109
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    !=
    // smart_contracts/staking-pool/contract.algo.ts:1109-1110
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/staking-pool/contract.algo.ts:1110
    // Global.latestTimestamp > this.signupTimestamp.value &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeySignupTimestamp })
    bytec 24 // "signup_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1110
    // Global.latestTimestamp > this.signupTimestamp.value &&
    app_global_get_ex
    assert // check GlobalState exists
    >
    // smart_contracts/staking-pool/contract.algo.ts:1109-1110
    // this.status.value !== PoolStatusDraft &&
    // Global.latestTimestamp > this.signupTimestamp.value &&
    bz signUpsOpen_bool_false@6
    // smart_contracts/staking-pool/contract.algo.ts:1111
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1111
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    <
    bnz signUpsOpen_bool_true@5
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ initialValue: false, key: PoolGlobalStateKeyAllowLateSignups })
    bytec 19 // "allow_late_signups"
    // smart_contracts/staking-pool/contract.algo.ts:1111
    // (Global.latestTimestamp < this.startTimestamp.value || this.allowLateSignups.value)
    app_global_get_ex
    assert // check GlobalState exists
    bz signUpsOpen_bool_false@6

signUpsOpen_bool_true@5:
    intc_1 // 1

signUpsOpen_bool_merge@7:
    // smart_contracts/staking-pool/contract.algo.ts:1106
    // @abimethod({ readonly: true })
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

signUpsOpen_bool_false@6:
    intc_0 // 0
    b signUpsOpen_bool_merge@7


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive[routing]() -> void:
isLive:
    // smart_contracts/staking-pool/contract.algo.ts:1116
    // @abimethod({ readonly: true })
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.isEntered[routing]() -> void:
isEntered:
    // smart_contracts/staking-pool/contract.algo.ts:1126
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    bytec 23 // "u"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1128
    // return this.uniques(address).exists;
    box_len
    bury 1
    // smart_contracts/staking-pool/contract.algo.ts:1126
    // @abimethod({ readonly: true })
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.getState[routing]() -> void:
getState:
    // smart_contracts/staking-pool/contract.algo.ts:1134
    // status: this.status.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:1134
    // status: this.status.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1135
    // title: this.title.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:115
    // title = GlobalState<string>({ key: PoolGlobalStateKeyTitle })
    bytec 28 // "title"
    // smart_contracts/staking-pool/contract.algo.ts:1135
    // title: this.title.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1136
    // type: this.type.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:1136
    // type: this.type.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1137
    // signupTimestamp: this.signupTimestamp.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:119
    // signupTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeySignupTimestamp })
    bytec 24 // "signup_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1137
    // signupTimestamp: this.signupTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1138
    // allowLateSignups: this.allowLateSignups.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:121
    // allowLateSignups = GlobalState<boolean>({ initialValue: false, key: PoolGlobalStateKeyAllowLateSignups })
    bytec 19 // "allow_late_signups"
    // smart_contracts/staking-pool/contract.algo.ts:1138
    // allowLateSignups: this.allowLateSignups.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1139
    // startTimestamp: this.startTimestamp.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1139
    // startTimestamp: this.startTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1140
    // endTimestamp: this.endTimestamp.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1140
    // endTimestamp: this.endTimestamp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1141
    // maxEntries: this.maxEntries.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:1141
    // maxEntries: this.maxEntries.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1142
    // entryCount: (this.entryID.value + 1),
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:1142
    // entryCount: (this.entryID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/staking-pool/contract.algo.ts:1143
    // rewardCount: (this.rewardID.value + 1),
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyRewardCount })
    bytec 25 // "reward_count"
    // smart_contracts/staking-pool/contract.algo.ts:1143
    // rewardCount: (this.rewardID.value + 1),
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/staking-pool/contract.algo.ts:1144
    // totalStaked: this.totalStaked.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:133
    // totalStaked = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyTotalStaked })
    bytec 31 // "total_staked"
    // smart_contracts/staking-pool/contract.algo.ts:1144
    // totalStaked: this.totalStaked.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1145
    // stakeKey: this.stakeKey.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 26 // "stake_key"
    // smart_contracts/staking-pool/contract.algo.ts:1145
    // stakeKey: this.stakeKey.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1146
    // minimumStakeAmount: this.minimumStakeAmount.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 29 // "minimum_stake_amount"
    // smart_contracts/staking-pool/contract.algo.ts:1146
    // minimumStakeAmount: this.minimumStakeAmount.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1147
    // gateID: this.gateID.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:142
    // gateID = GlobalState<uint64>({ key: PoolGlobalStateKeyGateID })
    bytec 16 // "gate_id"
    // smart_contracts/staking-pool/contract.algo.ts:1147
    // gateID: this.gateID.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1148
    // creator: this.creator.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:1148
    // creator: this.creator.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:1133-1149
    // return {
    //   status: this.status.value,
    //   title: this.title.value,
    //   type: this.type.value,
    //   signupTimestamp: this.signupTimestamp.value,
    //   allowLateSignups: this.allowLateSignups.value,
    //   startTimestamp: this.startTimestamp.value,
    //   endTimestamp: this.endTimestamp.value,
    //   maxEntries: this.maxEntries.value,
    //   entryCount: (this.entryID.value + 1),
    //   rewardCount: (this.rewardID.value + 1),
    //   totalStaked: this.totalStaked.value,
    //   stakeKey: this.stakeKey.value,
    //   minimumStakeAmount: this.minimumStakeAmount.value,
    //   gateID: this.gateID.value,
    //   creator: this.creator.value,
    // }
    dig 13
    len
    itob
    extract 6 2
    uncover 14
    concat
    uncover 14
    pushbytes 0x006f
    concat
    dig 1
    len
    pushint 111 // 111
    +
    swap
    uncover 15
    concat
    uncover 14
    itob
    concat
    uncover 12
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    uncover 14
    setbit
    concat
    uncover 11
    itob
    concat
    uncover 10
    itob
    concat
    uncover 9
    itob
    concat
    uncover 8
    itob
    concat
    uncover 7
    itob
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:1131
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:132
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:133
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 20 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:133
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:60
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 11 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:134
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:132
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 20 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:50
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/functions.ts:50
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 35 // "pal"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:51
    // const updatePlugin = getPluginAppList(this.akitaDAO.value).update
    pushint 16 // 16
    extract_uint64
    // smart_contracts/utils/base-contracts/base.ts:52
    // assert(Global.callerApplicationId === updatePlugin, ERR_INVALID_UPGRADE)
    global CallerApplicationID
    ==
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:53
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:48
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 20 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:40
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/staking-pool/base.ts::BaseStakingPool.mbr[routing]() -> void:
mbr:
    // smart_contracts/staking-pool/base.ts:13
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/staking-pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/staking-pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    pushbytes 0x00000000000062d400000000000049d400000000000062d4
    swap
    concat
    // smart_contracts/staking-pool/base.ts:20
    // disbursements: PoolDisbursementSMBR
    pushint 6100 // 6100
    // smart_contracts/staking-pool/base.ts:15-21
    // return {
    //   entries: PoolEntriesMBR,
    //   uniques: PoolUniquesMBR,
    //   entriesByAddress: PoolEntriesByAddressMBR,
    //   rewards: this.rewardsMbr(winningTickets),
    //   disbursements: PoolDisbursementSMBR
    // }
    itob
    concat
    // smart_contracts/staking-pool/base.ts:13
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.checkByID(id: uint64) -> bytes:
checkByID:
    // smart_contracts/staking-pool/contract.algo.ts:473
    // private checkByID(id: uint64): { valid: boolean, balance: uint64 } {
    proto 1 1
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 3
    // smart_contracts/staking-pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    !=
    bnz checkByID_bool_true@2
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:475
    // this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    app_global_get_ex
    assert // check GlobalState exists
    bytec 7 // 0x0a
    !=
    bz checkByID_bool_false@3

checkByID_bool_true@2:
    intc_1 // 1

checkByID_bool_merge@4:
    // smart_contracts/staking-pool/contract.algo.ts:474-477
    // assert(
    //   this.type.value !== POOL_STAKING_TYPE_NONE || this.type.value !== POOL_STAKING_TYPE_HEARTBEAT,
    //   ERR_INVALID_POOL_TYPE_FOR_CHECK
    // )
    assert // Invalid pool type for check
    // smart_contracts/staking-pool/contract.algo.ts:479
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    frame_dig -1
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/staking-pool/contract.algo.ts:479
    // const { disqualified, address, asset, quantity } = this.entries(id).value
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    intc_0 // 0
    pushint 32 // 32
    box_extract
    frame_bury 0
    dig 1
    pushint 32 // 32
    intc_2 // 8
    box_extract
    dup
    frame_bury 1
    btoi
    frame_bury 3
    swap
    pushint 40 // 40
    intc_2 // 8
    box_extract
    btoi
    frame_bury 4
    // smart_contracts/staking-pool/contract.algo.ts:481
    // if (disqualified) {
    bz checkByID_after_if_else@6
    // smart_contracts/staking-pool/contract.algo.ts:482
    // return { valid: false, balance: 0 }
    bytec 38 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_after_if_else@6:
    // smart_contracts/staking-pool/contract.algo.ts:485
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:485
    // if (this.type.value === POOL_STAKING_TYPE_SOFT) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 12 // 0x14
    ==
    bz checkByID_else_body@11
    // smart_contracts/staking-pool/contract.algo.ts:486-489
    // const check = abiCall<typeof Staking.prototype.softCheck>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [address, asset],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:487
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:487
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:487
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:486-489
    // const check = abiCall<typeof Staking.prototype.softCheck>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [address, asset],
    // }).returnValue
    pushbytes 0x48716f1a // method "softCheck(address,uint64)(bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 9 // 9
    ==
    assert // invalid number of bytes for (bool1,uint64)
    pushint 5 // 5
    // smart_contracts/staking-pool/contract.algo.ts:491
    // if (check.balance >= quantity) {
    extract_uint64
    dup
    frame_bury 5
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/staking-pool/contract.algo.ts:492
    // return { valid: true, balance: check.balance }
    frame_dig 5
    itob
    bytec 18 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_after_if_else@15:
    // smart_contracts/staking-pool/contract.algo.ts:511
    // this.entries(id).value.disqualified = true
    frame_dig 2
    dup
    pushint 50 // 50
    intc_1 // 1
    box_extract
    intc_0 // 0
    intc_1 // 1
    setbit
    pushint 50 // 50
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:512
    // return { valid: false, balance: 0 }
    bytec 38 // 0x000000000000000000
    frame_bury 0
    retsub

checkByID_else_body@11:
    // smart_contracts/staking-pool/contract.algo.ts:495-504
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     address,
    //     {
    //       asset: asset,
    //       type: this.type.value,
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:496
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:496
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:496
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:501
    // type: this.type.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:501
    // type: this.type.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:499-502
    // {
    //   asset: asset,
    //   type: this.type.value,
    // },
    frame_dig 3
    itob
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:495-504
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     address,
    //     {
    //       asset: asset,
    //       type: this.type.value,
    //     },
    //   ],
    // }).returnValue
    bytec 39 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 4 // 4
    // smart_contracts/staking-pool/contract.algo.ts:506
    // if (info.amount >= quantity) {
    extract_uint64
    dup
    frame_bury 6
    frame_dig 4
    >=
    bz checkByID_after_if_else@15
    // smart_contracts/staking-pool/contract.algo.ts:507
    // return { valid: true, balance: info.amount }
    frame_dig 6
    itob
    bytec 18 // 0x80
    swap
    concat
    frame_bury 0
    retsub

checkByID_bool_false@3:
    intc_0 // 0
    b checkByID_bool_merge@4


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.createRewardAllocations(disbursementID: uint64, asset: uint64, allocations: bytes, sum: uint64) -> bytes:
createRewardAllocations:
    // smart_contracts/staking-pool/contract.algo.ts:563-568
    // private createRewardAllocations(
    //   disbursementID: uint64,
    //   asset: uint64,
    //   allocations: UserAllocation[],
    //   sum: uint64
    // ): void {
    proto 4 1
    // smart_contracts/staking-pool/contract.algo.ts:570
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:570
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:570
    // const rewardsApp = Application(getAkitaAppList(this.akitaDAO.value).rewards)
    intc_2 // 8
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:641
    // return 24_900 * allocations.length
    frame_dig -2
    intc_0 // 0
    extract_uint16
    pushint 24900 // 24900
    *
    swap
    // smart_contracts/staking-pool/contract.algo.ts:573
    // if (asset === 0) {
    frame_dig -3
    bnz createRewardAllocations_else_body@6
    // smart_contracts/staking-pool/contract.algo.ts:575-585
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:579
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/staking-pool/contract.algo.ts:580
    // amount: mbrAmount + sum,
    frame_dig 0
    frame_dig -1
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking-pool/contract.algo.ts:578-581
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount + sum,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:575-585
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/staking-pool/contract.algo.ts:582
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/staking-pool/contract.algo.ts:575-585
    // abiCall<typeof Rewards.prototype.createUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount + sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x5656acf9 // method "createUserAllocations(pay,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

createRewardAllocations_after_if_else@10:
    frame_dig -2
    swap
    retsub

createRewardAllocations_else_body@6:
    // smart_contracts/staking-pool/contract.algo.ts:588-603
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:592
    // receiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking-pool/contract.algo.ts:591-594
    // itxn.payment({
    //   receiver: rewardsApp.address,
    //   amount: mbrAmount,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:595-599
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    itxn_next
    // smart_contracts/staking-pool/contract.algo.ts:596
    // assetReceiver: rewardsApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/staking-pool/contract.algo.ts:595-599
    // itxn.assetTransfer({
    //   assetReceiver: rewardsApp.address,
    //   xferAsset: asset,
    //   assetAmount: sum,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking-pool/contract.algo.ts:588-603
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    itxn_next
    // smart_contracts/staking-pool/contract.algo.ts:600
    // disbursementID,
    frame_dig -4
    itob
    // smart_contracts/staking-pool/contract.algo.ts:588-603
    // abiCall<typeof Rewards.prototype.createAsaUserAllocations>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: rewardsApp.address,
    //       amount: mbrAmount,
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: rewardsApp.address,
    //       xferAsset: asset,
    //       assetAmount: sum,
    //     }),
    //     disbursementID,
    //     allocations,
    //   ],
    // })
    pushbytes 0x3c60dfa0 // method "createAsaUserAllocations(pay,axfer,uint64,(address,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b createRewardAllocations_after_if_else@10


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.createPoolEntries(payment: uint64, entries: bytes, gateArgs: bytes) -> bytes, bytes:
createPoolEntries:
    // smart_contracts/staking-pool/contract.algo.ts:644
    // private createPoolEntries(payment: gtxn.PaymentTxn, entries: StakeEntry[], gateArgs: GateArgs): void {
    proto 3 2
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 4
    // smart_contracts/staking-pool/contract.algo.ts:645
    // assert(this.isLive(), 'the pool is not live')
    callsub smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive
    assert // the pool is not live
    // smart_contracts/staking-pool/contract.algo.ts:648
    // (this.entryID.value + 1) <= this.maxEntries.value ||
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:648
    // (this.entryID.value + 1) <= this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:648
    // (this.entryID.value + 1) <= this.maxEntries.value ||
    app_global_get_ex
    assert // check GlobalState exists
    <=
    // smart_contracts/staking-pool/contract.algo.ts:648-649
    // (this.entryID.value + 1) <= this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz createPoolEntries_bool_true@2
    // smart_contracts/staking-pool/contract.algo.ts:649
    // this.maxEntries.value === 0,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:649
    // this.maxEntries.value === 0,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:648-649
    // (this.entryID.value + 1) <= this.maxEntries.value ||
    // this.maxEntries.value === 0,
    bnz createPoolEntries_bool_false@3

createPoolEntries_bool_true@2:
    intc_1 // 1

createPoolEntries_bool_merge@4:
    // smart_contracts/staking-pool/contract.algo.ts:647-651
    // assert(
    //   (this.entryID.value + 1) <= this.maxEntries.value ||
    //   this.maxEntries.value === 0,
    //   'pool has reached maximum entries'
    // )
    assert // pool has reached maximum entries
    // smart_contracts/staking-pool/contract.algo.ts:655
    // let total: uint64 = entryMBR * entries.length
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 3
    intc 10 // 50600
    *
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    bytec 23 // "u"
    // smart_contracts/staking-pool/contract.algo.ts:656
    // if (!this.uniques(Txn.sender).exists) {
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    concat
    // smart_contracts/staking-pool/contract.algo.ts:656
    // if (!this.uniques(Txn.sender).exists) {
    box_len
    bury 1
    bnz createPoolEntries_after_if_else@6
    // smart_contracts/staking-pool/contract.algo.ts:657
    // total += PoolUniquesMBR
    intc 11 // 18900
    +

createPoolEntries_after_if_else@6:
    // smart_contracts/staking-pool/contract.algo.ts:660-667
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: { greaterThanEq: total },
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/staking-pool/contract.algo.ts:663
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking-pool/contract.algo.ts:660-667
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: { greaterThanEq: total },
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -3
    gtxns Amount
    uncover 2
    >=
    &&
    assert // Invalid payment
    // smart_contracts/staking-pool/contract.algo.ts:669
    // const { address, name } = this.stakeKey.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 26 // "stake_key"
    // smart_contracts/staking-pool/contract.algo.ts:669
    // const { address, name } = this.stakeKey.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    extract 0 32
    frame_bury 0
    dup
    pushint 32 // 32
    extract_uint16
    dig 1
    len
    substring3
    frame_bury 1
    // smart_contracts/staking-pool/contract.algo.ts:671
    // for (let i: uint64 = 0; i < entries.length; i++) {
    intc_0 // 0
    frame_bury 5

createPoolEntries_while_top@7:
    // smart_contracts/staking-pool/contract.algo.ts:671
    // for (let i: uint64 = 0; i < entries.length; i++) {
    frame_dig 5
    frame_dig 3
    <
    bz createPoolEntries_after_while@25
    // smart_contracts/staking-pool/contract.algo.ts:672
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    frame_dig -2
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 5
    frame_dig 3
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    frame_bury 2
    intc_2 // 8
    extract_uint64
    dup
    frame_bury 6
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:140
    // minimumStakeAmount = GlobalState<uint64>({ key: PoolGlobalStateKeyMinimumStakeAmount })
    bytec 29 // "minimum_stake_amount"
    // smart_contracts/staking-pool/contract.algo.ts:672
    // assert(entries[i].quantity >= this.minimumStakeAmount.value, 'quantity is less than minimum stake amount')
    app_global_get_ex
    assert // check GlobalState exists
    >=
    assert // quantity is less than minimum stake amount
    // smart_contracts/staking-pool/contract.algo.ts:674
    // if (address !== Global.zeroAddress) {
    frame_dig 0
    global ZeroAddress
    !=
    bz createPoolEntries_after_if_else@11
    // smart_contracts/staking-pool/contract.algo.ts:675-684
    // const verified = abiCall<typeof MetaMerkles.prototype.verify>({
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     sha256(sha256(itob(entries[i].asset))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:676
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:676
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:676
    // appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    pushint 72 // 72
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:680
    // sha256(sha256(itob(entries[i].asset))),
    frame_dig 2
    dup
    extract 0 8
    sha256
    sha256
    // smart_contracts/staking-pool/contract.algo.ts:681
    // entries[i].proof,
    dig 1
    pushint 16 // 16
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    // smart_contracts/staking-pool/contract.algo.ts:682
    // MERKLE_TREE_TYPE_ASSET,
    intc_1 // 1
    itob
    // smart_contracts/staking-pool/contract.algo.ts:675-684
    // const verified = abiCall<typeof MetaMerkles.prototype.verify>({
    //   appId: getAkitaAppList(this.akitaDAO.value).metaMerkles,
    //   args: [
    //     address,
    //     name,
    //     sha256(sha256(itob(entries[i].asset))),
    //     entries[i].proof,
    //     MERKLE_TREE_TYPE_ASSET,
    //   ],
    // }).returnValue
    pushbytes 0x2bf3cc5a // method "verify(address,string,byte[32],byte[32][],uint64)bool"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/staking-pool/contract.algo.ts:686
    // assert(verified, 'failed to verify stake requirements')
    assert // failed to verify stake requirements

createPoolEntries_after_if_else@11:
    // smart_contracts/staking-pool/contract.algo.ts:691
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:691
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    app_global_get_ex
    assert // check GlobalState exists
    bytec 7 // 0x0a
    ==
    // smart_contracts/staking-pool/contract.algo.ts:691-692
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bnz createPoolEntries_if_body@13
    // smart_contracts/staking-pool/contract.algo.ts:692
    // this.type.value === POOL_STAKING_TYPE_SOFT
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:692
    // this.type.value === POOL_STAKING_TYPE_SOFT
    app_global_get_ex
    assert // check GlobalState exists
    bytec 12 // 0x14
    ==
    // smart_contracts/staking-pool/contract.algo.ts:691-692
    // this.type.value === POOL_STAKING_TYPE_HEARTBEAT ||
    // this.type.value === POOL_STAKING_TYPE_SOFT
    bz createPoolEntries_after_if_else@21

createPoolEntries_if_body@13:
    // smart_contracts/staking-pool/contract.algo.ts:696
    // if (entries[i].asset !== 0) {
    frame_dig 2
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 7
    bz createPoolEntries_else_body@15
    // smart_contracts/staking-pool/contract.algo.ts:697
    // ([balance, optedIn] = AssetHolding.assetBalance(Txn.sender, entries[i].asset))
    txn Sender
    frame_dig 7
    asset_holding_get AssetBalance
    swap
    frame_bury 4

createPoolEntries_after_if_else@16:
    // smart_contracts/staking-pool/contract.algo.ts:702
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    bz createPoolEntries_bool_false@19
    frame_dig 4
    frame_dig 6
    >=
    bz createPoolEntries_bool_false@19
    intc_1 // 1

createPoolEntries_bool_merge@20:
    // smart_contracts/staking-pool/contract.algo.ts:702
    // assert(optedIn && balance >= entries[i].quantity, 'user does not have min balance')
    assert // user does not have min balance

createPoolEntries_after_if_else@21:
    // smart_contracts/staking-pool/contract.algo.ts:705-714
    // const stakeInfo = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     Txn.sender,
    //     {
    //       asset: entries[i].asset,
    //       type: this.type.value,
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:706
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/staking-pool/contract.algo.ts:706
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec 5 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:706
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:708
    // Txn.sender,
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:711
    // type: this.type.value,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:117
    // type = GlobalState<StakingPoolStakingType>({ key: PoolGlobalStateKeyType })
    bytec 4 // "type"
    // smart_contracts/staking-pool/contract.algo.ts:711
    // type: this.type.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:709-712
    // {
    //   asset: entries[i].asset,
    //   type: this.type.value,
    // },
    frame_dig 2
    extract 0 8
    dup
    uncover 2
    concat
    // smart_contracts/staking-pool/contract.algo.ts:705-714
    // const stakeInfo = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     Txn.sender,
    //     {
    //       asset: entries[i].asset,
    //       type: this.type.value,
    //     },
    //   ],
    // }).returnValue
    bytec 39 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 4 // 4
    // smart_contracts/staking-pool/contract.algo.ts:716
    // assert(stakeInfo.amount >= entries[i].quantity, 'user does not have enough staked')
    extract_uint64
    frame_dig 6
    dup
    cover 2
    >=
    assert // user does not have enough staked
    // smart_contracts/staking-pool/contract.algo.ts:175
    // const id = this.entryID.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:175
    // const id = this.entryID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:176
    // this.entryID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/staking-pool/contract.algo.ts:129
    // entryID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyEntryCount })
    bytec_1 // "entry_count"
    // smart_contracts/staking-pool/contract.algo.ts:176
    // this.entryID.value += 1
    swap
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:720
    // address: Txn.sender,
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:719-725
    // this.entries(entryID).value = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(gateArgs),
    //   disqualified: false
    // }
    dig 3
    concat
    uncover 2
    itob
    concat
    pushbytes 0x003300
    concat
    frame_dig -1
    concat
    // smart_contracts/staking-pool/contract.algo.ts:719
    // this.entries(entryID).value = {
    swap
    itob
    // smart_contracts/staking-pool/contract.algo.ts:161
    // entries = BoxMap<uint64, EntryData>({ keyPrefix: PoolBoxPrefixEntries })
    bytec 8 // "e"
    dig 1
    concat
    // smart_contracts/staking-pool/contract.algo.ts:719-725
    // this.entries(entryID).value = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    //   quantity: entries[i].quantity,
    //   gateArgs: clone(gateArgs),
    //   disqualified: false
    // }
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/staking-pool/contract.algo.ts:728
    // address: Txn.sender,
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:727-730
    // const aKey = {
    //   address: Txn.sender,
    //   asset: entries[i].asset,
    // }
    uncover 2
    concat
    // smart_contracts/staking-pool/contract.algo.ts:732
    // this.entriesByAddress(aKey).value = entryID
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/staking-pool/contract.algo.ts:165
    // entriesByAddress = BoxMap<EntryKey, uint64>({ keyPrefix: PoolBoxPrefixEntriesByAddress })
    bytec 30 // "a"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:732
    // this.entriesByAddress(aKey).value = entryID
    swap
    box_put
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    bytec 23 // "u"
    // smart_contracts/staking-pool/contract.algo.ts:733
    // if (!this.uniques(Txn.sender).exists) {
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    concat
    // smart_contracts/staking-pool/contract.algo.ts:733
    // if (!this.uniques(Txn.sender).exists) {
    box_len
    bury 1
    bnz createPoolEntries_while_top@7
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    bytec 23 // "u"
    // smart_contracts/staking-pool/contract.algo.ts:734
    // this.uniques(Txn.sender).value = entries.length  // or any non-zero value
    txn Sender
    // smart_contracts/staking-pool/contract.algo.ts:163
    // uniques = BoxMap<Account, uint64>({ keyPrefix: PoolGlobalStateKeyUniques })
    concat
    // smart_contracts/staking-pool/contract.algo.ts:734
    // this.uniques(Txn.sender).value = entries.length  // or any non-zero value
    frame_dig 3
    itob
    box_put
    b createPoolEntries_while_top@7

createPoolEntries_bool_false@19:
    intc_0 // 0
    b createPoolEntries_bool_merge@20

createPoolEntries_else_body@15:
    // smart_contracts/staking-pool/contract.algo.ts:699
    // optedIn = true
    intc_1 // 1
    // smart_contracts/staking-pool/contract.algo.ts:700
    // balance = Txn.sender.balance
    txn Sender
    acct_params_get AcctBalance
    swap
    frame_bury 4
    assert // account funded
    b createPoolEntries_after_if_else@16

createPoolEntries_after_while@25:
    frame_dig -2
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

createPoolEntries_bool_false@3:
    intc_0 // 0
    b createPoolEntries_bool_merge@4


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward(payment: uint64, reward: bytes) -> bytes:
smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward:
    // smart_contracts/staking-pool/contract.algo.ts:850
    // addReward(payment: gtxn.PaymentTxn, reward: Reward): void {
    proto 2 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/staking-pool/contract.algo.ts:851
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    txn Sender
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:146
    // creator = GlobalState<Account>({ key: PoolGlobalStateKeyCreator })
    bytec 10 // "creator"
    // smart_contracts/staking-pool/contract.algo.ts:851
    // assert(Txn.sender === this.creator.value, ERR_FORBIDDEN)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Forbidden
    // smart_contracts/staking-pool/contract.algo.ts:852
    // assert(reward.asset === 0, ERR_NOT_ALGO)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    !
    assert // Must be an Algo asset
    // smart_contracts/staking-pool/contract.algo.ts:623
    // this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:138
    // stakeKey = GlobalState<RootKey>({ key: PoolGlobalStateKeyStakeKey })
    bytec 26 // "stake_key"
    // smart_contracts/staking-pool/contract.algo.ts:623
    // this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    app_global_get_ex
    assert // check GlobalState exists
    extract 0 32
    global ZeroAddress
    !=
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_true@7
    frame_dig -1
    extract 8 1
    bytec 7 // 0x0a
    !=
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@8

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_true@7:
    intc_1 // 1

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@9:
    // smart_contracts/staking-pool/contract.algo.ts:622-625
    // assert(
    //   this.stakeKey.value.address !== Global.zeroAddress || reward.distribution !== DistributionTypePercentage,
    //   ERR_STAKE_KEY_REQUIRED
    // )
    assert // Stake key required
    // smart_contracts/staking-pool/contract.algo.ts:628
    // if (reward.distribution === DistributionTypeShuffle) {
    frame_dig -1
    extract 8 1
    dup
    frame_bury 0
    pushbytes 0x28
    ==
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_after_if_else@15
    // smart_contracts/staking-pool/contract.algo.ts:629
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    dup
    frame_bury 1
    >
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@13
    frame_dig 1
    pushint 10 // 10
    <=
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@13
    intc_1 // 1

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@14:
    // smart_contracts/staking-pool/contract.algo.ts:629
    // assert(reward.rate > reward.winnerCount && reward.winnerCount <= WinnerCountCap, ERR_RATE_MUST_BE_GREATER_THAN_WINNER_COUNT)
    assert // Rate must be greater than winner count

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_after_if_else@15:
    // smart_contracts/staking-pool/contract.algo.ts:633
    // if (reward.distribution === DistributionTypeEven) {
    frame_dig 0
    bytec 13 // 0x1e
    ==
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_after_if_else@21
    // smart_contracts/staking-pool/contract.algo.ts:634
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:634
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_true@18
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:127
    // maxEntries = GlobalState<uint64>({ key: PoolGlobalStateKeyMaxEntries })
    bytec 17 // "max_entries"
    // smart_contracts/staking-pool/contract.algo.ts:634
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    <=
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@19

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_true@18:
    intc_1 // 1

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@20:
    // smart_contracts/staking-pool/contract.algo.ts:634
    // assert(this.maxEntries.value === 0 || this.maxEntries.value <= reward.rate, ERR_MAX_ENTRIES_CANNOT_BE_GREATER_THAN_RATE)
    assert // Max entries cannot be greater than rate

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_after_if_else@21:
    // smart_contracts/staking-pool/contract.algo.ts:637
    // assert(reward.rate > 0, ERR_RATE_MUST_BE_GREATER_THAN_ZERO)
    frame_dig -1
    pushint 9 // 9
    extract_uint64
    assert // Rate must be greater than zero
    // smart_contracts/staking-pool/contract.algo.ts:856-865
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/staking-pool/contract.algo.ts:859
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking-pool/contract.algo.ts:856-865
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -2
    gtxns Amount
    // smart_contracts/staking-pool/contract.algo.ts:861
    // greaterThanEq: this.rewardsMbr(reward.winnerCount)
    frame_dig -1
    pushint 49 // 49
    extract_uint64
    // smart_contracts/staking-pool/base.ts:9
    // return MinPoolRewardsMBR + (BoxCostPerByte * winningTickets)
    intc 6 // 400
    *
    // smart_contracts/staking-pool/contract.algo.ts:856-865
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: this.rewardsMbr(reward.winnerCount)
    //     }
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    >=
    &&
    assert // Invalid payment
    // smart_contracts/staking-pool/contract.algo.ts:181
    // const id = this.rewardID.value
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyRewardCount })
    bytec 25 // "reward_count"
    // smart_contracts/staking-pool/contract.algo.ts:181
    // const id = this.rewardID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking-pool/contract.algo.ts:182
    // this.rewardID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/staking-pool/contract.algo.ts:131
    // rewardID = GlobalState<uint64>({ initialValue: 1, key: PoolGlobalStateKeyRewardCount })
    bytec 25 // "reward_count"
    // smart_contracts/staking-pool/contract.algo.ts:182
    // this.rewardID.value += 1
    swap
    app_global_put
    // smart_contracts/staking-pool/contract.algo.ts:868
    // this.rewards(id).value = clone(reward)
    itob
    // smart_contracts/staking-pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 21 // "r"
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:868
    // this.rewards(id).value = clone(reward)
    dup
    box_del
    pop
    frame_dig -1
    box_put
    frame_dig -1
    frame_bury 0
    retsub

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@19:
    intc_0 // 0
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@20

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@13:
    intc_0 // 0
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@14

smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_false@8:
    intc_0 // 0
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.addReward_bool_merge@9


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle(rewardID: uint64) -> void:
smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle:
    // smart_contracts/staking-pool/contract.algo.ts:959
    // raffle(rewardID: uint64): void {
    proto 1 0
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 7
    // smart_contracts/staking-pool/contract.algo.ts:960
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    frame_dig -1
    itob
    // smart_contracts/staking-pool/contract.algo.ts:167
    // rewards = BoxMap<uint64, Reward>({ keyPrefix: PoolBoxPrefixRewards })
    bytec 21 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/staking-pool/contract.algo.ts:960
    // assert(this.rewards(rewardID).exists, 'reward does not exist')
    box_len
    bury 1
    assert // reward does not exist
    // smart_contracts/staking-pool/contract.algo.ts:967
    // } = clone(this.rewards(rewardID).value)
    dup
    pushint 91 // 91
    intc_1 // 1
    box_extract
    dig 1
    pushint 108 // 108
    intc_2 // 8
    box_extract
    btoi
    dig 2
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    dig 3
    pushint 41 // 41
    intc_2 // 8
    box_extract
    btoi
    cover 4
    // smart_contracts/staking-pool/contract.algo.ts:969
    // assert(phase === DisbursementPhaseAllocation, ERR_INVALID_DISBURSEMENT_PHASE)
    uncover 2
    bytec 12 // 0x14
    ==
    assert // Invalid disbursement phase
    // smart_contracts/staking-pool/contract.algo.ts:970
    // assert(winningTickets.length === 0, ERR_WINNING_TICKETS_ALREADY_EXIST)
    uncover 2
    pushints 124 2 // 124, 2
    box_extract
    btoi
    !
    assert // Winning tickets already exist
    // smart_contracts/staking-pool/contract.algo.ts:972
    // const roundToUse: uint64 = activeDisbursementRoundStart + 1 + (4 * vrfFailureCount)
    swap
    intc_1 // 1
    +
    pushint 4 // 4
    uncover 2
    *
    +
    // smart_contracts/staking-pool/contract.algo.ts:974-977
    // const seed = abiCall<typeof RandomnessBeacon.prototype.get>({
    //   appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //   args: [roundToUse, this.salt.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/staking-pool/contract.algo.ts:975
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    global CurrentApplicationID
    // smart_contracts/utils/functions.ts:55
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    bytec 32 // "oal"
    app_global_get_ex
    pop
    // smart_contracts/staking-pool/contract.algo.ts:975
    // appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking-pool/contract.algo.ts:976
    // args: [roundToUse, this.salt.value],
    swap
    itob
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:156
    // salt = GlobalState<bytes<32>>({ key: PoolGlobalStateKeySalt })
    bytec 33 // "salt"
    // smart_contracts/staking-pool/contract.algo.ts:976
    // args: [roundToUse, this.salt.value],
    app_global_get_ex
    assert // check GlobalState exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking-pool/contract.algo.ts:974-977
    // const seed = abiCall<typeof RandomnessBeacon.prototype.get>({
    //   appId: getOtherAppList(Global.currentApplicationId).vrfBeacon,
    //   args: [roundToUse, this.salt.value],
    // }).returnValue
    pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/staking-pool/contract.algo.ts:979
    // if (seed.length === 0) {
    len
    dup
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@3
    // smart_contracts/staking-pool/contract.algo.ts:980
    // this.rewards(rewardID).value.vrfFailureCount += 1
    frame_dig 12
    dup
    pushint 83 // 83
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    pushint 83 // 83
    swap
    box_replace
    // smart_contracts/staking-pool/contract.algo.ts:981
    // return
    retsub

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@3:
    // smart_contracts/staking-pool/contract.algo.ts:985
    // const rngState = pcg64Init(seed.slice(0, 16))
    intc_0 // 0
    frame_dig 15
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig 14
    cover 2
    substring3
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:16
    // assert(seed.length === 16)
    dup
    len
    pushint 16 // 16
    ==
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:92
    // const state = __pcg32Step(0, incr)
    intc_0 // 0
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    dup
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:19
    // __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    cover 2
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    uncover 2
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    swap
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:93
    // const [, addLow] = op.addw(state, initialState)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:20
    // __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    intc 8 // 1442695040888963409
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:18-21
    // return [
    //     __pcg32Init(op.extractUint64(seed, 0), pcgFirstIncrement),
    //     __pcg32Init(op.extractUint64(seed, 8), pcgSecondIncrement),
    // ]
    swap
    itob
    swap
    itob
    concat
    frame_bury 2
    // smart_contracts/staking-pool/contract.algo.ts:989
    // if (upperBound < MAX_UINT64) {
    frame_dig 13
    intc 12 // 18446744073709551615
    <
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_if_body@4
    frame_dig 13
    frame_bury 11

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@5:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:30
    // const result = new DynamicArray<arc4.Uint64>()
    intc_0 // 0
    itob
    frame_bury 0
    bytec 6 // 0x0000
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:42
    // if (upperBound !== 0) {
    frame_dig 11
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_else_body@14
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:43
    // assert(upperBound > 1)
    frame_dig 11
    dup
    intc_1 // 1
    >
    assert
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    intc_1 // 1
    -
    dup
    frame_bury 4
    // smart_contracts/staking-pool/contract.algo.ts:993
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:44
    // assert(lowerBound < upperBound - 1)
    >
    assert

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@15:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:8
    // const [, addLow] = op.addw(~value, 1)
    frame_dig 4
    dup
    ~
    intc_1 // 1
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:53
    // const threshold: uint64 = __uint64Twos(absoluteBound) % absoluteBound
    swap
    %
    frame_bury 10
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    intc_0 // 0
    frame_bury 7
    frame_dig 2
    frame_bury 3

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_while_top@16:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    // smart_contracts/staking-pool/contract.algo.ts:993
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    pushint 15 // 15
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    <
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_while@22

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_while_top@18:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    frame_dig 3
    dup
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 9
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:9
    // const newState1 = __pcg32Step(state[0], pcgFirstIncrement)
    intc 7 // 1442695040888963407
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    addw
    dup
    cover 2
    frame_bury 5
    pop
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    swap
    intc_2 // 8
    extract_uint64
    frame_bury 8
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_ternary_false@26
    pushint 2885390081777926818 // 2885390081777926818

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_ternary_merge@27:
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:17
    // const [, mulLow] = op.mulw(state, pcgMultiplier)
    frame_dig 8
    dup
    intc 5 // 6364136223846793005
    mulw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg32.algo.ts:18
    // const [, addLow] = op.addw(mulLow, incr)
    uncover 2
    addw
    bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:12
    // return [[newState1, newState2], op.shl(__pcg32Output(state[0]), 32) | __pcg32Output(state[1])]
    frame_dig 5
    itob
    swap
    itob
    concat
    frame_dig 9
    callsub __pcg32Output
    pushint 32 // 32
    shl
    uncover 2
    callsub __pcg32Output
    |
    itob
    concat
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:57
    // const [newState, candidate] = __pcg64UnboundedRandom(state)
    dup
    extract 0 16
    swap
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 6
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:59
    // if (candidate >= threshold) {
    frame_dig 10
    >=
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@20
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    frame_dig 6
    frame_dig 4
    %
    // smart_contracts/staking-pool/contract.algo.ts:993
    // const rngResult = pcg64Random(rngState, 1, upperBound, MaxGlobalStateUint64Array)
    intc_1 // 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:60
    // result.push(new arc4.Uint64((candidate % absoluteBound) + lowerBound))
    +
    itob
    frame_dig 1
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 1
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:55
    // for (let i = Uint64(0); i < length; i = i + 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    frame_bury 3
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_while_top@16

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@20:
    frame_bury 3
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_while_top@18

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_ternary_false@26:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:10
    // const newState2 = __pcg32Step(state[1], newState1 === 0 ? op.shl(pcgSecondIncrement, 1) : pcgSecondIncrement)
    intc 8 // 1442695040888963409
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_ternary_merge@27

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_while@22:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:67
    // return [state, result]
    frame_dig 3
    pushbytes 0x0012
    concat
    frame_dig 1
    concat
    // smart_contracts/staking-pool/contract.algo.ts:995
    // this.rewards(rewardID).value.winningTickets = decodeArc4<uint64[]>(rngResult[1].bytes)
    dup
    pushint 16 // 16
    extract_uint16
    dig 1
    len
    substring3
    frame_dig 12
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    pushint 57 // 57
    extract_uint16
    intc_0 // 0
    swap
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    dig 1
    swap
    box_put
    // smart_contracts/staking-pool/contract.algo.ts:996
    // this.rewards(rewardID).value.vrfFailureCount = 0
    pushint 83 // 83
    frame_dig 0
    box_replace
    retsub

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_else_body@14:
    // smart_contracts/utils/types/lib_pcg/pcg64.algo.ts:50
    // absoluteBound = op.btoi(Bytes(BigUint(2 ** 64) - BigUint(lowerBound)))
    intc 12 // 18446744073709551615
    frame_bury 4
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@15

smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_if_body@4:
    // smart_contracts/staking-pool/contract.algo.ts:990
    // upperBound += 1
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 11
    b smart_contracts/staking-pool/contract.algo.ts::StakingPool.raffle_after_if_else@5


// smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive() -> uint64:
smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive:
    // smart_contracts/staking-pool/contract.algo.ts:1119
    // this.status.value !== PoolStatusDraft &&
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:113
    // status = GlobalState<StakingPoolStatus>({ key: PoolGlobalStateKeyStatus })
    bytec 9 // "status"
    // smart_contracts/staking-pool/contract.algo.ts:1119
    // this.status.value !== PoolStatusDraft &&
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // 0x00
    !=
    // smart_contracts/staking-pool/contract.algo.ts:1119-1120
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_false@5
    // smart_contracts/staking-pool/contract.algo.ts:1120
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:123
    // startTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyStartTimestamp })
    bytec 14 // "start_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1120
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    app_global_get_ex
    assert // check GlobalState exists
    >=
    // smart_contracts/staking-pool/contract.algo.ts:1119-1120
    // this.status.value !== PoolStatusDraft &&
    // (Global.latestTimestamp >= this.startTimestamp.value) &&
    bz smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_false@5
    // smart_contracts/staking-pool/contract.algo.ts:1121
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1121
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    <=
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_true@4
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:125
    // endTimestamp = GlobalState<uint64>({ initialValue: 0, key: PoolGlobalStateKeyEndTimestamp })
    bytec 15 // "end_timestamp"
    // smart_contracts/staking-pool/contract.algo.ts:1121
    // (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    app_global_get_ex
    assert // check GlobalState exists
    bnz smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_false@5

smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_true@4:
    intc_1 // 1
    // smart_contracts/staking-pool/contract.algo.ts:1118-1122
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub

smart_contracts/staking-pool/contract.algo.ts::StakingPool.isLive_bool_false@5:
    intc_0 // 0
    // smart_contracts/staking-pool/contract.algo.ts:1118-1122
    // return (
    //   this.status.value !== PoolStatusDraft &&
    //   (Global.latestTimestamp >= this.startTimestamp.value) &&
    //   (Global.latestTimestamp <= this.endTimestamp.value || this.endTimestamp.value === 0)
    // )
    retsub
