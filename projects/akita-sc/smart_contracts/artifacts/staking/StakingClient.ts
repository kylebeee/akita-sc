/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"Staking","structs":{"softCheckResult":[{"name":"valid","type":"bool"},{"name":"balance","type":"uint64"}],"Escrow":[{"name":"hard","type":"uint64"},{"name":"lock","type":"uint64"}],"HeartbeatKey":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"}],"Stake":[{"name":"amount","type":"uint64"},{"name":"lastUpdate","type":"uint64"},{"name":"expiration","type":"uint64"}],"StakeInfo":[{"name":"asset","type":"uint64"},{"name":"type","type":"uint8"}],"StakeKey":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"},{"name":"type","type":"uint8"}]},"methods":[{"name":"create","args":[{"type":"string","name":"version"},{"type":"uint64","name":"akitaDAO"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"stake","args":[{"type":"pay","name":"payment"},{"type":"uint8","name":"type"},{"type":"uint64","name":"amount"},{"type":"uint64","name":"expiration"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"stakeAsa","args":[{"type":"pay","name":"payment"},{"type":"axfer","name":"assetXfer"},{"type":"uint8","name":"type"},{"type":"uint64","name":"amount"},{"type":"uint64","name":"expiration"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"withdraw","args":[{"type":"uint64","name":"asset"},{"type":"uint8","name":"type"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"createHeartbeat","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"softCheck","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(bool,uint64)","struct":"softCheckResult"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateSettings","args":[{"type":"pay","name":"payment"},{"type":"uint64","name":"asset"},{"type":"uint64","name":"value"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"getTimeLeft","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mustGetTimeLeft","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getInfo","args":[{"type":"address","name":"address"},{"type":"(uint64,uint8)","struct":"StakeInfo","name":"stake"}],"returns":{"type":"(uint64,uint64,uint64)","struct":"Stake"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mustGetInfo","args":[{"type":"address","name":"address"},{"type":"(uint64,uint8)","struct":"StakeInfo","name":"stake"}],"returns":{"type":"(uint64,uint64,uint64)","struct":"Stake"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getEscrowInfo","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(uint64,uint64)","struct":"Escrow"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getHeartbeat","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(uint64,uint64,uint64,uint64)[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mustGetHeartbeat","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(uint64,uint64,uint64,uint64)[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getHeartbeatAverage","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"},{"type":"bool","name":"includeStaked"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mustGetHeartbeatAverage","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"},{"type":"bool","name":"includeStaked"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getInfoList","args":[{"type":"address","name":"address"},{"type":"uint8","name":"type"},{"type":"uint64[]","name":"assets"}],"returns":{"type":"(uint64,uint64,uint64)[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"mustGetInfoList","args":[{"type":"address","name":"address"},{"type":"uint8","name":"type"},{"type":"uint64[]","name":"assets"}],"returns":{"type":"(uint64,uint64,uint64)[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"stakeCheck","args":[{"type":"address","name":"address"},{"type":"(uint64,uint64)[]","name":"checks"},{"type":"uint8","name":"type"},{"type":"bool","name":"includeStaked"}],"returns":{"type":"bool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"update","args":[{"type":"string","name":"newVersion"}],"returns":{"type":"void"},"actions":{"create":[],"call":["UpdateApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateAkitaDAO","args":[{"type":"uint64","name":"app"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":1,"bytes":2},"local":{"ints":0,"bytes":0}},"keys":{"global":{"heartbeatManagerAddress":{"keyType":"AVMString","valueType":"address","key":"aGVhcnRiZWF0X21hbmFnZXJfYWRkcmVzcw==","desc":"The address that is allowed to call the 'beat' method to create heartbeat records"},"version":{"keyType":"AVMString","valueType":"AVMString","key":"dmVyc2lvbg==","desc":"the current version of the contract"},"akitaDAO":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZGFv","desc":"the app ID of the Akita DAO"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"stakes":{"keyType":"StakeKey","valueType":"Stake","prefix":"cw=="},"heartbeats":{"keyType":"HeartbeatKey","valueType":"(uint64,uint64,uint64,uint64)[4]","prefix":"aA=="},"settings":{"keyType":"uint64","valueType":"uint64","prefix":"ZQ=="}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[1041,1065,1186,1324,1499,1526,1636,1795,1951,1979,2006,2102,2159,2360,2373,2405,2449,2487,2531,2558,2727,2750,2787,2900,3098,3210,3333],"errorMessage":"Box must have value"},{"pc":[1206,1656],"errorMessage":"Expiration must be greater than or equal to the current unlock time or hardlock disabled"},{"pc":[919,1376],"errorMessage":"Expiration must be in the future or hardlock disabled"},{"pc":[1941,2748,2898],"errorMessage":"Heartbeat not found"},{"pc":[1182,1632],"errorMessage":"Heartbeat stakes cannot be updated"},{"pc":[523,566,2049,2066,2109,2822,2860,2931,2969,3297],"errorMessage":"Index access is out of bounds"},{"pc":[1147,1261,1601,1727],"errorMessage":"Insufficient balance"},{"pc":[1428,1436,1472,1552,1623,1683,1691,1733],"errorMessage":"Invalid asset amount"},{"pc":[975,1091,1169,2310],"errorMessage":"Invalid payment"},{"pc":[1227,1420,1546,1617,1670],"errorMessage":"Invalid payment amount"},{"pc":[1219,1412,1538,1609,1664],"errorMessage":"Invalid payment receiver"},{"pc":[1793,2400,2485],"errorMessage":"Lock not found"},{"pc":[1470,1597,1720,2226],"errorMessage":"Not opted in"},{"pc":[255,291,327,352,377,406,435,458,481,509,552,595,619,643,673,705,724,743,788,821],"errorMessage":"OnCompletion is not NoOp"},{"pc":[273],"errorMessage":"OnCompletion is not UpdateApplication"},{"pc":[3400,3421],"errorMessage":"Only the Akita DAO can call this function"},{"pc":[2272],"errorMessage":"Only the asset creator can call this method"},{"pc":[1920],"errorMessage":"Only the heartbeat manager can call this method"},{"pc":[2157],"errorMessage":"Stake does not exist"},{"pc":[3202],"errorMessage":"Stake not found"},{"pc":[1821,2412],"errorMessage":"This asset is still locked"},{"pc":[1773],"errorMessage":"Withdraw is only for hard or lock"},{"pc":[1011,1143,1254,2174,2186,2206],"errorMessage":"account funded"},{"pc":[3398,3419],"errorMessage":"application exists"},{"pc":[2270],"errorMessage":"asset exists"},{"pc":[825],"errorMessage":"can only call when creating"},{"pc":[258,276,294,330,355,380,409,438,461,484,512,555,598,622,646,676,708,727,746,791],"errorMessage":"can only call when not creating"},{"pc":[1918,3395,3416],"errorMessage":"check GlobalState exists"},{"pc":[768],"errorMessage":"transaction type is axfer"},{"pc":[656,757,801],"errorMessage":"transaction type is pay"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDE2IDMyIDI4OTAwIDMxNTM2MDAwIDk5MDAwCiAgICBieXRlY2Jsb2NrICJzIiAweDE1MWY3Yzc1IDB4MDMgIiIgMHgwMCAweDAyICJoIiAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgImFraXRhX2RhbyIgImUiICJ2ZXJzaW9uIiAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9hZnRlcl9pZl9lbHNlQDI5CiAgICBwdXNoYnl0ZXNzIDB4Y2Q5YWQ2N2UgMHg4MjU2Y2YxOSAweDIwNDY3YjkzIDB4ODMwNDgwZjMgMHhjODE3M2NhMSAweDQ4NzE2ZjFhIDB4NWQ5ZDE0MjggMHg5ZjRmNTY3NCAweDc1ZDEzOGZiIDB4YzkwNjg4MDkgMHhmNTIzMmJmMyAweDRjODhlYWNlIDB4NTkyNDdhN2YgMHg3NjE1YjQyMSAweGM2ZmQwY2E1IDB4OGFlMjY2YjkgMHhlOTdhNTY1NSAweDExMjVkNzNiIDB4OWRmZjQwNjAgMHhlYTkxODBkZCAweDMzZTkyYzk0IC8vIG1ldGhvZCAiY3JlYXRlKHN0cmluZyx1aW50NjQpdm9pZCIsIG1ldGhvZCAic3Rha2UocGF5LHVpbnQ4LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAic3Rha2VBc2EocGF5LGF4ZmVyLHVpbnQ4LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAid2l0aGRyYXcodWludDY0LHVpbnQ4KXZvaWQiLCBtZXRob2QgImNyZWF0ZUhlYXJ0YmVhdChhZGRyZXNzLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJzb2Z0Q2hlY2soYWRkcmVzcyx1aW50NjQpKGJvb2wsdWludDY0KSIsIG1ldGhvZCAidXBkYXRlU2V0dGluZ3MocGF5LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZ2V0VGltZUxlZnQoYWRkcmVzcyx1aW50NjQpdWludDY0IiwgbWV0aG9kICJtdXN0R2V0VGltZUxlZnQoYWRkcmVzcyx1aW50NjQpdWludDY0IiwgbWV0aG9kICJnZXRJbmZvKGFkZHJlc3MsKHVpbnQ2NCx1aW50OCkpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAibXVzdEdldEluZm8oYWRkcmVzcywodWludDY0LHVpbnQ4KSkodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRFc2Nyb3dJbmZvKGFkZHJlc3MsdWludDY0KSh1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiZ2V0SGVhcnRiZWF0KGFkZHJlc3MsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpW10iLCBtZXRob2QgIm11c3RHZXRIZWFydGJlYXQoYWRkcmVzcyx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NClbXSIsIG1ldGhvZCAiZ2V0SGVhcnRiZWF0QXZlcmFnZShhZGRyZXNzLHVpbnQ2NCxib29sKXVpbnQ2NCIsIG1ldGhvZCAibXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2UoYWRkcmVzcyx1aW50NjQsYm9vbCl1aW50NjQiLCBtZXRob2QgImdldEluZm9MaXN0KGFkZHJlc3MsdWludDgsdWludDY0W10pKHVpbnQ2NCx1aW50NjQsdWludDY0KVtdIiwgbWV0aG9kICJtdXN0R2V0SW5mb0xpc3QoYWRkcmVzcyx1aW50OCx1aW50NjRbXSkodWludDY0LHVpbnQ2NCx1aW50NjQpW10iLCBtZXRob2QgInN0YWtlQ2hlY2soYWRkcmVzcywodWludDY0LHVpbnQ2NClbXSx1aW50OCxib29sKWJvb2wiLCBtZXRob2QgInVwZGF0ZShzdHJpbmcpdm9pZCIsIG1ldGhvZCAidXBkYXRlQWtpdGFEQU8odWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9yb3V0ZUA1IG1haW5fc3Rha2Vfcm91dGVANiBtYWluX3N0YWtlQXNhX3JvdXRlQDcgbWFpbl93aXRoZHJhd19yb3V0ZUA4IG1haW5fY3JlYXRlSGVhcnRiZWF0X3JvdXRlQDkgbWFpbl9zb2Z0Q2hlY2tfcm91dGVAMTAgbWFpbl91cGRhdGVTZXR0aW5nc19yb3V0ZUAxMSBtYWluX2dldFRpbWVMZWZ0X3JvdXRlQDEyIG1haW5fbXVzdEdldFRpbWVMZWZ0X3JvdXRlQDEzIG1haW5fZ2V0SW5mb19yb3V0ZUAxNCBtYWluX211c3RHZXRJbmZvX3JvdXRlQDE1IG1haW5fZ2V0RXNjcm93SW5mb19yb3V0ZUAxNiBtYWluX2dldEhlYXJ0YmVhdF9yb3V0ZUAxNyBtYWluX211c3RHZXRIZWFydGJlYXRfcm91dGVAMTggbWFpbl9nZXRIZWFydGJlYXRBdmVyYWdlX3JvdXRlQDE5IG1haW5fbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2Vfcm91dGVAMjAgbWFpbl9nZXRJbmZvTGlzdF9yb3V0ZUAyMSBtYWluX211c3RHZXRJbmZvTGlzdF9yb3V0ZUAyMiBtYWluX3N0YWtlQ2hlY2tfcm91dGVAMjMgbWFpbl91cGRhdGVfcm91dGVAMjQgbWFpbl91cGRhdGVBa2l0YURBT19yb3V0ZUAyNQoKbWFpbl9hZnRlcl9pZl9lbHNlQDI5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fdXBkYXRlQWtpdGFEQU9fcm91dGVAMjU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYXBwOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhhcHA6IHVpbnQ2NCk6IHZvaWQgewogICAgY2FsbHN1YiB1cGRhdGVBa2l0YURBTwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfcm91dGVAMjQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyMAogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogWydVcGRhdGVBcHBsaWNhdGlvbiddIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBwdXNoaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBVcGRhdGVBcHBsaWNhdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZyBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSBpbXBsZW1lbnRzIFN0YWtpbmdJbnRlcmZhY2UgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjIwCiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIGNhbGxzdWIgdXBkYXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3N0YWtlQ2hlY2tfcm91dGVAMjM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIHN0YWtlQ2hlY2sKICAgIGJ5dGVjIDQgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX211c3RHZXRJbmZvTGlzdF9yb3V0ZUAyMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjU2CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjU2CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgbXVzdEdldEluZm9MaXN0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEluZm9MaXN0X3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MzEKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZyBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSBpbXBsZW1lbnRzIFN0YWtpbmdJbnRlcmZhY2UgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MzEKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgY2FsbHN1YiBnZXRJbmZvTGlzdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9tdXN0R2V0SGVhcnRiZWF0QXZlcmFnZV9yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjEyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjEyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2UKICAgIGl0b2IKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0SGVhcnRiZWF0QXZlcmFnZV9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTkwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTkwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgZ2V0SGVhcnRiZWF0QXZlcmFnZQogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9tdXN0R2V0SGVhcnRiZWF0X3JvdXRlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1ODMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZyBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSBpbXBsZW1lbnRzIFN0YWtpbmdJbnRlcmZhY2UgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1ODMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgY2FsbHN1YiBtdXN0R2V0SGVhcnRiZWF0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEhlYXJ0YmVhdF9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTY1CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTY1CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgZ2V0SGVhcnRiZWF0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEVzY3Jvd0luZm9fcm91dGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIGdldEVzY3Jvd0luZm8KICAgIHN3YXAKICAgIGl0b2IKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9tdXN0R2V0SW5mb19yb3V0ZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTM5CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBzd2FwCiAgICBleHRyYWN0IDggMSAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTM5CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgbXVzdEdldEluZm8KICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEluZm9fcm91dGVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyOQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgZXh0cmFjdCA4IDEgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyOQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIGdldEluZm8KICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX211c3RHZXRUaW1lTGVmdF9yb3V0ZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTIxCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTIxCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgbXVzdEdldFRpbWVMZWZ0CiAgICBpdG9iCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldFRpbWVMZWZ0X3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZyBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSBpbXBsZW1lbnRzIFN0YWtpbmdJbnRlcmZhY2UgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgY2FsbHN1YiBnZXRUaW1lTGVmdAogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVTZXR0aW5nc19yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDkzCiAgICAvLyB1cGRhdGVTZXR0aW5ncyhwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0OiB1aW50NjQsIHZhbHVlOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTMKICAgIC8vIHVwZGF0ZVNldHRpbmdzKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXQ6IHVpbnQ2NCwgdmFsdWU6IHVpbnQ2NCk6IHZvaWQgewogICAgY2FsbHN1YiB1cGRhdGVTZXR0aW5ncwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zb2Z0Q2hlY2tfcm91dGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2MAogICAgLy8gc29mdENoZWNrKGFkZHJlc3M6IEFkZHJlc3MsIGFzc2V0OiB1aW50NjQpOiB7IHZhbGlkOiBib29sZWFuLCBiYWxhbmNlOiB1aW50NjQgfSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2MAogICAgLy8gc29mdENoZWNrKGFkZHJlc3M6IEFkZHJlc3MsIGFzc2V0OiB1aW50NjQpOiB7IHZhbGlkOiBib29sZWFuLCBiYWxhbmNlOiB1aW50NjQgfSB7CiAgICBjYWxsc3ViIHNvZnRDaGVjawogICAgYnl0ZWMgNCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAzCiAgICBzZXRiaXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVIZWFydGJlYXRfcm91dGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDAzCiAgICAvLyBjcmVhdGVIZWFydGJlYXQoYWRkcmVzczogQWRkcmVzcywgYXNzZXQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZyBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSBpbXBsZW1lbnRzIFN0YWtpbmdJbnRlcmZhY2UgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MDMKICAgIC8vIGNyZWF0ZUhlYXJ0YmVhdChhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogdm9pZCB7CiAgICBjYWxsc3ViIGNyZWF0ZUhlYXJ0YmVhdAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl93aXRoZHJhd19yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzAKICAgIC8vIHdpdGhkcmF3KGFzc2V0OiB1aW50NjQsIHR5cGU6IFN0YWtpbmdUeXBlKTogdm9pZCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3MAogICAgLy8gd2l0aGRyYXcoYXNzZXQ6IHVpbnQ2NCwgdHlwZTogU3Rha2luZ1R5cGUpOiB2b2lkIHsKICAgIGNhbGxzdWIgd2l0aGRyYXcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc3Rha2VBc2Ffcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjM2LTI0MgogICAgLy8gc3Rha2VBc2EoCiAgICAvLyAgIHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwKICAgIC8vICAgYXNzZXRYZmVyOiBndHhuLkFzc2V0VHJhbnNmZXJUeG4sCiAgICAvLyAgIHR5cGU6IFN0YWtpbmdUeXBlLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBwdXNoaW50IDIgLy8gMgogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBwdXNoaW50IDQgLy8gYXhmZXIKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBheGZlcgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMzYtMjQyCiAgICAvLyBzdGFrZUFzYSgKICAgIC8vICAgcGF5bWVudDogZ3R4bi5QYXltZW50VHhuLAogICAgLy8gICBhc3NldFhmZXI6IGd0eG4uQXNzZXRUcmFuc2ZlclR4biwKICAgIC8vICAgdHlwZTogU3Rha2luZ1R5cGUsCiAgICAvLyAgIGFtb3VudDogdWludDY0LAogICAgLy8gICBleHBpcmF0aW9uOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgY2FsbHN1YiBzdGFrZUFzYQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zdGFrZV9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIHN0YWtlKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgdHlwZTogU3Rha2luZ1R5cGUsIGFtb3VudDogdWludDY0LCBleHBpcmF0aW9uOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmcgZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgaW1wbGVtZW50cyBTdGFraW5nSW50ZXJmYWNlIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIHN0YWtlKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgdHlwZTogU3Rha2luZ1R5cGUsIGFtb3VudDogdWludDY0LCBleHBpcmF0aW9uOiB1aW50NjQpOiB2b2lkIHsKICAgIGNhbGxzdWIgc3Rha2UKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjk1CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Rha2luZywgQWtpdGFCYXNlQ29udHJhY3QpIGltcGxlbWVudHMgU3Rha2luZ0ludGVyZmFjZSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo5NQogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGNhbGxzdWIgY3JlYXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5jcmVhdGUodmVyc2lvbjogYnl0ZXMsIGFraXRhREFPOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OTUtOTYKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICAvLyBjcmVhdGUodmVyc2lvbjogc3RyaW5nLCBha2l0YURBTzogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jb25zdGFudHMudHM6MwogICAgLy8gZXhwb3J0IGNvbnN0IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiA9ICd2ZXJzaW9uJwogICAgYnl0ZWMgMTAgLy8gInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjk3CiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY29uc3RhbnRzLnRzOjEKICAgIC8vIGV4cG9ydCBjb25zdCBHbG9iYWxTdGF0ZUtleUFraXRhREFPID0gJ2FraXRhX2RhbycKICAgIGJ5dGVjIDggLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OTgKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBBcHBsaWNhdGlvbihha2l0YURBTykKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcuc3Rha2UocGF5bWVudDogdWludDY0LCB0eXBlOiBieXRlcywgYW1vdW50OiB1aW50NjQsIGV4cGlyYXRpb246IHVpbnQ2NCkgLT4gdm9pZDoKc3Rha2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEwMwogICAgLy8gc3Rha2UocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCB0eXBlOiBTdGFraW5nVHlwZSwgYW1vdW50OiB1aW50NjQsIGV4cGlyYXRpb246IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gNCAwCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA1CiAgICBieXRlY18zIC8vICIiCiAgICBkdXBuIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA0CiAgICAvLyBjb25zdCBpblRoZUZ1dHVyZSA9IGV4cGlyYXRpb24gPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgLTEKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA1CiAgICAvLyBjb25zdCBsZXNzVGhhbk9uZVllYXJJblRoZUZ1dHVyZSA9IGV4cGlyYXRpb24gPD0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCArIE9ORV9ZRUFSCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6OQogICAgLy8gZXhwb3J0IGNvbnN0IE9ORV9ZRUFSOiB1aW50NjQgPSAzMV81MzZfMDAwIC8vIDM2NSBkYXlzICogMjQgaG91cnMgKiA2MCBtaW51dGVzICogNjAgc2Vjb25kcwogICAgaW50YyA1IC8vIDMxNTM2MDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEwNQogICAgLy8gY29uc3QgbGVzc1RoYW5PbmVZZWFySW5UaGVGdXR1cmUgPSBleHBpcmF0aW9uIDw9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgKyBPTkVfWUVBUgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDYKICAgIC8vIGNvbnN0IGxvY2tlZCA9IHR5cGUgIT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA2CiAgICAvLyBjb25zdCBsb2NrZWQgPSB0eXBlICE9PSBTVEFLSU5HX1RZUEVfTE9DSwogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA3CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjIzCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0hBUkQ6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDIpCiAgICBieXRlYyA1IC8vIDB4MDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA3CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICA9PQogICAgYm56IHN0YWtlX2Jvb2xfdHJ1ZUAyCiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA3CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUAzCgpzdGFrZV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDgKCnN0YWtlX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA4CiAgICAvLyBjb25zdCB0aW1lc3RhbXAgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExMAogICAgLy8gYXNzZXJ0KChpblRoZUZ1dHVyZSAmJiBsZXNzVGhhbk9uZVllYXJJblRoZUZ1dHVyZSkgfHwgIWxvY2tlZCwgRVJSX0JBRF9FWFBJUkFUSU9OKQogICAgZnJhbWVfZGlnIDExCiAgICBieiBzdGFrZV9vcl9jb250ZEA2CiAgICBmcmFtZV9kaWcgMTIKICAgIGJueiBzdGFrZV9ib29sX3RydWVANwoKc3Rha2Vfb3JfY29udGRANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTEwCiAgICAvLyBhc3NlcnQoKGluVGhlRnV0dXJlICYmIGxlc3NUaGFuT25lWWVhckluVGhlRnV0dXJlKSB8fCAhbG9ja2VkLCBFUlJfQkFEX0VYUElSQVRJT04pCiAgICBmcmFtZV9kaWcgMTMKICAgIGJueiBzdGFrZV9ib29sX2ZhbHNlQDgKCnN0YWtlX2Jvb2xfdHJ1ZUA3OgogICAgaW50Y18xIC8vIDEKCnN0YWtlX2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTEwCiAgICAvLyBhc3NlcnQoKGluVGhlRnV0dXJlICYmIGxlc3NUaGFuT25lWWVhckluVGhlRnV0dXJlKSB8fCAhbG9ja2VkLCBFUlJfQkFEX0VYUElSQVRJT04pCiAgICBhc3NlcnQgLy8gRXhwaXJhdGlvbiBtdXN0IGJlIGluIHRoZSBmdXR1cmUgb3IgaGFyZGxvY2sgZGlzYWJsZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBjb25zdCBhcmM0U2VuZGVyID0gbmV3IEFkZHJlc3MoVHhuLnNlbmRlcikKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBhc3NldDogMCwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gY29uc3Qgc2s6IFN0YWtlS2V5ID0gewogICAgaXRvYgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBjb25zdCBpc1VwZGF0ZSA9IHRoaXMuc3Rha2VzKHNrKS5leGlzdHMKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIGZyYW1lX2RpZyAtMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gY29uc3QgaXNVcGRhdGUgPSB0aGlzLnN0YWtlcyhzaykuZXhpc3RzCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBpZiAoIWlzVXBkYXRlKSB7CiAgICBibnogc3Rha2VfZWxzZV9ib2R5QDMzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gaWYgKGlzRXNjcm93KSB7CiAgICBmcmFtZV9kaWcgOAogICAgYnogc3Rha2VfZWxzZV9ib2R5QDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyNi0xMzMKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogYW1vdW50ICsgY29zdHMuc3Rha2VzLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTI2LTEzMwogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBhbW91bnQgKyBjb3N0cy5zdGFrZXMsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICBieiBzdGFrZV9ib29sX2ZhbHNlQDE0CiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMzAKICAgIC8vIGFtb3VudDogYW1vdW50ICsgY29zdHMuc3Rha2VzLAogICAgZnJhbWVfZGlnIC0yCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9iYXNlLnRzOjcKICAgIC8vIHN0YWtlczogMjhfOTAwLAogICAgaW50YyA0IC8vIDI4OTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gYW1vdW50OiBhbW91bnQgKyBjb3N0cy5zdGFrZXMsCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyNi0xMzMKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogYW1vdW50ICsgY29zdHMuc3Rha2VzLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUAxNAogICAgaW50Y18xIC8vIDEKCnN0YWtlX2Jvb2xfbWVyZ2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyNi0xMzMKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogYW1vdW50ICsgY29zdHMuc3Rha2VzLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CgpzdGFrZV9hZnRlcl9pZl9lbHNlQDMyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTAKICAgIC8vIGFtb3VudCwKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTEKICAgIC8vIGxhc3RVcGRhdGU6IHRpbWVzdGFtcCwKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTIKICAgIC8vIGV4cGlyYXRpb24sCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjA5CiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMDktMjEzCiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICAvLyAgIGFtb3VudCwKICAgIC8vICAgbGFzdFVwZGF0ZTogdGltZXN0YW1wLAogICAgLy8gICBleHBpcmF0aW9uLAogICAgLy8gfQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIHJldHN1YgoKc3Rha2VfYm9vbF9mYWxzZUAxNDoKICAgIGludGNfMCAvLyAwCiAgICBiIHN0YWtlX2Jvb2xfbWVyZ2VAMTUKCnN0YWtlX2Vsc2VfYm9keUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM0CiAgICAvLyB9IGVsc2UgaWYgKHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgIGZyYW1lX2RpZyAtMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MTEKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEVBUlRCRUFUOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgwKQogICAgYnl0ZWMgNCAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzNAogICAgLy8gfSBlbHNlIGlmICh0eXBlID09PSBTVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICA9PQogICAgYnogc3Rha2VfZWxzZV9ib2R5QDI2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzNwogICAgLy8gY29uc3QgaGVsZCA9IG5ldyBVaW50TjY0KFR4bi5zZW5kZXIuYmFsYW5jZSkKICAgIHR4biBTZW5kZXIKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBpdG9iCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBsZXQgaGFyZDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMzkKICAgIC8vIGxldCBsb2NrOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE0NwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGhhcmRTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MjMKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEFSRDogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMikKICAgIGJ5dGVjIDUgLy8gMHgwMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNDcKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhoYXJkU3Rha2VLZXkpLmV4aXN0cykgewogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE0NwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGhhcmRTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IHN0YWtlX2FmdGVyX2lmX2Vsc2VAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTQ4CiAgICAvLyBoYXJkID0gdGhpcy5zdGFrZXMoaGFyZFN0YWtlS2V5KS52YWx1ZS5hbW91bnQKICAgIGZyYW1lX2RpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDcKCnN0YWtlX2FmdGVyX2lmX2Vsc2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE1NwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGxvY2tTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MzAKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfTE9DSzogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMykKICAgIGJ5dGVjXzIgLy8gMHgwMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNTcKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhsb2NrU3Rha2VLZXkpLmV4aXN0cykgewogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE1NwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGxvY2tTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IHN0YWtlX2FmdGVyX2lmX2Vsc2VAMjEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTU4CiAgICAvLyBsb2NrID0gdGhpcy5zdGFrZXMobG9ja1N0YWtlS2V5KS52YWx1ZS5hbW91bnQKICAgIGZyYW1lX2RpZyAyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDkKCnN0YWtlX2FmdGVyX2lmX2Vsc2VAMjE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MS0xNjgKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogY29zdHMuc3Rha2VzICsgY29zdHMuaGVhcnRiZWF0cywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZnJhbWVfZGlnIC00CiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNjQKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MS0xNjgKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogY29zdHMuc3Rha2VzICsgY29zdHMuaGVhcnRiZWF0cywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgIGJ6IHN0YWtlX2Jvb2xfZmFsc2VAMjQKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2NQogICAgLy8gYW1vdW50OiBjb3N0cy5zdGFrZXMgKyBjb3N0cy5oZWFydGJlYXRzLAogICAgaW50YyA2IC8vIDk5MDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MS0xNjgKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogY29zdHMuc3Rha2VzICsgY29zdHMuaGVhcnRiZWF0cywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgIGJ6IHN0YWtlX2Jvb2xfZmFsc2VAMjQKICAgIGludGNfMSAvLyAxCgpzdGFrZV9ib29sX21lcmdlQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNjEtMTY4CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGNvc3RzLnN0YWtlcyArIGNvc3RzLmhlYXJ0YmVhdHMsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBhZGRyZXNzOiBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTc3CiAgICAvLyBoYXJkOiBuZXcgVWludE42NChoYXJkKSwKICAgIGZyYW1lX2RpZyA3CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE3OAogICAgLy8gbG9jazogbmV3IFVpbnRONjQobG9jayksCiAgICBmcmFtZV9kaWcgOQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNzkKICAgIC8vIHRpbWVzdGFtcDogbmV3IFVpbnRONjQodGltZXN0YW1wKSwKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNzUtMTgwCiAgICAvLyBjb25zdCBoYnYgPSBuZXcgYXJjNEhlYXJ0YmVhdCh7CiAgICAvLyAgIGhlbGQsCiAgICAvLyAgIGhhcmQ6IG5ldyBVaW50TjY0KGhhcmQpLAogICAgLy8gICBsb2NrOiBuZXcgVWludE42NChsb2NrKSwKICAgIC8vICAgdGltZXN0YW1wOiBuZXcgVWludE42NCh0aW1lc3RhbXApLAogICAgLy8gfSkKICAgIGZyYW1lX2RpZyA0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxODItMTg3CiAgICAvLyBjb25zdCBlaGJ2ID0gbmV3IGFyYzRIZWFydGJlYXQoewogICAgLy8gICBoZWxkOiBhcmM0WmVybywKICAgIC8vICAgaGFyZDogYXJjNFplcm8sCiAgICAvLyAgIGxvY2s6IGFyYzRaZXJvLAogICAgLy8gICB0aW1lc3RhbXA6IGFyYzRaZXJvLAogICAgLy8gfSkKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4OS0xOTQKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBuZXcgU3RhdGljQXJyYXk8YXJjNEhlYXJ0YmVhdCwgND4oCiAgICAvLyAgIGhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxODItMTg3CiAgICAvLyBjb25zdCBlaGJ2ID0gbmV3IGFyYzRIZWFydGJlYXQoewogICAgLy8gICBoZWxkOiBhcmM0WmVybywKICAgIC8vICAgaGFyZDogYXJjNFplcm8sCiAgICAvLyAgIGxvY2s6IGFyYzRaZXJvLAogICAgLy8gICB0aW1lc3RhbXA6IGFyYzRaZXJvLAogICAgLy8gfSkKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4OS0xOTQKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBuZXcgU3RhdGljQXJyYXk8YXJjNEhlYXJ0YmVhdCwgND4oCiAgICAvLyAgIGhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxODItMTg3CiAgICAvLyBjb25zdCBlaGJ2ID0gbmV3IGFyYzRIZWFydGJlYXQoewogICAgLy8gICBoZWxkOiBhcmM0WmVybywKICAgIC8vICAgaGFyZDogYXJjNFplcm8sCiAgICAvLyAgIGxvY2s6IGFyYzRaZXJvLAogICAgLy8gICB0aW1lc3RhbXA6IGFyYzRaZXJvLAogICAgLy8gfSkKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4OS0xOTQKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBuZXcgU3RhdGljQXJyYXk8YXJjNEhlYXJ0YmVhdCwgND4oCiAgICAvLyAgIGhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxOTYKICAgIC8vIHRoaXMuaGVhcnRiZWF0cyhoZWFydGJlYXRLZXkpLnZhbHVlID0gaGVhcnRiZWF0cy5jb3B5KCkKICAgIHN3YXAKICAgIGZyYW1lX2RpZyA1CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo2CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeEhlYXJ0YmVhdHMgPSAnaCcKICAgIGJ5dGVjIDYgLy8gImgiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTk2CiAgICAvLyB0aGlzLmhlYXJ0YmVhdHMoaGVhcnRiZWF0S2V5KS52YWx1ZSA9IGhlYXJ0YmVhdHMuY29weSgpCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VAMzIKCnN0YWtlX2Jvb2xfZmFsc2VAMjQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzdGFrZV9ib29sX21lcmdlQDI1CgpzdGFrZV9lbHNlX2JvZHlAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE5OAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIuYmFsYW5jZSA+PSBhbW91bnQsIEVSUl9JTlNVRkZJQ0lFTlRfQkFMQU5DRSkKICAgIHR4biBTZW5kZXIKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBmcmFtZV9kaWcgLTIKICAgID49CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IGJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTk5LTIwNgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBjb3N0cy5zdGFrZXMsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjAyCiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxOTktMjA2CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGNvc3RzLnN0YWtlcywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgIGJ6IHN0YWtlX2Jvb2xfZmFsc2VAMjkKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9iYXNlLnRzOjcKICAgIC8vIHN0YWtlczogMjhfOTAwLAogICAgaW50YyA0IC8vIDI4OTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE5OS0yMDYKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogY29zdHMuc3Rha2VzLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgYnogc3Rha2VfYm9vbF9mYWxzZUAyOQogICAgaW50Y18xIC8vIDEKCnN0YWtlX2Jvb2xfbWVyZ2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE5OS0yMDYKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogY29zdHMuc3Rha2VzLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VAMzIKCnN0YWtlX2Jvb2xfZmFsc2VAMjk6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzdGFrZV9ib29sX21lcmdlQDMwCgpzdGFrZV9lbHNlX2JvZHlAMzM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIxNQogICAgLy8gYXNzZXJ0KHR5cGUgIT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQsIEVSUl9IRUFSVEJFQVRfQ0FOTk9UX1VQREFURSkKICAgIGZyYW1lX2RpZyAtMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MTEKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEVBUlRCRUFUOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgwKQogICAgYnl0ZWMgNCAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIxNQogICAgLy8gYXNzZXJ0KHR5cGUgIT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQsIEVSUl9IRUFSVEJFQVRfQ0FOTk9UX1VQREFURSkKICAgICE9CiAgICBhc3NlcnQgLy8gSGVhcnRiZWF0IHN0YWtlcyBjYW5ub3QgYmUgdXBkYXRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTYKICAgIC8vIGNvbnN0IGN1cnJlbnRTdGFrZSA9IHRoaXMuc3Rha2VzKHNrKS52YWx1ZQogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSA2CiAgICBpbnRjXzIgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIxNwogICAgLy8gYXNzZXJ0KGV4cGlyYXRpb24gPj0gY3VycmVudFN0YWtlLmV4cGlyYXRpb24gfHwgIWxvY2tlZCwgRVJSX0JBRF9FWFBJUkFUSU9OX1VQREFURSkKICAgIGZyYW1lX2RpZyAtMQogICAgPD0KICAgIGJueiBzdGFrZV9ib29sX3RydWVAMzUKICAgIGZyYW1lX2RpZyAxMwogICAgYm56IHN0YWtlX2Jvb2xfZmFsc2VAMzYKCnN0YWtlX2Jvb2xfdHJ1ZUAzNToKICAgIGludGNfMSAvLyAxCgpzdGFrZV9ib29sX21lcmdlQDM3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTcKICAgIC8vIGFzc2VydChleHBpcmF0aW9uID49IGN1cnJlbnRTdGFrZS5leHBpcmF0aW9uIHx8ICFsb2NrZWQsIEVSUl9CQURfRVhQSVJBVElPTl9VUERBVEUpCiAgICBhc3NlcnQgLy8gRXhwaXJhdGlvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCB1bmxvY2sgdGltZSBvciBoYXJkbG9jayBkaXNhYmxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTkKICAgIC8vIGlmIChpc0VzY3JvdykgewogICAgZnJhbWVfZGlnIDgKICAgIGJ6IHN0YWtlX2Vsc2VfYm9keUAzOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMjAKICAgIC8vIGFzc2VydChwYXltZW50LnJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgRVJSX0lOVkFMSURfUEFZTUVOVF9SRUNFSVZFUikKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudCByZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMjEKICAgIC8vIGFzc2VydChwYXltZW50LmFtb3VudCA9PT0gYW1vdW50LCBFUlJfSU5WQUxJRF9QQVlNRU5UX0FNT1VOVCkKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50IGFtb3VudAoKc3Rha2VfYWZ0ZXJfaWZfZWxzZUA0MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyBjb25zdCBuZXdBbW91bnQ6IHVpbnQ2NCA9IGN1cnJlbnRTdGFrZS5hbW91bnQgKyBhbW91bnQKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgLTIKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI5CiAgICAvLyBhbW91bnQ6IG5ld0Ftb3VudCwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjMwCiAgICAvLyBsYXN0VXBkYXRlOiB0aW1lc3RhbXAsCiAgICBmcmFtZV9kaWcgMTAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjMxCiAgICAvLyBleHBpcmF0aW9uCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI4CiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMjgtMjMyCiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICAvLyAgIGFtb3VudDogbmV3QW1vdW50LAogICAgLy8gICBsYXN0VXBkYXRlOiB0aW1lc3RhbXAsCiAgICAvLyAgIGV4cGlyYXRpb24KICAgIC8vIH0KICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICByZXRzdWIKCnN0YWtlX2Vsc2VfYm9keUAzOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjIzCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlci5iYWxhbmNlID49IGN1cnJlbnRTdGFrZS5hbW91bnQgKyBhbW91bnQsIEVSUl9JTlNVRkZJQ0lFTlRfQkFMQU5DRSkKICAgIHR4biBTZW5kZXIKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIC0yCiAgICArCiAgICA+PQogICAgYXNzZXJ0IC8vIEluc3VmZmljaWVudCBiYWxhbmNlCiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VANDAKCnN0YWtlX2Jvb2xfZmFsc2VAMzY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzdGFrZV9ib29sX21lcmdlQDM3CgpzdGFrZV9ib29sX2ZhbHNlQDg6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzdGFrZV9ib29sX21lcmdlQDkKCnN0YWtlX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDgKICAgIGIgc3Rha2VfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5zdGFrZUFzYShwYXltZW50OiB1aW50NjQsIGFzc2V0WGZlcjogdWludDY0LCB0eXBlOiBieXRlcywgYW1vdW50OiB1aW50NjQsIGV4cGlyYXRpb246IHVpbnQ2NCkgLT4gdm9pZDoKc3Rha2VBc2E6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIzNi0yNDIKICAgIC8vIHN0YWtlQXNhKAogICAgLy8gICBwYXltZW50OiBndHhuLlBheW1lbnRUeG4sCiAgICAvLyAgIGFzc2V0WGZlcjogZ3R4bi5Bc3NldFRyYW5zZmVyVHhuLAogICAgLy8gICB0eXBlOiBTdGFraW5nVHlwZSwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIGV4cGlyYXRpb246IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBwcm90byA1IDAKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDQKICAgIGJ5dGVjXzMgLy8gIiIKICAgIGR1cG4gNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNDMKICAgIC8vIGNvbnN0IGluVGhlRnV0dXJlID0gZXhwaXJhdGlvbiA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGZyYW1lX2RpZyAtMQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNDQKICAgIC8vIGxldCBsZXNzVGhhbk1heExvY2t1cCA9IGV4cGlyYXRpb24gPD0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCArIE9ORV9ZRUFSCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6OQogICAgLy8gZXhwb3J0IGNvbnN0IE9ORV9ZRUFSOiB1aW50NjQgPSAzMV81MzZfMDAwIC8vIDM2NSBkYXlzICogMjQgaG91cnMgKiA2MCBtaW51dGVzICogNjAgc2Vjb25kcwogICAgaW50YyA1IC8vIDMxNTM2MDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gbGV0IGxlc3NUaGFuTWF4TG9ja3VwID0gZXhwaXJhdGlvbiA8PSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wICsgT05FX1lFQVIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ1CiAgICAvLyBpZiAodGhpcy5zZXR0aW5ncyhhc3NldFhmZXIueGZlckFzc2V0LmlkKS5leGlzdHMpIHsKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgWGZlckFzc2V0CiAgICBkdXAKICAgIGl0b2IKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjcKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4U2V0dGluZ3MgPSAnZScKICAgIGJ5dGVjIDkgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNDUKICAgIC8vIGlmICh0aGlzLnNldHRpbmdzKGFzc2V0WGZlci54ZmVyQXNzZXQuaWQpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBzdGFrZUFzYV9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ2CiAgICAvLyBsZXNzVGhhbk1heExvY2t1cCA9IGV4cGlyYXRpb24gPD0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCArIHRoaXMuc2V0dGluZ3MoYXNzZXRYZmVyLnhmZXJBc3NldC5pZCkudmFsdWUKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGZyYW1lX2RpZyAxNQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGJ0b2kKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgPj0KICAgIGZyYW1lX2J1cnkgMTIKCnN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ4CiAgICAvLyBjb25zdCBsb2NrZWQgPSB0eXBlICE9PSBTVEFLSU5HX1RZUEVfTE9DSwogICAgZnJhbWVfZGlnIC0zCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czozMAogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9MT0NLOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgzKQogICAgYnl0ZWNfMiAvLyAweDAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI0OAogICAgLy8gY29uc3QgbG9ja2VkID0gdHlwZSAhPT0gU1RBS0lOR19UWVBFX0xPQ0sKICAgICE9CiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ5CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjIzCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0hBUkQ6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDIpCiAgICBieXRlYyA1IC8vIDB4MDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ5CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICA9PQogICAgYm56IHN0YWtlQXNhX2Jvb2xfdHJ1ZUA0CiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQ5CiAgICAvLyBjb25zdCBpc0VzY3JvdyA9IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLCiAgICA9PQogICAgYnogc3Rha2VBc2FfYm9vbF9mYWxzZUA1CgpzdGFrZUFzYV9ib29sX3RydWVANDoKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDcKCnN0YWtlQXNhX2Jvb2xfbWVyZ2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjUwCiAgICAvLyBjb25zdCB0aW1lc3RhbXAgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1MgogICAgLy8gYXNzZXJ0KChpblRoZUZ1dHVyZSAmJiBsZXNzVGhhbk1heExvY2t1cCkgfHwgIWxvY2tlZCwgRVJSX0JBRF9FWFBJUkFUSU9OKQogICAgZnJhbWVfZGlnIDExCiAgICBieiBzdGFrZUFzYV9vcl9jb250ZEA4CiAgICBmcmFtZV9kaWcgMTIKICAgIGJueiBzdGFrZUFzYV9ib29sX3RydWVAOQoKc3Rha2VBc2Ffb3JfY29udGRAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjUyCiAgICAvLyBhc3NlcnQoKGluVGhlRnV0dXJlICYmIGxlc3NUaGFuTWF4TG9ja3VwKSB8fCAhbG9ja2VkLCBFUlJfQkFEX0VYUElSQVRJT04pCiAgICBmcmFtZV9kaWcgOQogICAgYm56IHN0YWtlQXNhX2Jvb2xfZmFsc2VAMTAKCnN0YWtlQXNhX2Jvb2xfdHJ1ZUA5OgogICAgaW50Y18xIC8vIDEKCnN0YWtlQXNhX2Jvb2xfbWVyZ2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1MgogICAgLy8gYXNzZXJ0KChpblRoZUZ1dHVyZSAmJiBsZXNzVGhhbk1heExvY2t1cCkgfHwgIWxvY2tlZCwgRVJSX0JBRF9FWFBJUkFUSU9OKQogICAgYXNzZXJ0IC8vIEV4cGlyYXRpb24gbXVzdCBiZSBpbiB0aGUgZnV0dXJlIG9yIGhhcmRsb2NrIGRpc2FibGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1NQogICAgLy8gY29uc3QgYXJjNFNlbmRlciA9IG5ldyBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1OQogICAgLy8gY29uc3QgaXNVcGRhdGUgPSB0aGlzLnN0YWtlcyhzaykuZXhpc3RzCiAgICBmcmFtZV9kaWcgMTQKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIGZyYW1lX2RpZyAtMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1OQogICAgLy8gY29uc3QgaXNVcGRhdGUgPSB0aGlzLnN0YWtlcyhzaykuZXhpc3RzCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjYxCiAgICAvLyBpZiAoIWlzVXBkYXRlKSB7CiAgICBibnogc3Rha2VBc2FfZWxzZV9ib2R5QDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI2NQogICAgLy8gaWYgKGlzRXNjcm93KSB7CiAgICBmcmFtZV9kaWcgNwogICAgYnogc3Rha2VBc2FfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI2NgogICAgLy8gYXNzZXJ0KHBheW1lbnQucmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBFUlJfSU5WQUxJRF9QQVlNRU5UX1JFQ0VJVkVSKQogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50IHJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI2NwogICAgLy8gYXNzZXJ0KHBheW1lbnQuYW1vdW50ID09PSBjb3N0cy5zdGFrZXMsIEVSUl9JTlZBTElEX1BBWU1FTlRfQU1PVU5UKQogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2Jhc2UudHM6NwogICAgLy8gc3Rha2VzOiAyOF85MDAsCiAgICBpbnRjIDQgLy8gMjg5MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjY3CiAgICAvLyBhc3NlcnQocGF5bWVudC5hbW91bnQgPT09IGNvc3RzLnN0YWtlcywgRVJSX0lOVkFMSURfUEFZTUVOVF9BTU9VTlQpCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudCBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjY5CiAgICAvLyBhc3NlcnQoYXNzZXRYZmVyLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBFUlJfSU5WQUxJRF9BU1NFVF9BTU9VTlQpCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgYXNzZXQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI3MAogICAgLy8gYXNzZXJ0KGFzc2V0WGZlci5hc3NldEFtb3VudCA9PT0gYW1vdW50LCBFUlJfSU5WQUxJRF9BU1NFVF9BTU9VTlQpCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgID09CiAgICBhc3NlcnQgLy8gSW52YWxpZCBhc3NldCBhbW91bnQKCnN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMzNgogICAgLy8gYW1vdW50LAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMzNwogICAgLy8gbGFzdFVwZGF0ZTogdGltZXN0YW1wLAogICAgZnJhbWVfZGlnIDEwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMzOAogICAgLy8gZXhwaXJhdGlvbiwKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMzUKICAgIC8vIHRoaXMuc3Rha2VzKHNrKS52YWx1ZSA9IHsKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMzNS0zMzkKICAgIC8vIHRoaXMuc3Rha2VzKHNrKS52YWx1ZSA9IHsKICAgIC8vICAgYW1vdW50LAogICAgLy8gICBsYXN0VXBkYXRlOiB0aW1lc3RhbXAsCiAgICAvLyAgIGV4cGlyYXRpb24sCiAgICAvLyB9CiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpzdGFrZUFzYV9lbHNlX2JvZHlAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI3MQogICAgLy8gfSBlbHNlIGlmICh0eXBlID09PSBTVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICBmcmFtZV9kaWcgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjExCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0hFQVJUQkVBVDogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMCkKICAgIGJ5dGVjIDQgLy8gMHgwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNzEKICAgIC8vIH0gZWxzZSBpZiAodHlwZSA9PT0gU1RBS0lOR19UWVBFX0hFQVJUQkVBVCkgewogICAgPT0KICAgIGJ6IHN0YWtlQXNhX2Vsc2VfYm9keUAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNzIKICAgIC8vIGNvbnN0IFtob2xkaW5nQW1vdW50LCBvcHRlZEluXSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2UoVHhuLnNlbmRlciwgYXNzZXQpCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgMTMKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNzQKICAgIC8vIGFzc2VydChvcHRlZEluLCBFUlJfTk9UX09QVEVEX0lOKQogICAgYXNzZXJ0IC8vIE5vdCBvcHRlZCBpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNzUKICAgIC8vIGFzc2VydChob2xkaW5nQW1vdW50ID4gMCwgRVJSX0lOVkFMSURfQVNTRVRfQU1PVU5UKQogICAgZHVwCiAgICBhc3NlcnQgLy8gSW52YWxpZCBhc3NldCBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjc3CiAgICAvLyBjb25zdCBoZWxkID0gbmV3IFVpbnRONjQoaG9sZGluZ0Ftb3VudCkKICAgIGl0b2IKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyODEKICAgIC8vIGxldCBoYXJkOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4MgogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGhhcmRTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MjMKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEFSRDogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMikKICAgIGJ5dGVjIDUgLy8gMHgwMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyODIKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhoYXJkU3Rha2VLZXkpLmV4aXN0cykgewogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4MgogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGhhcmRTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IHN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMTcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjgzCiAgICAvLyBoYXJkID0gdGhpcy5zdGFrZXMoaGFyZFN0YWtlS2V5KS52YWx1ZS5hbW91bnQKICAgIGZyYW1lX2RpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDYKCnN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4OAogICAgLy8gbGV0IGxvY2s6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjg5CiAgICAvLyBpZiAodGhpcy5zdGFrZXMobG9ja1N0YWtlS2V5KS5leGlzdHMpIHsKICAgIGZyYW1lX2RpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czozMAogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9MT0NLOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgzKQogICAgYnl0ZWNfMiAvLyAweDAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4OQogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGxvY2tTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjg5CiAgICAvLyBpZiAodGhpcy5zdGFrZXMobG9ja1N0YWtlS2V5KS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogc3Rha2VBc2FfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyOTAKICAgIC8vIGxvY2sgPSB0aGlzLnN0YWtlcyhsb2NrU3Rha2VLZXkpLnZhbHVlLmFtb3VudAogICAgZnJhbWVfZGlnIDIKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgOAoKc3Rha2VBc2FfYWZ0ZXJfaWZfZWxzZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjkzCiAgICAvLyBhc3NlcnQocGF5bWVudC5yZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsIEVSUl9JTlZBTElEX1BBWU1FTlRfUkVDRUlWRVIpCiAgICBmcmFtZV9kaWcgLTUKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQgcmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjk0CiAgICAvLyBhc3NlcnQocGF5bWVudC5hbW91bnQgPT09IChjb3N0cy5zdGFrZXMgKyBjb3N0cy5oZWFydGJlYXRzKSwgRVJSX0lOVkFMSURfUEFZTUVOVF9BTU9VTlQpCiAgICBmcmFtZV9kaWcgLTUKICAgIGd0eG5zIEFtb3VudAogICAgaW50YyA2IC8vIDk5MDAwCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudCBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjk3CiAgICAvLyBhc3NlcnQoYXNzZXRYZmVyLmFzc2V0QW1vdW50ID09PSAwLCBFUlJfSU5WQUxJRF9BU1NFVF9BTU9VTlQpCiAgICBmcmFtZV9kaWcgLTQKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICAhCiAgICBhc3NlcnQgLy8gSW52YWxpZCBhc3NldCBhbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzAzCiAgICAvLyBoYXJkOiBuZXcgVWludE42NChoYXJkKSwKICAgIGZyYW1lX2RpZyA2CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMwNAogICAgLy8gbG9jazogbmV3IFVpbnRONjQobG9jayksCiAgICBmcmFtZV9kaWcgOAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDUKICAgIC8vIHRpbWVzdGFtcDogbmV3IFVpbnRONjQodGltZXN0YW1wKSwKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDEtMzA2CiAgICAvLyBjb25zdCBoYnYgPSBuZXcgYXJjNEhlYXJ0YmVhdCh7CiAgICAvLyAgIGhlbGQsCiAgICAvLyAgIGhhcmQ6IG5ldyBVaW50TjY0KGhhcmQpLAogICAgLy8gICBsb2NrOiBuZXcgVWludE42NChsb2NrKSwKICAgIC8vICAgdGltZXN0YW1wOiBuZXcgVWludE42NCh0aW1lc3RhbXApLAogICAgLy8gfSkKICAgIGZyYW1lX2RpZyA0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDgtMzEzCiAgICAvLyBjb25zdCBlaGJ2ID0gbmV3IGFyYzRIZWFydGJlYXQoewogICAgLy8gICBoZWxkOiBhcmM0WmVybywKICAgIC8vICAgaGFyZDogYXJjNFplcm8sCiAgICAvLyAgIGxvY2s6IGFyYzRaZXJvLAogICAgLy8gICB0aW1lc3RhbXA6IGFyYzRaZXJvLAogICAgLy8gfSkKICAgIGJ5dGVjIDcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMxNS0zMjAKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBuZXcgYXJjNC5TdGF0aWNBcnJheTxhcmM0SGVhcnRiZWF0LCA0PigKICAgIC8vICAgaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKQogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMwOC0zMTMKICAgIC8vIGNvbnN0IGVoYnYgPSBuZXcgYXJjNEhlYXJ0YmVhdCh7CiAgICAvLyAgIGhlbGQ6IGFyYzRaZXJvLAogICAgLy8gICBoYXJkOiBhcmM0WmVybywKICAgIC8vICAgbG9jazogYXJjNFplcm8sCiAgICAvLyAgIHRpbWVzdGFtcDogYXJjNFplcm8sCiAgICAvLyB9KQogICAgYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzE1LTMyMAogICAgLy8gY29uc3QgaGVhcnRiZWF0cyA9IG5ldyBhcmM0LlN0YXRpY0FycmF5PGFyYzRIZWFydGJlYXQsIDQ+KAogICAgLy8gICBoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzA4LTMxMwogICAgLy8gY29uc3QgZWhidiA9IG5ldyBhcmM0SGVhcnRiZWF0KHsKICAgIC8vICAgaGVsZDogYXJjNFplcm8sCiAgICAvLyAgIGhhcmQ6IGFyYzRaZXJvLAogICAgLy8gICBsb2NrOiBhcmM0WmVybywKICAgIC8vICAgdGltZXN0YW1wOiBhcmM0WmVybywKICAgIC8vIH0pCiAgICBieXRlYyA3IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMTUtMzIwCiAgICAvLyBjb25zdCBoZWFydGJlYXRzID0gbmV3IGFyYzQuU3RhdGljQXJyYXk8YXJjNEhlYXJ0YmVhdCwgND4oCiAgICAvLyAgIGhidi5jb3B5KCksCiAgICAvLyAgIGVoYnYuY29weSgpLAogICAgLy8gICBlaGJ2LmNvcHkoKSwKICAgIC8vICAgZWhidi5jb3B5KCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjYKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4SGVhcnRiZWF0cyA9ICdoJwogICAgYnl0ZWMgNiAvLyAiaCIKICAgIGZyYW1lX2RpZyAzCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzIyCiAgICAvLyB0aGlzLmhlYXJ0YmVhdHMoaGVhcnRiZWF0S2V5KS52YWx1ZSA9IGhlYXJ0YmVhdHMuY29weSgpCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIHN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMjIKCnN0YWtlQXNhX2Vsc2VfYm9keUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyBjb25zdCBbaG9sZGluZ0Ftb3VudCwgb3B0ZWRJbl0gPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKFR4bi5zZW5kZXIsIGFzc2V0KQogICAgdHhuIFNlbmRlcgogICAgZnJhbWVfZGlnIDEzCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzI1CiAgICAvLyBhc3NlcnQob3B0ZWRJbiwgRVJSX05PVF9PUFRFRF9JTikKICAgIGFzc2VydCAvLyBOb3Qgb3B0ZWQgaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzI2CiAgICAvLyBhc3NlcnQoaG9sZGluZ0Ftb3VudCA+PSBhbW91bnQsIEVSUl9JTlNVRkZJQ0lFTlRfQkFMQU5DRSkKICAgIGZyYW1lX2RpZyAtMgogICAgPj0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgYmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMjgKICAgIC8vIGFzc2VydChwYXltZW50LnJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgRVJSX0lOVkFMSURfUEFZTUVOVF9SRUNFSVZFUikKICAgIGZyYW1lX2RpZyAtNQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudCByZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMjkKICAgIC8vIGFzc2VydChwYXltZW50LmFtb3VudCA9PT0gY29zdHMuc3Rha2VzLCBFUlJfSU5WQUxJRF9QQVlNRU5UX0FNT1VOVCkKICAgIGZyYW1lX2RpZyAtNQogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9iYXNlLnRzOjcKICAgIC8vIHN0YWtlczogMjhfOTAwLAogICAgaW50YyA0IC8vIDI4OTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMyOQogICAgLy8gYXNzZXJ0KHBheW1lbnQuYW1vdW50ID09PSBjb3N0cy5zdGFrZXMsIEVSUl9JTlZBTElEX1BBWU1FTlRfQU1PVU5UKQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMzMgogICAgLy8gYXNzZXJ0KGFzc2V0WGZlci5hc3NldEFtb3VudCA9PT0gMCwgRVJSX0lOVkFMSURfQVNTRVRfQU1PVU5UKQogICAgZnJhbWVfZGlnIC00CiAgICBndHhucyBBc3NldEFtb3VudAogICAgIQogICAgYXNzZXJ0IC8vIEludmFsaWQgYXNzZXQgYW1vdW50CiAgICBiIHN0YWtlQXNhX2FmdGVyX2lmX2Vsc2VAMjIKCnN0YWtlQXNhX2Vsc2VfYm9keUAyMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQxCiAgICAvLyBhc3NlcnQodHlwZSAhPT0gU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwgRVJSX0hFQVJUQkVBVF9DQU5OT1RfVVBEQVRFKQogICAgZnJhbWVfZGlnIC0zCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czoxMQogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQ6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDApCiAgICBieXRlYyA0IC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQxCiAgICAvLyBhc3NlcnQodHlwZSAhPT0gU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwgRVJSX0hFQVJUQkVBVF9DQU5OT1RfVVBEQVRFKQogICAgIT0KICAgIGFzc2VydCAvLyBIZWFydGJlYXQgc3Rha2VzIGNhbm5vdCBiZSB1cGRhdGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM0MgogICAgLy8gY29uc3QgY3VycmVudFN0YWtlID0gdGhpcy5zdGFrZXMoc2spLnZhbHVlCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDUKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQzCiAgICAvLyBhc3NlcnQoZXhwaXJhdGlvbiA+PSBjdXJyZW50U3Rha2UuZXhwaXJhdGlvbiB8fCAhbG9ja2VkLCBFUlJfQkFEX0VYUElSQVRJT05fVVBEQVRFKQogICAgZnJhbWVfZGlnIC0xCiAgICA8PQogICAgYm56IHN0YWtlQXNhX2Jvb2xfdHJ1ZUAyNQogICAgZnJhbWVfZGlnIDkKICAgIGJueiBzdGFrZUFzYV9ib29sX2ZhbHNlQDI2CgpzdGFrZUFzYV9ib29sX3RydWVAMjU6CiAgICBpbnRjXzEgLy8gMQoKc3Rha2VBc2FfYm9vbF9tZXJnZUAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQzCiAgICAvLyBhc3NlcnQoZXhwaXJhdGlvbiA+PSBjdXJyZW50U3Rha2UuZXhwaXJhdGlvbiB8fCAhbG9ja2VkLCBFUlJfQkFEX0VYUElSQVRJT05fVVBEQVRFKQogICAgYXNzZXJ0IC8vIEV4cGlyYXRpb24gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdW5sb2NrIHRpbWUgb3IgaGFyZGxvY2sgZGlzYWJsZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQ2CiAgICAvLyBhc3NlcnQocGF5bWVudC5yZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsIEVSUl9JTlZBTElEX1BBWU1FTlRfUkVDRUlWRVIpCiAgICBmcmFtZV9kaWcgLTUKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQgcmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQ3CiAgICAvLyBhc3NlcnQocGF5bWVudC5hbW91bnQgPT09IDAsIEVSUl9JTlZBTElEX1BBWU1FTlRfQU1PVU5UKQogICAgZnJhbWVfZGlnIC01CiAgICBndHhucyBBbW91bnQKICAgICEKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM0OQogICAgLy8gaWYgKGlzRXNjcm93KSB7CiAgICBmcmFtZV9kaWcgNwogICAgYnogc3Rha2VBc2FfZWxzZV9ib2R5QDI5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1MAogICAgLy8gYXNzZXJ0KGFzc2V0WGZlci5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgRVJSX0lOVkFMSURfQVNTRVRfQU1PVU5UKQogICAgZnJhbWVfZGlnIC00CiAgICBndHhucyBBc3NldFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGFzc2V0IGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNTEKICAgIC8vIGFzc2VydChhc3NldFhmZXIuYXNzZXRBbW91bnQgPT09IGFtb3VudCwgRVJSX0lOVkFMSURfQVNTRVRfQU1PVU5UKQogICAgZnJhbWVfZGlnIC00CiAgICBndHhucyBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgYXNzZXQgYW1vdW50CgpzdGFrZUFzYV9hZnRlcl9pZl9lbHNlQDMwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjAKICAgIC8vIGNvbnN0IG5ld0Ftb3VudDogdWludDY0ID0gY3VycmVudFN0YWtlLmFtb3VudCArIGFtb3VudAogICAgZnJhbWVfZGlnIDUKICAgIGZyYW1lX2RpZyAtMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjMKICAgIC8vIGFtb3VudDogbmV3QW1vdW50LAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjQKICAgIC8vIGxhc3RVcGRhdGU6IHRpbWVzdGFtcCwKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjUKICAgIC8vIGV4cGlyYXRpb24sCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzYyCiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjItMzY2CiAgICAvLyB0aGlzLnN0YWtlcyhzaykudmFsdWUgPSB7CiAgICAvLyAgIGFtb3VudDogbmV3QW1vdW50LAogICAgLy8gICBsYXN0VXBkYXRlOiB0aW1lc3RhbXAsCiAgICAvLyAgIGV4cGlyYXRpb24sCiAgICAvLyB9CiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpzdGFrZUFzYV9lbHNlX2JvZHlAMjk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1MwogICAgLy8gY29uc3QgW2hvbGRpbmdBbW91bnQsIG9wdGVkSW5dID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShUeG4uc2VuZGVyLCBhc3NldCkKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAxMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1NAogICAgLy8gYXNzZXJ0KG9wdGVkSW4sIEVSUl9OT1RfT1BURURfSU4pCiAgICBhc3NlcnQgLy8gTm90IG9wdGVkIGluCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1NQogICAgLy8gYXNzZXJ0KGhvbGRpbmdBbW91bnQgPj0gY3VycmVudFN0YWtlLmFtb3VudCArIGFtb3VudCwgRVJSX0lOU1VGRklDSUVOVF9CQUxBTkNFKQogICAgZnJhbWVfZGlnIDUKICAgIGZyYW1lX2RpZyAtMgogICAgKwogICAgPj0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgYmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNTcKICAgIC8vIGFzc2VydChhc3NldFhmZXIuYXNzZXRBbW91bnQgPT09IDAsIEVSUl9JTlZBTElEX0FTU0VUX0FNT1VOVCkKICAgIGZyYW1lX2RpZyAtNAogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgICEKICAgIGFzc2VydCAvLyBJbnZhbGlkIGFzc2V0IGFtb3VudAogICAgYiBzdGFrZUFzYV9hZnRlcl9pZl9lbHNlQDMwCgpzdGFrZUFzYV9ib29sX2ZhbHNlQDI2OgogICAgaW50Y18wIC8vIDAKICAgIGIgc3Rha2VBc2FfYm9vbF9tZXJnZUAyNwoKc3Rha2VBc2FfYm9vbF9mYWxzZUAxMDoKICAgIGludGNfMCAvLyAwCiAgICBiIHN0YWtlQXNhX2Jvb2xfbWVyZ2VAMTEKCnN0YWtlQXNhX2Jvb2xfZmFsc2VANToKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDcKICAgIGIgc3Rha2VBc2FfYm9vbF9tZXJnZUA2CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy53aXRoZHJhdyhhc3NldDogdWludDY0LCB0eXBlOiBieXRlcykgLT4gdm9pZDoKd2l0aGRyYXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3MAogICAgLy8gd2l0aGRyYXcoYXNzZXQ6IHVpbnQ2NCwgdHlwZTogU3Rha2luZ1R5cGUpOiB2b2lkIHsKICAgIHByb3RvIDIgMAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzIKICAgIC8vIHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IQVJEIHx8IHR5cGUgPT09IFNUQUtJTkdfVFlQRV9MT0NLLAogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czoyMwogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9IQVJEOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgyKQogICAgYnl0ZWMgNSAvLyAweDAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3MgogICAgLy8gdHlwZSA9PT0gU1RBS0lOR19UWVBFX0hBUkQgfHwgdHlwZSA9PT0gU1RBS0lOR19UWVBFX0xPQ0ssCiAgICA9PQogICAgYm56IHdpdGhkcmF3X2Jvb2xfdHJ1ZUAyCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzcyCiAgICAvLyB0eXBlID09PSBTVEFLSU5HX1RZUEVfSEFSRCB8fCB0eXBlID09PSBTVEFLSU5HX1RZUEVfTE9DSywKICAgID09CiAgICBieiB3aXRoZHJhd19ib29sX2ZhbHNlQDMKCndpdGhkcmF3X2Jvb2xfdHJ1ZUAyOgogICAgaW50Y18xIC8vIDEKCndpdGhkcmF3X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzcxLTM3NAogICAgLy8gYXNzZXJ0KAogICAgLy8gICB0eXBlID09PSBTVEFLSU5HX1RZUEVfSEFSRCB8fCB0eXBlID09PSBTVEFLSU5HX1RZUEVfTE9DSywKICAgIC8vICAgRVJSX1dJVEhEUkFXX0lTX09OTFlfRk9SX0hBUkRfT1JfTE9DSwogICAgLy8gKQogICAgYXNzZXJ0IC8vIFdpdGhkcmF3IGlzIG9ubHkgZm9yIGhhcmQgb3IgbG9jawogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzUKICAgIC8vIGNvbnN0IGFyYzRTZW5kZXIgPSBuZXcgQWRkcmVzcyhUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzYKICAgIC8vIGNvbnN0IHNrID0geyBhZGRyZXNzOiBhcmM0U2VuZGVyLCBhc3NldCwgdHlwZSB9CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mzc3CiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXMoc2spLmV4aXN0cywgRVJSX05PX0xPQ0spCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3NwogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VzKHNrKS5leGlzdHMsIEVSUl9OT19MT0NLKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBMb2NrIG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzkKICAgIC8vIGNvbnN0IGN1cnJlbnRTdGFrZSA9IHRoaXMuc3Rha2VzKHNrKS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDEKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODAKICAgIC8vIGFzc2VydCh0eXBlICE9PSBTVEFLSU5HX1RZUEVfTE9DSyB8fCBjdXJyZW50U3Rha2UuZXhwaXJhdGlvbiA8IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsIEVSUl9MT0NLRUQpCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzgwCiAgICAvLyBhc3NlcnQodHlwZSAhPT0gU1RBS0lOR19UWVBFX0xPQ0sgfHwgY3VycmVudFN0YWtlLmV4cGlyYXRpb24gPCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLCBFUlJfTE9DS0VEKQogICAgIT0KICAgIGJueiB3aXRoZHJhd19ib29sX3RydWVANgogICAgZnJhbWVfZGlnIDIKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIDwKICAgIGJ6IHdpdGhkcmF3X2Jvb2xfZmFsc2VANwoKd2l0aGRyYXdfYm9vbF90cnVlQDY6CiAgICBpbnRjXzEgLy8gMQoKd2l0aGRyYXdfYm9vbF9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODAKICAgIC8vIGFzc2VydCh0eXBlICE9PSBTVEFLSU5HX1RZUEVfTE9DSyB8fCBjdXJyZW50U3Rha2UuZXhwaXJhdGlvbiA8IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsIEVSUl9MT0NLRUQpCiAgICBhc3NlcnQgLy8gVGhpcyBhc3NldCBpcyBzdGlsbCBsb2NrZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzgyCiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGZyYW1lX2RpZyAtMgogICAgYm56IHdpdGhkcmF3X2Vsc2VfYm9keUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODMtMzg5CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ6IGN1cnJlbnRTdGFrZS5hbW91bnQsCiAgICAvLyAgICAgZmVlLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mzg1CiAgICAvLyByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAxCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODMtMzg4CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ6IGN1cnJlbnRTdGFrZS5hbW91bnQsCiAgICAvLyAgICAgZmVlLAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9jb25zdGFudHMudHM6NAogICAgLy8gZXhwb3J0IGNvbnN0IGZlZTogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM4My0zODkKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogY3VycmVudFN0YWtlLmFtb3VudCwKICAgIC8vICAgICBmZWUsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCndpdGhkcmF3X2FmdGVyX2lmX2Vsc2VAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwMAogICAgLy8gdGhpcy5zdGFrZXMoc2spLmRlbGV0ZSgpCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2RlbAogICAgcG9wCiAgICByZXRzdWIKCndpdGhkcmF3X2Vsc2VfYm9keUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzkxLTM5OAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhc3NldEFtb3VudDogY3VycmVudFN0YWtlLmFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIGZlZSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM5MwogICAgLy8gYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGZyYW1lX2RpZyAxCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzkxLTM5NwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhc3NldEFtb3VudDogY3VycmVudFN0YWtlLmFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIGZlZSwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvY29uc3RhbnRzLnRzOjQKICAgIC8vIGV4cG9ydCBjb25zdCBmZWU6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozOTEtMzk4CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBjdXJyZW50U3Rha2UuYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgZmVlLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIHdpdGhkcmF3X2FmdGVyX2lmX2Vsc2VAMTMKCndpdGhkcmF3X2Jvb2xfZmFsc2VANzoKICAgIGludGNfMCAvLyAwCiAgICBiIHdpdGhkcmF3X2Jvb2xfbWVyZ2VAOAoKd2l0aGRyYXdfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgd2l0aGRyYXdfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5jcmVhdGVIZWFydGJlYXQoYWRkcmVzczogYnl0ZXMsIGFzc2V0OiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZUhlYXJ0YmVhdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDAzCiAgICAvLyBjcmVhdGVIZWFydGJlYXQoYWRkcmVzczogQWRkcmVzcywgYXNzZXQ6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMiAwCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiIgogICAgZHVwbiAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwNAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuaGVhcnRiZWF0TWFuYWdlckFkZHJlc3MudmFsdWUubmF0aXZlLCBFUlJfTk9UX0hFQVJUQkVBVF9NQU5BR0VSKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjMKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nR2xvYmFsU3RhdGVLZXlIZWFydGJlYXRNYW5hZ2VyQWRkcmVzcyA9ICdoZWFydGJlYXRfbWFuYWdlcl9hZGRyZXNzJwogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiaGVhcnRiZWF0X21hbmFnZXJfYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwNAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuaGVhcnRiZWF0TWFuYWdlckFkZHJlc3MudmFsdWUubmF0aXZlLCBFUlJfTk9UX0hFQVJUQkVBVF9NQU5BR0VSKQogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBoZWFydGJlYXQgbWFuYWdlciBjYW4gY2FsbCB0aGlzIG1ldGhvZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MDYKICAgIC8vIGNvbnN0IGhiayA9IHsgYWRkcmVzcywgYXNzZXQgfQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwNwogICAgLy8gYXNzZXJ0KHRoaXMuaGVhcnRiZWF0cyhoYmspLmV4aXN0cywgRVJSX0hFQVJCRUFUX05PVF9GT1VORCkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo2CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeEhlYXJ0YmVhdHMgPSAnaCcKICAgIGJ5dGVjIDYgLy8gImgiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDA3CiAgICAvLyBhc3NlcnQodGhpcy5oZWFydGJlYXRzKGhiaykuZXhpc3RzLCBFUlJfSEVBUkJFQVRfTk9UX0ZPVU5EKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBIZWFydGJlYXQgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwOQogICAgLy8gY29uc3QgdGltZXN0YW1wID0gbmV3IFVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDEwCiAgICAvLyBjb25zdCBoZWFydGJlYXRzID0gZGVjb2RlQXJjNDxIZWFydGJlYXRzPih0aGlzLmhlYXJ0YmVhdHMoaGJrKS52YWx1ZS5ieXRlcykKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQxMgogICAgLy8gY29uc3QgW2hvbGRpbmdzXSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2UoYWRkcmVzcy5uYXRpdmUsIGFzc2V0KQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQxMwogICAgLy8gY29uc3QgaGVsZCA9IG5ldyBVaW50TjY0KGhvbGRpbmdzKQogICAgaXRvYgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MjEKICAgIC8vIGxldCBoYXJkOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MjMKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEFSRDogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMikKICAgIGJ5dGVjIDUgLy8gMHgwMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MjIKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhoYXJkU3Rha2VLZXkpLmV4aXN0cykgewogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MjIKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhoYXJkU3Rha2VLZXkpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBjcmVhdGVIZWFydGJlYXRfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQyMwogICAgLy8gaGFyZCA9IHRoaXMuc3Rha2VzKGhhcmRTdGFrZUtleSkudmFsdWUuYW1vdW50CiAgICBmcmFtZV9kaWcgMTEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTAKCmNyZWF0ZUhlYXJ0YmVhdF9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQzMgogICAgLy8gbGV0IGxvY2s6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDMzCiAgICAvLyBpZiAodGhpcy5zdGFrZXMobG9ja1N0YWtlS2V5KS5leGlzdHMpIHsKICAgIGZyYW1lX2RpZyA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czozMAogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9MT0NLOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgzKQogICAgYnl0ZWNfMiAvLyAweDAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQzMwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKGxvY2tTdGFrZUtleSkuZXhpc3RzKSB7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDMzCiAgICAvLyBpZiAodGhpcy5zdGFrZXMobG9ja1N0YWtlS2V5KS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogY3JlYXRlSGVhcnRiZWF0X2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MzQKICAgIC8vIGxvY2sgPSB0aGlzLnN0YWtlcyhsb2NrU3Rha2VLZXkpLnZhbHVlLmFtb3VudAogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMwoKY3JlYXRlSGVhcnRiZWF0X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQzCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgNDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxCgpjcmVhdGVIZWFydGJlYXRfd2hpbGVfdG9wQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ0MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IDQ7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDEKICAgIHB1c2hpbnQgNCAvLyA0CiAgICA8CiAgICBieiBjcmVhdGVIZWFydGJlYXRfYWZ0ZXJfd2hpbGVAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ1CiAgICAvLyBpID09PSAzIHx8CiAgICBmcmFtZV9kaWcgMQogICAgcHVzaGludCAzIC8vIDMKICAgID09CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NDUtNDQ2CiAgICAvLyBpID09PSAzIHx8CiAgICAvLyBoZWFydGJlYXRzW2ldLnRpbWVzdGFtcCA+IGhlYXJ0YmVhdHNbaSArIDFdLnRpbWVzdGFtcAogICAgYm56IGNyZWF0ZUhlYXJ0YmVhdF9pZl9ib2R5QDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ2CiAgICAvLyBoZWFydGJlYXRzW2ldLnRpbWVzdGFtcCA+IGhlYXJ0YmVhdHNbaSArIDFdLnRpbWVzdGFtcAogICAgZnJhbWVfZGlnIDgKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgcHVzaGludCAyNCAvLyAyNAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgaW50Y18zIC8vIDMyCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICA+CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ0NS00NDYKICAgIC8vIGkgPT09IDMgfHwKICAgIC8vIGhlYXJ0YmVhdHNbaV0udGltZXN0YW1wID4gaGVhcnRiZWF0c1tpICsgMV0udGltZXN0YW1wCiAgICBieiBjcmVhdGVIZWFydGJlYXRfYWZ0ZXJfaWZfZWxzZUAxMgoKY3JlYXRlSGVhcnRiZWF0X2lmX2JvZHlAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ4CiAgICAvLyBjb25zdCBpbmRleFRvTW9kaWZ5OiB1aW50NjQgPSBpID09PSAzID8gMCA6IGkgKyAxCiAgICBmcmFtZV9kaWcgNAogICAgYnogY3JlYXRlSGVhcnRiZWF0X3Rlcm5hcnlfZmFsc2VAMTAKICAgIGludGNfMCAvLyAwCgpjcmVhdGVIZWFydGJlYXRfdGVybmFyeV9tZXJnZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDUxCiAgICAvLyBoYXJkOiBuZXcgVWludE42NChoYXJkKSwKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NTIKICAgIC8vIGxvY2s6IG5ldyBVaW50TjY0KGxvY2spLAogICAgZnJhbWVfZGlnIDMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ5LTQ1NAogICAgLy8gdGhpcy5oZWFydGJlYXRzKGhiaykudmFsdWVbaW5kZXhUb01vZGlmeV0gPSBuZXcgYXJjNEhlYXJ0YmVhdCh7CiAgICAvLyAgIGhlbGQsCiAgICAvLyAgIGhhcmQ6IG5ldyBVaW50TjY0KGhhcmQpLAogICAgLy8gICBsb2NrOiBuZXcgVWludE42NChsb2NrKSwKICAgIC8vICAgdGltZXN0YW1wLAogICAgLy8gfSkKICAgIGZyYW1lX2RpZyA5CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgNwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ0OQogICAgLy8gdGhpcy5oZWFydGJlYXRzKGhiaykudmFsdWVbaW5kZXhUb01vZGlmeV0gPSBuZXcgYXJjNEhlYXJ0YmVhdCh7CiAgICBmcmFtZV9kaWcgNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NDktNDU0CiAgICAvLyB0aGlzLmhlYXJ0YmVhdHMoaGJrKS52YWx1ZVtpbmRleFRvTW9kaWZ5XSA9IG5ldyBhcmM0SGVhcnRiZWF0KHsKICAgIC8vICAgaGVsZCwKICAgIC8vICAgaGFyZDogbmV3IFVpbnRONjQoaGFyZCksCiAgICAvLyAgIGxvY2s6IG5ldyBVaW50TjY0KGxvY2spLAogICAgLy8gICB0aW1lc3RhbXAsCiAgICAvLyB9KQogICAgdW5jb3ZlciAzCiAgICBkdXAKICAgIHB1c2hpbnQgNCAvLyA0CiAgICA8CiAgICBhc3NlcnQgLy8gSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMyAvLyAzMgogICAgKgogICAgdW5jb3ZlciAyCiAgICByZXBsYWNlMwogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NTUKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgpjcmVhdGVIZWFydGJlYXRfdGVybmFyeV9mYWxzZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ4CiAgICAvLyBjb25zdCBpbmRleFRvTW9kaWZ5OiB1aW50NjQgPSBpID09PSAzID8gMCA6IGkgKyAxCiAgICBmcmFtZV9kaWcgMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGIgY3JlYXRlSGVhcnRiZWF0X3Rlcm5hcnlfbWVyZ2VAMTEKCmNyZWF0ZUhlYXJ0YmVhdF9hZnRlcl9pZl9lbHNlQDEyOgogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2J1cnkgMQogICAgYiBjcmVhdGVIZWFydGJlYXRfd2hpbGVfdG9wQDUKCmNyZWF0ZUhlYXJ0YmVhdF9hZnRlcl93aGlsZUAxMzoKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcuc29mdENoZWNrKGFkZHJlc3M6IGJ5dGVzLCBhc3NldDogdWludDY0KSAtPiB1aW50NjQsIHVpbnQ2NDoKc29mdENoZWNrOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjAKICAgIC8vIHNvZnRDaGVjayhhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogeyB2YWxpZDogYm9vbGVhbiwgYmFsYW5jZTogdWludDY0IH0gewogICAgcHJvdG8gMiAyCiAgICBieXRlY18zIC8vICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDYxCiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgYXNzZXQsIHR5cGU6IFNUQUtJTkdfVFlQRV9TT0ZUIH0KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjIKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzaykuZXhpc3RzLCBFUlJfU1RBS0VfRE9FU05UX0VYSVNUKQogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjE3CiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX1NPRlQ6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDEpCiAgICBwdXNoYnl0ZXMgMHgwMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjIKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzaykuZXhpc3RzLCBFUlJfU1RBS0VfRE9FU05UX0VYSVNUKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjIKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzaykuZXhpc3RzLCBFUlJfU1RBS0VfRE9FU05UX0VYSVNUKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gU3Rha2UgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDY0CiAgICAvLyBjb25zdCBzdGFrZSA9IHRoaXMuc3Rha2VzKHNrKS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjUKICAgIC8vIGNvbnN0IGxhc3RVcGRhdGUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2NwogICAgLy8gaWYgKGFzc2V0ID09PSAwKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGJueiBzb2Z0Q2hlY2tfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2OAogICAgLy8gY29uc3QgdmFsaWQgPSBhZGRyZXNzLm5hdGl2ZS5iYWxhbmNlID49IHN0YWtlLmFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgPD0KICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2OQogICAgLy8gaWYgKCF2YWxpZCkgewogICAgYm56IHNvZnRDaGVja19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDcxCiAgICAvLyBhbW91bnQ6IGFkZHJlc3MubmF0aXZlLmJhbGFuY2UsCiAgICBmcmFtZV9kaWcgLTIKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ3MgogICAgLy8gbGFzdFVwZGF0ZSwKICAgIGZyYW1lX2RpZyA0CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ3MwogICAgLy8gZXhwaXJhdGlvbjogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ3MAogICAgLy8gdGhpcy5zdGFrZXMoc2spLnZhbHVlID0gewogICAgY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDcwLTQ3NAogICAgLy8gdGhpcy5zdGFrZXMoc2spLnZhbHVlID0gewogICAgLy8gICBhbW91bnQ6IGFkZHJlc3MubmF0aXZlLmJhbGFuY2UsCiAgICAvLyAgIGxhc3RVcGRhdGUsCiAgICAvLyAgIGV4cGlyYXRpb246IDAsCiAgICAvLyB9CiAgICBmcmFtZV9kaWcgMwogICAgc3dhcAogICAgYm94X3B1dAoKc29mdENoZWNrX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDc2CiAgICAvLyByZXR1cm4geyB2YWxpZCwgYmFsYW5jZTogYWRkcmVzcy5uYXRpdmUuYmFsYW5jZSB9CiAgICBmcmFtZV9kaWcgLTIKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfYnVyeSAwCiAgICBmcmFtZV9idXJ5IDEKICAgIHJldHN1YgoKc29mdENoZWNrX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDc5CiAgICAvLyBjb25zdCBbaG9sZGluZ0Ftb3VudCwgb3B0ZWRJbl0gPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKGFkZHJlc3MubmF0aXZlLCBhc3NldCkKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ4MAogICAgLy8gYXNzZXJ0KG9wdGVkSW4sIEVSUl9OT1RfT1BURURfSU4pCiAgICBhc3NlcnQgLy8gTm90IG9wdGVkIGluCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ4MQogICAgLy8gY29uc3QgdmFsaWQgPSBob2xkaW5nQW1vdW50ID49IHN0YWtlLmFtb3VudAogICAgPD0KICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ4MgogICAgLy8gaWYgKCF2YWxpZCkgewogICAgYm56IHNvZnRDaGVja19hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDg0CiAgICAvLyBhbW91bnQ6IGhvbGRpbmdBbW91bnQsCiAgICBmcmFtZV9kaWcgMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0ODUKICAgIC8vIGxhc3RVcGRhdGUsCiAgICBmcmFtZV9kaWcgNAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0ODYKICAgIC8vIGV4cGlyYXRpb246IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0ODMKICAgIC8vIHRoaXMuc3Rha2VzKHNrKS52YWx1ZSA9IHsKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ4My00ODcKICAgIC8vIHRoaXMuc3Rha2VzKHNrKS52YWx1ZSA9IHsKICAgIC8vICAgYW1vdW50OiBob2xkaW5nQW1vdW50LAogICAgLy8gICBsYXN0VXBkYXRlLAogICAgLy8gICBleHBpcmF0aW9uOiAwLAogICAgLy8gfQogICAgZnJhbWVfZGlnIDMKICAgIHN3YXAKICAgIGJveF9wdXQKCnNvZnRDaGVja19hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ5MAogICAgLy8gcmV0dXJuIHsgdmFsaWQsIGJhbGFuY2U6IGhvbGRpbmdBbW91bnQgfQogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy51cGRhdGVTZXR0aW5ncyhwYXltZW50OiB1aW50NjQsIGFzc2V0OiB1aW50NjQsIHZhbHVlOiB1aW50NjQpIC0+IHZvaWQ6CnVwZGF0ZVNldHRpbmdzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTMKICAgIC8vIHVwZGF0ZVNldHRpbmdzKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXQ6IHVpbnQ2NCwgdmFsdWU6IHVpbnQ2NCk6IHZvaWQgewogICAgcHJvdG8gMyAwCiAgICBieXRlY18zIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ5NAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEFzc2V0KGFzc2V0KS5jcmVhdG9yLCBFUlJfTk9UX0FTU0VUX0NSRUFUT1IpCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGFzc2V0IGNyZWF0b3IgY2FuIGNhbGwgdGhpcyBtZXRob2QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDk1LTUwMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLnNldHRpbmdzKGFzc2V0KS5leGlzdHMgPyAwIDogdGhpcy5tYnIoKS5zZXR0aW5ncywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0zCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTgKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ5NS01MDIKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5zZXR0aW5ncyhhc3NldCkuZXhpc3RzID8gMCA6IHRoaXMubWJyKCkuc2V0dGluZ3MsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICBieiB1cGRhdGVTZXR0aW5nc19ib29sX2ZhbHNlQDYKICAgIGZyYW1lX2RpZyAtMwogICAgZ3R4bnMgQW1vdW50CiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDk5CiAgICAvLyBhbW91bnQ6IHRoaXMuc2V0dGluZ3MoYXNzZXQpLmV4aXN0cyA/IDAgOiB0aGlzLm1icigpLnNldHRpbmdzLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NwogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTZXR0aW5ncyA9ICdlJwogICAgYnl0ZWMgOSAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTkKICAgIC8vIGFtb3VudDogdGhpcy5zZXR0aW5ncyhhc3NldCkuZXhpc3RzID8gMCA6IHRoaXMubWJyKCkuc2V0dGluZ3MsCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IHVwZGF0ZVNldHRpbmdzX3Rlcm5hcnlfZmFsc2VAMwogICAgaW50Y18wIC8vIDAKCnVwZGF0ZVNldHRpbmdzX3Rlcm5hcnlfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDk1LTUwMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLnNldHRpbmdzKGFzc2V0KS5leGlzdHMgPyAwIDogdGhpcy5tYnIoKS5zZXR0aW5ncywKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZnJhbWVfZGlnIDAKICAgID09CiAgICBieiB1cGRhdGVTZXR0aW5nc19ib29sX2ZhbHNlQDYKICAgIGludGNfMSAvLyAxCgp1cGRhdGVTZXR0aW5nc19ib29sX21lcmdlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ5NS01MDIKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5zZXR0aW5ncyhhc3NldCkuZXhpc3RzID8gMCA6IHRoaXMubWJyKCkuc2V0dGluZ3MsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTA0CiAgICAvLyB0aGlzLnNldHRpbmdzKGFzc2V0KS52YWx1ZSA9IHZhbHVlCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo3CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFNldHRpbmdzID0gJ2UnCiAgICBieXRlYyA5IC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUwNAogICAgLy8gdGhpcy5zZXR0aW5ncyhhc3NldCkudmFsdWUgPSB2YWx1ZQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICByZXRzdWIKCnVwZGF0ZVNldHRpbmdzX2Jvb2xfZmFsc2VANjoKICAgIGludGNfMCAvLyAwCiAgICBiIHVwZGF0ZVNldHRpbmdzX2Jvb2xfbWVyZ2VANwoKdXBkYXRlU2V0dGluZ3NfdGVybmFyeV9mYWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvYmFzZS50czo5CiAgICAvLyBzZXR0aW5nczogOV8zMDAKICAgIHB1c2hpbnQgOTMwMCAvLyA5MzAwCiAgICBiIHVwZGF0ZVNldHRpbmdzX3Rlcm5hcnlfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcuZ2V0VGltZUxlZnQoYWRkcmVzczogYnl0ZXMsIGFzc2V0OiB1aW50NjQpIC0+IHVpbnQ2NDoKZ2V0VGltZUxlZnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUxMC01MTEKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gZ2V0VGltZUxlZnQoYWRkcmVzczogQWRkcmVzcywgYXNzZXQ6IHVpbnQ2NCk6IHVpbnQ2NCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTEyCiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgYXNzZXQsIHR5cGU6IFNUQUtJTkdfVFlQRV9MT0NLIH0KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MTQKICAgIC8vIGlmICghdGhpcy5zdGFrZXMoc2spLmV4aXN0cyB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3Rha2VzKHNrKS52YWx1ZS5leHBpcmF0aW9uKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MzAKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfTE9DSzogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMykKICAgIGJ5dGVjXzIgLy8gMHgwMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MTQKICAgIC8vIGlmICghdGhpcy5zdGFrZXMoc2spLmV4aXN0cyB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3Rha2VzKHNrKS52YWx1ZS5leHBpcmF0aW9uKSB7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUxNAogICAgLy8gaWYgKCF0aGlzLnN0YWtlcyhzaykuZXhpc3RzIHx8IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFrZXMoc2spLnZhbHVlLmV4cGlyYXRpb24pIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogZ2V0VGltZUxlZnRfaWZfYm9keUAyCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgID49CiAgICBieiBnZXRUaW1lTGVmdF9hZnRlcl9pZl9lbHNlQDMKCmdldFRpbWVMZWZ0X2lmX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTE1CiAgICAvLyByZXR1cm4gMAogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIHJldHN1YgoKZ2V0VGltZUxlZnRfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MTgKICAgIC8vIHJldHVybiB0aGlzLnN0YWtlcyhzaykudmFsdWUuZXhwaXJhdGlvbiAtIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18yIC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLQogICAgc3dhcAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5tdXN0R2V0VGltZUxlZnQoYWRkcmVzczogYnl0ZXMsIGFzc2V0OiB1aW50NjQpIC0+IHVpbnQ2NDoKbXVzdEdldFRpbWVMZWZ0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MjEtNTIyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIG11c3RHZXRUaW1lTGVmdChhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogdWludDY0IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MjMKICAgIC8vIGNvbnN0IHNrID0geyBhZGRyZXNzLCBhc3NldCwgdHlwZTogU1RBS0lOR19UWVBFX0xPQ0sgfQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyNAogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VzKHNrKS5leGlzdHMsIEVSUl9OT19MT0NLKQogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL3R5cGVzLnRzOjMwCiAgICAvLyBleHBvcnQgY29uc3QgU1RBS0lOR19UWVBFX0xPQ0s6IFN0YWtpbmdUeXBlID0gbmV3IGFyYzQuVWludE44KDMpCiAgICBieXRlY18yIC8vIDB4MDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTI0CiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXMoc2spLmV4aXN0cywgRVJSX05PX0xPQ0spCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MjQKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzaykuZXhpc3RzLCBFUlJfTk9fTE9DSykKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTG9jayBub3QgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTI1CiAgICAvLyBhc3NlcnQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IHRoaXMuc3Rha2VzKHNrKS52YWx1ZS5leHBpcmF0aW9uLCBFUlJfTE9DS0VEKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgc3dhcAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIHN3YXAKICAgIGRpZyAxCiAgICA8CiAgICBhc3NlcnQgLy8gVGhpcyBhc3NldCBpcyBzdGlsbCBsb2NrZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTI2CiAgICAvLyByZXR1cm4gdGhpcy5zdGFrZXMoc2spLnZhbHVlLmV4cGlyYXRpb24gLSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICAtCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nLmdldEluZm8oYWRkcmVzczogYnl0ZXMsIHN0YWtlLmFzc2V0OiB1aW50NjQsIHN0YWtlLnR5cGU6IGJ5dGVzKSAtPiB1aW50NjQsIHVpbnQ2NCwgdWludDY0OgpnZXRJbmZvOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MjktNTMwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIGdldEluZm8oYWRkcmVzczogQWRkcmVzcywgc3Rha2U6IFN0YWtlSW5mbyk6IFN0YWtlIHsKICAgIHByb3RvIDMgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzEKICAgIC8vIGNvbnN0IHNrID0geyBhZGRyZXNzLCAuLi5zdGFrZSB9CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTMyCiAgICAvLyBpZiAoIXRoaXMuc3Rha2VzKHNrKS5leGlzdHMpIHsKICAgIGZyYW1lX2RpZyAtMwogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjUKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4U3Rha2VzID0gJ3MnCiAgICBieXRlY18wIC8vICJzIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTMyCiAgICAvLyBpZiAoIXRoaXMuc3Rha2VzKHNrKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGdldEluZm9fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUzMwogICAgLy8gcmV0dXJuIHsgYW1vdW50OiAwLCBsYXN0VXBkYXRlOiAwLCBleHBpcmF0aW9uOiAwIH0KICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDIKICAgIHVuY292ZXIgMwogICAgcmV0c3ViCgpnZXRJbmZvX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTM2CiAgICAvLyByZXR1cm4gdGhpcy5zdGFrZXMoc2spLnZhbHVlCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5tdXN0R2V0SW5mbyhhZGRyZXNzOiBieXRlcywgc3Rha2UuYXNzZXQ6IHVpbnQ2NCwgc3Rha2UudHlwZTogYnl0ZXMpIC0+IHVpbnQ2NCwgdWludDY0LCB1aW50NjQ6Cm11c3RHZXRJbmZvOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzktNTQwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIG11c3RHZXRJbmZvKGFkZHJlc3M6IEFkZHJlc3MsIHN0YWtlOiBTdGFrZUluZm8pOiBTdGFrZSB7CiAgICBwcm90byAzIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQxCiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgLi4uc3Rha2UgfQogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0MgogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VzKHNrKS5leGlzdHMsIEVSUl9OT19MT0NLKQogICAgZnJhbWVfZGlnIC0zCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NQogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhTdGFrZXMgPSAncycKICAgIGJ5dGVjXzAgLy8gInMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQyCiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXMoc2spLmV4aXN0cywgRVJSX05PX0xPQ0spCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIExvY2sgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0NAogICAgLy8gcmV0dXJuIHRoaXMuc3Rha2VzKHNrKS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcuZ2V0RXNjcm93SW5mbyhhZGRyZXNzOiBieXRlcywgYXNzZXQ6IHVpbnQ2NCkgLT4gdWludDY0LCB1aW50NjQ6CmdldEVzY3Jvd0luZm86CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0Ny01NDgKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gZ2V0RXNjcm93SW5mbyhhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogRXNjcm93IHsKICAgIHByb3RvIDIgMgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTUyCiAgICAvLyBsZXQgaGFyZDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQ5CiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgYXNzZXQsIHR5cGU6IFNUQUtJTkdfVFlQRV9IQVJEIH0KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NTMKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhzaykuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy90eXBlcy50czoyMwogICAgLy8gZXhwb3J0IGNvbnN0IFNUQUtJTkdfVFlQRV9IQVJEOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgyKQogICAgYnl0ZWMgNSAvLyAweDAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1MwogICAgLy8gaWYgKHRoaXMuc3Rha2VzKHNrKS5leGlzdHMpIHsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjUKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4U3Rha2VzID0gJ3MnCiAgICBieXRlY18wIC8vICJzIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTUzCiAgICAvLyBpZiAodGhpcy5zdGFrZXMoc2spLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBnZXRFc2Nyb3dJbmZvX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NTQKICAgIC8vIGhhcmQgPSB0aGlzLnN0YWtlcyhzaykudmFsdWUuYW1vdW50CiAgICBmcmFtZV9kaWcgNAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAyCgpnZXRFc2Nyb3dJbmZvX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTU3CiAgICAvLyBsZXQgbG9jazogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NTgKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhsaykuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MzAKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfTE9DSzogU3Rha2luZ1R5cGUgPSBuZXcgYXJjNC5VaW50TjgoMykKICAgIGJ5dGVjXzIgLy8gMHgwMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NTgKICAgIC8vIGlmICh0aGlzLnN0YWtlcyhsaykuZXhpc3RzKSB7CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTU4CiAgICAvLyBpZiAodGhpcy5zdGFrZXMobGspLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBnZXRFc2Nyb3dJbmZvX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NTkKICAgIC8vIGxvY2sgPSB0aGlzLnN0YWtlcyhsaykudmFsdWUuYW1vdW50CiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxCgpnZXRFc2Nyb3dJbmZvX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYyCiAgICAvLyByZXR1cm4geyBoYXJkLCBsb2NrIH0KICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcuZ2V0SGVhcnRiZWF0KGFkZHJlc3M6IGJ5dGVzLCBhc3NldDogdWludDY0KSAtPiBieXRlczoKZ2V0SGVhcnRiZWF0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NjUtNTY2CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIGdldEhlYXJ0YmVhdChhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0KTogSGVhcnRiZWF0cyB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTY3CiAgICAvLyBjb25zdCBoYmsgPSB7IGFkZHJlc3MsIGFzc2V0IH0KICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NjgKICAgIC8vIGlmICghdGhpcy5oZWFydGJlYXRzKGhiaykuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjYKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4SGVhcnRiZWF0cyA9ICdoJwogICAgYnl0ZWMgNiAvLyAiaCIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2OAogICAgLy8gaWYgKCF0aGlzLmhlYXJ0YmVhdHMoaGJrKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGdldEhlYXJ0YmVhdF9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTc3CiAgICAvLyByZXR1cm4gW2VoYnYsIGVoYnYsIGVoYnYsIGVoYnZdCiAgICBwdXNoYnl0ZXMgMHgwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgc3dhcAogICAgcmV0c3ViCgpnZXRIZWFydGJlYXRfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1ODAKICAgIC8vIHJldHVybiBkZWNvZGVBcmM0PEhlYXJ0YmVhdHM+KHRoaXMuaGVhcnRiZWF0cyhoYmspLnZhbHVlLmJ5dGVzKQogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nLm11c3RHZXRIZWFydGJlYXQoYWRkcmVzczogYnl0ZXMsIGFzc2V0OiB1aW50NjQpIC0+IGJ5dGVzOgptdXN0R2V0SGVhcnRiZWF0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1ODMtNTg0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIG11c3RHZXRIZWFydGJlYXQoYWRkcmVzczogQWRkcmVzcywgYXNzZXQ6IHVpbnQ2NCk6IEhlYXJ0YmVhdHMgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU4NQogICAgLy8gY29uc3QgaGJrID0geyBhZGRyZXNzLCBhc3NldCB9CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTg2CiAgICAvLyBhc3NlcnQodGhpcy5oZWFydGJlYXRzKGhiaykuZXhpc3RzLCBFUlJfSEVBUkJFQVRfTk9UX0ZPVU5EKQogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo2CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeEhlYXJ0YmVhdHMgPSAnaCcKICAgIGJ5dGVjIDYgLy8gImgiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTg2CiAgICAvLyBhc3NlcnQodGhpcy5oZWFydGJlYXRzKGhiaykuZXhpc3RzLCBFUlJfSEVBUkJFQVRfTk9UX0ZPVU5EKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBIZWFydGJlYXQgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU4NwogICAgLy8gcmV0dXJuIGRlY29kZUFyYzQ8SGVhcnRiZWF0cz4odGhpcy5oZWFydGJlYXRzKGhiaykudmFsdWUuYnl0ZXMpCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5nZXRIZWFydGJlYXRBdmVyYWdlKGFkZHJlc3M6IGJ5dGVzLCBhc3NldDogdWludDY0LCBpbmNsdWRlU3Rha2VkOiB1aW50NjQpIC0+IHVpbnQ2NDoKZ2V0SGVhcnRiZWF0QXZlcmFnZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTkwLTU5MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBnZXRIZWFydGJlYXRBdmVyYWdlKGFkZHJlc3M6IEFkZHJlc3MsIGFzc2V0OiB1aW50NjQsIGluY2x1ZGVTdGFrZWQ6IGJvb2xlYW4pOiB1aW50NjQgewogICAgcHJvdG8gMyAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU5MgogICAgLy8gY29uc3QgaGJrID0geyBhZGRyZXNzLCBhc3NldCB9CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTk0CiAgICAvLyBpZiAoIXRoaXMuaGVhcnRiZWF0cyhoYmspLmV4aXN0cykgewogICAgZnJhbWVfZGlnIC0zCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo2CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeEhlYXJ0YmVhdHMgPSAnaCcKICAgIGJ5dGVjIDYgLy8gImgiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OTQKICAgIC8vIGlmICghdGhpcy5oZWFydGJlYXRzKGhiaykuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBnZXRIZWFydGJlYXRBdmVyYWdlX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OTUKICAgIC8vIHJldHVybiAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmdldEhlYXJ0YmVhdEF2ZXJhZ2VfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OTgKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBkZWNvZGVBcmM0PEhlYXJ0YmVhdHM+KHRoaXMuaGVhcnRiZWF0cyhoYmspLnZhbHVlLmJ5dGVzKQogICAgZnJhbWVfZGlnIDQKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAwCiAgICAvLyBsZXQgdG90YWw6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAxCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgaGVhcnRiZWF0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMQoKZ2V0SGVhcnRiZWF0QXZlcmFnZV93aGlsZV90b3BAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAxCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgaGVhcnRiZWF0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIGZyYW1lX2RpZyAxCiAgICA+CiAgICBieiBnZXRIZWFydGJlYXRBdmVyYWdlX2FmdGVyX3doaWxlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAyCiAgICAvLyBpZiAoaW5jbHVkZVN0YWtlZCkgewogICAgZnJhbWVfZGlnIC0xCiAgICBieiBnZXRIZWFydGJlYXRBdmVyYWdlX2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYwMwogICAgLy8gdG90YWwgKz0gaGVhcnRiZWF0c1tpXS5oZWxkICsgaGVhcnRiZWF0c1tpXS5oYXJkICsgaGVhcnRiZWF0c1tpXS5sb2NrCiAgICBmcmFtZV9kaWcgMAogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgKwogICAgc3dhcAogICAgaW50Y18yIC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgKwogICAgZnJhbWVfZGlnIDMKICAgICsKICAgIGZyYW1lX2J1cnkgMwoKZ2V0SGVhcnRiZWF0QXZlcmFnZV9hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYwMQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGhlYXJ0YmVhdHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAxCiAgICBiIGdldEhlYXJ0YmVhdEF2ZXJhZ2Vfd2hpbGVfdG9wQDMKCmdldEhlYXJ0YmVhdEF2ZXJhZ2VfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYwNQogICAgLy8gdG90YWwgKz0gaGVhcnRiZWF0c1tpXS5oZWxkCiAgICBmcmFtZV9kaWcgMAogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAzCiAgICArCiAgICBmcmFtZV9idXJ5IDMKICAgIGIgZ2V0SGVhcnRiZWF0QXZlcmFnZV9hZnRlcl9pZl9lbHNlQDcKCmdldEhlYXJ0YmVhdEF2ZXJhZ2VfYWZ0ZXJfd2hpbGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjA5CiAgICAvLyByZXR1cm4gdG90YWwgLyBoZWFydGJlYXRzLmxlbmd0aAogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2RpZyAyCiAgICAvCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmcubXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2UoYWRkcmVzczogYnl0ZXMsIGFzc2V0OiB1aW50NjQsIGluY2x1ZGVTdGFrZWQ6IHVpbnQ2NCkgLT4gdWludDY0OgptdXN0R2V0SGVhcnRiZWF0QXZlcmFnZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjEyLTYxMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBtdXN0R2V0SGVhcnRiZWF0QXZlcmFnZShhZGRyZXNzOiBBZGRyZXNzLCBhc3NldDogdWludDY0LCBpbmNsdWRlU3Rha2VkOiBib29sZWFuKTogdWludDY0IHsKICAgIHByb3RvIDMgMQogICAgYnl0ZWNfMyAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MTQKICAgIC8vIGNvbnN0IGhiayA9IHsgYWRkcmVzcywgYXNzZXQgfQogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxNQogICAgLy8gYXNzZXJ0KHRoaXMuaGVhcnRiZWF0cyhoYmspLmV4aXN0cywgRVJSX0hFQVJCRUFUX05PVF9GT1VORCkKICAgIGZyYW1lX2RpZyAtMwogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb25zdGFudHMudHM6NgogICAgLy8gZXhwb3J0IGNvbnN0IFN0YWtpbmdCb3hQcmVmaXhIZWFydGJlYXRzID0gJ2gnCiAgICBieXRlYyA2IC8vICJoIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxNQogICAgLy8gYXNzZXJ0KHRoaXMuaGVhcnRiZWF0cyhoYmspLmV4aXN0cywgRVJSX0hFQVJCRUFUX05PVF9GT1VORCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gSGVhcnRiZWF0IG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MTcKICAgIC8vIGNvbnN0IGhlYXJ0YmVhdHMgPSBkZWNvZGVBcmM0PEhlYXJ0YmVhdHM+KHRoaXMuaGVhcnRiZWF0cyhoYmspLnZhbHVlLmJ5dGVzKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjE5CiAgICAvLyBsZXQgdG90YWw6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYyMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGhlYXJ0YmVhdHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGR1cAoKbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2Vfd2hpbGVfdG9wQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYyMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGhlYXJ0YmVhdHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBmcmFtZV9kaWcgMwogICAgPgogICAgYnogbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2VfYWZ0ZXJfd2hpbGVANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MjEKICAgIC8vIGlmIChpbmNsdWRlU3Rha2VkKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGJ6IG11c3RHZXRIZWFydGJlYXRBdmVyYWdlX2Vsc2VfYm9keUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYyMgogICAgLy8gdG90YWwgKz0gaGVhcnRiZWF0c1tpXS5oZWxkICsgaGVhcnRiZWF0c1tpXS5oYXJkICsgaGVhcnRiZWF0c1tpXS5sb2NrCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAzCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgKwogICAgc3dhcAogICAgaW50Y18yIC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgKwogICAgZnJhbWVfZGlnIDIKICAgICsKICAgIGZyYW1lX2J1cnkgMgoKbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2VfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MjAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBoZWFydGJlYXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMwogICAgYiBtdXN0R2V0SGVhcnRiZWF0QXZlcmFnZV93aGlsZV90b3BAMQoKbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2VfZWxzZV9ib2R5QDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYyNAogICAgLy8gdG90YWwgKz0gaGVhcnRiZWF0c1tpXS5oZWxkCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAzCiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAyCiAgICArCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgbXVzdEdldEhlYXJ0YmVhdEF2ZXJhZ2VfYWZ0ZXJfaWZfZWxzZUA1CgptdXN0R2V0SGVhcnRiZWF0QXZlcmFnZV9hZnRlcl93aGlsZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MjgKICAgIC8vIHJldHVybiB0b3RhbCAvIGhlYXJ0YmVhdHMubGVuZ3RoCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDAKICAgIC8KICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5nZXRJbmZvTGlzdChhZGRyZXNzOiBieXRlcywgdHlwZTogYnl0ZXMsIGFzc2V0czogYnl0ZXMpIC0+IGJ5dGVzOgpnZXRJbmZvTGlzdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjMxLTYzMgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBnZXRJbmZvTGlzdChhZGRyZXNzOiBBZGRyZXNzLCB0eXBlOiBTdGFraW5nVHlwZSwgYXNzZXRzOiB1aW50NjRbXSk6IFN0YWtlW10gewogICAgcHJvdG8gMyAxCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MzMKICAgIC8vIGxldCByZXN1bHRzOiBTdGFrZVtdID0gW10KICAgIGJ5dGVjIDExIC8vIDB4MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MzQKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCgpnZXRJbmZvTGlzdF93aGlsZV90b3BAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjM0CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIDIKICAgID4KICAgIGJ6IGdldEluZm9MaXN0X2FmdGVyX3doaWxlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjM1CiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgYXNzZXQ6IGFzc2V0c1tpXSwgdHlwZSB9CiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMgogICAgcHVzaGludCA4IC8vIDgKICAgICoKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYzNgogICAgLy8gaWYgKCF0aGlzLnN0YWtlcyhzaykuZXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgLTMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjM2CiAgICAvLyBpZiAoIXRoaXMuc3Rha2VzKHNrKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGdldEluZm9MaXN0X2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NDQKICAgIC8vIHJlc3VsdHMgPSBbLi4ucmVzdWx0cywgZW1wdHlTdGFrZV0KICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0IDIgMAogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKCmdldEluZm9MaXN0X2Jsb2NrQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYzNAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgZ2V0SW5mb0xpc3Rfd2hpbGVfdG9wQDEKCmdldEluZm9MaXN0X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjQ4LTY1MQogICAgLy8gcmVzdWx0cyA9IFsKICAgIC8vICAgLi4ucmVzdWx0cywKICAgIC8vICAgdGhpcy5zdGFrZXMoc2spLnZhbHVlLAogICAgLy8gXQogICAgZnJhbWVfZGlnIDEKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY1MAogICAgLy8gdGhpcy5zdGFrZXMoc2spLnZhbHVlLAogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciAyCiAgICBpbnRjXzIgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjQ4LTY1MQogICAgLy8gcmVzdWx0cyA9IFsKICAgIC8vICAgLi4ucmVzdWx0cywKICAgIC8vICAgdGhpcy5zdGFrZXMoc2spLnZhbHVlLAogICAgLy8gXQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGV4dHJhY3QgMiAwCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKICAgIGIgZ2V0SW5mb0xpc3RfYmxvY2tANQoKZ2V0SW5mb0xpc3RfYWZ0ZXJfd2hpbGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjUzCiAgICAvLyByZXR1cm4gcmVzdWx0cwogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5tdXN0R2V0SW5mb0xpc3QoYWRkcmVzczogYnl0ZXMsIHR5cGU6IGJ5dGVzLCBhc3NldHM6IGJ5dGVzKSAtPiBieXRlczoKbXVzdEdldEluZm9MaXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NTYtNjU3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIG11c3RHZXRJbmZvTGlzdChhZGRyZXNzOiBBZGRyZXNzLCB0eXBlOiBTdGFraW5nVHlwZSwgYXNzZXRzOiB1aW50NjRbXSk6IFN0YWtlW10gewogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY1OAogICAgLy8gbGV0IHJlc3VsdHM6IFN0YWtlW10gPSBbXQogICAgYnl0ZWMgMTEgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY1OQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKCm11c3RHZXRJbmZvTGlzdF93aGlsZV90b3BAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjU5CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIDEKICAgID4KICAgIGJ6IG11c3RHZXRJbmZvTGlzdF9hZnRlcl93aGlsZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY2MAogICAgLy8gY29uc3Qgc2sgPSB7IGFkZHJlc3MsIGFzc2V0OiBhc3NldHNbaV0sIHR5cGUgfQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgY292ZXIgMgogICAgcHVzaGludCA4IC8vIDgKICAgICoKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY2MQogICAgLy8gYXNzZXJ0KHRoaXMuc3Rha2VzKHNrKS5leGlzdHMsIEVSUl9TVEFLRV9OT1RfRk9VTkQpCiAgICBmcmFtZV9kaWcgLTMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnN0YW50cy50czo1CiAgICAvLyBleHBvcnQgY29uc3QgU3Rha2luZ0JveFByZWZpeFN0YWtlcyA9ICdzJwogICAgYnl0ZWNfMCAvLyAicyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NjEKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzaykuZXhpc3RzLCBFUlJfU1RBS0VfTk9UX0ZPVU5EKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBTdGFrZSBub3QgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjYzLTY2NgogICAgLy8gcmVzdWx0cyA9IFsKICAgIC8vICAgLi4ucmVzdWx0cywKICAgIC8vICAgdGhpcy5zdGFrZXMoc2spLnZhbHVlLAogICAgLy8gXQogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY2NQogICAgLy8gdGhpcy5zdGFrZXMoc2spLnZhbHVlLAogICAgc3dhcAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NjMtNjY2CiAgICAvLyByZXN1bHRzID0gWwogICAgLy8gICAuLi5yZXN1bHRzLAogICAgLy8gICB0aGlzLnN0YWtlcyhzaykudmFsdWUsCiAgICAvLyBdCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAyNCAvLyAyNAogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZXh0cmFjdCAyIDAKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NTkKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDEKICAgIGIgbXVzdEdldEluZm9MaXN0X3doaWxlX3RvcEAxCgptdXN0R2V0SW5mb0xpc3RfYWZ0ZXJfd2hpbGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjY4CiAgICAvLyByZXR1cm4gcmVzdWx0cwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZy5zdGFrZUNoZWNrKGFkZHJlc3M6IGJ5dGVzLCBjaGVja3M6IGJ5dGVzLCB0eXBlOiBieXRlcywgaW5jbHVkZVN0YWtlZDogdWludDY0KSAtPiB1aW50NjQ6CnN0YWtlQ2hlY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3MS02NzIKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gc3Rha2VDaGVjayhhZGRyZXNzOiBBZGRyZXNzLCBjaGVja3M6IEFzc2V0Q2hlY2tbXSwgdHlwZTogU3Rha2luZ1R5cGUsIGluY2x1ZGVTdGFrZWQ6IGJvb2xlYW4pOiBib29sZWFuIHsKICAgIHByb3RvIDQgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgYnl0ZWNfMyAvLyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKCnN0YWtlQ2hlY2tfd2hpbGVfdG9wQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIC0zCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyA0CiAgICA+CiAgICBieiBzdGFrZUNoZWNrX2FmdGVyX3doaWxlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Njc0CiAgICAvLyBjb25zdCBzayA9IHsgYWRkcmVzcywgYXNzZXQ6IGNoZWNrc1tpXS5hc3NldCwgdHlwZSB9CiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18yIC8vIDE2CiAgICAqCiAgICBpbnRjXzIgLy8gMTYKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Njc1CiAgICAvLyBpZiAoIXRoaXMuc3Rha2VzKHNrKS5leGlzdHMpIHsKICAgIGZyYW1lX2RpZyAtNAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29uc3RhbnRzLnRzOjUKICAgIC8vIGV4cG9ydCBjb25zdCBTdGFraW5nQm94UHJlZml4U3Rha2VzID0gJ3MnCiAgICBieXRlY18wIC8vICJzIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NzUKICAgIC8vIGlmICghdGhpcy5zdGFrZXMoc2spLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogc3Rha2VDaGVja19hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Njc2CiAgICAvLyByZXR1cm4gZmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKc3Rha2VDaGVja19hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY3OQogICAgLy8gY29uc3Qgc3Rha2UgPSB0aGlzLnN0YWtlcyhzaykudmFsdWUKICAgIGZyYW1lX2RpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY4MgogICAgLy8gaWYgKHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgIGZyYW1lX2RpZyAtMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvdHlwZXMudHM6MTEKICAgIC8vIGV4cG9ydCBjb25zdCBTVEFLSU5HX1RZUEVfSEVBUlRCRUFUOiBTdGFraW5nVHlwZSA9IG5ldyBhcmM0LlVpbnROOCgwKQogICAgYnl0ZWMgNCAvLyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY4MgogICAgLy8gaWYgKHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgID09CiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDIKICAgIGJ6IHN0YWtlQ2hlY2tfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY4MwogICAgLy8gYW1vdW50VG9DaGVjayA9IHRoaXMuZ2V0SGVhcnRiZWF0QXZlcmFnZShhZGRyZXNzLCBjaGVja3NbaV0uYXNzZXQsIGluY2x1ZGVTdGFrZWQpCiAgICBmcmFtZV9kaWcgLTQKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgZ2V0SGVhcnRiZWF0QXZlcmFnZQogICAgZnJhbWVfYnVyeSAyCgpzdGFrZUNoZWNrX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Njg2CiAgICAvLyBpZiAoY2hlY2tzW2ldLmFtb3VudCA+PSBhbW91bnRUb0NoZWNrKSB7CiAgICBmcmFtZV9kaWcgMAogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgMgogICAgPj0KICAgIGJ6IHN0YWtlQ2hlY2tfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY4NwogICAgLy8gcmV0dXJuIGZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnN0YWtlQ2hlY2tfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2NzMKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBjaGVja3MubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyA0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIHN0YWtlQ2hlY2tfd2hpbGVfdG9wQDEKCnN0YWtlQ2hlY2tfYWZ0ZXJfd2hpbGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjkxCiAgICAvLyByZXR1cm4gdHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OkFraXRhQmFzZUNvbnRyYWN0LnVwZGF0ZShuZXdWZXJzaW9uOiBieXRlcykgLT4gdm9pZDoKdXBkYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjAtMjEKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgLy8gdXBkYXRlKG5ld1ZlcnNpb246IHN0cmluZyk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyMgogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuYWtpdGFEQU8udmFsdWUuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY29uc3RhbnRzLnRzOjEKICAgIC8vIGV4cG9ydCBjb25zdCBHbG9iYWxTdGF0ZUtleUFraXRhREFPID0gJ2FraXRhX2RhbycKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJha2l0YV9kYW8iCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjIKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmFraXRhREFPLnZhbHVlLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2NvbnN0YW50cy50czozCiAgICAvLyBleHBvcnQgY29uc3QgR2xvYmFsU3RhdGVLZXlWZXJzaW9uID0gJ3ZlcnNpb24nCiAgICBieXRlYyAxMCAvLyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjIzCiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSBuZXdWZXJzaW9uCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU8oYXBwOiB1aW50NjQpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFwcDogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5ha2l0YURBTy52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jb25zdGFudHMudHM6MQogICAgLy8gZXhwb3J0IGNvbnN0IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gPSAnYWtpdGFfZGFvJwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDggLy8gImFraXRhX2RhbyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuYWtpdGFEQU8udmFsdWUuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvY29uc3RhbnRzLnRzOjEKICAgIC8vIGV4cG9ydCBjb25zdCBHbG9iYWxTdGF0ZUtleUFraXRhREFPID0gJ2FraXRhX2RhbycKICAgIGJ5dGVjIDggLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMwCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gQXBwbGljYXRpb24oYXBwKQogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CiAHAAEQIOThAYDnhA+4hQYmDAFzBBUffHUBAwABAAECAWggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJYWtpdGFfZGFvAWUHdmVyc2lvbgIAADEbQQCaghUEzZrWfgSCVs8ZBCBGe5MEgwSA8wTIFzyhBEhxbxoEXZ0UKASfT1Z0BHXROPsEyQaICQT1IyvzBEyI6s4EWSR6fwR2FbQhBMb9DKUEiuJmuQTpelZVBBEl1zsEnf9AYATqkYDdBDPpLJQ2GgCOFQI4AhcB6gHXAcQBpAGGAW4BVgErAQAA5ADNALYAmQB8AGMASgAmABIAAiJDMRkURDEYRDYaAReIDEUjQzEZgQQSRDEYRDYaAVcCAIgMHCNDMRkURDEYRDYaATYaAjYaAzYaBCJTiAuNJwQiTwJUKUxQsCNDMRkURDEYRDYaATYaAjYaA4gK/ilMULAjQzEZFEQxGEQ2GgE2GgI2GgOICjwpTFCwI0MxGRREMRhENhoBNhoCFzYaAyJTiAmzFilMULAjQzEZFEQxGEQ2GgE2GgIXNhoDIlOICRcWKUxQsCNDMRkURDEYRDYaATYaAheICOkpTFCwI0MxGRREMRhENhoBNhoCF4gIMClMULAjQzEZFEQxGEQ2GgE2GgIXiAfWTBZMFlApTFCwI0MxGRREMRhENhoBNhoCSSJbTFcIAYgHkE8CFk8CFk8CFk4CUExQKUxQsCNDMRkURDEYRDYaATYaAkkiW0xXCAGIBzVPAhZPAhZPAhZOAlBMUClMULAjQzEZFEQxGEQ2GgE2GgIXiAbsFilMULAjQzEZFEQxGEQ2GgE2GgIXiAakFilMULAjQzEZFEQxGEQxFiMJSTgQIxJENhoBFzYaAheIBjgjQzEZFEQxGEQ2GgE2GgIXiAWlJwQiTwNUTBZQKUxQsCNDMRkURDEYRDYaATYaAheIBIkjQzEZFEQxGEQ2GgEXNhoCiAP1I0MxGRREMRhEMRaBAglJOBAjEkQxFiMJSTgQgQQSRDYaATYaAhc2GgMXiAHwI0MxGRREMRhEMRYjCUk4ECMSRDYaATYaAhc2GgMXiAAnI0MxGRREMRgURDYaAVcCADYaAheIAAIjQ4oCACcKi/5nJwiL/2eJigQAIkcFK0cEi/8yBw0yByEFCIv/D4v9KhOL/ScFEkAAB4v9KhJBAXkjjAgyB4wKiwtBAAWLDEAABYsNQAFfI0QxACIWSYwFUEmMA4v9UChMUEmMAL1FAUAA54sIQQAwi/w4BzIKEkEAIov8OAiL/iEECBJBABUjRIv+FosKFov/Fk4CUExQiwBMv4kiQv/oi/0nBBJBAIQxAHMARBaMBCKMByKMCYsDJwVQKExQSYwBvUUBQQAIiwG+RCJbjAeLAypQKExQSYwCvUUBQQAIiwK+RCJbjAmL/DgHMgoSQQA3i/w4CCEGEkEALSNEMQCLBxaLCRaLChaLBE8DUE8CUExQJwdQJwdQJwdQTIsFUCcGTFBMv0L/YSJC/9AxAHMARIv+D0SL/DgHMgoSQQAPi/w4CCEEEkEABSNEQv87IkL/+Iv9JwQTRIsAvkRJIluMBiRbi/8OQAAFiw1AADwjRIsIQQAmi/w4BzIKEkSL/DgIi/4SRIsGi/4IFosKFov/Fk4CUExQiwBMv4kxAHMARIsGi/4ID0RC/9siQv/BIkL+niKMCEL+hIoFACJHBCtHBYv/MgcNMgchBQiL/w+L/DgRSRZJJwlMUEm9RQFBAA0yB4sPvkQXCIv/D4wMi/0qE4wJi/0nBRJAAAeL/SoSQQGII4wHMgeMCosLQQAFiwxAAAWLCUABbiNEMQCLDlBJjAOL/VAoTFBJjAC9RQFAAOOLB0EAM4v7OAcyChJEi/s4CCEEEkSL/DgUMgoSRIv8OBKL/hJEi/4WiwoWi/8WTgJQTFCLAEy/iYv9JwQSQQB/MQCLDXAARElEFowEIowGiwMnBVAoTFBJjAG9RQFBAAiLAb5EIluMBiKMCIsDKlAoTFBJjAK9RQFBAAiLAr5EIluMCIv7OAcyChJEi/s4CCEGEkSL/DgSFESLBhaLCBaLChaLBE8DUE8CUExQJwdQJwdQJwdQJwaLA1BMv0L/ZjEAiw1wAESL/g9Ei/s4BzIKEkSL+zgIIQQSRIv8OBIUREL/Qov9JwQTRIsAvkRJIluMBSRbi/8OQAAFiwlAAFIjRIv7OAcyChJEi/s4CBREiwdBACaL/DgUMgoSRIv8OBKL/hJEiwWL/ggWiwoWi/8WTgJQTFCLAEy/iTEAiw1wAESLBYv+CA9Ei/w4EhREQv/TIkL/qyJC/o8ijAdC/nWKAgAiK0mL/ycFEkAAB4v/KhJBAGgjRDEAi/4WUIv/UChMUEmMAEm9RQFEvkRJIluMASRbjAKL/yoTQAAIiwIyBwxBADQjRIv+QAAVsTEAiwGyCLIHI7IQIrIBs4sAvEiJsTEAi/6yEYsBshKyFIEEshAisgGzQv/jIkL/ySJC/5WKAgAiK0cDMQAigBloZWFydGJlYXRfbWFuYWdlcl9hZGRyZXNzZUQSRIv/Fov+TFBJJwZLAVBJTgJJvUUBRDIHFk4CvkxOAkSL/ov/cABIFkwiTCcFUChMUEm9RQFBAAiLC75EIluMCiKMA4sFKlAoTFBJjAC9RQFBAAiLAL5EIluMAyKMAYsBgQQMQQBtiwGBAxJJjARAACmLCFcCAIsBSU4CJQtLAUwlWIEYW08CIwhJjAIlC08CTCVYgRhbDUEAMosEQQAmIosKFosDFosJTwJQTFCLB1CLBklOAr5ETwNJgQQMRCULTwJdv4mLASMIQv/UiwKMAUL/i4mKAgIrRwKL/xaL/kxQgAEBUChMUEcCvUUBRL5EIlsyB0yL/0AALIv+cwBEDkmMAUAAFIv+cwBEFosEFiIWTgJQTFCLA0y/i/5zAESLAYwAjAGJi/6L/3AATElOAowARA5JjAJAABGLABaLBBYiFk4CUExQiwNMv4sCiwCMAYwAiYoDACsxAIv+cQtEEkSL/TgHMgoSQQAoi/04CIwAi/4WJwlMUL1FAUEAGSKLABJBAA4jRIv+FicJTFCL/xa/iSJC/++B1EhC/+KKAgGL/xaL/kxQKlAoTFBJvUUBQQAMMgeLAL5EJFsPQQADIkyJiwC+RCRbMgcJTImKAgGL/xaL/kxQKlAoTFBJvUUBRDIHTL5EJFtMSwEMRDIHCYmKAwOL/haL/UxQi/9QKExQSb1FAUAABiJHAk8DiYsAvkRJIltLAYEIW08CJFtPA4mKAwOL/haL/UxQi/9QKExQSb1FAUS+REkiW0sBgQhbTwIkW4mKAgIiKyKL/xaL/kxQSScFUChMUEm9RQFBAAiLBL5EIluMAiKMAYsDKlAoTFBJjAC9RQFBAAiLAL5EIluMAYsCjACJigIBi/8Wi/5MUCcGTFBJvUUBQACHgIIBAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEyJiwC+REyJigIBi/8Wi/5MUCcGTFBJvUUBRL5EiYoDASIrRwKL/haL/UxQJwZMUEm9RQFAAAQijACJiwS+TIwARCKMAyKMAYsAIllJjAKLAQ1BAECL/0EAJosAVwIAiwElCyVYSSJbSwGBCFsITCRbCIsDCIwDiwEjCIwBQv/IiwBXAgCLASULJVgiW4sDCIwDQv/iiwOLAgqMAImKAwEri/4Wi/1MUCcGTFBJvUUBRL5EIkmLASJZSYwAiwMNQQBAi/9BACaLAVcCAIsDJQslWEkiW0sBgQhbCEwkWwiLAgiMAosDIwiMA0L/yIsBVwIAiwMlCyVYIluLAgiMAkL/4osCiwAKjACJigMBIicLIov/IlmLAg1BAJOL/1cCAIsCgQgLWxaL/UxQi/5QKExQSYwAvUUBQAA2iwFXAgCAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBJFYEYChZXBgJMUIwBiwIjCIwCQv+hiwFXAgCLAL5ESSJbSwGBCFtPAiRbTwIWTwIWUEwWUEkVgRgKFlcGAkxQVwIAUEkVgRgKFlcGAkxQjAFC/7mLAYwAiYoDAScLIov/IlmLAQ1BAF+L/1cCAIsBSU4CgQgLWxaL/UxQi/5QKExQSb1FAUSLAFcCAEy+REkiW0sBgQhbTwIkW08CFk8CFlBMFlBJFYEYChZXBgJMUFcCAFBJFYEYChZXBgJMUIwAIwiMAUL/l4mKBAEiSStJIov9IlmLBA1BAF+L/VcCAIsEJAskWEmMACJbSYwDFov8TFCL/lAoTFBJjAG9RQFAAAQijACJiwG+RCJbi/4nBBJMjAJBAAuL/IsDi/+I/aSMAosAgQhbiwIPQQAEIowAiYsEIwiMBEL/lyOMAImKAQAxACInCGVEcghEEkQnCov/Z4mKAQAxACInCGVEcghEEkQnCIv/Z4k=","clear":"CoEBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":4,"minor":9,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type SoftCheckResult = {
  valid: boolean,
  balance: bigint
}


/**
 * Converts the ABI tuple representation of a softCheckResult to the struct representation
 */
export function SoftCheckResultFromTuple(abiTuple: [boolean, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.softCheckResult, APP_SPEC.structs) as SoftCheckResult
}

export type Escrow = {
  hard: bigint,
  lock: bigint
}


/**
 * Converts the ABI tuple representation of a Escrow to the struct representation
 */
export function EscrowFromTuple(abiTuple: [bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Escrow, APP_SPEC.structs) as Escrow
}

export type HeartbeatKey = {
  address: string,
  asset: bigint
}


/**
 * Converts the ABI tuple representation of a HeartbeatKey to the struct representation
 */
export function HeartbeatKeyFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.HeartbeatKey, APP_SPEC.structs) as HeartbeatKey
}

export type Stake = {
  amount: bigint,
  lastUpdate: bigint,
  expiration: bigint
}


/**
 * Converts the ABI tuple representation of a Stake to the struct representation
 */
export function StakeFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Stake, APP_SPEC.structs) as Stake
}

export type StakeInfo = {
  asset: bigint,
  type: number
}


/**
 * Converts the ABI tuple representation of a StakeInfo to the struct representation
 */
export function StakeInfoFromTuple(abiTuple: [bigint, number]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakeInfo, APP_SPEC.structs) as StakeInfo
}

export type StakeKey = {
  address: string,
  asset: bigint,
  type: number
}


/**
 * Converts the ABI tuple representation of a StakeKey to the struct representation
 */
export function StakeKeyFromTuple(abiTuple: [string, bigint, number]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakeKey, APP_SPEC.structs) as StakeKey
}

/**
 * The argument types for the Staking contract
 */
export type StakingArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create(string,uint64)void': {
      version: string
      akitaDao: bigint | number
    }
    'stake(pay,uint8,uint64,uint64)void': {
      payment: AppMethodCallTransactionArgument
      type: bigint | number
      amount: bigint | number
      expiration: bigint | number
    }
    'stakeAsa(pay,axfer,uint8,uint64,uint64)void': {
      payment: AppMethodCallTransactionArgument
      assetXfer: AppMethodCallTransactionArgument
      type: bigint | number
      amount: bigint | number
      expiration: bigint | number
    }
    'withdraw(uint64,uint8)void': {
      asset: bigint | number
      type: bigint | number
    }
    'createHeartbeat(address,uint64)void': {
      address: string
      asset: bigint | number
    }
    'softCheck(address,uint64)(bool,uint64)': {
      address: string
      asset: bigint | number
    }
    'updateSettings(pay,uint64,uint64)void': {
      payment: AppMethodCallTransactionArgument
      asset: bigint | number
      value: bigint | number
    }
    'getTimeLeft(address,uint64)uint64': {
      address: string
      asset: bigint | number
    }
    'mustGetTimeLeft(address,uint64)uint64': {
      address: string
      asset: bigint | number
    }
    'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': {
      address: string
      stake: StakeInfo
    }
    'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': {
      address: string
      stake: StakeInfo
    }
    'getEscrowInfo(address,uint64)(uint64,uint64)': {
      address: string
      asset: bigint | number
    }
    'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': {
      address: string
      asset: bigint | number
    }
    'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': {
      address: string
      asset: bigint | number
    }
    'getHeartbeatAverage(address,uint64,bool)uint64': {
      address: string
      asset: bigint | number
      includeStaked: boolean
    }
    'mustGetHeartbeatAverage(address,uint64,bool)uint64': {
      address: string
      asset: bigint | number
      includeStaked: boolean
    }
    'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': {
      address: string
      type: bigint | number
      assets: bigint[] | number[]
    }
    'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': {
      address: string
      type: bigint | number
      assets: bigint[] | number[]
    }
    'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': {
      address: string
      checks: [bigint | number, bigint | number][]
      type: bigint | number
      includeStaked: boolean
    }
    'update(string)void': {
      newVersion: string
    }
    'updateAkitaDAO(uint64)void': {
      app: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create(string,uint64)void': [version: string, akitaDao: bigint | number]
    'stake(pay,uint8,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, type: bigint | number, amount: bigint | number, expiration: bigint | number]
    'stakeAsa(pay,axfer,uint8,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, type: bigint | number, amount: bigint | number, expiration: bigint | number]
    'withdraw(uint64,uint8)void': [asset: bigint | number, type: bigint | number]
    'createHeartbeat(address,uint64)void': [address: string, asset: bigint | number]
    'softCheck(address,uint64)(bool,uint64)': [address: string, asset: bigint | number]
    'updateSettings(pay,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number, value: bigint | number]
    'getTimeLeft(address,uint64)uint64': [address: string, asset: bigint | number]
    'mustGetTimeLeft(address,uint64)uint64': [address: string, asset: bigint | number]
    'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': [address: string, stake: StakeInfo]
    'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': [address: string, stake: StakeInfo]
    'getEscrowInfo(address,uint64)(uint64,uint64)': [address: string, asset: bigint | number]
    'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': [address: string, asset: bigint | number]
    'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': [address: string, asset: bigint | number]
    'getHeartbeatAverage(address,uint64,bool)uint64': [address: string, asset: bigint | number, includeStaked: boolean]
    'mustGetHeartbeatAverage(address,uint64,bool)uint64': [address: string, asset: bigint | number, includeStaked: boolean]
    'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [address: string, type: bigint | number, assets: bigint[] | number[]]
    'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [address: string, type: bigint | number, assets: bigint[] | number[]]
    'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': [address: string, checks: [bigint | number, bigint | number][], type: bigint | number, includeStaked: boolean]
    'update(string)void': [newVersion: string]
    'updateAkitaDAO(uint64)void': [app: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type StakingReturns = {
  'create(string,uint64)void': void
  'stake(pay,uint8,uint64,uint64)void': void
  'stakeAsa(pay,axfer,uint8,uint64,uint64)void': void
  'withdraw(uint64,uint8)void': void
  'createHeartbeat(address,uint64)void': void
  'softCheck(address,uint64)(bool,uint64)': SoftCheckResult
  'updateSettings(pay,uint64,uint64)void': void
  'getTimeLeft(address,uint64)uint64': bigint
  'mustGetTimeLeft(address,uint64)uint64': bigint
  'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': Stake
  'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': Stake
  'getEscrowInfo(address,uint64)(uint64,uint64)': Escrow
  'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': [bigint, bigint, bigint, bigint][]
  'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]': [bigint, bigint, bigint, bigint][]
  'getHeartbeatAverage(address,uint64,bool)uint64': bigint
  'mustGetHeartbeatAverage(address,uint64,bool)uint64': bigint
  'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [bigint, bigint, bigint][]
  'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [bigint, bigint, bigint][]
  'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': boolean
  'update(string)void': void
  'updateAkitaDAO(uint64)void': void
}

/**
 * Defines the types of available calls and state of the Staking smart contract.
 */
export type StakingTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create(string,uint64)void' | 'create', {
      argsObj: StakingArgs['obj']['create(string,uint64)void']
      argsTuple: StakingArgs['tuple']['create(string,uint64)void']
      returns: StakingReturns['create(string,uint64)void']
    }>
    & Record<'stake(pay,uint8,uint64,uint64)void' | 'stake', {
      argsObj: StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void']
      argsTuple: StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']
      returns: StakingReturns['stake(pay,uint8,uint64,uint64)void']
    }>
    & Record<'stakeAsa(pay,axfer,uint8,uint64,uint64)void' | 'stakeAsa', {
      argsObj: StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']
      argsTuple: StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']
      returns: StakingReturns['stakeAsa(pay,axfer,uint8,uint64,uint64)void']
    }>
    & Record<'withdraw(uint64,uint8)void' | 'withdraw', {
      argsObj: StakingArgs['obj']['withdraw(uint64,uint8)void']
      argsTuple: StakingArgs['tuple']['withdraw(uint64,uint8)void']
      returns: StakingReturns['withdraw(uint64,uint8)void']
    }>
    & Record<'createHeartbeat(address,uint64)void' | 'createHeartbeat', {
      argsObj: StakingArgs['obj']['createHeartbeat(address,uint64)void']
      argsTuple: StakingArgs['tuple']['createHeartbeat(address,uint64)void']
      returns: StakingReturns['createHeartbeat(address,uint64)void']
    }>
    & Record<'softCheck(address,uint64)(bool,uint64)' | 'softCheck', {
      argsObj: StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)']
      argsTuple: StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']
      returns: StakingReturns['softCheck(address,uint64)(bool,uint64)']
    }>
    & Record<'updateSettings(pay,uint64,uint64)void' | 'updateSettings', {
      argsObj: StakingArgs['obj']['updateSettings(pay,uint64,uint64)void']
      argsTuple: StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']
      returns: StakingReturns['updateSettings(pay,uint64,uint64)void']
    }>
    & Record<'getTimeLeft(address,uint64)uint64' | 'getTimeLeft', {
      argsObj: StakingArgs['obj']['getTimeLeft(address,uint64)uint64']
      argsTuple: StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']
      returns: StakingReturns['getTimeLeft(address,uint64)uint64']
    }>
    & Record<'mustGetTimeLeft(address,uint64)uint64' | 'mustGetTimeLeft', {
      argsObj: StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64']
      argsTuple: StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']
      returns: StakingReturns['mustGetTimeLeft(address,uint64)uint64']
    }>
    & Record<'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)' | 'getInfo', {
      argsObj: StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
      argsTuple: StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
      returns: StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
    }>
    & Record<'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)' | 'mustGetInfo', {
      argsObj: StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
      argsTuple: StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
      returns: StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
    }>
    & Record<'getEscrowInfo(address,uint64)(uint64,uint64)' | 'getEscrowInfo', {
      argsObj: StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)']
      argsTuple: StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']
      returns: StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)']
    }>
    & Record<'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]' | 'getHeartbeat', {
      argsObj: StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
      argsTuple: StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
      returns: StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
    }>
    & Record<'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]' | 'mustGetHeartbeat', {
      argsObj: StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
      argsTuple: StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
      returns: StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
    }>
    & Record<'getHeartbeatAverage(address,uint64,bool)uint64' | 'getHeartbeatAverage', {
      argsObj: StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64']
      argsTuple: StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']
      returns: StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64']
    }>
    & Record<'mustGetHeartbeatAverage(address,uint64,bool)uint64' | 'mustGetHeartbeatAverage', {
      argsObj: StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64']
      argsTuple: StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']
      returns: StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64']
    }>
    & Record<'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' | 'getInfoList', {
      argsObj: StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
      argsTuple: StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
      returns: StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
    }>
    & Record<'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' | 'mustGetInfoList', {
      argsObj: StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
      argsTuple: StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
      returns: StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
    }>
    & Record<'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool' | 'stakeCheck', {
      argsObj: StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']
      argsTuple: StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']
      returns: StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']
    }>
    & Record<'update(string)void' | 'update', {
      argsObj: StakingArgs['obj']['update(string)void']
      argsTuple: StakingArgs['tuple']['update(string)void']
      returns: StakingReturns['update(string)void']
    }>
    & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
      argsObj: StakingArgs['obj']['updateAkitaDAO(uint64)void']
      argsTuple: StakingArgs['tuple']['updateAkitaDAO(uint64)void']
      returns: StakingReturns['updateAkitaDAO(uint64)void']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        /**
         * The address that is allowed to call the 'beat' method to create heartbeat records
         */
        heartbeatManagerAddress: string
        /**
         * the current version of the contract
         */
        version: string
        /**
         * the app ID of the Akita DAO
         */
        akitaDao: bigint
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        stakes: Map<StakeKey, Stake>
        heartbeats: Map<HeartbeatKey, [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>
        settings: Map<bigint | number, bigint>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type StakingSignatures = keyof StakingTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type StakingNonVoidMethodSignatures = keyof StakingTypes['methods'] extends infer T ? T extends keyof StakingTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the Staking smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends StakingSignatures> = StakingTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Staking smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingSignatures> = StakingTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = StakingTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = StakingTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type StakingCreateCallParams =
  | Expand<CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & {method: 'create'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & {method: 'create(string,uint64)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type StakingUpdateCallParams =
  | Expand<CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & {method: 'update'}>
  | Expand<CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & {method: 'update(string)void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type StakingDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: StakingCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: StakingUpdateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Staking smart contract
 */
export abstract class StakingParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends StakingCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'create':
          case 'create(string,uint64)void':
            return StakingParamsFactory.create.create(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the Staking smart contract using the create(string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params: CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'create(string,uint64)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao],
        }
      },
    }
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends StakingUpdateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'update':
          case 'update(string)void':
            return StakingParamsFactory.update.update(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs update ABI call params for the Staking smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: 'update(string)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.newVersion],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the stake(pay,uint8,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stake(params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stake(pay,uint8,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.type, params.args.amount, params.args.expiration],
    }
  }
  /**
   * Constructs a no op call for the stakeAsa(pay,axfer,uint8,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeAsa(params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeAsa(pay,axfer,uint8,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.assetXfer, params.args.type, params.args.amount, params.args.expiration],
    }
  }
  /**
   * Constructs a no op call for the withdraw(uint64,uint8)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdraw(params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdraw(uint64,uint8)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.asset, params.args.type],
    }
  }
  /**
   * Constructs a no op call for the createHeartbeat(address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createHeartbeat(params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'createHeartbeat(address,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the softCheck(address,uint64)(bool,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static softCheck(params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'softCheck(address,uint64)(bool,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the updateSettings(pay,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateSettings(params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateSettings(pay,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.asset, params.args.value],
    }
  }
  /**
   * Constructs a no op call for the getTimeLeft(address,uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTimeLeft(params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getTimeLeft(address,uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the mustGetTimeLeft(address,uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mustGetTimeLeft(params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mustGetTimeLeft(address,uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the getInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getInfo(params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.stake],
    }
  }
  /**
   * Constructs a no op call for the mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mustGetInfo(params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.stake],
    }
  }
  /**
   * Constructs a no op call for the getEscrowInfo(address,uint64)(uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getEscrowInfo(params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getEscrowInfo(address,uint64)(uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getHeartbeat(params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mustGetHeartbeat(params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the getHeartbeatAverage(address,uint64,bool)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getHeartbeatAverage(params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getHeartbeatAverage(address,uint64,bool)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset, params.args.includeStaked],
    }
  }
  /**
   * Constructs a no op call for the mustGetHeartbeatAverage(address,uint64,bool)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mustGetHeartbeatAverage(params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mustGetHeartbeatAverage(address,uint64,bool)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset, params.args.includeStaked],
    }
  }
  /**
   * Constructs a no op call for the getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getInfoList(params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.type, params.args.assets],
    }
  }
  /**
   * Constructs a no op call for the mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mustGetInfoList(params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.type, params.args.assets],
    }
  }
  /**
   * Constructs a no op call for the stakeCheck(address,(uint64,uint64)[],uint8,bool)bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeCheck(params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.checks, params.args.type, params.args.includeStaked],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAO(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.app],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the Staking smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class StakingFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `StakingFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new StakingClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new StakingClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the Staking smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: StakingDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? StakingParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (StakingCreateCallParams & { args: Uint8Array[] }) : undefined,
      updateParams: params.updateParams?.method ? StakingParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams as (StakingUpdateCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new StakingClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Staking smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params: CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(StakingParamsFactory.create.create(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the Staking smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appFactory.params.deployUpdate(StakingParamsFactory.update.update(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Staking smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params: CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(StakingParamsFactory.create.create(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the Staking smart contract using an ABI method call using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params: CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(StakingParamsFactory.create.create(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | StakingReturns['create(string,uint64)void']) }, appClient: new StakingClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the Staking smart contract
 */
export class StakingClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `StakingClient`
   *
   * @param appClient An `AppClient` instance which has been created with the Staking app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `StakingClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends StakingNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `StakingClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<StakingClient> {
    return new StakingClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `StakingClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<StakingClient> {
    return new StakingClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Staking smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.params.update(StakingParamsFactory.update.update(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Staking smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stake: (params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.stake(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeAsa: (params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.stakeAsa(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdraw: (params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createHeartbeat: (params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.createHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    softCheck: (params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.softCheck(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateSettings: (params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.updateSettings(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getTimeLeft: (params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getTimeLeft(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mustGetTimeLeft: (params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.mustGetTimeLeft(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getInfo: (params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mustGetInfo: (params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.mustGetInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getEscrowInfo: (params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getEscrowInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getHeartbeat: (params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mustGetHeartbeat: (params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.mustGetHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getHeartbeatAverage: (params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getHeartbeatAverage(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mustGetHeartbeatAverage: (params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.mustGetHeartbeatAverage(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getInfoList: (params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.getInfoList(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mustGetInfoList: (params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.mustGetInfoList(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeCheck: (params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.stakeCheck(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingParamsFactory.updateAkitaDao(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Staking smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.createTransaction.update(StakingParamsFactory.update.update(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Staking smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stake: (params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.stake(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeAsa: (params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.stakeAsa(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdraw: (params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createHeartbeat: (params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.createHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    softCheck: (params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.softCheck(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateSettings: (params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.updateSettings(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getTimeLeft: (params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getTimeLeft(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mustGetTimeLeft: (params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.mustGetTimeLeft(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getInfo: (params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mustGetInfo: (params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.mustGetInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getEscrowInfo: (params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getEscrowInfo(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getHeartbeat: (params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mustGetHeartbeat: (params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.mustGetHeartbeat(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getHeartbeatAverage: (params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getHeartbeatAverage(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mustGetHeartbeatAverage: (params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.mustGetHeartbeatAverage(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getInfoList: (params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.getInfoList(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mustGetInfoList: (params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.mustGetInfoList(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeCheck: (params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.stakeCheck(params))
    },

    /**
     * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingParamsFactory.updateAkitaDao(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the Staking smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams & SendParams) => {
        const result = await this.appClient.send.update(StakingParamsFactory.update.update(params))
        return {...result, return: result.return as unknown as (undefined | StakingReturns['update(string)void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the Staking smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stake: async (params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.stake(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['stake(pay,uint8,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeAsa: async (params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.stakeAsa(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['stakeAsa(pay,axfer,uint8,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdraw: async (params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.withdraw(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['withdraw(uint64,uint8)void'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createHeartbeat: async (params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.createHeartbeat(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['createHeartbeat(address,uint64)void'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    softCheck: async (params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.softCheck(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['softCheck(address,uint64)(bool,uint64)'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateSettings: async (params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.updateSettings(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['updateSettings(pay,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTimeLeft: async (params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getTimeLeft(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getTimeLeft(address,uint64)uint64'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetTimeLeft: async (params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.mustGetTimeLeft(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['mustGetTimeLeft(address,uint64)uint64'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getInfo: async (params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getInfo(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetInfo: async (params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.mustGetInfo(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getEscrowInfo: async (params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getEscrowInfo(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getHeartbeat: async (params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getHeartbeat(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetHeartbeat: async (params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.mustGetHeartbeat(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getHeartbeatAverage: async (params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getHeartbeatAverage(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetHeartbeatAverage: async (params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.mustGetHeartbeatAverage(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getInfoList: async (params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.getInfoList(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetInfoList: async (params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.mustGetInfoList(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeCheck: async (params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.stakeCheck(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'])}
    },

    /**
     * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingParamsFactory.updateAkitaDao(params))
      return {...result, return: result.return as unknown as (undefined | StakingReturns['updateAkitaDAO(uint64)void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new StakingClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getTimeLeft(params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getTimeLeft(params))
    return result.return as unknown as StakingReturns['getTimeLeft(address,uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mustGetTimeLeft(params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.mustGetTimeLeft(params))
    return result.return as unknown as StakingReturns['mustGetTimeLeft(address,uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getInfo(params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getInfo(params))
    return result.return as unknown as StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mustGetInfo(params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.mustGetInfo(params))
    return result.return as unknown as StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getEscrowInfo(params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getEscrowInfo(params))
    return result.return as unknown as StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getHeartbeat(params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getHeartbeat(params))
    return result.return as unknown as StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mustGetHeartbeat(params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.mustGetHeartbeat(params))
    return result.return as unknown as StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getHeartbeatAverage(params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getHeartbeatAverage(params))
    return result.return as unknown as StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mustGetHeartbeatAverage(params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.mustGetHeartbeatAverage(params))
    return result.return as unknown as StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getInfoList(params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.getInfoList(params))
    return result.return as unknown as StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mustGetInfoList(params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.mustGetInfoList(params))
    return result.return as unknown as StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async stakeCheck(params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']>) {
    const result = await this.appClient.send.call(StakingParamsFactory.stakeCheck(params))
    return result.return as unknown as StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']
  }

  /**
   * Methods to access state for the current Staking app
   */
  state = {
    /**
     * Methods to access global state for the current Staking app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          heartbeatManagerAddress: result.heartbeatManagerAddress,
          version: result.version,
          akitaDao: result.akitaDAO,
        }
      },
      /**
       * Get the current value of the heartbeatManagerAddress key in global state
       */
      heartbeatManagerAddress: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("heartbeatManagerAddress")) as string | undefined },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("version")) as string | undefined },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAO")) as bigint | undefined },
    },
    /**
     * Methods to access box state for the current Staking app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the stakes map in box state
       */
      stakes: {
        /**
         * Get all current values of the stakes map in box state
         */
        getMap: async (): Promise<Map<StakeKey, Stake>> => { return (await this.appClient.state.box.getMap("stakes")) as Map<StakeKey, Stake> },
        /**
         * Get a current value of the stakes map by key from box state
         */
        value: async (key: StakeKey): Promise<Stake | undefined> => { return await this.appClient.state.box.getMapValue("stakes", key) as Stake | undefined },
      },
      /**
       * Get values from the heartbeats map in box state
       */
      heartbeats: {
        /**
         * Get all current values of the heartbeats map in box state
         */
        getMap: async (): Promise<Map<HeartbeatKey, [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>> => { return (await this.appClient.state.box.getMap("heartbeats")) as Map<HeartbeatKey, [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]> },
        /**
         * Get a current value of the heartbeats map by key from box state
         */
        value: async (key: HeartbeatKey): Promise<[[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]] | undefined> => { return await this.appClient.state.box.getMapValue("heartbeats", key) as [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]] | undefined },
      },
      /**
       * Get values from the settings map in box state
       */
      settings: {
        /**
         * Get all current values of the settings map in box state
         */
        getMap: async (): Promise<Map<bigint, bigint>> => { return (await this.appClient.state.box.getMap("settings")) as Map<bigint, bigint> },
        /**
         * Get a current value of the settings map by key from box state
         */
        value: async (key: bigint | number): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("settings", key) as bigint | undefined },
      },
    },
  }

  public newGroup(): StakingComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a stake(pay,uint8,uint64,uint64)void method call against the Staking contract
       */
      stake(params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stake(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a stakeAsa(pay,axfer,uint8,uint64,uint64)void method call against the Staking contract
       */
      stakeAsa(params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeAsa(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a withdraw(uint64,uint8)void method call against the Staking contract
       */
      withdraw(params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdraw(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a createHeartbeat(address,uint64)void method call against the Staking contract
       */
      createHeartbeat(params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createHeartbeat(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a softCheck(address,uint64)(bool,uint64) method call against the Staking contract
       */
      softCheck(params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.softCheck(params)))
        resultMappers.push((v) => client.decodeReturnValue('softCheck(address,uint64)(bool,uint64)', v))
        return this
      },
      /**
       * Add a updateSettings(pay,uint64,uint64)void method call against the Staking contract
       */
      updateSettings(params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateSettings(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getTimeLeft(address,uint64)uint64 method call against the Staking contract
       */
      getTimeLeft(params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getTimeLeft(params)))
        resultMappers.push((v) => client.decodeReturnValue('getTimeLeft(address,uint64)uint64', v))
        return this
      },
      /**
       * Add a mustGetTimeLeft(address,uint64)uint64 method call against the Staking contract
       */
      mustGetTimeLeft(params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mustGetTimeLeft(params)))
        resultMappers.push((v) => client.decodeReturnValue('mustGetTimeLeft(address,uint64)uint64', v))
        return this
      },
      /**
       * Add a getInfo(address,(uint64,uint8))(uint64,uint64,uint64) method call against the Staking contract
       */
      getInfo(params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('getInfo(address,(uint64,uint8))(uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64) method call against the Staking contract
       */
      mustGetInfo(params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mustGetInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a getEscrowInfo(address,uint64)(uint64,uint64) method call against the Staking contract
       */
      getEscrowInfo(params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getEscrowInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('getEscrowInfo(address,uint64)(uint64,uint64)', v))
        return this
      },
      /**
       * Add a getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] method call against the Staking contract
       */
      getHeartbeat(params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getHeartbeat(params)))
        resultMappers.push((v) => client.decodeReturnValue('getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]', v))
        return this
      },
      /**
       * Add a mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] method call against the Staking contract
       */
      mustGetHeartbeat(params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mustGetHeartbeat(params)))
        resultMappers.push((v) => client.decodeReturnValue('mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]', v))
        return this
      },
      /**
       * Add a getHeartbeatAverage(address,uint64,bool)uint64 method call against the Staking contract
       */
      getHeartbeatAverage(params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getHeartbeatAverage(params)))
        resultMappers.push((v) => client.decodeReturnValue('getHeartbeatAverage(address,uint64,bool)uint64', v))
        return this
      },
      /**
       * Add a mustGetHeartbeatAverage(address,uint64,bool)uint64 method call against the Staking contract
       */
      mustGetHeartbeatAverage(params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mustGetHeartbeatAverage(params)))
        resultMappers.push((v) => client.decodeReturnValue('mustGetHeartbeatAverage(address,uint64,bool)uint64', v))
        return this
      },
      /**
       * Add a getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] method call against the Staking contract
       */
      getInfoList(params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getInfoList(params)))
        resultMappers.push((v) => client.decodeReturnValue('getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]', v))
        return this
      },
      /**
       * Add a mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] method call against the Staking contract
       */
      mustGetInfoList(params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mustGetInfoList(params)))
        resultMappers.push((v) => client.decodeReturnValue('mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]', v))
        return this
      },
      /**
       * Add a stakeCheck(address,(uint64,uint64)[],uint8,bool)bool method call against the Staking contract
       */
      stakeCheck(params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeCheck(params)))
        resultMappers.push((v) => client.decodeReturnValue('stakeCheck(address,(uint64,uint64)[],uint8,bool)bool', v))
        return this
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the Staking contract
       */
      updateAkitaDao(params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)))
        resultMappers.push(undefined)
        return this
      },
      get update() {
        return {
          update: (params: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the Staking contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as StakingComposer
  }
}
export type StakingComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the stake(pay,uint8,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stake(params?: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['stake(pay,uint8,uint64,uint64)void'] | undefined]>

  /**
   * Calls the stakeAsa(pay,axfer,uint8,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeAsa(params?: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | undefined]>

  /**
   * Calls the withdraw(uint64,uint8)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdraw(params?: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']>): StakingComposer<[...TReturns, StakingReturns['withdraw(uint64,uint8)void'] | undefined]>

  /**
   * Calls the createHeartbeat(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createHeartbeat(params?: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['createHeartbeat(address,uint64)void'] | undefined]>

  /**
   * Calls the softCheck(address,uint64)(bool,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  softCheck(params?: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']>): StakingComposer<[...TReturns, StakingReturns['softCheck(address,uint64)(bool,uint64)'] | undefined]>

  /**
   * Calls the updateSettings(pay,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateSettings(params?: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['updateSettings(pay,uint64,uint64)void'] | undefined]>

  /**
   * Calls the getTimeLeft(address,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTimeLeft(params?: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']>): StakingComposer<[...TReturns, StakingReturns['getTimeLeft(address,uint64)uint64'] | undefined]>

  /**
   * Calls the mustGetTimeLeft(address,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mustGetTimeLeft(params?: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']>): StakingComposer<[...TReturns, StakingReturns['mustGetTimeLeft(address,uint64)uint64'] | undefined]>

  /**
   * Calls the getInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getInfo(params?: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mustGetInfo(params?: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the getEscrowInfo(address,uint64)(uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getEscrowInfo(params?: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)'] | undefined]>

  /**
   * Calls the getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getHeartbeat(params?: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | undefined]>

  /**
   * Calls the mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mustGetHeartbeat(params?: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]'] | undefined]>

  /**
   * Calls the getHeartbeatAverage(address,uint64,bool)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getHeartbeatAverage(params?: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']>): StakingComposer<[...TReturns, StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64'] | undefined]>

  /**
   * Calls the mustGetHeartbeatAverage(address,uint64,bool)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mustGetHeartbeatAverage(params?: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']>): StakingComposer<[...TReturns, StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | undefined]>

  /**
   * Calls the getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getInfoList(params?: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | undefined]>

  /**
   * Calls the mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mustGetInfoList(params?: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | undefined]>

  /**
   * Calls the stakeCheck(address,(uint64,uint64)[],uint8,bool)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeCheck(params?: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']>): StakingComposer<[...TReturns, StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | undefined]>

  /**
   * Calls the updateAkitaDAO(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDao(params?: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']>): StakingComposer<[...TReturns, StakingReturns['updateAkitaDAO(uint64)void'] | undefined]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the Staking smart contract using the update(string)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    update(params?: CallParams<StakingArgs['obj']['update(string)void'] | StakingArgs['tuple']['update(string)void']>): StakingComposer<[...TReturns, StakingReturns['update(string)void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the Staking smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): StakingComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): StakingComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<StakingComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<StakingComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<StakingComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<StakingComposerResults<TReturns>>
}
export type StakingComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

