#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 16 32 28900 31536000 99000
    bytecblock "s" 0x151f7c75 0x03 "" 0x00 0x02 "h" 0x0000000000000000000000000000000000000000000000000000000000000000 "akita_dao" "e" "version" 0x0000
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txn NumAppArgs
    bz main_after_if_else@29
    pushbytess 0xcd9ad67e 0x8256cf19 0x20467b93 0x830480f3 0xc8173ca1 0x48716f1a 0x5d9d1428 0x9f4f5674 0x75d138fb 0xc9068809 0xf5232bf3 0x4c88eace 0x59247a7f 0x7615b421 0xc6fd0ca5 0x8ae266b9 0xe97a5655 0x1125d73b 0x9dff4060 0xea9180dd 0x33e92c94 // method "create(string,uint64)void", method "stake(pay,uint8,uint64,uint64)void", method "stakeAsa(pay,axfer,uint8,uint64,uint64)void", method "withdraw(uint64,uint8)void", method "createHeartbeat(address,uint64)void", method "softCheck(address,uint64)(bool,uint64)", method "updateSettings(pay,uint64,uint64)void", method "getTimeLeft(address,uint64)uint64", method "mustGetTimeLeft(address,uint64)uint64", method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)", method "mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)", method "getEscrowInfo(address,uint64)(uint64,uint64)", method "getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]", method "mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[]", method "getHeartbeatAverage(address,uint64,bool)uint64", method "mustGetHeartbeatAverage(address,uint64,bool)uint64", method "getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]", method "mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]", method "stakeCheck(address,(uint64,uint64)[],uint8,bool)bool", method "update(string)void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@5 main_stake_route@6 main_stakeAsa_route@7 main_withdraw_route@8 main_createHeartbeat_route@9 main_softCheck_route@10 main_updateSettings_route@11 main_getTimeLeft_route@12 main_mustGetTimeLeft_route@13 main_getInfo_route@14 main_mustGetInfo_route@15 main_getEscrowInfo_route@16 main_getHeartbeat_route@17 main_mustGetHeartbeat_route@18 main_getHeartbeatAverage_route@19 main_mustGetHeartbeatAverage_route@20 main_getInfoList_route@21 main_mustGetInfoList_route@22 main_stakeCheck_route@23 main_update_route@24 main_updateAkitaDAO_route@25

main_after_if_else@29:
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    intc_0 // 0
    return

main_updateAkitaDAO_route@25:
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@24:
    // smart_contracts/utils/base-contracts/base.ts:20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:20
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_stakeCheck_route@23:
    // smart_contracts/staking/contract.algo.ts:671
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/staking/contract.algo.ts:671
    // @abimethod({ readonly: true })
    callsub stakeCheck
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mustGetInfoList_route@22:
    // smart_contracts/staking/contract.algo.ts:656
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/staking/contract.algo.ts:656
    // @abimethod({ readonly: true })
    callsub mustGetInfoList
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getInfoList_route@21:
    // smart_contracts/staking/contract.algo.ts:631
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/staking/contract.algo.ts:631
    // @abimethod({ readonly: true })
    callsub getInfoList
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mustGetHeartbeatAverage_route@20:
    // smart_contracts/staking/contract.algo.ts:612
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    intc_0 // 0
    getbit
    // smart_contracts/staking/contract.algo.ts:612
    // @abimethod({ readonly: true })
    callsub mustGetHeartbeatAverage
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getHeartbeatAverage_route@19:
    // smart_contracts/staking/contract.algo.ts:590
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    intc_0 // 0
    getbit
    // smart_contracts/staking/contract.algo.ts:590
    // @abimethod({ readonly: true })
    callsub getHeartbeatAverage
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mustGetHeartbeat_route@18:
    // smart_contracts/staking/contract.algo.ts:583
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:583
    // @abimethod({ readonly: true })
    callsub mustGetHeartbeat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getHeartbeat_route@17:
    // smart_contracts/staking/contract.algo.ts:565
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:565
    // @abimethod({ readonly: true })
    callsub getHeartbeat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getEscrowInfo_route@16:
    // smart_contracts/staking/contract.algo.ts:547
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:547
    // @abimethod({ readonly: true })
    callsub getEscrowInfo
    swap
    itob
    swap
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mustGetInfo_route@15:
    // smart_contracts/staking/contract.algo.ts:539
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint64
    swap
    extract 8 1 // on error: Index access is out of bounds
    // smart_contracts/staking/contract.algo.ts:539
    // @abimethod({ readonly: true })
    callsub mustGetInfo
    uncover 2
    itob
    uncover 2
    itob
    uncover 2
    itob
    cover 2
    concat
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getInfo_route@14:
    // smart_contracts/staking/contract.algo.ts:529
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint64
    swap
    extract 8 1 // on error: Index access is out of bounds
    // smart_contracts/staking/contract.algo.ts:529
    // @abimethod({ readonly: true })
    callsub getInfo
    uncover 2
    itob
    uncover 2
    itob
    uncover 2
    itob
    cover 2
    concat
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mustGetTimeLeft_route@13:
    // smart_contracts/staking/contract.algo.ts:521
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:521
    // @abimethod({ readonly: true })
    callsub mustGetTimeLeft
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTimeLeft_route@12:
    // smart_contracts/staking/contract.algo.ts:510
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:510
    // @abimethod({ readonly: true })
    callsub getTimeLeft
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateSettings_route@11:
    // smart_contracts/staking/contract.algo.ts:493
    // updateSettings(payment: gtxn.PaymentTxn, asset: uint64, value: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:493
    // updateSettings(payment: gtxn.PaymentTxn, asset: uint64, value: uint64): void {
    callsub updateSettings
    intc_1 // 1
    return

main_softCheck_route@10:
    // smart_contracts/staking/contract.algo.ts:460
    // softCheck(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:460
    // softCheck(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    callsub softCheck
    bytec 4 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    swap
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createHeartbeat_route@9:
    // smart_contracts/staking/contract.algo.ts:403
    // createHeartbeat(address: Address, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:403
    // createHeartbeat(address: Address, asset: uint64): void {
    callsub createHeartbeat
    intc_1 // 1
    return

main_withdraw_route@8:
    // smart_contracts/staking/contract.algo.ts:370
    // withdraw(asset: uint64, type: StakingType): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:370
    // withdraw(asset: uint64, type: StakingType): void {
    callsub withdraw
    intc_1 // 1
    return

main_stakeAsa_route@7:
    // smart_contracts/staking/contract.algo.ts:236-242
    // stakeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   type: StakingType,
    //   amount: uint64,
    //   expiration: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/staking/contract.algo.ts:236-242
    // stakeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   type: StakingType,
    //   amount: uint64,
    //   expiration: uint64
    // ): void {
    callsub stakeAsa
    intc_1 // 1
    return

main_stake_route@6:
    // smart_contracts/staking/contract.algo.ts:103
    // stake(payment: gtxn.PaymentTxn, type: StakingType, amount: uint64, expiration: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/staking/contract.algo.ts:103
    // stake(payment: gtxn.PaymentTxn, type: StakingType, amount: uint64, expiration: uint64): void {
    callsub stake
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/staking/contract.algo.ts:95
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/staking/contract.algo.ts:75
    // export class Staking extends classes(BaseStaking, AkitaBaseContract) implements StakingInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/staking/contract.algo.ts:95
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::Staking.create(version: bytes, akitaDAO: uint64) -> void:
create:
    // smart_contracts/staking/contract.algo.ts:95-96
    // @abimethod({ onCreate: 'require' })
    // create(version: string, akitaDAO: uint64): void {
    proto 2 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 10 // "version"
    // smart_contracts/staking/contract.algo.ts:97
    // this.version.value = version
    frame_dig -2
    app_global_put
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec 8 // "akita_dao"
    // smart_contracts/staking/contract.algo.ts:98
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.stake(payment: uint64, type: bytes, amount: uint64, expiration: uint64) -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:103
    // stake(payment: gtxn.PaymentTxn, type: StakingType, amount: uint64, expiration: uint64): void {
    proto 4 0
    intc_0 // 0
    dupn 5
    bytec_3 // ""
    dupn 4
    // smart_contracts/staking/contract.algo.ts:104
    // const inTheFuture = expiration > Global.latestTimestamp
    frame_dig -1
    global LatestTimestamp
    >
    // smart_contracts/staking/contract.algo.ts:105
    // const lessThanOneYearInTheFuture = expiration <= Global.latestTimestamp + ONE_YEAR
    global LatestTimestamp
    // smart_contracts/staking/constants.ts:9
    // export const ONE_YEAR: uint64 = 31_536_000 // 365 days * 24 hours * 60 minutes * 60 seconds
    intc 5 // 31536000
    // smart_contracts/staking/contract.algo.ts:105
    // const lessThanOneYearInTheFuture = expiration <= Global.latestTimestamp + ONE_YEAR
    +
    frame_dig -1
    >=
    // smart_contracts/staking/contract.algo.ts:106
    // const locked = type !== STAKING_TYPE_LOCK
    frame_dig -3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:106
    // const locked = type !== STAKING_TYPE_LOCK
    !=
    // smart_contracts/staking/contract.algo.ts:107
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    frame_dig -3
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:107
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    ==
    bnz stake_bool_true@2
    frame_dig -3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:107
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    ==
    bz stake_bool_false@3

stake_bool_true@2:
    intc_1 // 1
    frame_bury 8

stake_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:108
    // const timestamp = Global.latestTimestamp
    global LatestTimestamp
    frame_bury 10
    // smart_contracts/staking/contract.algo.ts:110
    // assert((inTheFuture && lessThanOneYearInTheFuture) || !locked, ERR_BAD_EXPIRATION)
    frame_dig 11
    bz stake_or_contd@6
    frame_dig 12
    bnz stake_bool_true@7

stake_or_contd@6:
    // smart_contracts/staking/contract.algo.ts:110
    // assert((inTheFuture && lessThanOneYearInTheFuture) || !locked, ERR_BAD_EXPIRATION)
    frame_dig 13
    bnz stake_bool_false@8

stake_bool_true@7:
    intc_1 // 1

stake_bool_merge@9:
    // smart_contracts/staking/contract.algo.ts:110
    // assert((inTheFuture && lessThanOneYearInTheFuture) || !locked, ERR_BAD_EXPIRATION)
    assert // Expiration must be in the future or hardlock disabled
    // smart_contracts/staking/contract.algo.ts:112
    // const arc4Sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/staking/contract.algo.ts:115
    // asset: 0,
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:113
    // const sk: StakeKey = {
    itob
    dup
    frame_bury 5
    // smart_contracts/staking/contract.algo.ts:119
    // const isUpdate = this.stakes(sk).exists
    concat
    dup
    frame_bury 3
    frame_dig -3
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:119
    // const isUpdate = this.stakes(sk).exists
    box_len
    bury 1
    // smart_contracts/staking/contract.algo.ts:121
    // if (!isUpdate) {
    bnz stake_else_body@33
    // smart_contracts/staking/contract.algo.ts:125
    // if (isEscrow) {
    frame_dig 8
    bz stake_else_body@16
    // smart_contracts/staking/contract.algo.ts:126-133
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: amount + costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/staking/contract.algo.ts:129
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/contract.algo.ts:126-133
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: amount + costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@14
    frame_dig -4
    gtxns Amount
    // smart_contracts/staking/contract.algo.ts:130
    // amount: amount + costs.stakes,
    frame_dig -2
    // smart_contracts/staking/base.ts:7
    // stakes: 28_900,
    intc 4 // 28900
    // smart_contracts/staking/contract.algo.ts:130
    // amount: amount + costs.stakes,
    +
    // smart_contracts/staking/contract.algo.ts:126-133
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: amount + costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@14
    intc_1 // 1

stake_bool_merge@15:
    // smart_contracts/staking/contract.algo.ts:126-133
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: amount + costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment

stake_after_if_else@32:
    // smart_contracts/staking/contract.algo.ts:210
    // amount,
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:211
    // lastUpdate: timestamp,
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:212
    // expiration,
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:209
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:209-213
    // this.stakes(sk).value = {
    //   amount,
    //   lastUpdate: timestamp,
    //   expiration,
    // }
    frame_dig 0
    swap
    box_put
    retsub

stake_bool_false@14:
    intc_0 // 0
    b stake_bool_merge@15

stake_else_body@16:
    // smart_contracts/staking/contract.algo.ts:134
    // } else if (type === STAKING_TYPE_HEARTBEAT) {
    frame_dig -3
    // smart_contracts/staking/types.ts:11
    // export const STAKING_TYPE_HEARTBEAT: StakingType = new arc4.UintN8(0)
    bytec 4 // 0x00
    // smart_contracts/staking/contract.algo.ts:134
    // } else if (type === STAKING_TYPE_HEARTBEAT) {
    ==
    bz stake_else_body@26
    // smart_contracts/staking/contract.algo.ts:137
    // const held = new UintN64(Txn.sender.balance)
    txn Sender
    acct_params_get AcctBalance
    assert // account funded
    itob
    frame_bury 4
    // smart_contracts/staking/contract.algo.ts:138
    // let hard: uint64 = 0
    intc_0 // 0
    frame_bury 7
    // smart_contracts/staking/contract.algo.ts:139
    // let lock: uint64 = 0
    intc_0 // 0
    frame_bury 9
    // smart_contracts/staking/contract.algo.ts:147
    // if (this.stakes(hardStakeKey).exists) {
    frame_dig 3
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:147
    // if (this.stakes(hardStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:147
    // if (this.stakes(hardStakeKey).exists) {
    box_len
    bury 1
    bz stake_after_if_else@19
    // smart_contracts/staking/contract.algo.ts:148
    // hard = this.stakes(hardStakeKey).value.amount
    frame_dig 1
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 7

stake_after_if_else@19:
    // smart_contracts/staking/contract.algo.ts:157
    // if (this.stakes(lockStakeKey).exists) {
    frame_dig 3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:157
    // if (this.stakes(lockStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:157
    // if (this.stakes(lockStakeKey).exists) {
    box_len
    bury 1
    bz stake_after_if_else@21
    // smart_contracts/staking/contract.algo.ts:158
    // lock = this.stakes(lockStakeKey).value.amount
    frame_dig 2
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 9

stake_after_if_else@21:
    // smart_contracts/staking/contract.algo.ts:161-168
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes + costs.heartbeats,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/staking/contract.algo.ts:164
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/contract.algo.ts:161-168
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes + costs.heartbeats,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@24
    frame_dig -4
    gtxns Amount
    // smart_contracts/staking/contract.algo.ts:165
    // amount: costs.stakes + costs.heartbeats,
    intc 6 // 99000
    // smart_contracts/staking/contract.algo.ts:161-168
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes + costs.heartbeats,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@24
    intc_1 // 1

stake_bool_merge@25:
    // smart_contracts/staking/contract.algo.ts:161-168
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes + costs.heartbeats,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/staking/contract.algo.ts:171
    // address: new Address(Txn.sender),
    txn Sender
    // smart_contracts/staking/contract.algo.ts:177
    // hard: new UintN64(hard),
    frame_dig 7
    itob
    // smart_contracts/staking/contract.algo.ts:178
    // lock: new UintN64(lock),
    frame_dig 9
    itob
    // smart_contracts/staking/contract.algo.ts:179
    // timestamp: new UintN64(timestamp),
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:175-180
    // const hbv = new arc4Heartbeat({
    //   held,
    //   hard: new UintN64(hard),
    //   lock: new UintN64(lock),
    //   timestamp: new UintN64(timestamp),
    // })
    frame_dig 4
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:182-187
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:189-194
    // const heartbeats = new StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/contract.algo.ts:182-187
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:189-194
    // const heartbeats = new StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/contract.algo.ts:182-187
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:189-194
    // const heartbeats = new StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/contract.algo.ts:196
    // this.heartbeats(heartbeatKey).value = heartbeats.copy()
    swap
    frame_dig 5
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:196
    // this.heartbeats(heartbeatKey).value = heartbeats.copy()
    swap
    box_put
    b stake_after_if_else@32

stake_bool_false@24:
    intc_0 // 0
    b stake_bool_merge@25

stake_else_body@26:
    // smart_contracts/staking/contract.algo.ts:198
    // assert(Txn.sender.balance >= amount, ERR_INSUFFICIENT_BALANCE)
    txn Sender
    acct_params_get AcctBalance
    assert // account funded
    frame_dig -2
    >=
    assert // Insufficient balance
    // smart_contracts/staking/contract.algo.ts:199-206
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -4
    gtxns Receiver
    // smart_contracts/staking/contract.algo.ts:202
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/contract.algo.ts:199-206
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@29
    frame_dig -4
    gtxns Amount
    // smart_contracts/staking/base.ts:7
    // stakes: 28_900,
    intc 4 // 28900
    // smart_contracts/staking/contract.algo.ts:199-206
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz stake_bool_false@29
    intc_1 // 1

stake_bool_merge@30:
    // smart_contracts/staking/contract.algo.ts:199-206
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.stakes,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    b stake_after_if_else@32

stake_bool_false@29:
    intc_0 // 0
    b stake_bool_merge@30

stake_else_body@33:
    // smart_contracts/staking/contract.algo.ts:215
    // assert(type !== STAKING_TYPE_HEARTBEAT, ERR_HEARTBEAT_CANNOT_UPDATE)
    frame_dig -3
    // smart_contracts/staking/types.ts:11
    // export const STAKING_TYPE_HEARTBEAT: StakingType = new arc4.UintN8(0)
    bytec 4 // 0x00
    // smart_contracts/staking/contract.algo.ts:215
    // assert(type !== STAKING_TYPE_HEARTBEAT, ERR_HEARTBEAT_CANNOT_UPDATE)
    !=
    assert // Heartbeat stakes cannot be updated
    // smart_contracts/staking/contract.algo.ts:216
    // const currentStake = this.stakes(sk).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 6
    intc_2 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:217
    // assert(expiration >= currentStake.expiration || !locked, ERR_BAD_EXPIRATION_UPDATE)
    frame_dig -1
    <=
    bnz stake_bool_true@35
    frame_dig 13
    bnz stake_bool_false@36

stake_bool_true@35:
    intc_1 // 1

stake_bool_merge@37:
    // smart_contracts/staking/contract.algo.ts:217
    // assert(expiration >= currentStake.expiration || !locked, ERR_BAD_EXPIRATION_UPDATE)
    assert // Expiration must be greater than or equal to the current unlock time or hardlock disabled
    // smart_contracts/staking/contract.algo.ts:219
    // if (isEscrow) {
    frame_dig 8
    bz stake_else_body@39
    // smart_contracts/staking/contract.algo.ts:220
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/staking/contract.algo.ts:221
    // assert(payment.amount === amount, ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -4
    gtxns Amount
    frame_dig -2
    ==
    assert // Invalid payment amount

stake_after_if_else@40:
    // smart_contracts/staking/contract.algo.ts:226
    // const newAmount: uint64 = currentStake.amount + amount
    frame_dig 6
    frame_dig -2
    +
    // smart_contracts/staking/contract.algo.ts:229
    // amount: newAmount,
    itob
    // smart_contracts/staking/contract.algo.ts:230
    // lastUpdate: timestamp,
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:231
    // expiration
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:228
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:228-232
    // this.stakes(sk).value = {
    //   amount: newAmount,
    //   lastUpdate: timestamp,
    //   expiration
    // }
    frame_dig 0
    swap
    box_put
    retsub

stake_else_body@39:
    // smart_contracts/staking/contract.algo.ts:223
    // assert(Txn.sender.balance >= currentStake.amount + amount, ERR_INSUFFICIENT_BALANCE)
    txn Sender
    acct_params_get AcctBalance
    assert // account funded
    frame_dig 6
    frame_dig -2
    +
    >=
    assert // Insufficient balance
    b stake_after_if_else@40

stake_bool_false@36:
    intc_0 // 0
    b stake_bool_merge@37

stake_bool_false@8:
    intc_0 // 0
    b stake_bool_merge@9

stake_bool_false@3:
    intc_0 // 0
    frame_bury 8
    b stake_bool_merge@4


// smart_contracts/staking/contract.algo.ts::Staking.stakeAsa(payment: uint64, assetXfer: uint64, type: bytes, amount: uint64, expiration: uint64) -> void:
stakeAsa:
    // smart_contracts/staking/contract.algo.ts:236-242
    // stakeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   type: StakingType,
    //   amount: uint64,
    //   expiration: uint64
    // ): void {
    proto 5 0
    intc_0 // 0
    dupn 4
    bytec_3 // ""
    dupn 5
    // smart_contracts/staking/contract.algo.ts:243
    // const inTheFuture = expiration > Global.latestTimestamp
    frame_dig -1
    global LatestTimestamp
    >
    // smart_contracts/staking/contract.algo.ts:244
    // let lessThanMaxLockup = expiration <= Global.latestTimestamp + ONE_YEAR
    global LatestTimestamp
    // smart_contracts/staking/constants.ts:9
    // export const ONE_YEAR: uint64 = 31_536_000 // 365 days * 24 hours * 60 minutes * 60 seconds
    intc 5 // 31536000
    // smart_contracts/staking/contract.algo.ts:244
    // let lessThanMaxLockup = expiration <= Global.latestTimestamp + ONE_YEAR
    +
    frame_dig -1
    >=
    // smart_contracts/staking/contract.algo.ts:245
    // if (this.settings(assetXfer.xferAsset.id).exists) {
    frame_dig -4
    gtxns XferAsset
    dup
    itob
    dup
    // smart_contracts/staking/constants.ts:7
    // export const StakingBoxPrefixSettings = 'e'
    bytec 9 // "e"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:245
    // if (this.settings(assetXfer.xferAsset.id).exists) {
    box_len
    bury 1
    bz stakeAsa_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:246
    // lessThanMaxLockup = expiration <= Global.latestTimestamp + this.settings(assetXfer.xferAsset.id).value
    global LatestTimestamp
    frame_dig 15
    box_get
    assert // Box must have value
    btoi
    +
    frame_dig -1
    >=
    frame_bury 12

stakeAsa_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:248
    // const locked = type !== STAKING_TYPE_LOCK
    frame_dig -3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:248
    // const locked = type !== STAKING_TYPE_LOCK
    !=
    frame_bury 9
    // smart_contracts/staking/contract.algo.ts:249
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    frame_dig -3
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:249
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    ==
    bnz stakeAsa_bool_true@4
    frame_dig -3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:249
    // const isEscrow = type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK
    ==
    bz stakeAsa_bool_false@5

stakeAsa_bool_true@4:
    intc_1 // 1
    frame_bury 7

stakeAsa_bool_merge@6:
    // smart_contracts/staking/contract.algo.ts:250
    // const timestamp = Global.latestTimestamp
    global LatestTimestamp
    frame_bury 10
    // smart_contracts/staking/contract.algo.ts:252
    // assert((inTheFuture && lessThanMaxLockup) || !locked, ERR_BAD_EXPIRATION)
    frame_dig 11
    bz stakeAsa_or_contd@8
    frame_dig 12
    bnz stakeAsa_bool_true@9

stakeAsa_or_contd@8:
    // smart_contracts/staking/contract.algo.ts:252
    // assert((inTheFuture && lessThanMaxLockup) || !locked, ERR_BAD_EXPIRATION)
    frame_dig 9
    bnz stakeAsa_bool_false@10

stakeAsa_bool_true@9:
    intc_1 // 1

stakeAsa_bool_merge@11:
    // smart_contracts/staking/contract.algo.ts:252
    // assert((inTheFuture && lessThanMaxLockup) || !locked, ERR_BAD_EXPIRATION)
    assert // Expiration must be in the future or hardlock disabled
    // smart_contracts/staking/contract.algo.ts:255
    // const arc4Sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/staking/contract.algo.ts:259
    // const isUpdate = this.stakes(sk).exists
    frame_dig 14
    concat
    dup
    frame_bury 3
    frame_dig -3
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:259
    // const isUpdate = this.stakes(sk).exists
    box_len
    bury 1
    // smart_contracts/staking/contract.algo.ts:261
    // if (!isUpdate) {
    bnz stakeAsa_else_body@23
    // smart_contracts/staking/contract.algo.ts:265
    // if (isEscrow) {
    frame_dig 7
    bz stakeAsa_else_body@14
    // smart_contracts/staking/contract.algo.ts:266
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/staking/contract.algo.ts:267
    // assert(payment.amount === costs.stakes, ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -5
    gtxns Amount
    // smart_contracts/staking/base.ts:7
    // stakes: 28_900,
    intc 4 // 28900
    // smart_contracts/staking/contract.algo.ts:267
    // assert(payment.amount === costs.stakes, ERR_INVALID_PAYMENT_AMOUNT)
    ==
    assert // Invalid payment amount
    // smart_contracts/staking/contract.algo.ts:269
    // assert(assetXfer.assetReceiver === Global.currentApplicationAddress, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Invalid asset amount
    // smart_contracts/staking/contract.algo.ts:270
    // assert(assetXfer.assetAmount === amount, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetAmount
    frame_dig -2
    ==
    assert // Invalid asset amount

stakeAsa_after_if_else@22:
    // smart_contracts/staking/contract.algo.ts:336
    // amount,
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:337
    // lastUpdate: timestamp,
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:338
    // expiration,
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:335
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:335-339
    // this.stakes(sk).value = {
    //   amount,
    //   lastUpdate: timestamp,
    //   expiration,
    // }
    frame_dig 0
    swap
    box_put
    retsub

stakeAsa_else_body@14:
    // smart_contracts/staking/contract.algo.ts:271
    // } else if (type === STAKING_TYPE_HEARTBEAT) {
    frame_dig -3
    // smart_contracts/staking/types.ts:11
    // export const STAKING_TYPE_HEARTBEAT: StakingType = new arc4.UintN8(0)
    bytec 4 // 0x00
    // smart_contracts/staking/contract.algo.ts:271
    // } else if (type === STAKING_TYPE_HEARTBEAT) {
    ==
    bz stakeAsa_else_body@20
    // smart_contracts/staking/contract.algo.ts:272
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Txn.sender, asset)
    txn Sender
    frame_dig 13
    asset_holding_get AssetBalance
    // smart_contracts/staking/contract.algo.ts:274
    // assert(optedIn, ERR_NOT_OPTED_IN)
    assert // Not opted in
    // smart_contracts/staking/contract.algo.ts:275
    // assert(holdingAmount > 0, ERR_INVALID_ASSET_AMOUNT)
    dup
    assert // Invalid asset amount
    // smart_contracts/staking/contract.algo.ts:277
    // const held = new UintN64(holdingAmount)
    itob
    frame_bury 4
    // smart_contracts/staking/contract.algo.ts:281
    // let hard: uint64 = 0
    intc_0 // 0
    frame_bury 6
    // smart_contracts/staking/contract.algo.ts:282
    // if (this.stakes(hardStakeKey).exists) {
    frame_dig 3
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:282
    // if (this.stakes(hardStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:282
    // if (this.stakes(hardStakeKey).exists) {
    box_len
    bury 1
    bz stakeAsa_after_if_else@17
    // smart_contracts/staking/contract.algo.ts:283
    // hard = this.stakes(hardStakeKey).value.amount
    frame_dig 1
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 6

stakeAsa_after_if_else@17:
    // smart_contracts/staking/contract.algo.ts:288
    // let lock: uint64 = 0
    intc_0 // 0
    frame_bury 8
    // smart_contracts/staking/contract.algo.ts:289
    // if (this.stakes(lockStakeKey).exists) {
    frame_dig 3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:289
    // if (this.stakes(lockStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:289
    // if (this.stakes(lockStakeKey).exists) {
    box_len
    bury 1
    bz stakeAsa_after_if_else@19
    // smart_contracts/staking/contract.algo.ts:290
    // lock = this.stakes(lockStakeKey).value.amount
    frame_dig 2
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 8

stakeAsa_after_if_else@19:
    // smart_contracts/staking/contract.algo.ts:293
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/staking/contract.algo.ts:294
    // assert(payment.amount === (costs.stakes + costs.heartbeats), ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -5
    gtxns Amount
    intc 6 // 99000
    ==
    assert // Invalid payment amount
    // smart_contracts/staking/contract.algo.ts:297
    // assert(assetXfer.assetAmount === 0, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetAmount
    !
    assert // Invalid asset amount
    // smart_contracts/staking/contract.algo.ts:303
    // hard: new UintN64(hard),
    frame_dig 6
    itob
    // smart_contracts/staking/contract.algo.ts:304
    // lock: new UintN64(lock),
    frame_dig 8
    itob
    // smart_contracts/staking/contract.algo.ts:305
    // timestamp: new UintN64(timestamp),
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:301-306
    // const hbv = new arc4Heartbeat({
    //   held,
    //   hard: new UintN64(hard),
    //   lock: new UintN64(lock),
    //   timestamp: new UintN64(timestamp),
    // })
    frame_dig 4
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:308-313
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:315-320
    // const heartbeats = new arc4.StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/contract.algo.ts:308-313
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:315-320
    // const heartbeats = new arc4.StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/contract.algo.ts:308-313
    // const ehbv = new arc4Heartbeat({
    //   held: arc4Zero,
    //   hard: arc4Zero,
    //   lock: arc4Zero,
    //   timestamp: arc4Zero,
    // })
    bytec 7 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/staking/contract.algo.ts:315-320
    // const heartbeats = new arc4.StaticArray<arc4Heartbeat, 4>(
    //   hbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy(),
    //   ehbv.copy()
    // )
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    frame_dig 3
    concat
    // smart_contracts/staking/contract.algo.ts:322
    // this.heartbeats(heartbeatKey).value = heartbeats.copy()
    swap
    box_put
    b stakeAsa_after_if_else@22

stakeAsa_else_body@20:
    // smart_contracts/staking/contract.algo.ts:324
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Txn.sender, asset)
    txn Sender
    frame_dig 13
    asset_holding_get AssetBalance
    // smart_contracts/staking/contract.algo.ts:325
    // assert(optedIn, ERR_NOT_OPTED_IN)
    assert // Not opted in
    // smart_contracts/staking/contract.algo.ts:326
    // assert(holdingAmount >= amount, ERR_INSUFFICIENT_BALANCE)
    frame_dig -2
    >=
    assert // Insufficient balance
    // smart_contracts/staking/contract.algo.ts:328
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/staking/contract.algo.ts:329
    // assert(payment.amount === costs.stakes, ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -5
    gtxns Amount
    // smart_contracts/staking/base.ts:7
    // stakes: 28_900,
    intc 4 // 28900
    // smart_contracts/staking/contract.algo.ts:329
    // assert(payment.amount === costs.stakes, ERR_INVALID_PAYMENT_AMOUNT)
    ==
    assert // Invalid payment amount
    // smart_contracts/staking/contract.algo.ts:332
    // assert(assetXfer.assetAmount === 0, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetAmount
    !
    assert // Invalid asset amount
    b stakeAsa_after_if_else@22

stakeAsa_else_body@23:
    // smart_contracts/staking/contract.algo.ts:341
    // assert(type !== STAKING_TYPE_HEARTBEAT, ERR_HEARTBEAT_CANNOT_UPDATE)
    frame_dig -3
    // smart_contracts/staking/types.ts:11
    // export const STAKING_TYPE_HEARTBEAT: StakingType = new arc4.UintN8(0)
    bytec 4 // 0x00
    // smart_contracts/staking/contract.algo.ts:341
    // assert(type !== STAKING_TYPE_HEARTBEAT, ERR_HEARTBEAT_CANNOT_UPDATE)
    !=
    assert // Heartbeat stakes cannot be updated
    // smart_contracts/staking/contract.algo.ts:342
    // const currentStake = this.stakes(sk).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 5
    intc_2 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:343
    // assert(expiration >= currentStake.expiration || !locked, ERR_BAD_EXPIRATION_UPDATE)
    frame_dig -1
    <=
    bnz stakeAsa_bool_true@25
    frame_dig 9
    bnz stakeAsa_bool_false@26

stakeAsa_bool_true@25:
    intc_1 // 1

stakeAsa_bool_merge@27:
    // smart_contracts/staking/contract.algo.ts:343
    // assert(expiration >= currentStake.expiration || !locked, ERR_BAD_EXPIRATION_UPDATE)
    assert // Expiration must be greater than or equal to the current unlock time or hardlock disabled
    // smart_contracts/staking/contract.algo.ts:346
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/staking/contract.algo.ts:347
    // assert(payment.amount === 0, ERR_INVALID_PAYMENT_AMOUNT)
    frame_dig -5
    gtxns Amount
    !
    assert // Invalid payment amount
    // smart_contracts/staking/contract.algo.ts:349
    // if (isEscrow) {
    frame_dig 7
    bz stakeAsa_else_body@29
    // smart_contracts/staking/contract.algo.ts:350
    // assert(assetXfer.assetReceiver === Global.currentApplicationAddress, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Invalid asset amount
    // smart_contracts/staking/contract.algo.ts:351
    // assert(assetXfer.assetAmount === amount, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetAmount
    frame_dig -2
    ==
    assert // Invalid asset amount

stakeAsa_after_if_else@30:
    // smart_contracts/staking/contract.algo.ts:360
    // const newAmount: uint64 = currentStake.amount + amount
    frame_dig 5
    frame_dig -2
    +
    // smart_contracts/staking/contract.algo.ts:363
    // amount: newAmount,
    itob
    // smart_contracts/staking/contract.algo.ts:364
    // lastUpdate: timestamp,
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:365
    // expiration,
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:362
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:362-366
    // this.stakes(sk).value = {
    //   amount: newAmount,
    //   lastUpdate: timestamp,
    //   expiration,
    // }
    frame_dig 0
    swap
    box_put
    retsub

stakeAsa_else_body@29:
    // smart_contracts/staking/contract.algo.ts:353
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Txn.sender, asset)
    txn Sender
    frame_dig 13
    asset_holding_get AssetBalance
    // smart_contracts/staking/contract.algo.ts:354
    // assert(optedIn, ERR_NOT_OPTED_IN)
    assert // Not opted in
    // smart_contracts/staking/contract.algo.ts:355
    // assert(holdingAmount >= currentStake.amount + amount, ERR_INSUFFICIENT_BALANCE)
    frame_dig 5
    frame_dig -2
    +
    >=
    assert // Insufficient balance
    // smart_contracts/staking/contract.algo.ts:357
    // assert(assetXfer.assetAmount === 0, ERR_INVALID_ASSET_AMOUNT)
    frame_dig -4
    gtxns AssetAmount
    !
    assert // Invalid asset amount
    b stakeAsa_after_if_else@30

stakeAsa_bool_false@26:
    intc_0 // 0
    b stakeAsa_bool_merge@27

stakeAsa_bool_false@10:
    intc_0 // 0
    b stakeAsa_bool_merge@11

stakeAsa_bool_false@5:
    intc_0 // 0
    frame_bury 7
    b stakeAsa_bool_merge@6


// smart_contracts/staking/contract.algo.ts::Staking.withdraw(asset: uint64, type: bytes) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:370
    // withdraw(asset: uint64, type: StakingType): void {
    proto 2 0
    intc_0 // 0
    bytec_3 // ""
    dup
    // smart_contracts/staking/contract.algo.ts:372
    // type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK,
    frame_dig -1
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:372
    // type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK,
    ==
    bnz withdraw_bool_true@2
    frame_dig -1
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:372
    // type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK,
    ==
    bz withdraw_bool_false@3

withdraw_bool_true@2:
    intc_1 // 1

withdraw_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:371-374
    // assert(
    //   type === STAKING_TYPE_HARD || type === STAKING_TYPE_LOCK,
    //   ERR_WITHDRAW_IS_ONLY_FOR_HARD_OR_LOCK
    // )
    assert // Withdraw is only for hard or lock
    // smart_contracts/staking/contract.algo.ts:375
    // const arc4Sender = new Address(Txn.sender)
    txn Sender
    // smart_contracts/staking/contract.algo.ts:376
    // const sk = { address: arc4Sender, asset, type }
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:377
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    concat
    frame_dig -1
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:377
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    dup
    box_len
    bury 1
    assert // Lock not found
    // smart_contracts/staking/contract.algo.ts:379
    // const currentStake = this.stakes(sk).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 1
    intc_2 // 16
    extract_uint64
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:380
    // assert(type !== STAKING_TYPE_LOCK || currentStake.expiration < Global.latestTimestamp, ERR_LOCKED)
    frame_dig -1
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:380
    // assert(type !== STAKING_TYPE_LOCK || currentStake.expiration < Global.latestTimestamp, ERR_LOCKED)
    !=
    bnz withdraw_bool_true@6
    frame_dig 2
    global LatestTimestamp
    <
    bz withdraw_bool_false@7

withdraw_bool_true@6:
    intc_1 // 1

withdraw_bool_merge@8:
    // smart_contracts/staking/contract.algo.ts:380
    // assert(type !== STAKING_TYPE_LOCK || currentStake.expiration < Global.latestTimestamp, ERR_LOCKED)
    assert // This asset is still locked
    // smart_contracts/staking/contract.algo.ts:382
    // if (asset === 0) {
    frame_dig -2
    bnz withdraw_else_body@11
    // smart_contracts/staking/contract.algo.ts:383-389
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: currentStake.amount,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:385
    // receiver: Txn.sender,
    txn Sender
    frame_dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking/contract.algo.ts:383-388
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: currentStake.amount,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:383-389
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: currentStake.amount,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

withdraw_after_if_else@13:
    // smart_contracts/staking/contract.algo.ts:400
    // this.stakes(sk).delete()
    frame_dig 0
    box_del
    pop
    retsub

withdraw_else_body@11:
    // smart_contracts/staking/contract.algo.ts:391-398
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: currentStake.amount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:393
    // assetReceiver: Txn.sender,
    txn Sender
    frame_dig -2
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:391-397
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: currentStake.amount,
    //     xferAsset: asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:391-398
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: currentStake.amount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    b withdraw_after_if_else@13

withdraw_bool_false@7:
    intc_0 // 0
    b withdraw_bool_merge@8

withdraw_bool_false@3:
    intc_0 // 0
    b withdraw_bool_merge@4


// smart_contracts/staking/contract.algo.ts::Staking.createHeartbeat(address: bytes, asset: uint64) -> void:
createHeartbeat:
    // smart_contracts/staking/contract.algo.ts:403
    // createHeartbeat(address: Address, asset: uint64): void {
    proto 2 0
    intc_0 // 0
    bytec_3 // ""
    dupn 3
    // smart_contracts/staking/contract.algo.ts:404
    // assert(Txn.sender === this.heartbeatManagerAddress.value.native, ERR_NOT_HEARTBEAT_MANAGER)
    txn Sender
    // smart_contracts/staking/constants.ts:3
    // export const StakingGlobalStateKeyHeartbeatManagerAddress = 'heartbeat_manager_address'
    intc_0 // 0
    pushbytes "heartbeat_manager_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:404
    // assert(Txn.sender === this.heartbeatManagerAddress.value.native, ERR_NOT_HEARTBEAT_MANAGER)
    ==
    assert // Only the heartbeat manager can call this method
    // smart_contracts/staking/contract.algo.ts:406
    // const hbk = { address, asset }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:407
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    frame_dig -2
    swap
    concat
    dup
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    dig 1
    concat
    dup
    cover 2
    // smart_contracts/staking/contract.algo.ts:407
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Heartbeat not found
    // smart_contracts/staking/contract.algo.ts:409
    // const timestamp = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    cover 2
    // smart_contracts/staking/contract.algo.ts:410
    // const heartbeats = decodeArc4<Heartbeats>(this.heartbeats(hbk).value.bytes)
    box_get
    swap
    cover 2
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:412
    // const [holdings] = AssetHolding.assetBalance(address.native, asset)
    frame_dig -2
    frame_dig -1
    asset_holding_get AssetBalance
    pop
    // smart_contracts/staking/contract.algo.ts:413
    // const held = new UintN64(holdings)
    itob
    swap
    // smart_contracts/staking/contract.algo.ts:421
    // let hard: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:422
    // if (this.stakes(hardStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:422
    // if (this.stakes(hardStakeKey).exists) {
    box_len
    bury 1
    bz createHeartbeat_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:423
    // hard = this.stakes(hardStakeKey).value.amount
    frame_dig 11
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 10

createHeartbeat_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:432
    // let lock: uint64 = 0
    intc_0 // 0
    frame_bury 3
    // smart_contracts/staking/contract.algo.ts:433
    // if (this.stakes(lockStakeKey).exists) {
    frame_dig 5
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:433
    // if (this.stakes(lockStakeKey).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:433
    // if (this.stakes(lockStakeKey).exists) {
    box_len
    bury 1
    bz createHeartbeat_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:434
    // lock = this.stakes(lockStakeKey).value.amount
    frame_dig 0
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 3

createHeartbeat_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:443
    // for (let i: uint64 = 0; i < 4; i += 1) {
    intc_0 // 0
    frame_bury 1

createHeartbeat_while_top@5:
    // smart_contracts/staking/contract.algo.ts:443
    // for (let i: uint64 = 0; i < 4; i += 1) {
    frame_dig 1
    pushint 4 // 4
    <
    bz createHeartbeat_after_while@13
    // smart_contracts/staking/contract.algo.ts:445
    // i === 3 ||
    frame_dig 1
    pushint 3 // 3
    ==
    dup
    frame_bury 4
    // smart_contracts/staking/contract.algo.ts:445-446
    // i === 3 ||
    // heartbeats[i].timestamp > heartbeats[i + 1].timestamp
    bnz createHeartbeat_if_body@8
    // smart_contracts/staking/contract.algo.ts:446
    // heartbeats[i].timestamp > heartbeats[i + 1].timestamp
    frame_dig 8
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 32
    *
    dig 1
    swap
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    pushint 24 // 24
    extract_uint64
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 2
    intc_3 // 32
    *
    uncover 2
    swap
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    pushint 24 // 24
    extract_uint64
    >
    // smart_contracts/staking/contract.algo.ts:445-446
    // i === 3 ||
    // heartbeats[i].timestamp > heartbeats[i + 1].timestamp
    bz createHeartbeat_after_if_else@12

createHeartbeat_if_body@8:
    // smart_contracts/staking/contract.algo.ts:448
    // const indexToModify: uint64 = i === 3 ? 0 : i + 1
    frame_dig 4
    bz createHeartbeat_ternary_false@10
    intc_0 // 0

createHeartbeat_ternary_merge@11:
    // smart_contracts/staking/contract.algo.ts:451
    // hard: new UintN64(hard),
    frame_dig 10
    itob
    // smart_contracts/staking/contract.algo.ts:452
    // lock: new UintN64(lock),
    frame_dig 3
    itob
    // smart_contracts/staking/contract.algo.ts:449-454
    // this.heartbeats(hbk).value[indexToModify] = new arc4Heartbeat({
    //   held,
    //   hard: new UintN64(hard),
    //   lock: new UintN64(lock),
    //   timestamp,
    // })
    frame_dig 9
    uncover 2
    concat
    swap
    concat
    frame_dig 7
    concat
    // smart_contracts/staking/contract.algo.ts:449
    // this.heartbeats(hbk).value[indexToModify] = new arc4Heartbeat({
    frame_dig 6
    dup
    cover 2
    box_get
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:449-454
    // this.heartbeats(hbk).value[indexToModify] = new arc4Heartbeat({
    //   held,
    //   hard: new UintN64(hard),
    //   lock: new UintN64(lock),
    //   timestamp,
    // })
    uncover 3
    dup
    pushint 4 // 4
    <
    assert // Index access is out of bounds
    intc_3 // 32
    *
    uncover 2
    replace3
    box_put
    // smart_contracts/staking/contract.algo.ts:455
    // return
    retsub

createHeartbeat_ternary_false@10:
    // smart_contracts/staking/contract.algo.ts:448
    // const indexToModify: uint64 = i === 3 ? 0 : i + 1
    frame_dig 1
    intc_1 // 1
    +
    b createHeartbeat_ternary_merge@11

createHeartbeat_after_if_else@12:
    frame_dig 2
    frame_bury 1
    b createHeartbeat_while_top@5

createHeartbeat_after_while@13:
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.softCheck(address: bytes, asset: uint64) -> uint64, uint64:
softCheck:
    // smart_contracts/staking/contract.algo.ts:460
    // softCheck(address: Address, asset: uint64): { valid: boolean, balance: uint64 } {
    proto 2 2
    bytec_3 // ""
    dupn 2
    // smart_contracts/staking/contract.algo.ts:461
    // const sk = { address, asset, type: STAKING_TYPE_SOFT }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:462
    // assert(this.stakes(sk).exists, ERR_STAKE_DOESNT_EXIST)
    frame_dig -2
    swap
    concat
    // smart_contracts/staking/types.ts:17
    // export const STAKING_TYPE_SOFT: StakingType = new arc4.UintN8(1)
    pushbytes 0x01
    // smart_contracts/staking/contract.algo.ts:462
    // assert(this.stakes(sk).exists, ERR_STAKE_DOESNT_EXIST)
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dupn 2
    // smart_contracts/staking/contract.algo.ts:462
    // assert(this.stakes(sk).exists, ERR_STAKE_DOESNT_EXIST)
    box_len
    bury 1
    assert // Stake does not exist
    // smart_contracts/staking/contract.algo.ts:464
    // const stake = this.stakes(sk).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:465
    // const lastUpdate = Global.latestTimestamp
    global LatestTimestamp
    swap
    // smart_contracts/staking/contract.algo.ts:467
    // if (asset === 0) {
    frame_dig -1
    bnz softCheck_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:468
    // const valid = address.native.balance >= stake.amount
    frame_dig -2
    acct_params_get AcctBalance
    assert // account funded
    <=
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:469
    // if (!valid) {
    bnz softCheck_after_if_else@3
    // smart_contracts/staking/contract.algo.ts:471
    // amount: address.native.balance,
    frame_dig -2
    acct_params_get AcctBalance
    assert // account funded
    itob
    // smart_contracts/staking/contract.algo.ts:472
    // lastUpdate,
    frame_dig 4
    itob
    // smart_contracts/staking/contract.algo.ts:473
    // expiration: 0,
    intc_0 // 0
    itob
    // smart_contracts/staking/contract.algo.ts:470
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:470-474
    // this.stakes(sk).value = {
    //   amount: address.native.balance,
    //   lastUpdate,
    //   expiration: 0,
    // }
    frame_dig 3
    swap
    box_put

softCheck_after_if_else@3:
    // smart_contracts/staking/contract.algo.ts:476
    // return { valid, balance: address.native.balance }
    frame_dig -2
    acct_params_get AcctBalance
    assert // account funded
    frame_dig 1
    frame_bury 0
    frame_bury 1
    retsub

softCheck_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:479
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(address.native, asset)
    frame_dig -2
    frame_dig -1
    asset_holding_get AssetBalance
    swap
    dup
    cover 2
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:480
    // assert(optedIn, ERR_NOT_OPTED_IN)
    assert // Not opted in
    // smart_contracts/staking/contract.algo.ts:481
    // const valid = holdingAmount >= stake.amount
    <=
    dup
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:482
    // if (!valid) {
    bnz softCheck_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:484
    // amount: holdingAmount,
    frame_dig 0
    itob
    // smart_contracts/staking/contract.algo.ts:485
    // lastUpdate,
    frame_dig 4
    itob
    // smart_contracts/staking/contract.algo.ts:486
    // expiration: 0,
    intc_0 // 0
    itob
    // smart_contracts/staking/contract.algo.ts:483
    // this.stakes(sk).value = {
    cover 2
    concat
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:483-487
    // this.stakes(sk).value = {
    //   amount: holdingAmount,
    //   lastUpdate,
    //   expiration: 0,
    // }
    frame_dig 3
    swap
    box_put

softCheck_after_if_else@6:
    // smart_contracts/staking/contract.algo.ts:490
    // return { valid, balance: holdingAmount }
    frame_dig 2
    frame_dig 0
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.updateSettings(payment: uint64, asset: uint64, value: uint64) -> void:
updateSettings:
    // smart_contracts/staking/contract.algo.ts:493
    // updateSettings(payment: gtxn.PaymentTxn, asset: uint64, value: uint64): void {
    proto 3 0
    bytec_3 // ""
    // smart_contracts/staking/contract.algo.ts:494
    // assert(Txn.sender === Asset(asset).creator, ERR_NOT_ASSET_CREATOR)
    txn Sender
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    ==
    assert // Only the asset creator can call this method
    // smart_contracts/staking/contract.algo.ts:495-502
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/staking/contract.algo.ts:498
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/contract.algo.ts:495-502
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz updateSettings_bool_false@6
    frame_dig -3
    gtxns Amount
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:499
    // amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    frame_dig -2
    itob
    // smart_contracts/staking/constants.ts:7
    // export const StakingBoxPrefixSettings = 'e'
    bytec 9 // "e"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:499
    // amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    box_len
    bury 1
    bz updateSettings_ternary_false@3
    intc_0 // 0

updateSettings_ternary_merge@4:
    // smart_contracts/staking/contract.algo.ts:495-502
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig 0
    ==
    bz updateSettings_bool_false@6
    intc_1 // 1

updateSettings_bool_merge@7:
    // smart_contracts/staking/contract.algo.ts:495-502
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.settings(asset).exists ? 0 : this.mbr().settings,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/staking/contract.algo.ts:504
    // this.settings(asset).value = value
    frame_dig -2
    itob
    // smart_contracts/staking/constants.ts:7
    // export const StakingBoxPrefixSettings = 'e'
    bytec 9 // "e"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:504
    // this.settings(asset).value = value
    frame_dig -1
    itob
    box_put
    retsub

updateSettings_bool_false@6:
    intc_0 // 0
    b updateSettings_bool_merge@7

updateSettings_ternary_false@3:
    // smart_contracts/staking/base.ts:9
    // settings: 9_300
    pushint 9300 // 9300
    b updateSettings_ternary_merge@4


// smart_contracts/staking/contract.algo.ts::Staking.getTimeLeft(address: bytes, asset: uint64) -> uint64:
getTimeLeft:
    // smart_contracts/staking/contract.algo.ts:510-511
    // @abimethod({ readonly: true })
    // getTimeLeft(address: Address, asset: uint64): uint64 {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:512
    // const sk = { address, asset, type: STAKING_TYPE_LOCK }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:514
    // if (!this.stakes(sk).exists || Global.latestTimestamp >= this.stakes(sk).value.expiration) {
    frame_dig -2
    swap
    concat
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:514
    // if (!this.stakes(sk).exists || Global.latestTimestamp >= this.stakes(sk).value.expiration) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:514
    // if (!this.stakes(sk).exists || Global.latestTimestamp >= this.stakes(sk).value.expiration) {
    box_len
    bury 1
    bz getTimeLeft_if_body@2
    global LatestTimestamp
    frame_dig 0
    box_get
    assert // Box must have value
    intc_2 // 16
    extract_uint64
    >=
    bz getTimeLeft_after_if_else@3

getTimeLeft_if_body@2:
    // smart_contracts/staking/contract.algo.ts:515
    // return 0
    intc_0 // 0
    swap
    retsub

getTimeLeft_after_if_else@3:
    // smart_contracts/staking/contract.algo.ts:518
    // return this.stakes(sk).value.expiration - Global.latestTimestamp
    frame_dig 0
    box_get
    assert // Box must have value
    intc_2 // 16
    extract_uint64
    global LatestTimestamp
    -
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.mustGetTimeLeft(address: bytes, asset: uint64) -> uint64:
mustGetTimeLeft:
    // smart_contracts/staking/contract.algo.ts:521-522
    // @abimethod({ readonly: true })
    // mustGetTimeLeft(address: Address, asset: uint64): uint64 {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:523
    // const sk = { address, asset, type: STAKING_TYPE_LOCK }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:524
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    frame_dig -2
    swap
    concat
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:524
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:524
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    dup
    box_len
    bury 1
    assert // Lock not found
    // smart_contracts/staking/contract.algo.ts:525
    // assert(Global.latestTimestamp < this.stakes(sk).value.expiration, ERR_LOCKED)
    global LatestTimestamp
    swap
    box_get
    assert // Box must have value
    intc_2 // 16
    extract_uint64
    swap
    dig 1
    <
    assert // This asset is still locked
    // smart_contracts/staking/contract.algo.ts:526
    // return this.stakes(sk).value.expiration - Global.latestTimestamp
    global LatestTimestamp
    -
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.getInfo(address: bytes, stake.asset: uint64, stake.type: bytes) -> uint64, uint64, uint64:
getInfo:
    // smart_contracts/staking/contract.algo.ts:529-530
    // @abimethod({ readonly: true })
    // getInfo(address: Address, stake: StakeInfo): Stake {
    proto 3 3
    // smart_contracts/staking/contract.algo.ts:531
    // const sk = { address, ...stake }
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:532
    // if (!this.stakes(sk).exists) {
    frame_dig -3
    swap
    concat
    frame_dig -1
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:532
    // if (!this.stakes(sk).exists) {
    box_len
    bury 1
    bnz getInfo_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:533
    // return { amount: 0, lastUpdate: 0, expiration: 0 }
    intc_0 // 0
    dupn 2
    uncover 3
    retsub

getInfo_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:536
    // return this.stakes(sk).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    uncover 2
    intc_2 // 16
    extract_uint64
    uncover 3
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.mustGetInfo(address: bytes, stake.asset: uint64, stake.type: bytes) -> uint64, uint64, uint64:
mustGetInfo:
    // smart_contracts/staking/contract.algo.ts:539-540
    // @abimethod({ readonly: true })
    // mustGetInfo(address: Address, stake: StakeInfo): Stake {
    proto 3 3
    // smart_contracts/staking/contract.algo.ts:541
    // const sk = { address, ...stake }
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:542
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    frame_dig -3
    swap
    concat
    frame_dig -1
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:542
    // assert(this.stakes(sk).exists, ERR_NO_LOCK)
    dup
    box_len
    bury 1
    assert // Lock not found
    // smart_contracts/staking/contract.algo.ts:544
    // return this.stakes(sk).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    uncover 2
    intc_2 // 16
    extract_uint64
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.getEscrowInfo(address: bytes, asset: uint64) -> uint64, uint64:
getEscrowInfo:
    // smart_contracts/staking/contract.algo.ts:547-548
    // @abimethod({ readonly: true })
    // getEscrowInfo(address: Address, asset: uint64): Escrow {
    proto 2 2
    intc_0 // 0
    bytec_3 // ""
    // smart_contracts/staking/contract.algo.ts:552
    // let hard: uint64 = 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:549
    // const sk = { address, asset, type: STAKING_TYPE_HARD }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:553
    // if (this.stakes(sk).exists) {
    frame_dig -2
    swap
    concat
    dup
    // smart_contracts/staking/types.ts:23
    // export const STAKING_TYPE_HARD: StakingType = new arc4.UintN8(2)
    bytec 5 // 0x02
    // smart_contracts/staking/contract.algo.ts:553
    // if (this.stakes(sk).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:553
    // if (this.stakes(sk).exists) {
    box_len
    bury 1
    bz getEscrowInfo_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:554
    // hard = this.stakes(sk).value.amount
    frame_dig 4
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 2

getEscrowInfo_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:557
    // let lock: uint64 = 0
    intc_0 // 0
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:558
    // if (this.stakes(lk).exists) {
    frame_dig 3
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec_2 // 0x03
    // smart_contracts/staking/contract.algo.ts:558
    // if (this.stakes(lk).exists) {
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:558
    // if (this.stakes(lk).exists) {
    box_len
    bury 1
    bz getEscrowInfo_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:559
    // lock = this.stakes(lk).value.amount
    frame_dig 0
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 1

getEscrowInfo_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:562
    // return { hard, lock }
    frame_dig 2
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.getHeartbeat(address: bytes, asset: uint64) -> bytes:
getHeartbeat:
    // smart_contracts/staking/contract.algo.ts:565-566
    // @abimethod({ readonly: true })
    // getHeartbeat(address: Address, asset: uint64): Heartbeats {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:567
    // const hbk = { address, asset }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:568
    // if (!this.heartbeats(hbk).exists) {
    frame_dig -2
    swap
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:568
    // if (!this.heartbeats(hbk).exists) {
    box_len
    bury 1
    bnz getHeartbeat_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:577
    // return [ehbv, ehbv, ehbv, ehbv]
    pushbytes 0x00040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

getHeartbeat_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:580
    // return decodeArc4<Heartbeats>(this.heartbeats(hbk).value.bytes)
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.mustGetHeartbeat(address: bytes, asset: uint64) -> bytes:
mustGetHeartbeat:
    // smart_contracts/staking/contract.algo.ts:583-584
    // @abimethod({ readonly: true })
    // mustGetHeartbeat(address: Address, asset: uint64): Heartbeats {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:585
    // const hbk = { address, asset }
    frame_dig -1
    itob
    // smart_contracts/staking/contract.algo.ts:586
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    frame_dig -2
    swap
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:586
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Heartbeat not found
    // smart_contracts/staking/contract.algo.ts:587
    // return decodeArc4<Heartbeats>(this.heartbeats(hbk).value.bytes)
    box_get
    assert // Box must have value
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.getHeartbeatAverage(address: bytes, asset: uint64, includeStaked: uint64) -> uint64:
getHeartbeatAverage:
    // smart_contracts/staking/contract.algo.ts:590-591
    // @abimethod({ readonly: true })
    // getHeartbeatAverage(address: Address, asset: uint64, includeStaked: boolean): uint64 {
    proto 3 1
    intc_0 // 0
    bytec_3 // ""
    dupn 2
    // smart_contracts/staking/contract.algo.ts:592
    // const hbk = { address, asset }
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:594
    // if (!this.heartbeats(hbk).exists) {
    frame_dig -3
    swap
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    swap
    concat
    dup
    // smart_contracts/staking/contract.algo.ts:594
    // if (!this.heartbeats(hbk).exists) {
    box_len
    bury 1
    bnz getHeartbeatAverage_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:595
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getHeartbeatAverage_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:598
    // const heartbeats = decodeArc4<Heartbeats>(this.heartbeats(hbk).value.bytes)
    frame_dig 4
    box_get
    swap
    frame_bury 0
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:600
    // let total: uint64 = 0
    intc_0 // 0
    frame_bury 3
    // smart_contracts/staking/contract.algo.ts:601
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    intc_0 // 0
    frame_bury 1

getHeartbeatAverage_while_top@3:
    // smart_contracts/staking/contract.algo.ts:601
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    frame_dig 0
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    frame_dig 1
    >
    bz getHeartbeatAverage_after_while@8
    // smart_contracts/staking/contract.algo.ts:602
    // if (includeStaked) {
    frame_dig -1
    bz getHeartbeatAverage_else_body@6
    // smart_contracts/staking/contract.algo.ts:603
    // total += heartbeats[i].held + heartbeats[i].hard + heartbeats[i].lock
    frame_dig 0
    extract 2 0
    frame_dig 1
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    +
    swap
    intc_2 // 16
    extract_uint64
    +
    frame_dig 3
    +
    frame_bury 3

getHeartbeatAverage_after_if_else@7:
    // smart_contracts/staking/contract.algo.ts:601
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b getHeartbeatAverage_while_top@3

getHeartbeatAverage_else_body@6:
    // smart_contracts/staking/contract.algo.ts:605
    // total += heartbeats[i].held
    frame_dig 0
    extract 2 0
    frame_dig 1
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    intc_0 // 0
    extract_uint64
    frame_dig 3
    +
    frame_bury 3
    b getHeartbeatAverage_after_if_else@7

getHeartbeatAverage_after_while@8:
    // smart_contracts/staking/contract.algo.ts:609
    // return total / heartbeats.length
    frame_dig 3
    frame_dig 2
    /
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.mustGetHeartbeatAverage(address: bytes, asset: uint64, includeStaked: uint64) -> uint64:
mustGetHeartbeatAverage:
    // smart_contracts/staking/contract.algo.ts:612-613
    // @abimethod({ readonly: true })
    // mustGetHeartbeatAverage(address: Address, asset: uint64, includeStaked: boolean): uint64 {
    proto 3 1
    bytec_3 // ""
    // smart_contracts/staking/contract.algo.ts:614
    // const hbk = { address, asset }
    frame_dig -2
    itob
    // smart_contracts/staking/contract.algo.ts:615
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    frame_dig -3
    swap
    concat
    // smart_contracts/staking/constants.ts:6
    // export const StakingBoxPrefixHeartbeats = 'h'
    bytec 6 // "h"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:615
    // assert(this.heartbeats(hbk).exists, ERR_HEARBEAT_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Heartbeat not found
    // smart_contracts/staking/contract.algo.ts:617
    // const heartbeats = decodeArc4<Heartbeats>(this.heartbeats(hbk).value.bytes)
    box_get
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:619
    // let total: uint64 = 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:620
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    dup

mustGetHeartbeatAverage_while_top@1:
    // smart_contracts/staking/contract.algo.ts:620
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    frame_dig 1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 0
    frame_dig 3
    >
    bz mustGetHeartbeatAverage_after_while@6
    // smart_contracts/staking/contract.algo.ts:621
    // if (includeStaked) {
    frame_dig -1
    bz mustGetHeartbeatAverage_else_body@4
    // smart_contracts/staking/contract.algo.ts:622
    // total += heartbeats[i].held + heartbeats[i].hard + heartbeats[i].lock
    frame_dig 1
    extract 2 0
    frame_dig 3
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    +
    swap
    intc_2 // 16
    extract_uint64
    +
    frame_dig 2
    +
    frame_bury 2

mustGetHeartbeatAverage_after_if_else@5:
    // smart_contracts/staking/contract.algo.ts:620
    // for (let i: uint64 = 0; i < heartbeats.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b mustGetHeartbeatAverage_while_top@1

mustGetHeartbeatAverage_else_body@4:
    // smart_contracts/staking/contract.algo.ts:624
    // total += heartbeats[i].held
    frame_dig 1
    extract 2 0
    frame_dig 3
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    intc_0 // 0
    extract_uint64
    frame_dig 2
    +
    frame_bury 2
    b mustGetHeartbeatAverage_after_if_else@5

mustGetHeartbeatAverage_after_while@6:
    // smart_contracts/staking/contract.algo.ts:628
    // return total / heartbeats.length
    frame_dig 2
    frame_dig 0
    /
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.getInfoList(address: bytes, type: bytes, assets: bytes) -> bytes:
getInfoList:
    // smart_contracts/staking/contract.algo.ts:631-632
    // @abimethod({ readonly: true })
    // getInfoList(address: Address, type: StakingType, assets: uint64[]): Stake[] {
    proto 3 1
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:633
    // let results: Stake[] = []
    bytec 11 // 0x0000
    // smart_contracts/staking/contract.algo.ts:634
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

getInfoList_while_top@1:
    // smart_contracts/staking/contract.algo.ts:634
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz getInfoList_after_while@6
    // smart_contracts/staking/contract.algo.ts:635
    // const sk = { address, asset: assets[i], type }
    frame_dig -1
    extract 2 0
    frame_dig 2
    pushint 8 // 8
    *
    extract_uint64
    itob
    // smart_contracts/staking/contract.algo.ts:636
    // if (!this.stakes(sk).exists) {
    frame_dig -3
    swap
    concat
    frame_dig -2
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:636
    // if (!this.stakes(sk).exists) {
    box_len
    bury 1
    bnz getInfoList_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:644
    // results = [...results, emptyStake]
    frame_dig 1
    extract 2 0
    pushbytes 0x000000000000000000000000000000000000000000000000
    concat
    dup
    len
    pushint 24 // 24
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

getInfoList_block@5:
    // smart_contracts/staking/contract.algo.ts:634
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b getInfoList_while_top@1

getInfoList_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:648-651
    // results = [
    //   ...results,
    //   this.stakes(sk).value,
    // ]
    frame_dig 1
    extract 2 0
    // smart_contracts/staking/contract.algo.ts:650
    // this.stakes(sk).value,
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    uncover 2
    intc_2 // 16
    extract_uint64
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/staking/contract.algo.ts:648-651
    // results = [
    //   ...results,
    //   this.stakes(sk).value,
    // ]
    dup
    len
    pushint 24 // 24
    /
    itob
    extract 6 2
    swap
    concat
    extract 2 0
    concat
    dup
    len
    pushint 24 // 24
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    b getInfoList_block@5

getInfoList_after_while@6:
    // smart_contracts/staking/contract.algo.ts:653
    // return results
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.mustGetInfoList(address: bytes, type: bytes, assets: bytes) -> bytes:
mustGetInfoList:
    // smart_contracts/staking/contract.algo.ts:656-657
    // @abimethod({ readonly: true })
    // mustGetInfoList(address: Address, type: StakingType, assets: uint64[]): Stake[] {
    proto 3 1
    // smart_contracts/staking/contract.algo.ts:658
    // let results: Stake[] = []
    bytec 11 // 0x0000
    // smart_contracts/staking/contract.algo.ts:659
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

mustGetInfoList_while_top@1:
    // smart_contracts/staking/contract.algo.ts:659
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz mustGetInfoList_after_while@3
    // smart_contracts/staking/contract.algo.ts:660
    // const sk = { address, asset: assets[i], type }
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    pushint 8 // 8
    *
    extract_uint64
    itob
    // smart_contracts/staking/contract.algo.ts:661
    // assert(this.stakes(sk).exists, ERR_STAKE_NOT_FOUND)
    frame_dig -3
    swap
    concat
    frame_dig -2
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:661
    // assert(this.stakes(sk).exists, ERR_STAKE_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Stake not found
    // smart_contracts/staking/contract.algo.ts:663-666
    // results = [
    //   ...results,
    //   this.stakes(sk).value,
    // ]
    frame_dig 0
    extract 2 0
    // smart_contracts/staking/contract.algo.ts:665
    // this.stakes(sk).value,
    swap
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    uncover 2
    intc_2 // 16
    extract_uint64
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/staking/contract.algo.ts:663-666
    // results = [
    //   ...results,
    //   this.stakes(sk).value,
    // ]
    dup
    len
    pushint 24 // 24
    /
    itob
    extract 6 2
    swap
    concat
    extract 2 0
    concat
    dup
    len
    pushint 24 // 24
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:659
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 1
    b mustGetInfoList_while_top@1

mustGetInfoList_after_while@3:
    // smart_contracts/staking/contract.algo.ts:668
    // return results
    retsub


// smart_contracts/staking/contract.algo.ts::Staking.stakeCheck(address: bytes, checks: bytes, type: bytes, includeStaked: uint64) -> uint64:
stakeCheck:
    // smart_contracts/staking/contract.algo.ts:671-672
    // @abimethod({ readonly: true })
    // stakeCheck(address: Address, checks: AssetCheck[], type: StakingType, includeStaked: boolean): boolean {
    proto 4 1
    intc_0 // 0
    dup
    bytec_3 // ""
    dup
    // smart_contracts/staking/contract.algo.ts:673
    // for (let i: uint64 = 0; i < checks.length; i += 1) {
    intc_0 // 0

stakeCheck_while_top@1:
    // smart_contracts/staking/contract.algo.ts:673
    // for (let i: uint64 = 0; i < checks.length; i += 1) {
    frame_dig -3
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz stakeCheck_after_while@9
    // smart_contracts/staking/contract.algo.ts:674
    // const sk = { address, asset: checks[i].asset, type }
    frame_dig -3
    extract 2 0
    frame_dig 4
    intc_2 // 16
    *
    intc_2 // 16
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 0
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 3
    itob
    // smart_contracts/staking/contract.algo.ts:675
    // if (!this.stakes(sk).exists) {
    frame_dig -4
    swap
    concat
    frame_dig -2
    concat
    // smart_contracts/staking/constants.ts:5
    // export const StakingBoxPrefixStakes = 's'
    bytec_0 // "s"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:675
    // if (!this.stakes(sk).exists) {
    box_len
    bury 1
    bnz stakeCheck_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:676
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

stakeCheck_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:679
    // const stake = this.stakes(sk).value
    frame_dig 1
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:682
    // if (type === STAKING_TYPE_HEARTBEAT) {
    frame_dig -2
    // smart_contracts/staking/types.ts:11
    // export const STAKING_TYPE_HEARTBEAT: StakingType = new arc4.UintN8(0)
    bytec 4 // 0x00
    // smart_contracts/staking/contract.algo.ts:682
    // if (type === STAKING_TYPE_HEARTBEAT) {
    ==
    swap
    frame_bury 2
    bz stakeCheck_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:683
    // amountToCheck = this.getHeartbeatAverage(address, checks[i].asset, includeStaked)
    frame_dig -4
    frame_dig 3
    frame_dig -1
    callsub getHeartbeatAverage
    frame_bury 2

stakeCheck_after_if_else@6:
    // smart_contracts/staking/contract.algo.ts:686
    // if (checks[i].amount >= amountToCheck) {
    frame_dig 0
    pushint 8 // 8
    extract_uint64
    frame_dig 2
    >=
    bz stakeCheck_after_if_else@8
    // smart_contracts/staking/contract.algo.ts:687
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

stakeCheck_after_if_else@8:
    // smart_contracts/staking/contract.algo.ts:673
    // for (let i: uint64 = 0; i < checks.length; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b stakeCheck_while_top@1

stakeCheck_after_while@9:
    // smart_contracts/staking/contract.algo.ts:691
    // return true
    intc_1 // 1
    frame_bury 0
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:20-21
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:22
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec 8 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:22
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 10 // "version"
    // smart_contracts/utils/base-contracts/base.ts:23
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:28
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec 8 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:29
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec 8 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
