#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 16 100000 321 1000 320 216 392 1000000 352 86400
    bytecblock 0x00 "" "controlled_address" "proposal_creation_settings" "r" "spending_address" "p" "krby_percentage" "mod_percentage" 0x14 0x151f7c75 "version" "akita_assets" "revocation_address" 0x03 "l" 0x28 "content_policy" "min_rewards_impact" "social_fees" "staking_fees" "subscription_fees" "nft_fees" "proposal_id" 0x01 0x02 0x1e "e" "emoderators" 0x0f885493 "escrow_factory" "status" "swap_fees" "proposal_participation_settings" "proposal_approval_threshold_settings" "proposal_voting_duration_settings" "proposal_fee" "akita_al" "ekrby"
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txn NumAppArgs
    bz main_after_if_else@22
    pushbytess 0x240d2f67 0xd380c4f0 0x6b434be0 // method "create(uint64)void", method "update(uint64)void", method "init(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64)),address)void"
    bytec 29 // method "arc58_verifyAuthAddr()void"
    pushbytess 0x682fdbf8 0xde300fe9 0xbe39d3c8 0x91a02490 0x6a6494b6 0x68fd9595 0x56fd2375 0x29da5e80 0x3cc3d0a4 0x4baf3f0a 0x76dcf443 0xac7d2518 // method "arc58_canCall(uint64,bool,address,byte[4])bool", method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void", method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void", method "newProposal(pay,uint8,byte[36],byte[],uint8)void", method "finalizeProposal(uint64,byte[])void", method "createModDisbursement()void", method "createDailyDisbursement()void", method "arc58_pluginOptinEscrow(uint64,address,uint64[],pay)void", method "optinReceiveEscrow(pay,string,uint64)void", method "startEscrowDisbursement(string)void", method "processEscrowAllocation(string,uint64[])void", method "getState()(uint64,string,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),uint64,uint64,(uint64,uint64),((uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64)),address)"
    txna ApplicationArgs 0
    match main_create_route@3 main_update_route@4 main_init_route@5 main_arc58_verifyAuthAddr_route@6 main_arc58_canCall_route@7 main_arc58_rekeyToPlugin_route@8 main_arc58_rekeyToNamedPlugin_route@9 main_newProposal_route@10 main_finalizeProposal_route@11 main_createModDisbursement_route@12 main_createDailyDisbursement_route@13 main_arc58_pluginOptinEscrow_route@14 main_optinReceiveEscrow_route@15 main_startEscrowDisbursement_route@16 main_processEscrowAllocation_route@17 main_getState_route@18

main_after_if_else@22:
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    intc_0 // 0
    return

main_getState_route@18:
    // smart_contracts/dao/contract.algo.ts:1925
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getState
    uncover 72
    itob
    dig 72
    len
    itob
    extract 6 2
    uncover 73
    concat
    dig 72
    len
    pushint 36 // 36
    ==
    assert // invalid size
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 71
    itob
    uncover 11
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 60
    itob
    uncover 60
    itob
    uncover 60
    itob
    cover 2
    concat
    swap
    concat
    uncover 58
    itob
    uncover 58
    itob
    uncover 58
    itob
    uncover 58
    itob
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 55
    itob
    uncover 55
    itob
    uncover 55
    itob
    cover 2
    concat
    swap
    concat
    uncover 53
    itob
    uncover 53
    itob
    uncover 53
    itob
    cover 2
    concat
    swap
    concat
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 51
    itob
    uncover 14
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 37
    itob
    uncover 37
    itob
    uncover 37
    itob
    uncover 37
    itob
    concat
    uncover 36
    itob
    uncover 36
    itob
    uncover 36
    itob
    uncover 36
    itob
    uncover 36
    itob
    uncover 36
    itob
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 31
    itob
    uncover 31
    itob
    uncover 31
    itob
    uncover 31
    itob
    uncover 31
    itob
    uncover 31
    itob
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 26
    itob
    uncover 26
    itob
    uncover 26
    itob
    uncover 26
    itob
    uncover 26
    itob
    uncover 26
    itob
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 21
    itob
    uncover 21
    itob
    uncover 21
    itob
    uncover 21
    itob
    uncover 21
    itob
    uncover 21
    itob
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 12
    pushbytes 0x0276
    concat
    uncover 14
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_processEscrowAllocation_route@17:
    // smart_contracts/dao/contract.algo.ts:1815
    // processEscrowAllocation(escrow: string, ids: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/dao/contract.algo.ts:1815
    // processEscrowAllocation(escrow: string, ids: uint64[]): void {
    callsub processEscrowAllocation
    intc_1 // 1
    return

main_startEscrowDisbursement_route@16:
    // smart_contracts/dao/contract.algo.ts:1796
    // startEscrowDisbursement(escrow: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/dao/contract.algo.ts:1796
    // startEscrowDisbursement(escrow: string): void {
    callsub startEscrowDisbursement
    intc_1 // 1
    return

main_optinReceiveEscrow_route@15:
    // smart_contracts/dao/contract.algo.ts:1679
    // optinReceiveEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dao/contract.algo.ts:1679
    // optinReceiveEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    callsub optinReceiveEscrow
    intc_1 // 1
    return

main_arc58_pluginOptinEscrow_route@14:
    // smart_contracts/dao/contract.algo.ts:1618-1623
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/dao/contract.algo.ts:1618-1623
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    callsub arc58_pluginOptinEscrow
    intc_1 // 1
    return

main_createDailyDisbursement_route@13:
    // smart_contracts/dao/contract.algo.ts:1603
    // createDailyDisbursement(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub createDailyDisbursement
    intc_1 // 1
    return

main_createModDisbursement_route@12:
    // smart_contracts/dao/contract.algo.ts:1599
    // createModDisbursement(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_finalizeProposal_route@11:
    // smart_contracts/dao/contract.algo.ts:1535
    // finalizeProposal(proposalID: uint64, args: bytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/dao/contract.algo.ts:1535
    // finalizeProposal(proposalID: uint64, args: bytes): void {
    callsub finalizeProposal
    intc_1 // 1
    return

main_newProposal_route@10:
    // smart_contracts/dao/contract.algo.ts:1455-1461
    // newProposal(
    //   payment: gtxn.PaymentTxn,
    //   action: ProposalAction,
    //   cid: CID,
    //   data: bytes,
    //   status: ProposalStatus,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1455-1461
    // newProposal(
    //   payment: gtxn.PaymentTxn,
    //   action: ProposalAction,
    //   cid: CID,
    //   data: bytes,
    //   status: ProposalStatus,
    // ): void {
    callsub newProposal
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@9:
    // smart_contracts/dao/contract.algo.ts:1410
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1410
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@8:
    // smart_contracts/dao/contract.algo.ts:1367-1372
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1367-1372
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    callsub arc58_rekeyToPlugin
    intc_1 // 1
    return

main_arc58_canCall_route@7:
    // smart_contracts/dao/contract.algo.ts:1345
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1345
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_verifyAuthAddr_route@6:
    // smart_contracts/dao/contract.algo.ts:1333
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    return

main_init_route@5:
    // smart_contracts/dao/contract.algo.ts:1234-1247
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   fees: Fees,
    //   proposalSettings: {
    //     creation: ProposalSettings,
    //     participation: ProposalSettings,
    //     approval: ProposalSettings,
    //     duration: ProposalSettings,
    //   },
    //   revocationAddress: Address
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    pushint 48 // 48
    extract_uint64
    dig 7
    pushint 56 // 56
    extract_uint64
    dig 8
    pushint 64 // 64
    extract_uint64
    dig 9
    pushint 72 // 72
    extract_uint64
    dig 10
    pushint 80 // 80
    extract_uint64
    dig 11
    pushint 88 // 88
    extract_uint64
    dig 12
    pushint 96 // 96
    extract_uint64
    dig 13
    pushint 104 // 104
    extract_uint64
    dig 14
    pushint 112 // 112
    extract_uint64
    dig 15
    pushint 120 // 120
    extract_uint64
    dig 16
    pushint 128 // 128
    extract_uint64
    dig 17
    pushint 136 // 136
    extract_uint64
    dig 18
    pushint 144 // 144
    extract_uint64
    dig 19
    pushint 152 // 152
    extract_uint64
    dig 20
    pushint 160 // 160
    extract_uint64
    dig 21
    pushint 168 // 168
    extract_uint64
    dig 22
    pushint 176 // 176
    extract_uint64
    dig 23
    pushint 184 // 184
    extract_uint64
    dig 24
    pushint 192 // 192
    extract_uint64
    dig 25
    pushint 200 // 200
    extract_uint64
    dig 26
    pushint 208 // 208
    extract_uint64
    dig 27
    intc 8 // 216
    extract_uint64
    dig 28
    pushint 224 // 224
    extract_uint64
    dig 29
    pushint 232 // 232
    extract_uint64
    uncover 30
    pushint 240 // 240
    extract_uint64
    txna ApplicationArgs 6
    dup
    extract 0 48 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    dig 6
    extract 48 48 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    dig 12
    extract 96 48 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    uncover 18
    extract 144 48 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    txna ApplicationArgs 7
    // smart_contracts/dao/contract.algo.ts:1234-1247
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   fees: Fees,
    //   proposalSettings: {
    //     creation: ProposalSettings,
    //     participation: ProposalSettings,
    //     approval: ProposalSettings,
    //     duration: ProposalSettings,
    //   },
    //   revocationAddress: Address
    // ): void {
    callsub init
    intc_1 // 1
    return

main_update_route@4:
    // smart_contracts/dao/contract.algo.ts:1222
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dao/contract.algo.ts:1222
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_create_route@3:
    // smart_contracts/dao/contract.algo.ts:1216
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/dao/contract.algo.ts:129
    // export class AkitaDAO extends Contract implements AkitaDAOInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dao/contract.algo.ts:1216
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::wideRatio(numerators.0: uint64, numerators.1: uint64, denominators.0: uint64, denominators.1: uint64) -> uint64:
wideRatio:
    // smart_contracts/utils/functions.ts:79
    // export function wideRatio(numerators: [uint64, uint64], denominators: [uint64, uint64]): uint64 {
    proto 4 1
    // smart_contracts/utils/functions.ts:80
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    frame_dig -2
    bz wideRatio_bool_false@3
    frame_dig -1
    bz wideRatio_bool_false@3
    intc_1 // 1

wideRatio_bool_merge@4:
    // smart_contracts/utils/functions.ts:80
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:81
    // const [overflow, result] = op.divmodw(...op.mulw(...numerators), ...op.mulw(...denominators))
    frame_dig -4
    frame_dig -3
    mulw
    frame_dig -2
    frame_dig -1
    mulw
    divmodw
    popn 2
    swap
    // smart_contracts/utils/functions.ts:82
    // assert(overflow === 0, ERR_INVALID_PERCENTAGE)
    !
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:83
    // return result
    retsub

wideRatio_bool_false@3:
    intc_0 // 0
    b wideRatio_bool_merge@4


// smart_contracts/dao/contract.algo.ts::AkitaDAO.pluginCallAllowed(application: uint64, allowedCaller: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/dao/contract.algo.ts:351
    // private pluginCallAllowed(application: uint64, allowedCaller: Account, method: bytes<4>): boolean {
    proto 3 1
    intc_0 // 0
    bytec_1 // ""
    dupn 5
    // smart_contracts/dao/contract.algo.ts:352
    // const key: PluginKey = { application, allowedCaller }
    frame_dig -3
    itob
    // smart_contracts/dao/contract.algo.ts:354
    // if (!this.plugins(key).exists) {
    frame_dig -2
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    dup
    // smart_contracts/dao/contract.algo.ts:354
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:355
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:358
    // if (!this.plugins(key).value.useExecutionKey.native) {
    frame_dig 7
    box_get
    assert // Box must have value
    intc 11 // 352
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bnz pluginCallAllowed_after_if_else@4
    // smart_contracts/dao/contract.algo.ts:359
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@4:
    // smart_contracts/dao/contract.algo.ts:362
    // const methods = this.plugins(key).value.methods.copy()
    frame_dig 7
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:363
    // let methodAllowed = methods.length > 0 ? false : true;
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 6
    !
    frame_bury 3
    // smart_contracts/dao/contract.algo.ts:364
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@5:
    // smart_contracts/dao/contract.algo.ts:364
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    frame_dig 6
    <
    bz pluginCallAllowed_block@10
    // smart_contracts/dao/contract.algo.ts:365
    // if (methods[i].selector.native === method) {
    frame_dig 0
    extract 2 0
    frame_dig 2
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    extract 0 4 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@8
    // smart_contracts/dao/contract.algo.ts:366
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 3

pluginCallAllowed_block@10:
    // smart_contracts/dao/contract.algo.ts:371
    // const p = decodeArc4<PluginInfo>(this.plugins(key).value.bytes)
    frame_dig 7
    box_get
    assert // Box must have value
    dup
    pushint 18 // 18
    extract_uint64
    frame_bury 4
    dup
    pushint 224 // 224
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    pushint 29 // 29
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:372
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCallAllowed_ternary_false@12
    global Round
    frame_bury 1

pluginCallAllowed_ternary_merge@13:
    // smart_contracts/dao/contract.algo.ts:375
    // p.lastCalled >= epochRef &&
    frame_dig 5
    frame_dig 1
    >=
    // smart_contracts/dao/contract.algo.ts:375-376
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    bz pluginCallAllowed_bool_false@16
    // smart_contracts/dao/contract.algo.ts:376
    // (epochRef - p.lastCalled) >= p.cooldown &&
    frame_dig 1
    frame_dig 5
    -
    frame_dig 4
    >=
    // smart_contracts/dao/contract.algo.ts:375-376
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    bz pluginCallAllowed_bool_false@16
    intc_1 // 1

pluginCallAllowed_bool_merge@17:
    // smart_contracts/dao/contract.algo.ts:375-377
    // p.lastCalled >= epochRef &&
    // (epochRef - p.lastCalled) >= p.cooldown &&
    // methodAllowed
    frame_dig 3
    &&
    // smart_contracts/dao/contract.algo.ts:374-378
    // return (
    //   p.lastCalled >= epochRef &&
    //   (epochRef - p.lastCalled) >= p.cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@16:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@17

pluginCallAllowed_ternary_false@12:
    // smart_contracts/dao/contract.algo.ts:372
    // const epochRef = p.useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 1
    b pluginCallAllowed_ternary_merge@13

pluginCallAllowed_after_if_else@8:
    // smart_contracts/dao/contract.algo.ts:364
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@5


// smart_contracts/dao/contract.algo.ts::AkitaDAO.pluginCheck(key.application: uint64, key.allowedCaller: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64:
pluginCheck:
    // smart_contracts/dao/contract.algo.ts:399
    // private pluginCheck(key: PluginKey): PluginValidation {
    proto 2 6
    intc_0 // 0
    bytec_1 // ""
    dupn 7
    frame_dig -2
    itob
    // smart_contracts/dao/contract.algo.ts:401
    // const exists = this.plugins(key).exists;
    frame_dig -1
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    dup
    // smart_contracts/dao/contract.algo.ts:401
    // const exists = this.plugins(key).exists;
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/dao/contract.algo.ts:402
    // if (!exists) {
    bnz pluginCheck_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:404
    // exists: false,
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:405
    // expired: true,
    intc_1 // 1
    // smart_contracts/dao/contract.algo.ts:406-407
    // hasCooldown: true,
    // onCooldown: true,
    dupn 2
    // smart_contracts/dao/contract.algo.ts:408
    // hasMethodRestrictions: false,
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:409
    // valid: false
    dup
    // smart_contracts/dao/contract.algo.ts:403-410
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:413
    // const pluginInfo = decodeArc4<DAOPluginInfo>(this.plugins(key).value.bytes)
    frame_dig 9
    box_get
    assert // Box must have value
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 7
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 5
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    dig 2
    cover 2
    substring3
    frame_bury 0
    dup
    intc 8 // 216
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 8
    dup
    pushint 28 // 28
    extract_uint64
    frame_bury 6
    intc 11 // 352
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/dao/contract.algo.ts:415
    // if (pluginInfo.useExecutionKey) {
    bz pluginCheck_after_if_else@4
    // smart_contracts/dao/constants.ts:32
    // export const AkitaDAOBoxPrefixExecutions = 'x'
    pushbytes "x"
    // smart_contracts/dao/contract.algo.ts:416
    // assert(this.executions(Global.groupId).exists)
    global GroupID
    // smart_contracts/dao/constants.ts:32
    // export const AkitaDAOBoxPrefixExecutions = 'x'
    concat
    // smart_contracts/dao/contract.algo.ts:416
    // assert(this.executions(Global.groupId).exists)
    box_len
    bury 1
    assert

pluginCheck_after_if_else@4:
    // smart_contracts/dao/contract.algo.ts:419
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 8
    bz pluginCheck_ternary_false@6
    global Round

pluginCheck_ternary_merge@7:
    // smart_contracts/dao/contract.algo.ts:421
    // const expired = epochRef > pluginInfo.lastValid;
    dup
    frame_dig 7
    >
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:422
    // const hasCooldown = pluginInfo.cooldown > 0;
    frame_dig 5
    dup
    cover 2
    intc_0 // 0
    >
    frame_bury 2
    // smart_contracts/dao/contract.algo.ts:423
    // const onCooldown = (epochRef - pluginInfo.lastCalled) < pluginInfo.cooldown;
    frame_dig 6
    -
    >
    frame_bury 4
    // smart_contracts/dao/contract.algo.ts:424
    // const hasMethodRestrictions = pluginInfo.methods.length > 0;
    frame_dig 0
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    frame_bury 3
    // smart_contracts/dao/contract.algo.ts:426
    // const valid = exists && !expired && !onCooldown;
    frame_dig 10
    bz pluginCheck_bool_false@11
    frame_dig 1
    bnz pluginCheck_bool_false@11
    frame_dig 4
    bnz pluginCheck_bool_false@11
    intc_1 // 1

pluginCheck_bool_merge@12:
    // smart_contracts/dao/contract.algo.ts:428-435
    // return {
    //   exists,
    //   expired,
    //   hasCooldown,
    //   onCooldown,
    //   hasMethodRestrictions,
    //   valid
    // }
    frame_dig 10
    frame_dig 1
    frame_dig 2
    frame_dig 4
    frame_dig 3
    uncover 5
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_bool_false@11:
    intc_0 // 0
    b pluginCheck_bool_merge@12

pluginCheck_ternary_false@6:
    // smart_contracts/dao/contract.algo.ts:419
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCheck_ternary_merge@7


// smart_contracts/dao/contract.algo.ts::AkitaDAO.create(escrowFactoryApp: uint64) -> void:
create:
    // smart_contracts/dao/contract.algo.ts:1216-1217
    // @abimethod({ onCreate: 'require' })
    // create(escrowFactoryApp: uint64): void {
    proto 1 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 11 // "version"
    // smart_contracts/dao/contract.algo.ts:1218
    // this.version.value = ''
    bytec_1 // ""
    app_global_put
    // smart_contracts/arc58/account/constants.ts:12
    // export const AbstractAccountGlobalStateKeysEscrowFactory = 'escrow_factory'
    bytec 30 // "escrow_factory"
    // smart_contracts/dao/contract.algo.ts:1219
    // this.escrowFactory.value = Application(escrowFactoryApp)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.update(proposalID: uint64) -> void:
update:
    // smart_contracts/dao/contract.algo.ts:1222-1223
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(proposalID: uint64): void {
    proto 1 0
    // smart_contracts/dao/contract.algo.ts:1224
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    frame_dig -1
    itob
    // smart_contracts/dao/constants.ts:31
    // export const AkitaDAOBoxPrefixProposals = 'l'
    bytec 15 // "l"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1224
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/dao/contract.algo.ts:1225
    // const { status, action, data } = this.proposals(proposalID).value
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    dig 2
    pushint 86 // 86
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    // smart_contracts/dao/contract.algo.ts:1226
    // assert(status === ProposalStatusApproved, ERR_PROPOSAL_NOT_APPROVED)
    uncover 2
    // smart_contracts/dao/constants.ts:61
    // export const ProposalStatusApproved = new UintN8(40)
    bytec 16 // 0x28
    // smart_contracts/dao/contract.algo.ts:1226
    // assert(status === ProposalStatusApproved, ERR_PROPOSAL_NOT_APPROVED)
    ==
    assert // Proposal is not approved
    // smart_contracts/dao/contract.algo.ts:1227
    // assert(action === ProposalActionUpgradeApp, ERR_PROPOSAL_NOT_UPGRADE_APP)
    swap
    // smart_contracts/dao/constants.ts:63
    // export const ProposalActionUpgradeApp = new UintN8(0)
    bytec_0 // 0x00
    // smart_contracts/dao/contract.algo.ts:1227
    // assert(action === ProposalActionUpgradeApp, ERR_PROPOSAL_NOT_UPGRADE_APP)
    ==
    assert // Proposal is not an upgrade app
    // smart_contracts/dao/contract.algo.ts:1229
    // const { app, executionKey } = decodeArc4<ProposalUpgradeApp>(data)
    dup
    pushint 2 // 2
    extract_uint64
    swap
    extract 10 32
    // smart_contracts/dao/contract.algo.ts:1230
    // assert(app === Global.currentApplicationId.id, ERR_PROPOSAL_NOT_UPGRADE_APP)
    global CurrentApplicationID
    uncover 2
    ==
    assert // Proposal is not an upgrade app
    // smart_contracts/dao/contract.algo.ts:1231
    // assert(Global.groupId === executionKey, ERR_EXECUTION_KEY_MISMATCH)
    global GroupID
    ==
    assert // Execution key mismatch
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.init(version: bytes, akta: uint64, contentPolicy: bytes, minRewardsImpact: uint64, fees.postFee: uint64, fees.reactFee: uint64, fees.impactTaxMin: uint64, fees.impactTaxMax: uint64, fees.poolCreationFee: uint64, fees.poolImpactTaxMin: uint64, fees.poolImpactTaxMax: uint64, fees.subscriptionServiceCreationFee: uint64, fees.subscriptionPaymentPercentage: uint64, fees.subscriptionTriggerPercentage: uint64, fees.marketplaceSalePercentageMin: uint64, fees.marketplaceSalePercentageMax: uint64, fees.marketplaceComposablePercentage: uint64, fees.marketplaceRoyaltyDefaultPercentage: uint64, fees.shuffleSalePercentage: uint64, fees.omnigemSaleFee: uint64, fees.auctionCreationFee: uint64, fees.auctionSaleImpactTaxMin: uint64, fees.auctionSaleImpactTaxMax: uint64, fees.auctionComposablePercentage: uint64, fees.auctionRafflePercentage: uint64, fees.raffleCreationFee: uint64, fees.raffleSaleImpactTaxMin: uint64, fees.raffleSaleImpactTaxMax: uint64, fees.raffleComposablePercentage: uint64, fees.swapFeeImpactTaxMin: uint64, fees.swapFeeImpactTaxMax: uint64, fees.swapComposablePercentage: uint64, fees.swapLiquidityPercentage: uint64, fees.krbyPercentage: uint64, fees.moderatorPercentage: uint64, proposalSettings.creation.upgradeApp: uint64, proposalSettings.creation.addPlugin: uint64, proposalSettings.creation.removePlugin: uint64, proposalSettings.creation.addAllowance: uint64, proposalSettings.creation.removeAllowance: uint64, proposalSettings.creation.updateField: uint64, proposalSettings.participation.upgradeApp: uint64, proposalSettings.participation.addPlugin: uint64, proposalSettings.participation.removePlugin: uint64, proposalSettings.participation.addAllowance: uint64, proposalSettings.participation.removeAllowance: uint64, proposalSettings.participation.updateField: uint64, proposalSettings.approval.upgradeApp: uint64, proposalSettings.approval.addPlugin: uint64, proposalSettings.approval.removePlugin: uint64, proposalSettings.approval.addAllowance: uint64, proposalSettings.approval.removeAllowance: uint64, proposalSettings.approval.updateField: uint64, proposalSettings.duration.upgradeApp: uint64, proposalSettings.duration.addPlugin: uint64, proposalSettings.duration.removePlugin: uint64, proposalSettings.duration.addAllowance: uint64, proposalSettings.duration.removeAllowance: uint64, proposalSettings.duration.updateField: uint64, revocationAddress: bytes) -> void:
init:
    // smart_contracts/dao/contract.algo.ts:1234-1247
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   fees: Fees,
    //   proposalSettings: {
    //     creation: ProposalSettings,
    //     participation: ProposalSettings,
    //     approval: ProposalSettings,
    //     duration: ProposalSettings,
    //   },
    //   revocationAddress: Address
    // ): void {
    proto 60 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    intc_0 // 0
    bytec 11 // "version"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1248
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    bytec_1 // ""
    ==
    assert // Already initialized
    // smart_contracts/dao/contract.algo.ts:1249
    // assert(version !== '', ERR_VERSION_CANNOT_BE_EMPTY)
    frame_dig -60
    bytec_1 // ""
    !=
    assert // Version cannot be empty
    // smart_contracts/dao/contract.algo.ts:1251-1264
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:1257
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:1258
    // reserve: Global.currentApplicationAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:1259
    // freeze: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/dao/contract.algo.ts:1260
    // clawback: Global.zeroAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:1262
    // url: Bytes('https://akita.community'),
    pushbytes "https://akita.community"
    itxn_field ConfigAssetURL
    // smart_contracts/dao/contract.algo.ts:1261
    // defaultFrozen: false,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/dao/contract.algo.ts:1256
    // decimals: 6,
    pushint 6 // 6
    itxn_field ConfigAssetDecimals
    // smart_contracts/dao/contract.algo.ts:1255
    // total: 1_000_000_000_000_000, // 1 billion
    pushint 1000000000000000 // 1000000000000000
    itxn_field ConfigAssetTotal
    // smart_contracts/dao/contract.algo.ts:1254
    // unitName: Bytes('BONES'),
    pushbytes "BONES"
    itxn_field ConfigAssetUnitName
    // smart_contracts/dao/contract.algo.ts:1253
    // assetName: Bytes('Bones'),
    pushbytes "Bones"
    itxn_field ConfigAssetName
    // smart_contracts/dao/contract.algo.ts:1251-1263
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1251-1264
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/dao/constants.ts:4
    // export const AkitaDAOGlobalStateKeysStatus = 'status'
    bytec 31 // "status"
    // smart_contracts/dao/constants.ts:46
    // export const DAOStatusInit: uint64 = 0
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:1266
    // this.status.value = DAOStatusInit
    app_global_put
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 11 // "version"
    // smart_contracts/dao/contract.algo.ts:1267
    // this.version.value = version
    frame_dig -60
    app_global_put
    // smart_contracts/dao/constants.ts:5
    // export const AkitaDAOGlobalStateKeysContentPolicy = 'content_policy'
    bytec 17 // "content_policy"
    // smart_contracts/dao/contract.algo.ts:1268
    // this.contentPolicy.value = contentPolicy
    frame_dig -58
    app_global_put
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysMinRewardsImpact = 'min_rewards_impact'
    bytec 18 // "min_rewards_impact"
    // smart_contracts/dao/contract.algo.ts:1269
    // this.minRewardsImpact.value = minRewardsImpact
    frame_dig -57
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1239
    // fees: Fees,
    frame_dig -56
    itob
    frame_dig -55
    itob
    frame_dig -54
    itob
    frame_dig -53
    itob
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 19 // "social_fees"
    // smart_contracts/dao/contract.algo.ts:1271-1276
    // this.socialFees.value = {
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1239
    // fees: Fees,
    frame_dig -52
    itob
    frame_dig -51
    itob
    frame_dig -50
    itob
    // smart_contracts/dao/constants.ts:11
    // export const AkitaDAOGlobalStateKeysStakingFees = 'staking_fees'
    cover 2
    concat
    swap
    concat
    bytec 20 // "staking_fees"
    // smart_contracts/dao/contract.algo.ts:1278-1282
    // this.stakingFees.value = {
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // }
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1239
    // fees: Fees,
    frame_dig -49
    itob
    frame_dig -48
    itob
    frame_dig -47
    itob
    // smart_contracts/dao/constants.ts:12
    // export const AkitaDAOGlobalStateKeysSubscriptionFees = 'subscription_fees'
    cover 2
    concat
    swap
    concat
    bytec 21 // "subscription_fees"
    // smart_contracts/dao/contract.algo.ts:1284-1288
    // this.subscriptionFees.value = {
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // }
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1239
    // fees: Fees,
    frame_dig -46
    itob
    frame_dig -45
    itob
    frame_dig -44
    itob
    frame_dig -43
    itob
    frame_dig -42
    itob
    frame_dig -41
    itob
    frame_dig -40
    itob
    frame_dig -39
    itob
    frame_dig -38
    itob
    frame_dig -37
    itob
    frame_dig -36
    itob
    frame_dig -35
    itob
    frame_dig -34
    itob
    frame_dig -33
    itob
    frame_dig -32
    itob
    // smart_contracts/dao/constants.ts:14
    // export const AkitaDAOGlobalStateKeysNFTFees = 'nft_fees'
    uncover 14
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 22 // "nft_fees"
    // smart_contracts/dao/contract.algo.ts:1290-1306
    // this.nftFees.value = {
    //   marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    //   marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   shuffleSalePercentage: fees.shuffleSalePercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // }
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1239
    // fees: Fees,
    frame_dig -31
    itob
    frame_dig -30
    itob
    // smart_contracts/dao/constants.ts:13
    // export const AkitaDAOGlobalStateKeysSwapFees = 'swap_fees'
    concat
    bytec 32 // "swap_fees"
    // smart_contracts/dao/contract.algo.ts:1308-1311
    // this.swapFees.value = {
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    bytec 7 // "krby_percentage"
    // smart_contracts/dao/contract.algo.ts:1313
    // this.krbyPercentage.value = fees.krbyPercentage
    frame_dig -27
    app_global_put
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    bytec 8 // "mod_percentage"
    // smart_contracts/dao/contract.algo.ts:1314
    // this.moderatorPercentage.value = fees.moderatorPercentage
    frame_dig -26
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1240-1245
    // proposalSettings: {
    //   creation: ProposalSettings,
    //   participation: ProposalSettings,
    //   approval: ProposalSettings,
    //   duration: ProposalSettings,
    // },
    frame_dig -25
    itob
    frame_dig -24
    itob
    frame_dig -23
    itob
    frame_dig -22
    itob
    frame_dig -21
    itob
    frame_dig -20
    itob
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_3 // "proposal_creation_settings"
    // smart_contracts/dao/contract.algo.ts:1316
    // this.proposalCreationSettings.value = proposalSettings.creation
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1240-1245
    // proposalSettings: {
    //   creation: ProposalSettings,
    //   participation: ProposalSettings,
    //   approval: ProposalSettings,
    //   duration: ProposalSettings,
    // },
    frame_dig -19
    itob
    frame_dig -18
    itob
    frame_dig -17
    itob
    frame_dig -16
    itob
    frame_dig -15
    itob
    frame_dig -14
    itob
    // smart_contracts/dao/constants.ts:23
    // export const AkitaDAOGlobalStateKeysProposalParticipationSettings = 'proposal_participation_settings'
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 33 // "proposal_participation_settings"
    // smart_contracts/dao/contract.algo.ts:1317
    // this.proposalParticipationSettings.value = proposalSettings.participation
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1240-1245
    // proposalSettings: {
    //   creation: ProposalSettings,
    //   participation: ProposalSettings,
    //   approval: ProposalSettings,
    //   duration: ProposalSettings,
    // },
    frame_dig -13
    itob
    frame_dig -12
    itob
    frame_dig -11
    itob
    frame_dig -10
    itob
    frame_dig -9
    itob
    frame_dig -8
    itob
    // smart_contracts/dao/constants.ts:24
    // export const AkitaDAOGlobalStateKeysProposalApprovalThresholdSettings = 'proposal_approval_threshold_settings'
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 34 // "proposal_approval_threshold_settings"
    // smart_contracts/dao/contract.algo.ts:1318
    // this.proposalApprovalThresholdSettings.value = proposalSettings.approval
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1240-1245
    // proposalSettings: {
    //   creation: ProposalSettings,
    //   participation: ProposalSettings,
    //   approval: ProposalSettings,
    //   duration: ProposalSettings,
    // },
    frame_dig -7
    itob
    frame_dig -6
    itob
    frame_dig -5
    itob
    frame_dig -4
    itob
    frame_dig -3
    itob
    frame_dig -2
    itob
    // smart_contracts/dao/constants.ts:25
    // export const AkitaDAOGlobalStateKeysProposalVotingDurationSettings = 'proposal_voting_duration_settings'
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 35 // "proposal_voting_duration_settings"
    // smart_contracts/dao/contract.algo.ts:1319
    // this.proposalVotingDurationSettings.value = proposalSettings.duration
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1322
    // this.akitaAssets.value = { akta, bones }
    frame_dig -59
    itob
    swap
    itob
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    concat
    bytec 12 // "akita_assets"
    // smart_contracts/dao/contract.algo.ts:1322
    // this.akitaAssets.value = { akta, bones }
    swap
    app_global_put
    // smart_contracts/dao/constants.ts:27
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    bytec 13 // "revocation_address"
    // smart_contracts/dao/contract.algo.ts:1324
    // this.revocationAddress.value = revocationAddress.native
    frame_dig -1
    app_global_put
    // smart_contracts/dao/constants.ts:28
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    bytec 23 // "proposal_id"
    // smart_contracts/dao/contract.algo.ts:1325
    // this.proposalID.value = 0
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:
    // smart_contracts/dao/contract.algo.ts:1333
    // arc58_verifyAuthAddr(): void {
    proto 0 0
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 5 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1334
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    dup
    acct_params_get AcctAuthAddr
    swap
    cover 2
    assert // account funded
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:690
    // this.spendingAddress.value === this.controlledAddress.value
    ==
    // smart_contracts/dao/contract.algo.ts:690-691
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddr_ternary_false@4
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:691
    // && this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // smart_contracts/dao/contract.algo.ts:690-691
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddr_ternary_false@4
    // smart_contracts/dao/contract.algo.ts:692
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global ZeroAddress

arc58_verifyAuthAddr_ternary_merge@5:
    // smart_contracts/dao/contract.algo.ts:1334
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    frame_dig 0
    ==
    assert
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 5 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1335
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    app_global_put
    retsub

arc58_verifyAuthAddr_ternary_false@4:
    // smart_contracts/dao/contract.algo.ts:692
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global CurrentApplicationAddress
    b arc58_verifyAuthAddr_ternary_merge@5


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_canCall(plugin: uint64, global: uint64, address: bytes, method: bytes) -> uint64:
arc58_canCall:
    // smart_contracts/dao/contract.algo.ts:1345-1351
    // @abimethod({ readonly: true })
    // arc58_canCall(
    //   plugin: uint64,
    //   global: boolean,
    //   address: Address,
    //   method: bytes<4>
    // ): boolean {
    proto 4 1
    // smart_contracts/dao/contract.algo.ts:1352
    // if (global) {
    frame_dig -3
    bz arc58_canCall_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:1353
    // this.pluginCallAllowed(plugin, Global.zeroAddress, method);
    frame_dig -4
    global ZeroAddress
    frame_dig -1
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:1355
    // return this.pluginCallAllowed(plugin, address.native, method);
    frame_dig -4
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_rekeyToPlugin(plugin: uint64, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToPlugin:
    // smart_contracts/dao/contract.algo.ts:1367-1372
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    proto 4 0
    intc_0 // 0
    dupn 6
    bytec_1 // ""
    dupn 22
    // smart_contracts/dao/contract.algo.ts:1374
    // const caller = global ? Global.zeroAddress : Txn.sender
    frame_dig -3
    bz arc58_rekeyToPlugin_ternary_false@2
    global ZeroAddress
    frame_bury 3

arc58_rekeyToPlugin_ternary_merge@3:
    // smart_contracts/dao/contract.algo.ts:1375
    // const key = { application: plugin, allowedCaller: caller }
    frame_dig -4
    itob
    // smart_contracts/dao/contract.algo.ts:1377
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    frame_dig 3
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:1377
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/dao/contract.algo.ts:482
    // const epochRef = this.plugins(key).value.useRounds.native
    box_get
    assert // Box must have value
    intc 8 // 216
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/dao/contract.algo.ts:482-484
    // const epochRef = this.plugins(key).value.useRounds.native
    //   ? Global.round
    //   : Global.latestTimestamp;
    bz arc58_rekeyToPlugin_ternary_false@32
    // smart_contracts/dao/contract.algo.ts:483
    // ? Global.round
    global Round
    frame_bury 11

arc58_rekeyToPlugin_ternary_merge@33:
    // smart_contracts/dao/contract.algo.ts:486
    // const initialCheck = this.pluginCheck(key);
    frame_dig -4
    frame_dig 3
    callsub pluginCheck
    popn 2
    cover 3
    frame_bury 14
    swap
    // smart_contracts/dao/contract.algo.ts:488
    // assert(initialCheck.exists, ERR_PLUGIN_DOES_NOT_EXIST);
    assert // Plugin does not exist
    // smart_contracts/dao/contract.algo.ts:489
    // assert(!initialCheck.expired, ERR_PLUGIN_EXPIRED);
    !
    assert // Plugin has expired
    // smart_contracts/dao/contract.algo.ts:490
    // assert(!initialCheck.onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    !
    assert // Plugin is on cooldown
    // smart_contracts/dao/contract.algo.ts:492
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 25
    // smart_contracts/dao/contract.algo.ts:493
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 21
    // smart_contracts/dao/contract.algo.ts:495
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 13

arc58_rekeyToPlugin_while_top@34:
    // smart_contracts/dao/contract.algo.ts:495
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 13
    global GroupSize
    <
    bz arc58_rekeyToPlugin_block@77
    // smart_contracts/dao/contract.algo.ts:384
    // txn.sender === this.controlledAddress.value &&
    frame_dig 13
    gtxns Sender
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:384
    // txn.sender === this.controlledAddress.value &&
    ==
    // smart_contracts/dao/contract.algo.ts:384-385
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz arc58_rekeyToPlugin_after_if_else@38
    // smart_contracts/dao/contract.algo.ts:385
    // txn.rekeyTo === Global.currentApplicationAddress
    frame_dig 13
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    // smart_contracts/dao/contract.algo.ts:384-385
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz arc58_rekeyToPlugin_after_if_else@38
    // smart_contracts/dao/contract.algo.ts:387
    // return true;
    intc_1 // 1

arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.txnRekeysBack@46:
    // smart_contracts/dao/contract.algo.ts:498
    // if (this.txnRekeysBack(txn)) {
    bz arc58_rekeyToPlugin_after_if_else@48
    // smart_contracts/dao/contract.algo.ts:499
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 25

arc58_rekeyToPlugin_block@77:
    // smart_contracts/dao/contract.algo.ts:526
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 25
    assert // missing rekey back
    // smart_contracts/dao/contract.algo.ts:1381
    // if (this.plugins(key).value.escrow.native !== 0) {
    frame_dig 1
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    bz arc58_rekeyToPlugin_else_body@5
    // smart_contracts/dao/contract.algo.ts:1382
    // const spendingApp = Application(this.plugins(key).value.escrow.native)
    frame_dig 1
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1383
    // this.spendingAddress.value = spendingApp.address;
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 5 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1383
    // this.spendingAddress.value = spendingApp.address;
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:582
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0
    frame_bury 13

arc58_rekeyToPlugin_while_top@9:
    // smart_contracts/dao/contract.algo.ts:582
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 13
    >
    bz arc58_rekeyToPlugin_after_if_else@6
    // smart_contracts/dao/contract.algo.ts:583
    // const pluginInfo = decodeArc4<PluginInfo>(this.plugins(key).value.bytes)
    frame_dig 1
    box_get
    assert // Box must have value
    pushint 2 // 2
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:587
    // asset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    frame_dig 13
    intc_3 // 16
    *
    intc_3 // 16
    extract3 // on error: Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    frame_bury 7
    // smart_contracts/dao/contract.algo.ts:590
    // this.verifyAllowance(allowanceKey, fundsRequests[i]);
    intc_2 // 8
    extract_uint64
    frame_bury 12
    // smart_contracts/dao/contract.algo.ts:616
    // key: AllowanceKey,
    swap
    itob
    swap
    itob
    // smart_contracts/dao/contract.algo.ts:619
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    concat
    // smart_contracts/arc58/account/constants.ts:18
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    pushbytes "a"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/dao/contract.algo.ts:619
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/dao/contract.algo.ts:620
    // const { type, spent, allowed, last, max, interval, start, useRounds } = this.allowances(key).value
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    frame_bury 6
    dup
    intc_1 // 1
    extract_uint64
    frame_bury 20
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 8
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 26
    dup
    pushint 25 // 25
    extract_uint64
    frame_bury 15
    dup
    pushint 33 // 33
    extract_uint64
    frame_bury 17
    dup
    pushint 41 // 41
    extract_uint64
    frame_bury 27
    intc 9 // 392
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dup
    frame_bury 29
    // smart_contracts/dao/contract.algo.ts:621
    // const newLast = useRounds ? Global.round : Global.latestTimestamp
    bz arc58_rekeyToPlugin_ternary_false@12
    global Round
    frame_bury 22

arc58_rekeyToPlugin_ternary_merge@13:
    // smart_contracts/dao/contract.algo.ts:623
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 6
    // smart_contracts/arc58/account/types.ts:13
    // export const SpendAllowanceTypeFlat: SpendAllowanceType = new UintN8(1)
    bytec 24 // 0x01
    // smart_contracts/dao/contract.algo.ts:623
    // if (type === SpendAllowanceTypeFlat) {
    ==
    bz arc58_rekeyToPlugin_else_body@15
    // smart_contracts/dao/contract.algo.ts:624
    // const leftover: uint64 = allowed - spent;
    frame_dig 8
    frame_dig 26
    dup
    cover 2
    -
    // smart_contracts/dao/contract.algo.ts:626
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 12
    dup
    cover 2
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:630
    // spent: (spent + fundRequest.amount)
    +
    // smart_contracts/dao/contract.algo.ts:629
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    intc 9 // 392
    getbit
    dig 2
    intc_1 // 1
    extract_uint64
    dig 3
    pushint 9 // 9
    extract_uint64
    dig 4
    pushint 25 // 25
    extract_uint64
    dig 5
    pushint 33 // 33
    extract_uint64
    uncover 6
    pushint 41 // 41
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 7
    setbit
    intc_0 // 0
    getbit
    uncover 5
    itob
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:630
    // spent: (spent + fundRequest.amount)
    uncover 7
    itob
    // smart_contracts/dao/contract.algo.ts:629
    // ...this.allowances(key).value,
    uncover 6
    itob
    uncover 6
    itob
    uncover 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:628
    // this.allowances(key).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:628-631
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount)
    // }
    box_put

arc58_rekeyToPlugin_after_if_else@24:
    // smart_contracts/dao/contract.algo.ts:592
    // if (fundsRequests[i].asset !== 0) {
    frame_dig 7
    bz arc58_rekeyToPlugin_else_body@26
    // smart_contracts/dao/contract.algo.ts:593-601
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset,
    //     fee,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 5 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 7
    itxn_field XferAsset
    frame_dig 12
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:593-600
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:593-601
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset,
    //     fee,
    //   })
    //   .submit();
    itxn_submit

arc58_rekeyToPlugin_after_if_else@27:
    // smart_contracts/dao/contract.algo.ts:582
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 13
    b arc58_rekeyToPlugin_while_top@9

arc58_rekeyToPlugin_else_body@26:
    // smart_contracts/dao/contract.algo.ts:603-610
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount,
    //     fee,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 5 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 12
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:603-609
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:603-610
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount,
    //     fee,
    //   })
    //   .submit();
    itxn_submit
    b arc58_rekeyToPlugin_after_if_else@27

arc58_rekeyToPlugin_else_body@15:
    // smart_contracts/dao/contract.algo.ts:632
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 6
    // smart_contracts/arc58/account/types.ts:14
    // export const SpendAllowanceTypeWindow: SpendAllowanceType = new UintN8(2)
    bytec 25 // 0x02
    // smart_contracts/dao/contract.algo.ts:632
    // } else if (type === SpendAllowanceTypeWindow) {
    ==
    bz arc58_rekeyToPlugin_else_body@19
    // smart_contracts/dao/contract.algo.ts:678
    // if (useRounds) {
    frame_dig 29
    bz arc58_rekeyToPlugin_after_if_else@80
    // smart_contracts/dao/contract.algo.ts:679
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig 27
    -
    frame_dig 15
    %
    -

arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.getLatestWindowStart@81:
    // smart_contracts/dao/contract.algo.ts:635
    // if (currentWindowStart > last) {
    frame_dig 17
    >
    bz arc58_rekeyToPlugin_else_body@18
    // smart_contracts/dao/contract.algo.ts:636
    // assert(allowed >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 8
    frame_dig 12
    dup
    cover 2
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:639
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    intc 9 // 392
    getbit
    dig 2
    intc_1 // 1
    extract_uint64
    dig 3
    pushint 9 // 9
    extract_uint64
    dig 4
    pushint 25 // 25
    extract_uint64
    uncover 5
    pushint 41 // 41
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    uncover 4
    itob
    uncover 4
    itob
    // smart_contracts/dao/contract.algo.ts:617
    // fundRequest: FundsRequest
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:639
    // ...this.allowances(key).value,
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:641
    // last: newLast
    frame_dig 22
    itob
    // smart_contracts/dao/contract.algo.ts:639
    // ...this.allowances(key).value,
    uncover 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:638
    // this.allowances(key).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:638-642
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: fundRequest.amount,
    //   last: newLast
    // }
    box_put
    b arc58_rekeyToPlugin_after_if_else@24

arc58_rekeyToPlugin_else_body@18:
    // smart_contracts/dao/contract.algo.ts:645
    // const leftover: uint64 = allowed - spent;
    frame_dig 8
    frame_dig 26
    dup
    cover 2
    -
    // smart_contracts/dao/contract.algo.ts:646
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 12
    dup
    cover 2
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:650
    // spent: (spent + fundRequest.amount),
    +
    // smart_contracts/dao/contract.algo.ts:649
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    intc 9 // 392
    getbit
    dig 2
    intc_1 // 1
    extract_uint64
    dig 3
    pushint 9 // 9
    extract_uint64
    dig 4
    pushint 25 // 25
    extract_uint64
    uncover 5
    pushint 41 // 41
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    uncover 4
    itob
    uncover 4
    itob
    // smart_contracts/dao/contract.algo.ts:650
    // spent: (spent + fundRequest.amount),
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:649
    // ...this.allowances(key).value,
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:651
    // last: newLast
    frame_dig 22
    itob
    // smart_contracts/dao/contract.algo.ts:649
    // ...this.allowances(key).value,
    uncover 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:648
    // this.allowances(key).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:648-652
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount),
    //   last: newLast
    // }
    box_put
    b arc58_rekeyToPlugin_after_if_else@24

arc58_rekeyToPlugin_after_if_else@80:
    // smart_contracts/dao/contract.algo.ts:681
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig 27
    -
    frame_dig 15
    %
    -
    // smart_contracts/dao/contract.algo.ts:633
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.getLatestWindowStart@81

arc58_rekeyToPlugin_else_body@19:
    // smart_contracts/dao/contract.algo.ts:655
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 6
    // smart_contracts/arc58/account/types.ts:15
    // export const SpendAllowanceTypeDrip: SpendAllowanceType = new UintN8(3)
    bytec 14 // 0x03
    // smart_contracts/dao/contract.algo.ts:655
    // } else if (type === SpendAllowanceTypeDrip) {
    ==
    bz arc58_rekeyToPlugin_after_if_else@24
    // smart_contracts/dao/contract.algo.ts:656
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 29
    bz arc58_rekeyToPlugin_ternary_false@22
    global Round
    frame_bury 11

arc58_rekeyToPlugin_ternary_merge@23:
    // smart_contracts/dao/contract.algo.ts:662
    // const passed: uint64 = epochRef - last
    frame_dig 11
    frame_dig 17
    -
    // smart_contracts/dao/contract.algo.ts:663
    // const accrued: uint64 = lastLeftover + ((passed / interval) * accrualRate)
    frame_dig 15
    /
    frame_dig 8
    *
    frame_dig 26
    +
    // smart_contracts/dao/contract.algo.ts:665
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 20
    dup
    cover 3
    >
    swap
    cover 2
    select
    // smart_contracts/dao/contract.algo.ts:667
    // assert(available >= amount, ERR_ALLOWANCE_EXCEEDED);
    dup
    frame_dig 12
    dup
    cover 3
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:671
    // spent: (available - amount),
    swap
    -
    // smart_contracts/dao/contract.algo.ts:670
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    intc 9 // 392
    getbit
    dig 2
    intc_1 // 1
    extract_uint64
    dig 3
    pushint 9 // 9
    extract_uint64
    dig 4
    pushint 25 // 25
    extract_uint64
    uncover 5
    pushint 41 // 41
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    uncover 4
    itob
    uncover 4
    itob
    // smart_contracts/dao/contract.algo.ts:671
    // spent: (available - amount),
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:670
    // ...this.allowances(key).value,
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:672
    // last: newLast
    frame_dig 22
    itob
    // smart_contracts/dao/contract.algo.ts:670
    // ...this.allowances(key).value,
    uncover 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:669
    // this.allowances(key).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:669-673
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (available - amount),
    //   last: newLast
    // }
    box_put
    b arc58_rekeyToPlugin_after_if_else@24

arc58_rekeyToPlugin_ternary_false@22:
    // smart_contracts/dao/contract.algo.ts:656
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 11
    b arc58_rekeyToPlugin_ternary_merge@23

arc58_rekeyToPlugin_ternary_false@12:
    // smart_contracts/dao/contract.algo.ts:621
    // const newLast = useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    frame_bury 22
    b arc58_rekeyToPlugin_ternary_merge@13

arc58_rekeyToPlugin_after_if_else@6:
    // smart_contracts/dao/contract.algo.ts:1389-1397
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    intc_0 // 0
    bytec 5 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1393
    // rekeyTo: pluginApp.address,
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:1394
    // note: 'rekeying to plugin app',
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1389-1396
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1389-1397
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app',
    //     fee,
    //   })
    //   .submit();
    itxn_submit
    retsub

arc58_rekeyToPlugin_else_body@5:
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/constants.ts:11
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec 5 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1386
    // this.spendingAddress.value = this.controlledAddress.value;
    swap
    app_global_put
    b arc58_rekeyToPlugin_after_if_else@6

arc58_rekeyToPlugin_after_if_else@48:
    // smart_contracts/dao/contract.algo.ts:503
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 13
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bnz arc58_rekeyToPlugin_block@75
    // smart_contracts/dao/contract.algo.ts:507
    // assert(txn.appId.id === key.application, ERR_CANNOT_CALL_OTHER_APPS_DURING_REKEY);
    frame_dig 13
    dup
    gtxns ApplicationID
    frame_dig -4
    ==
    assert // cannot call other apps during rekey
    // smart_contracts/dao/contract.algo.ts:508
    // assert(txn.onCompletion === OnCompleteAction.NoOp, ERR_INVALID_ONCOMPLETE);
    dup
    gtxns OnCompletion
    !
    assert // invalid oncomplete must be no op
    // smart_contracts/dao/contract.algo.ts:511
    // assert(txn.numAppArgs > 1, ERR_INVALID_SENDER_ARG);
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // invalid sender must be this app id
    // smart_contracts/dao/contract.algo.ts:512
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, ERR_INVALID_SENDER_VALUE);
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // invalid sender app id
    // smart_contracts/dao/contract.algo.ts:445
    // const check = this.pluginCheck(key);
    frame_dig -4
    frame_dig 3
    callsub pluginCheck
    dup
    cover 6
    frame_bury 10
    frame_bury 9
    popn 4
    // smart_contracts/dao/contract.algo.ts:447
    // if (!check.valid) {
    bnz arc58_rekeyToPlugin_after_if_else@52
    // smart_contracts/dao/contract.algo.ts:452
    // methodOnCooldown: true
    intc_1 // 1

arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.fullPluginCheck@72:
    // smart_contracts/dao/contract.algo.ts:516
    // assert(!check.methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    !
    assert // method on cooldown
    // smart_contracts/dao/contract.algo.ts:517
    // assert(check.valid, ERR_INVALID_PLUGIN_CALL);
    frame_dig 10
    assert // invalid plugin call
    // smart_contracts/dao/contract.algo.ts:519
    // if (initialCheck.hasCooldown) {
    frame_dig 14
    bz arc58_rekeyToPlugin_after_if_else@74
    // smart_contracts/dao/contract.algo.ts:520
    // this.plugins(key).value.lastCalled = new UintN64(epochRef)
    frame_dig 11
    itob
    frame_dig 1
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 28
    dig 1
    box_del
    pop
    box_put

arc58_rekeyToPlugin_after_if_else@74:
    // smart_contracts/dao/contract.algo.ts:523
    // methodIndex += 1;
    frame_dig 21
    intc_1 // 1
    +
    frame_bury 21

arc58_rekeyToPlugin_block@75:
    // smart_contracts/dao/contract.algo.ts:495
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 13
    intc_1 // 1
    +
    frame_bury 13
    b arc58_rekeyToPlugin_while_top@34

arc58_rekeyToPlugin_after_if_else@52:
    // smart_contracts/dao/contract.algo.ts:457
    // methodAllowed: !check.hasMethodRestrictions,
    frame_dig 9
    dup
    !
    frame_bury 18
    // smart_contracts/dao/contract.algo.ts:459
    // methodOnCooldown: false
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:456-460
    // let mCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 19
    // smart_contracts/dao/contract.algo.ts:462
    // if (check.hasMethodRestrictions) {
    bz arc58_rekeyToPlugin_after_if_else@67
    // smart_contracts/dao/contract.algo.ts:463
    // assert(methodIndex < methodOffsets.length, ERR_MALFORMED_OFFSETS);
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig 21
    dup
    uncover 2
    <
    assert // malformed method offsets
    // smart_contracts/dao/contract.algo.ts:464
    // mCheck = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    frame_dig -2
    extract 2 0
    swap
    intc_2 // 8
    *
    extract_uint64
    dup
    frame_bury 23
    // smart_contracts/dao/contract.algo.ts:539
    // assert(len(txn.appArgs(0)) === 4, ERR_INVALID_METHOD_SIGNATURE_LENGTH);
    frame_dig 13
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    frame_bury 5
    len
    pushint 4 // 4
    ==
    assert // Invalid method signature length
    // smart_contracts/dao/contract.algo.ts:542
    // const methods = this.plugins(key).value.methods.copy()
    frame_dig 1
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    dig 2
    cover 2
    substring3
    dup
    frame_bury 4
    // smart_contracts/dao/contract.algo.ts:543
    // const allowedMethod = methods[offset].copy()
    extract 2 0
    uncover 2
    pushint 20 // 20
    *
    dup
    frame_bury 16
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:545
    // const hasCooldown = allowedMethod.cooldown.native > 0
    pushint 4 // 4
    extract_uint64
    frame_bury 28
    // smart_contracts/dao/contract.algo.ts:547
    // const useRounds = this.plugins(key).value.useRounds.native
    intc 8 // 216
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dup
    frame_bury 29
    // smart_contracts/dao/contract.algo.ts:549
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    bz arc58_rekeyToPlugin_ternary_false@55
    global Round

arc58_rekeyToPlugin_ternary_merge@56:
    // smart_contracts/dao/contract.algo.ts:550
    // const onCooldown = (epochRef - allowedMethod.lastCalled.native) < allowedMethod.cooldown.native;
    frame_dig 0
    dup
    pushint 12 // 12
    extract_uint64
    uncover 2
    swap
    -
    frame_dig 28
    <
    frame_bury 24
    // smart_contracts/dao/contract.algo.ts:552
    // if (allowedMethod.selector.native === selectorArg && (!hasCooldown || !onCooldown)) {
    extract 0 4 // on error: Index access is out of bounds
    frame_dig 5
    ==
    bz arc58_rekeyToPlugin_after_if_else@65
    frame_dig 28
    bz arc58_rekeyToPlugin_if_body@59
    frame_dig 24
    bnz arc58_rekeyToPlugin_after_if_else@65

arc58_rekeyToPlugin_if_body@59:
    // smart_contracts/dao/contract.algo.ts:554
    // if (hasCooldown) {
    frame_dig 28
    bz arc58_rekeyToPlugin_after_if_else@64
    // smart_contracts/dao/contract.algo.ts:555-557
    // const lastCalled = useRounds
    //   ? Global.round
    //   : Global.latestTimestamp
    frame_dig 29
    bz arc58_rekeyToPlugin_ternary_false@62
    // smart_contracts/dao/contract.algo.ts:556
    // ? Global.round
    global Round

arc58_rekeyToPlugin_ternary_merge@63:
    // smart_contracts/dao/contract.algo.ts:559
    // methods[offset].lastCalled = new UintN64(lastCalled);
    itob
    frame_dig 0
    swap
    replace2 12
    frame_dig 4
    dup
    intc_0 // 0
    extract_uint16
    frame_dig 23
    >
    assert // Index access is out of bounds
    frame_dig 16
    pushint 2 // 2
    +
    uncover 2
    replace3
    // smart_contracts/dao/contract.algo.ts:562
    // ...this.plugins(key).value,
    frame_dig 1
    dup
    cover 2
    box_get
    assert // Box must have value
    // smart_contracts/dao/contract.algo.ts:561-564
    // this.plugins(key).value = new arc4DAOPluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    extract 1 8 // on error: Index access is out of bounds
    dig 2
    extract 9 8 // on error: Index access is out of bounds
    dig 3
    extract 17 8 // on error: Index access is out of bounds
    dig 4
    intc 8 // 216
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 5
    extract 28 8 // on error: Index access is out of bounds
    dig 6
    extract 36 8 // on error: Index access is out of bounds
    dig 7
    intc 11 // 352
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 8
    extract 45 8 // on error: Index access is out of bounds
    dig 9
    extract 53 8 // on error: Index access is out of bounds
    dig 10
    extract 61 8 // on error: Index access is out of bounds
    uncover 11
    extract 69 8 // on error: Index access is out of bounds
    uncover 11
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    pushbytes 0x004d
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put

arc58_rekeyToPlugin_after_if_else@64:
    // smart_contracts/dao/contract.algo.ts:568
    // methodAllowed: true,
    intc_1 // 1
    frame_dig 24
    frame_bury 19
    frame_bury 18

arc58_rekeyToPlugin_after_if_else@67:
    // smart_contracts/dao/contract.algo.ts:470
    // valid: check.valid && mCheck.methodAllowed
    frame_dig 10
    bz arc58_rekeyToPlugin_bool_false@70
    frame_dig 18
    bz arc58_rekeyToPlugin_bool_false@70
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@71:
    frame_bury 10
    frame_dig 19
    // smart_contracts/dao/contract.algo.ts:514
    // const check = this.fullPluginCheck(key, txn, methodOffsets, methodIndex);
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.fullPluginCheck@72

arc58_rekeyToPlugin_bool_false@70:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@71

arc58_rekeyToPlugin_ternary_false@62:
    // smart_contracts/dao/contract.algo.ts:557
    // : Global.latestTimestamp
    global LatestTimestamp
    b arc58_rekeyToPlugin_ternary_merge@63

arc58_rekeyToPlugin_after_if_else@65:
    // smart_contracts/dao/contract.algo.ts:575
    // methodAllowed: false,
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:577
    // methodOnCooldown: true
    intc_1 // 1
    frame_bury 19
    frame_bury 18
    // smart_contracts/dao/contract.algo.ts:464
    // mCheck = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    b arc58_rekeyToPlugin_after_if_else@67

arc58_rekeyToPlugin_ternary_false@55:
    // smart_contracts/dao/contract.algo.ts:549
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_rekeyToPlugin_ternary_merge@56

arc58_rekeyToPlugin_after_if_else@38:
    // smart_contracts/dao/contract.algo.ts:391
    // txn.type === TransactionType.ApplicationCall
    frame_dig 13
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // smart_contracts/dao/contract.algo.ts:391-392
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyToPlugin_bool_false@44
    // smart_contracts/dao/contract.algo.ts:392
    // && txn.appId === Global.currentApplicationId
    frame_dig 13
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/dao/contract.algo.ts:391-392
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz arc58_rekeyToPlugin_bool_false@44
    // smart_contracts/dao/contract.algo.ts:393
    // && txn.numAppArgs === 1
    frame_dig 13
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // smart_contracts/dao/contract.algo.ts:391-393
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz arc58_rekeyToPlugin_bool_false@44
    // smart_contracts/dao/contract.algo.ts:394
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig 13
    gtxns OnCompletion
    // smart_contracts/dao/contract.algo.ts:391-394
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bnz arc58_rekeyToPlugin_bool_false@44
    // smart_contracts/dao/contract.algo.ts:395
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    frame_dig 13
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 29 // method "arc58_verifyAuthAddr()void"
    ==
    // smart_contracts/dao/contract.algo.ts:391-395
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    bz arc58_rekeyToPlugin_bool_false@44
    intc_1 // 1
    // smart_contracts/dao/contract.algo.ts:498
    // if (this.txnRekeysBack(txn)) {
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.txnRekeysBack@46

arc58_rekeyToPlugin_bool_false@44:
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:498
    // if (this.txnRekeysBack(txn)) {
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.txnRekeysBack@46

arc58_rekeyToPlugin_ternary_false@32:
    // smart_contracts/dao/contract.algo.ts:484
    // : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 11
    b arc58_rekeyToPlugin_ternary_merge@33

arc58_rekeyToPlugin_ternary_false@2:
    // smart_contracts/dao/contract.algo.ts:1374
    // const caller = global ? Global.zeroAddress : Txn.sender
    txn Sender
    frame_bury 3
    b arc58_rekeyToPlugin_ternary_merge@3


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_rekeyToNamedPlugin(name: bytes, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/dao/contract.algo.ts:1410
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    proto 4 0
    // smart_contracts/arc58/account/constants.ts:16
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    pushbytes "n"
    frame_dig -4
    concat
    // smart_contracts/dao/contract.algo.ts:1412
    // this.namedPlugins(name).value.application,
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1411-1416
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.application,
    //   global,
    //   methodOffsets,
    //   fundsRequest
    // );
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub arc58_rekeyToPlugin
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.newProposal(payment: uint64, action: bytes, cid: bytes, data: bytes, status: bytes) -> void:
newProposal:
    // smart_contracts/dao/contract.algo.ts:1455-1461
    // newProposal(
    //   payment: gtxn.PaymentTxn,
    //   action: ProposalAction,
    //   cid: CID,
    //   data: bytes,
    //   status: ProposalStatus,
    // ): void {
    proto 5 0
    intc_0 // 0
    dup
    bytec_1 // ""
    dupn 6
    // smart_contracts/dao/contract.algo.ts:1462
    // assert(status === ProposalStatusDraft || status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATUS)
    frame_dig -1
    // smart_contracts/dao/constants.ts:57
    // export const ProposalStatusDraft = new UintN8(0)
    bytec_0 // 0x00
    // smart_contracts/dao/contract.algo.ts:1462
    // assert(status === ProposalStatusDraft || status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATUS)
    ==
    bnz newProposal_bool_true@2
    frame_dig -1
    // smart_contracts/dao/constants.ts:59
    // export const ProposalStatusVoting = new UintN8(20)
    bytec 9 // 0x14
    // smart_contracts/dao/contract.algo.ts:1462
    // assert(status === ProposalStatusDraft || status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATUS)
    ==
    bz newProposal_bool_false@3

newProposal_bool_true@2:
    intc_1 // 1

newProposal_bool_merge@4:
    // smart_contracts/dao/contract.algo.ts:1462
    // assert(status === ProposalStatusDraft || status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATUS)
    assert // Invalid proposal status
    // smart_contracts/dao/contract.algo.ts:1464-1470
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.proposalFee.value
    //   }
    // )
    frame_dig -5
    gtxns Receiver
    // smart_contracts/dao/contract.algo.ts:1467
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:1464-1470
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.proposalFee.value
    //   }
    // )
    ==
    bz newProposal_bool_false@7
    frame_dig -5
    gtxns Amount
    // smart_contracts/dao/constants.ts:17
    // export const AkitaDAOGlobalStateKeysProposalFee = 'proposal_fee'
    intc_0 // 0
    bytec 36 // "proposal_fee"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1464-1470
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.proposalFee.value
    //   }
    // )
    ==
    bz newProposal_bool_false@7
    intc_1 // 1

newProposal_bool_merge@8:
    // smart_contracts/dao/contract.algo.ts:1464-1470
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.proposalFee.value
    //   }
    // )
    assert // assert target is match for conditions
    // smart_contracts/arc58/account/constants.ts:12
    // export const AbstractAccountGlobalStateKeysEscrowFactory = 'escrow_factory'
    intc_0 // 0
    bytec 30 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:117-124
    // const data = abiCall(
    //   EscrowFactoryInterface.prototype.get,
    //   {
    //     appId: escrowFactory,
    //     args: [new Address(Txn.sender)],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:121
    // args: [new Address(Txn.sender)],
    txn Sender
    // smart_contracts/utils/functions.ts:117-124
    // const data = abiCall(
    //   EscrowFactoryInterface.prototype.get,
    //   {
    //     appId: escrowFactory,
    //     args: [new Address(Txn.sender)],
    //     fee: 0,
    //   }
    // ).returnValue
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:122
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:117-124
    // const data = abiCall(
    //   EscrowFactoryInterface.prototype.get,
    //   {
    //     appId: escrowFactory,
    //     args: [new Address(Txn.sender)],
    //     fee: 0,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 10 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 0
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:126
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    frame_bury 7
    bz newProposal_if_body@44
    frame_dig 7
    intc_2 // 8
    !=
    bz newProposal_after_if_else@45

newProposal_if_body@44:
    // smart_contracts/utils/functions.ts:127
    // return 0
    intc_0 // 0
    frame_bury 8

newProposal_after_inlined_smart_contracts/utils/functions.ts::walletID@46:
    // smart_contracts/utils/functions.ts:136
    // if (wallet === 0) {
    frame_dig 8
    bnz newProposal_after_if_else@48
    // smart_contracts/utils/functions.ts:137
    // return Txn.sender
    txn Sender
    frame_bury 1

newProposal_after_inlined_smart_contracts/utils/functions.ts::getOrigin@49:
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    intc_0 // 0
    bytec 37 // "akita_al"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    intc_0 // 0
    bytec 12 // "akita_assets"
    app_global_get_ex
    assert // check GlobalState exists
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:343-352
    // const info = abiCall(StakingInterface.prototype.getInfo, {
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:348
    // asset,
    itob
    // smart_contracts/staking/types.ts:30
    // export const STAKING_TYPE_LOCK: StakingType = new arc4.UintN8(3)
    bytec 14 // 0x03
    // smart_contracts/utils/functions.ts:347-350
    // {
    //   asset,
    //   type: STAKING_TYPE_LOCK,
    // },
    concat
    // smart_contracts/utils/functions.ts:343-352
    // const info = abiCall(StakingInterface.prototype.getInfo, {
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    pushbytes 0xc9068809 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 10 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    pushint 4 // 4
    extract_uint64
    frame_bury 2
    pushint 20 // 20
    extract_uint64
    dup
    frame_bury 3
    // smart_contracts/utils/functions.ts:354
    // if (info.expiration <= Global.latestTimestamp) {
    global LatestTimestamp
    <=
    bz newProposal_after_if_else@52
    // smart_contracts/utils/functions.ts:355
    // return 0
    intc_0 // 0
    frame_bury 4

newProposal_after_inlined_smart_contracts/utils/functions.ts::getStakingPower@55:
    // smart_contracts/dao/contract.algo.ts:1480
    // let powerPrerequisite: uint64 = 0
    intc_0 // 0
    frame_bury 5
    // smart_contracts/dao/constants.ts:63
    // export const ProposalActionUpgradeApp = new UintN8(0)
    frame_dig -4
    bytec_0 // 0x00
    ==
    // smart_contracts/dao/contract.algo.ts:1482-1485
    // case ProposalActionUpgradeApp: {
    //   powerPrerequisite = this.proposalCreationSettings.value.upgradeApp
    //   break;
    // }
    bz newProposal_after_if_else@11
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    frame_bury 5

newProposal_block@39:
    // smart_contracts/dao/contract.algo.ts:1517
    // assert(power >= powerPrerequisite, ERR_INSUFFICIENT_PROPOSAL_THRESHOLD)
    frame_dig 4
    frame_dig 5
    >=
    assert // Insufficient proposal threshold
    // smart_contracts/dao/constants.ts:28
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    intc_0 // 0
    bytec 23 // "proposal_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:335
    // this.proposalID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/dao/constants.ts:28
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    bytec 23 // "proposal_id"
    // smart_contracts/dao/contract.algo.ts:335
    // this.proposalID.value += 1
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1529
    // created: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/dao/contract.algo.ts:1524
    // this.proposals(id).value = {
    swap
    itob
    // smart_contracts/dao/constants.ts:31
    // export const AkitaDAOBoxPrefixProposals = 'l'
    bytec 15 // "l"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1524-1532
    // this.proposals(id).value = {
    //   action,
    //   status,
    //   cid,
    //   creator: new Address(origin),
    //   created: Global.latestTimestamp,
    //   votes: 0,
    //   data,
    // }
    dup
    box_del
    pop
    // smart_contracts/dao/contract.algo.ts:1527
    // cid,
    frame_dig -3
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/dao/contract.algo.ts:1529
    // created: Global.latestTimestamp,
    swap
    itob
    // smart_contracts/dao/contract.algo.ts:1530
    // votes: 0,
    intc_0 // 0
    itob
    // smart_contracts/dao/contract.algo.ts:1531
    // data,
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/dao/contract.algo.ts:1524
    // this.proposals(id).value = {
    frame_dig -1
    frame_dig -4
    concat
    frame_dig -3
    concat
    uncover 3
    concat
    uncover 2
    concat
    frame_dig 1
    concat
    pushbytes 0x0058
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1524-1532
    // this.proposals(id).value = {
    //   action,
    //   status,
    //   cid,
    //   creator: new Address(origin),
    //   created: Global.latestTimestamp,
    //   votes: 0,
    //   data,
    // }
    box_put
    retsub

newProposal_after_if_else@11:
    // smart_contracts/dao/constants.ts:64
    // export const ProposalActionAddPlugin = new UintN8(10)
    frame_dig -4
    pushbytes 0x0a
    ==
    // smart_contracts/dao/contract.algo.ts:1486
    // case ProposalActionAddPlugin:
    bnz newProposal_block@16
    // smart_contracts/dao/constants.ts:65
    // export const ProposalActionAddNamedPlugin = new UintN8(20)
    frame_dig -4
    bytec 9 // 0x14
    ==
    // smart_contracts/dao/contract.algo.ts:1487-1490
    // case ProposalActionAddNamedPlugin: {
    //   powerPrerequisite = this.proposalCreationSettings.value.addPlugin
    //   break;
    // }
    bz newProposal_after_if_else@17

newProposal_block@16:
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    intc_2 // 8
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1489
    // break;
    b newProposal_block@39

newProposal_after_if_else@17:
    // smart_contracts/dao/constants.ts:66
    // export const ProposalActionExecutePlugin = new UintN8(30)
    frame_dig -4
    bytec 26 // 0x1e
    ==
    // smart_contracts/dao/contract.algo.ts:1491
    // case ProposalActionExecutePlugin:
    bnz newProposal_block@22
    // smart_contracts/dao/constants.ts:67
    // export const ProposalActionExecuteNamedPlugin = new UintN8(40)
    frame_dig -4
    bytec 16 // 0x28
    ==
    // smart_contracts/dao/contract.algo.ts:1492-1497
    // case ProposalActionExecuteNamedPlugin: {
    //   const params = decodeArc4<ProposalExecutePlugin>(data)
    //   const pluginKey: PluginKey = { application: params.app, allowedCaller: params.allowedCaller.native }
    //   powerPrerequisite = this.plugins(pluginKey).value.executionProposalCreationMinimum.native
    //   break;
    // }
    bz newProposal_after_if_else@23

newProposal_block@22:
    // smart_contracts/dao/contract.algo.ts:1493
    // const params = decodeArc4<ProposalExecutePlugin>(data)
    frame_dig -2
    intc_0 // 0
    extract_uint64
    frame_dig -2
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/dao/contract.algo.ts:1494
    // const pluginKey: PluginKey = { application: params.app, allowedCaller: params.allowedCaller.native }
    swap
    itob
    // smart_contracts/dao/contract.algo.ts:1495
    // powerPrerequisite = this.plugins(pluginKey).value.executionProposalCreationMinimum.native
    swap
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1495
    // powerPrerequisite = this.plugins(pluginKey).value.executionProposalCreationMinimum.native
    box_get
    assert // Box must have value
    pushint 45 // 45
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1496
    // break;
    b newProposal_block@39

newProposal_after_if_else@23:
    // smart_contracts/dao/constants.ts:68
    // export const ProposalActionRemovePlugin = new UintN8(50)
    frame_dig -4
    pushbytes 0x32
    ==
    // smart_contracts/dao/contract.algo.ts:1498
    // case ProposalActionRemovePlugin:
    bnz newProposal_block@28
    // smart_contracts/dao/constants.ts:69
    // export const ProposalActionRemoveNamedPlugin = new UintN8(60)
    frame_dig -4
    pushbytes 0x3c
    ==
    // smart_contracts/dao/contract.algo.ts:1499-1502
    // case ProposalActionRemoveNamedPlugin: {
    //   powerPrerequisite = this.proposalCreationSettings.value.removePlugin
    //   break;
    // }
    bz newProposal_after_if_else@29

newProposal_block@28:
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 16
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1501
    // break;
    b newProposal_block@39

newProposal_after_if_else@29:
    // smart_contracts/dao/constants.ts:70
    // export const ProposalActionAddAllowance = new UintN8(70)
    frame_dig -4
    pushbytes 0x46
    ==
    // smart_contracts/dao/contract.algo.ts:1503-1506
    // case ProposalActionAddAllowance: {
    //   powerPrerequisite = this.proposalCreationSettings.value.addAllowance
    //   break;
    // }
    bz newProposal_after_if_else@32
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1505
    // break;
    b newProposal_block@39

newProposal_after_if_else@32:
    // smart_contracts/dao/constants.ts:71
    // export const ProposalActionRemoveAllowance = new UintN8(80)
    frame_dig -4
    pushbytes 0x50
    ==
    // smart_contracts/dao/contract.algo.ts:1507-1510
    // case ProposalActionRemoveAllowance: {
    //   powerPrerequisite = this.proposalCreationSettings.value.removeAllowance
    //   break;
    // }
    bz newProposal_after_if_else@35
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    pushint 32 // 32
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1509
    // break;
    b newProposal_block@39

newProposal_after_if_else@35:
    // smart_contracts/dao/constants.ts:72
    // export const ProposalActionUpdateFields = new UintN8(90)
    frame_dig -4
    pushbytes 0x5a
    ==
    // smart_contracts/dao/contract.algo.ts:1511-1514
    // case ProposalActionUpdateFields: {
    //   powerPrerequisite = this.proposalCreationSettings.value.updateField
    //   break;
    // }
    bz newProposal_block@39
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    pushint 40 // 40
    extract_uint64
    frame_bury 5
    // smart_contracts/dao/contract.algo.ts:1513
    // break;
    b newProposal_block@39

newProposal_after_if_else@52:
    // smart_contracts/utils/functions.ts:358
    // const remainingTime: uint64 = info.expiration - Global.latestTimestamp
    frame_dig 3
    global LatestTimestamp
    -
    dup
    frame_bury 6
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 12 // 86400
    // smart_contracts/utils/functions.ts:360
    // if (remainingTime < ONE_DAY) {
    <
    bz newProposal_after_if_else@54
    // smart_contracts/utils/functions.ts:361
    // return 0
    intc_0 // 0
    frame_bury 4
    // smart_contracts/dao/contract.algo.ts:1474-1478
    // const power = getStakingPower(
    //   this.akitaAppList.value.staking,
    //   new Address(origin),
    //   this.akitaAssets.value.bones
    // )
    b newProposal_after_inlined_smart_contracts/utils/functions.ts::getStakingPower@55

newProposal_after_if_else@54:
    // smart_contracts/utils/functions.ts:364
    // const remainingDays: uint64 = remainingTime / ONE_DAY
    frame_dig 6
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 12 // 86400
    // smart_contracts/utils/functions.ts:364
    // const remainingDays: uint64 = remainingTime / ONE_DAY
    /
    // smart_contracts/utils/functions.ts:365
    // return op.divw(...op.mulw(wideRatio([info.amount, 1_000_000], [ONE_YEAR_IN_DAYS, 1_000_000]), remainingDays), 1_000_000)
    frame_dig 2
    dup
    cover 2
    intc 10 // 1000000
    // smart_contracts/gates/plugins/staking-power/constants.ts:4
    // export const ONE_YEAR_IN_DAYS: uint64 = 365
    pushint 365 // 365
    // smart_contracts/utils/functions.ts:365
    // return op.divw(...op.mulw(wideRatio([info.amount, 1_000_000], [ONE_YEAR_IN_DAYS, 1_000_000]), remainingDays), 1_000_000)
    intc 10 // 1000000
    callsub wideRatio
    dig 1
    mulw
    pop
    cover 2
    swap
    intc 10 // 1000000
    // smart_contracts/gates/plugins/staking-power/constants.ts:4
    // export const ONE_YEAR_IN_DAYS: uint64 = 365
    pushint 365 // 365
    // smart_contracts/utils/functions.ts:365
    // return op.divw(...op.mulw(wideRatio([info.amount, 1_000_000], [ONE_YEAR_IN_DAYS, 1_000_000]), remainingDays), 1_000_000)
    intc 10 // 1000000
    callsub wideRatio
    mulw
    bury 1
    intc 10 // 1000000
    divw
    frame_bury 4
    // smart_contracts/dao/contract.algo.ts:1474-1478
    // const power = getStakingPower(
    //   this.akitaAppList.value.staking,
    //   new Address(origin),
    //   this.akitaAssets.value.bones
    // )
    b newProposal_after_inlined_smart_contracts/utils/functions.ts::getStakingPower@55

newProposal_after_if_else@48:
    // smart_contracts/utils/functions.ts:109-112
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 8
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:109-112
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:1472
    // const origin = getOrigin(this.escrowFactory.value.id)
    b newProposal_after_inlined_smart_contracts/utils/functions.ts::getOrigin@49

newProposal_after_if_else@45:
    // smart_contracts/utils/functions.ts:130
    // return btoi(data)
    frame_dig 0
    btoi
    frame_bury 8
    // smart_contracts/utils/functions.ts:134
    // const wallet = walletID(escrowFactory)
    b newProposal_after_inlined_smart_contracts/utils/functions.ts::walletID@46

newProposal_bool_false@7:
    intc_0 // 0
    b newProposal_bool_merge@8

newProposal_bool_false@3:
    intc_0 // 0
    b newProposal_bool_merge@4


// smart_contracts/dao/contract.algo.ts::AkitaDAO.finalizeProposal(proposalID: uint64, args: bytes) -> void:
finalizeProposal:
    // smart_contracts/dao/contract.algo.ts:1535
    // finalizeProposal(proposalID: uint64, args: bytes): void {
    proto 2 0
    intc_0 // 0
    dupn 5
    bytec_1 // ""
    dupn 28
    // smart_contracts/dao/contract.algo.ts:1536
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    frame_dig -2
    itob
    // smart_contracts/dao/constants.ts:31
    // export const AkitaDAOBoxPrefixProposals = 'l'
    bytec 15 // "l"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1536
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/dao/contract.algo.ts:1538
    // const { action, creator } = this.proposals(proposalID).value
    box_get
    assert // Box must have value
    dup
    extract 1 1 // on error: Index access is out of bounds
    dup
    uncover 2
    extract 54 32 // on error: Index access is out of bounds
    // smart_contracts/dao/contract.algo.ts:1540
    // assert(Txn.sender === creator.native, ERR_INCORRECT_SENDER)
    txn Sender
    ==
    assert // Incorrect sender
    // smart_contracts/dao/constants.ts:63
    // export const ProposalActionUpgradeApp = new UintN8(0)
    bytec_0 // 0x00
    ==
    // smart_contracts/dao/contract.algo.ts:1543-1548
    // case ProposalActionUpgradeApp: {
    //   // TODO: ensure its an app we control
    //   const params = decodeArc4<ProposalUpgradeApp>(args)
    //   this.validateUpgradeAppProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:64
    // export const ProposalActionAddPlugin = new UintN8(10)
    frame_dig 35
    pushbytes 0x0a
    ==
    // smart_contracts/dao/contract.algo.ts:1549-1553
    // case ProposalActionAddPlugin: {
    //   const params = decodeArc4<ProposalAddPlugin>(args)
    //   this.validateAddPluginProposal(params)
    //   break;
    // }
    bz finalizeProposal_after_if_else@6
    // smart_contracts/dao/contract.algo.ts:1550
    // const params = decodeArc4<ProposalAddPlugin>(args)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    frame_dig -1
    extract 8 32 // on error: Index access is out of bounds
    frame_dig -1
    extract 40 1 // on error: Index access is out of bounds
    frame_dig -1
    pushint 59 // 59
    extract_uint16
    frame_dig -1
    pushint 94 // 94
    extract_uint16
    frame_dig -1
    cover 2
    substring3
    frame_bury 4
    frame_dig -1
    pushint 70 // 70
    extract_uint64
    dup
    cover 2
    frame_bury 24
    frame_dig -1
    pushint 78 // 78
    extract_uint64
    frame_bury 23
    frame_dig -1
    pushint 86 // 86
    extract_uint64
    frame_bury 25
    frame_dig -1
    pushint 96 // 96
    extract_uint16
    frame_dig -1
    len
    frame_dig -1
    cover 2
    substring3
    frame_bury 3
    // smart_contracts/arc58/account/types.ts:55
    // export const DelegationTypeSelf = new UintN8(1)
    bytec 24 // 0x01
    // smart_contracts/dao/contract.algo.ts:699
    // assert(params.delegationType !== DelegationTypeSelf, ERR_BAD_DAO_DELEGATION_TYPE)
    !=
    assert // Bad DAO delegation type
    // smart_contracts/dao/contract.algo.ts:702
    // const key: PluginKey = { application: params.app, allowedCaller: params.allowedCaller.native }
    uncover 2
    itob
    // smart_contracts/dao/contract.algo.ts:703
    // assert(!this.plugins(key).exists, 'Plugin already exists')
    uncover 2
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:703
    // assert(!this.plugins(key).exists, 'Plugin already exists')
    box_len
    bury 1
    !
    assert // Plugin already exists
    // smart_contracts/dao/contract.algo.ts:707
    // assert(params.executionParticipationThreshold > 0 && params.executionParticipationThreshold <= DIVISOR, 'Invalid execution participation threshold')
    bz finalizeProposal_bool_false@124
    frame_dig 24
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:707
    // assert(params.executionParticipationThreshold > 0 && params.executionParticipationThreshold <= DIVISOR, 'Invalid execution participation threshold')
    <=
    bz finalizeProposal_bool_false@124
    intc_1 // 1

finalizeProposal_bool_merge@125:
    // smart_contracts/dao/contract.algo.ts:707
    // assert(params.executionParticipationThreshold > 0 && params.executionParticipationThreshold <= DIVISOR, 'Invalid execution participation threshold')
    assert // Invalid execution participation threshold
    // smart_contracts/dao/contract.algo.ts:708
    // assert(params.executionApprovalThreshold > 0 && params.executionApprovalThreshold <= DIVISOR, 'Invalid execution approval threshold')
    frame_dig 23
    bz finalizeProposal_bool_false@128
    frame_dig 23
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:708
    // assert(params.executionApprovalThreshold > 0 && params.executionApprovalThreshold <= DIVISOR, 'Invalid execution approval threshold')
    <=
    bz finalizeProposal_bool_false@128
    intc_1 // 1

finalizeProposal_bool_merge@129:
    // smart_contracts/dao/contract.algo.ts:708
    // assert(params.executionApprovalThreshold > 0 && params.executionApprovalThreshold <= DIVISOR, 'Invalid execution approval threshold')
    assert // Invalid execution approval threshold
    // smart_contracts/dao/contract.algo.ts:709
    // assert(params.executionVotingDuration > 0, 'Invalid execution voting duration')
    frame_dig 25
    assert // Invalid execution voting duration
    // smart_contracts/dao/contract.algo.ts:712
    // for (let i: uint64 = 0; i < params.methods.length; i += 1) {
    intc_0 // 0
    frame_bury 13

finalizeProposal_while_top@130:
    // smart_contracts/dao/contract.algo.ts:712
    // for (let i: uint64 = 0; i < params.methods.length; i += 1) {
    frame_dig 4
    intc_0 // 0
    extract_uint16
    frame_dig 13
    >
    bz finalizeProposal_after_while@132
    // smart_contracts/dao/contract.algo.ts:713
    // const method = params.methods[i]
    frame_dig 4
    extract 2 0
    frame_dig 13
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    pushint 4 // 4
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:717
    // assert(method.cooldown <= 365 * ONE_DAY, 'Method cooldown too long')
    pushint 31536000 // 31536000
    <=
    assert // Method cooldown too long
    // smart_contracts/dao/contract.algo.ts:712
    // for (let i: uint64 = 0; i < params.methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 13
    b finalizeProposal_while_top@130

finalizeProposal_after_while@132:
    // smart_contracts/dao/contract.algo.ts:721
    // if (params.allowances.length > 0) {
    frame_dig 3
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 34
    bz finalizeProposal_block@31
    // smart_contracts/dao/contract.algo.ts:722
    // for (let i: uint64 = 0; i < params.allowances.length; i += 1) {
    intc_0 // 0
    frame_bury 17

finalizeProposal_while_top@134:
    // smart_contracts/dao/contract.algo.ts:722
    // for (let i: uint64 = 0; i < params.allowances.length; i += 1) {
    frame_dig 17
    frame_dig 34
    <
    bz finalizeProposal_block@31
    // smart_contracts/dao/contract.algo.ts:723
    // const allowance = params.allowances[i]
    frame_dig 3
    extract 2 0
    frame_dig 17
    pushint 49 // 49
    *
    pushint 49 // 49
    extract3 // on error: Index access is out of bounds
    dup
    extract 8 1 // on error: Index access is out of bounds
    dup
    cover 2
    frame_bury 0
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 8
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 6
    pushint 33 // 33
    extract_uint64
    frame_bury 7
    // smart_contracts/arc58/account/types.ts:13
    // export const SpendAllowanceTypeFlat: SpendAllowanceType = new UintN8(1)
    bytec 24 // 0x01
    // smart_contracts/dao/contract.algo.ts:727
    // allowance.type === SpendAllowanceTypeFlat ||
    ==
    // smart_contracts/dao/contract.algo.ts:727-728
    // allowance.type === SpendAllowanceTypeFlat ||
    // allowance.type === SpendAllowanceTypeWindow ||
    bnz finalizeProposal_bool_true@138
    // smart_contracts/dao/contract.algo.ts:728
    // allowance.type === SpendAllowanceTypeWindow ||
    frame_dig 0
    // smart_contracts/arc58/account/types.ts:14
    // export const SpendAllowanceTypeWindow: SpendAllowanceType = new UintN8(2)
    bytec 25 // 0x02
    // smart_contracts/dao/contract.algo.ts:728
    // allowance.type === SpendAllowanceTypeWindow ||
    ==
    // smart_contracts/dao/contract.algo.ts:727-728
    // allowance.type === SpendAllowanceTypeFlat ||
    // allowance.type === SpendAllowanceTypeWindow ||
    bnz finalizeProposal_bool_true@138
    // smart_contracts/dao/contract.algo.ts:729
    // allowance.type === SpendAllowanceTypeDrip,
    frame_dig 0
    // smart_contracts/arc58/account/types.ts:15
    // export const SpendAllowanceTypeDrip: SpendAllowanceType = new UintN8(3)
    bytec 14 // 0x03
    // smart_contracts/dao/contract.algo.ts:729
    // allowance.type === SpendAllowanceTypeDrip,
    ==
    // smart_contracts/dao/contract.algo.ts:727-729
    // allowance.type === SpendAllowanceTypeFlat ||
    // allowance.type === SpendAllowanceTypeWindow ||
    // allowance.type === SpendAllowanceTypeDrip,
    bz finalizeProposal_bool_false@139

finalizeProposal_bool_true@138:
    intc_1 // 1

finalizeProposal_bool_merge@140:
    // smart_contracts/dao/contract.algo.ts:726-731
    // assert(
    //   allowance.type === SpendAllowanceTypeFlat ||
    //   allowance.type === SpendAllowanceTypeWindow ||
    //   allowance.type === SpendAllowanceTypeDrip,
    //   'Invalid allowance type'
    // )
    assert // Invalid allowance type
    // smart_contracts/dao/contract.algo.ts:734
    // assert(allowance.allowed > 0, 'Allowance amount must be positive')
    frame_dig 6
    assert // Allowance amount must be positive
    // smart_contracts/dao/contract.algo.ts:736
    // if (allowance.type === SpendAllowanceTypeDrip) {
    frame_dig 0
    // smart_contracts/arc58/account/types.ts:15
    // export const SpendAllowanceTypeDrip: SpendAllowanceType = new UintN8(3)
    bytec 14 // 0x03
    // smart_contracts/dao/contract.algo.ts:736
    // if (allowance.type === SpendAllowanceTypeDrip) {
    ==
    bz finalizeProposal_after_if_else@142
    // smart_contracts/dao/contract.algo.ts:737
    // assert(allowance.max > 0, 'Max allowance must be positive for drip type')
    frame_dig 8
    assert // Max allowance must be positive for drip type
    // smart_contracts/dao/contract.algo.ts:738
    // assert(allowance.interval > 0, 'Interval must be positive for drip type')
    frame_dig 7
    assert // Interval must be positive for drip type

finalizeProposal_after_if_else@142:
    // smart_contracts/dao/contract.algo.ts:741
    // if (allowance.type === SpendAllowanceTypeWindow) {
    frame_dig 0
    // smart_contracts/arc58/account/types.ts:14
    // export const SpendAllowanceTypeWindow: SpendAllowanceType = new UintN8(2)
    bytec 25 // 0x02
    // smart_contracts/dao/contract.algo.ts:741
    // if (allowance.type === SpendAllowanceTypeWindow) {
    ==
    bz finalizeProposal_after_if_else@144
    // smart_contracts/dao/contract.algo.ts:742
    // assert(allowance.interval > 0, 'Interval must be positive for window type')
    frame_dig 7
    assert // Interval must be positive for window type

finalizeProposal_after_if_else@144:
    // smart_contracts/dao/contract.algo.ts:722
    // for (let i: uint64 = 0; i < params.allowances.length; i += 1) {
    frame_dig 17
    intc_1 // 1
    +
    frame_bury 17
    b finalizeProposal_while_top@134

finalizeProposal_bool_false@139:
    intc_0 // 0
    b finalizeProposal_bool_merge@140

finalizeProposal_block@31:
    retsub

finalizeProposal_bool_false@128:
    intc_0 // 0
    b finalizeProposal_bool_merge@129

finalizeProposal_bool_false@124:
    intc_0 // 0
    b finalizeProposal_bool_merge@125

finalizeProposal_after_if_else@6:
    // smart_contracts/dao/constants.ts:65
    // export const ProposalActionAddNamedPlugin = new UintN8(20)
    frame_dig 35
    bytec 9 // 0x14
    ==
    // smart_contracts/dao/contract.algo.ts:1554-1558
    // case ProposalActionAddNamedPlugin: {
    //   const params = decodeArc4<ProposalAddNamedPlugin>(args)
    //   this.validateAddNamedPluginProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:66
    // export const ProposalActionExecutePlugin = new UintN8(30)
    frame_dig 35
    bytec 26 // 0x1e
    ==
    // smart_contracts/dao/contract.algo.ts:1559-1563
    // case ProposalActionExecutePlugin: {
    //   const params = decodeArc4<ProposalExecutePlugin>(args)
    //   this.validateExecutePluginProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:67
    // export const ProposalActionExecuteNamedPlugin = new UintN8(40)
    frame_dig 35
    bytec 16 // 0x28
    ==
    // smart_contracts/dao/contract.algo.ts:1564-1568
    // case ProposalActionExecuteNamedPlugin: {
    //   const params = decodeArc4<ProposalExecuteNamedPlugin>(args)
    //   this.validateExecuteNamedPluginProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:68
    // export const ProposalActionRemovePlugin = new UintN8(50)
    frame_dig 35
    pushbytes 0x32
    ==
    // smart_contracts/dao/contract.algo.ts:1569-1573
    // case ProposalActionRemovePlugin: {
    //   const params = decodeArc4<ProposalRemovePlugin>(args)
    //   this.validateRemovePluginProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:69
    // export const ProposalActionRemoveNamedPlugin = new UintN8(60)
    frame_dig 35
    pushbytes 0x3c
    ==
    // smart_contracts/dao/contract.algo.ts:1574-1578
    // case ProposalActionRemoveNamedPlugin: {
    //   const params = decodeArc4<ProposalRemoveNamedPlugin>(args)
    //   this.validateRemoveNamedPluginProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:70
    // export const ProposalActionAddAllowance = new UintN8(70)
    frame_dig 35
    pushbytes 0x46
    ==
    // smart_contracts/dao/contract.algo.ts:1579-1583
    // case ProposalActionAddAllowance: {
    //   const params = decodeArc4<ProposalAddAllowance>(args)
    //   this.validateAddAllowanceProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:71
    // export const ProposalActionRemoveAllowance = new UintN8(80)
    frame_dig 35
    pushbytes 0x50
    ==
    // smart_contracts/dao/contract.algo.ts:1584-1588
    // case ProposalActionRemoveAllowance: {
    //   const params = decodeArc4<ProposalRemoveAllowance>(args)
    //   this.validateRemoveAllowanceProposal(params)
    //   break;
    // }
    bnz finalizeProposal_block@31
    // smart_contracts/dao/constants.ts:72
    // export const ProposalActionUpdateFields = new UintN8(90)
    frame_dig 35
    pushbytes 0x5a
    ==
    // smart_contracts/dao/contract.algo.ts:1589-1593
    // case ProposalActionUpdateFields: {
    //   const params = decodeArc4<ProposalUpdateField[]>(args)
    //   this.validateUpdateFieldsProposal(params)
    //   break;
    // }
    bz finalizeProposal_block@31
    // smart_contracts/dao/contract.algo.ts:1060
    // for (let i: uint64 = 0; i < params.length; i += 1) {
    intc_0 // 0
    frame_bury 13

finalizeProposal_while_top@33:
    // smart_contracts/dao/contract.algo.ts:1060
    // for (let i: uint64 = 0; i < params.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 33
    frame_dig 13
    >
    bz finalizeProposal_block@31
    // smart_contracts/dao/contract.algo.ts:1061
    // const { field, value } = params[i]
    frame_dig -1
    extract 2 0
    frame_dig 13
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 13
    frame_dig 33
    dig 1
    - // on error: Index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dup
    cover 3
    frame_bury 1
    dig 1
    len
    substring3
    dup
    frame_bury 2
    extract 2 0
    frame_bury 5
    // smart_contracts/dao/constants.ts:5
    // export const AkitaDAOGlobalStateKeysContentPolicy = 'content_policy'
    bytec 17 // "content_policy"
    ==
    // smart_contracts/dao/contract.algo.ts:1064-1067
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    //   assert(Bytes(value).length === CID_LENGTH, ERR_INVALID_CONTENT_POLICY)
    //   break
    // }
    bz finalizeProposal_after_if_else@36
    // smart_contracts/dao/contract.algo.ts:1065
    // assert(Bytes(value).length === CID_LENGTH, ERR_INVALID_CONTENT_POLICY)
    frame_dig 5
    len
    // smart_contracts/utils/constants.ts:51
    // export const CID_LENGTH: uint64 = 36
    pushint 36 // 36
    // smart_contracts/dao/contract.algo.ts:1065
    // assert(Bytes(value).length === CID_LENGTH, ERR_INVALID_CONTENT_POLICY)
    ==
    assert // Invalid content policy
    // smart_contracts/dao/contract.algo.ts:1066
    // break
    b finalizeProposal_while_top@33

finalizeProposal_after_if_else@36:
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysMinRewardsImpact = 'min_rewards_impact'
    frame_dig 1
    bytec 18 // "min_rewards_impact"
    ==
    // smart_contracts/dao/contract.algo.ts:1068-1072
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //   const minRewardsImpact = decodeArc4<uint64>(Bytes(value))
    //   assert(minRewardsImpact >= 0, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    //   break
    // }
    bnz finalizeProposal_while_top@33
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    frame_dig 1
    bytec 19 // "social_fees"
    ==
    // smart_contracts/dao/contract.algo.ts:1073-1085
    // case AkitaDAOGlobalStateKeysSocialFees: {
    //   const { postFee, reactFee, impactTaxMin, impactTaxMax } = decodeArc4<SocialFees>(Bytes(value))
    //   assert(postFee >= MIN_POST_FEE && postFee < MAX_POST_FEE, ERR_INVALID_POST_FEE)
    //   assert(reactFee >= MIN_REACT_FEE && reactFee < MAX_REACT_FEE, ERR_INVALID_REACT_FEE)
    //   assert(impactTaxMin >= MIN_IMPACT_TAX_MIN, ERR_INVALID_IMPACT_TAX_MIN)
    //   assert(
    //     impactTaxMax > impactTaxMin
    //     && impactTaxMax >= MIN_IMPACT_TAX_MAX
    //     && impactTaxMax <= DIVISOR,
    //     ERR_INVALID_IMPACT_TAX_MAX
    //   )
    //   break
    // }
    bz finalizeProposal_after_if_else@53
    // smart_contracts/dao/contract.algo.ts:1074
    // const { postFee, reactFee, impactTaxMin, impactTaxMax } = decodeArc4<SocialFees>(Bytes(value))
    frame_dig 2
    dup
    pushint 2 // 2
    extract_uint64
    dup
    cover 2
    frame_bury 26
    dup
    pushint 10 // 10
    extract_uint64
    frame_bury 30
    dup
    pushint 18 // 18
    extract_uint64
    frame_bury 16
    pushint 26 // 26
    extract_uint64
    frame_bury 14
    // smart_contracts/utils/constants.ts:20
    // export const MIN_POST_FEE: uint64 = 10 // 0.000010 AKTA or 10 keets
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1075
    // assert(postFee >= MIN_POST_FEE && postFee < MAX_POST_FEE, ERR_INVALID_POST_FEE)
    >=
    bz finalizeProposal_bool_false@42
    frame_dig 26
    // smart_contracts/utils/constants.ts:21
    // export const MAX_POST_FEE: uint64 = 100_000_000_000 // 100K AKTA
    pushint 100000000000 // 100000000000
    // smart_contracts/dao/contract.algo.ts:1075
    // assert(postFee >= MIN_POST_FEE && postFee < MAX_POST_FEE, ERR_INVALID_POST_FEE)
    <
    bz finalizeProposal_bool_false@42
    intc_1 // 1

finalizeProposal_bool_merge@43:
    // smart_contracts/dao/contract.algo.ts:1075
    // assert(postFee >= MIN_POST_FEE && postFee < MAX_POST_FEE, ERR_INVALID_POST_FEE)
    assert // Invalid post fee
    // smart_contracts/dao/contract.algo.ts:1076
    // assert(reactFee >= MIN_REACT_FEE && reactFee < MAX_REACT_FEE, ERR_INVALID_REACT_FEE)
    frame_dig 30
    // smart_contracts/utils/constants.ts:22
    // export const MIN_REACT_FEE: uint64 = 10 // 0.000010 AKTA or 10 keets
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1076
    // assert(reactFee >= MIN_REACT_FEE && reactFee < MAX_REACT_FEE, ERR_INVALID_REACT_FEE)
    >=
    bz finalizeProposal_bool_false@46
    frame_dig 30
    // smart_contracts/utils/constants.ts:23
    // export const MAX_REACT_FEE: uint64 = 10_000_000_000 // 10K AKTA
    pushint 10000000000 // 10000000000
    // smart_contracts/dao/contract.algo.ts:1076
    // assert(reactFee >= MIN_REACT_FEE && reactFee < MAX_REACT_FEE, ERR_INVALID_REACT_FEE)
    <
    bz finalizeProposal_bool_false@46
    intc_1 // 1

finalizeProposal_bool_merge@47:
    // smart_contracts/dao/contract.algo.ts:1076
    // assert(reactFee >= MIN_REACT_FEE && reactFee < MAX_REACT_FEE, ERR_INVALID_REACT_FEE)
    assert // Invalid react fee
    // smart_contracts/dao/contract.algo.ts:1077
    // assert(impactTaxMin >= MIN_IMPACT_TAX_MIN, ERR_INVALID_IMPACT_TAX_MIN)
    frame_dig 16
    dup
    // smart_contracts/utils/constants.ts:24
    // export const MIN_IMPACT_TAX_MIN: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1077
    // assert(impactTaxMin >= MIN_IMPACT_TAX_MIN, ERR_INVALID_IMPACT_TAX_MIN)
    >=
    assert // Invalid impact tax minimum
    // smart_contracts/dao/contract.algo.ts:1079
    // impactTaxMax > impactTaxMin
    frame_dig 14
    <
    // smart_contracts/dao/contract.algo.ts:1079-1080
    // impactTaxMax > impactTaxMin
    // && impactTaxMax >= MIN_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@51
    // smart_contracts/dao/contract.algo.ts:1080
    // && impactTaxMax >= MIN_IMPACT_TAX_MAX
    frame_dig 14
    // smart_contracts/utils/constants.ts:25
    // export const MIN_IMPACT_TAX_MAX: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1080
    // && impactTaxMax >= MIN_IMPACT_TAX_MAX
    >=
    // smart_contracts/dao/contract.algo.ts:1079-1080
    // impactTaxMax > impactTaxMin
    // && impactTaxMax >= MIN_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@51
    // smart_contracts/dao/contract.algo.ts:1081
    // && impactTaxMax <= DIVISOR,
    frame_dig 14
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1081
    // && impactTaxMax <= DIVISOR,
    <=
    // smart_contracts/dao/contract.algo.ts:1079-1081
    // impactTaxMax > impactTaxMin
    // && impactTaxMax >= MIN_IMPACT_TAX_MAX
    // && impactTaxMax <= DIVISOR,
    bz finalizeProposal_bool_false@51
    intc_1 // 1

finalizeProposal_bool_merge@52:
    // smart_contracts/dao/contract.algo.ts:1078-1083
    // assert(
    //   impactTaxMax > impactTaxMin
    //   && impactTaxMax >= MIN_IMPACT_TAX_MAX
    //   && impactTaxMax <= DIVISOR,
    //   ERR_INVALID_IMPACT_TAX_MAX
    // )
    assert // Invalid impact tax maximum
    // smart_contracts/dao/contract.algo.ts:1084
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@51:
    intc_0 // 0
    b finalizeProposal_bool_merge@52

finalizeProposal_bool_false@46:
    intc_0 // 0
    b finalizeProposal_bool_merge@47

finalizeProposal_bool_false@42:
    intc_0 // 0
    b finalizeProposal_bool_merge@43

finalizeProposal_after_if_else@53:
    // smart_contracts/dao/constants.ts:11
    // export const AkitaDAOGlobalStateKeysStakingFees = 'staking_fees'
    frame_dig 1
    bytec 20 // "staking_fees"
    ==
    // smart_contracts/dao/contract.algo.ts:1086-1097
    // case AkitaDAOGlobalStateKeysStakingFees: {
    //   const { creationFee, impactTaxMin, impactTaxMax } = decodeArc4<StakingFees>(Bytes(value))
    //   assert(creationFee > 0, ERR_INVALID_POOL_CREATION_FEE)
    //   assert(impactTaxMin >= MIN_POOL_IMPACT_TAX_MIN, ERR_INVALID_POOL_IMPACT_TAX_MIN)
    //   assert(
    //     impactTaxMax >= impactTaxMin
    //     && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    //     && impactTaxMax <= DIVISOR,
    //     ERR_INVALID_POOL_IMPACT_TAX_MAX
    //   )
    //   break
    // }
    bz finalizeProposal_after_if_else@60
    // smart_contracts/dao/contract.algo.ts:1087
    // const { creationFee, impactTaxMin, impactTaxMax } = decodeArc4<StakingFees>(Bytes(value))
    frame_dig 2
    dup
    pushint 2 // 2
    extract_uint64
    dig 1
    pushint 10 // 10
    extract_uint64
    uncover 2
    pushint 18 // 18
    extract_uint64
    dup
    cover 3
    frame_bury 15
    // smart_contracts/dao/contract.algo.ts:1088
    // assert(creationFee > 0, ERR_INVALID_POOL_CREATION_FEE)
    swap
    assert // Invalid pool creation fee
    // smart_contracts/dao/contract.algo.ts:1089
    // assert(impactTaxMin >= MIN_POOL_IMPACT_TAX_MIN, ERR_INVALID_POOL_IMPACT_TAX_MIN)
    dup
    // smart_contracts/utils/constants.ts:26
    // export const MIN_POOL_IMPACT_TAX_MIN: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1089
    // assert(impactTaxMin >= MIN_POOL_IMPACT_TAX_MIN, ERR_INVALID_POOL_IMPACT_TAX_MIN)
    >=
    assert // Invalid pool impact tax minimum
    // smart_contracts/dao/contract.algo.ts:1091
    // impactTaxMax >= impactTaxMin
    >=
    // smart_contracts/dao/contract.algo.ts:1091-1092
    // impactTaxMax >= impactTaxMin
    // && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@58
    // smart_contracts/dao/contract.algo.ts:1092
    // && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    frame_dig 15
    // smart_contracts/utils/constants.ts:27
    // export const MIN_POOL_IMPACT_TAX_MAX: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1092
    // && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    >=
    // smart_contracts/dao/contract.algo.ts:1091-1092
    // impactTaxMax >= impactTaxMin
    // && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@58
    // smart_contracts/dao/contract.algo.ts:1093
    // && impactTaxMax <= DIVISOR,
    frame_dig 15
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1093
    // && impactTaxMax <= DIVISOR,
    <=
    // smart_contracts/dao/contract.algo.ts:1091-1093
    // impactTaxMax >= impactTaxMin
    // && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    // && impactTaxMax <= DIVISOR,
    bz finalizeProposal_bool_false@58
    intc_1 // 1

finalizeProposal_bool_merge@59:
    // smart_contracts/dao/contract.algo.ts:1090-1095
    // assert(
    //   impactTaxMax >= impactTaxMin
    //   && impactTaxMax >= MIN_POOL_IMPACT_TAX_MAX
    //   && impactTaxMax <= DIVISOR,
    //   ERR_INVALID_POOL_IMPACT_TAX_MAX
    // )
    assert // Invalid pool impact tax maximum
    // smart_contracts/dao/contract.algo.ts:1096
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@58:
    intc_0 // 0
    b finalizeProposal_bool_merge@59

finalizeProposal_after_if_else@60:
    // smart_contracts/dao/constants.ts:12
    // export const AkitaDAOGlobalStateKeysSubscriptionFees = 'subscription_fees'
    frame_dig 1
    bytec 21 // "subscription_fees"
    ==
    // smart_contracts/dao/contract.algo.ts:1098-1105
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //   const { serviceCreationFee, paymentPercentage, triggerPercentage } = decodeArc4<SubscriptionFees>(Bytes(value))
    //   assert(serviceCreationFee > 0, ERR_INVALID_SERVICE_CREATION_FEE)
    //   assert(paymentPercentage >= MIN_PAYMENT_PERCENTAGE, ERR_INVALID_PAYMENT_PERCENTAGE)
    //   assert(triggerPercentage >= MIN_TRIGGER_PERCENTAGE, ERR_INVALID_TRIGGER_PERCENTAGE)
    //   assert((paymentPercentage + triggerPercentage) < DIVISOR, ERR_INVALID_TOTAL_PERCENTAGE_FEES)
    //   break
    // }
    bz finalizeProposal_after_if_else@62
    // smart_contracts/dao/contract.algo.ts:1099
    // const { serviceCreationFee, paymentPercentage, triggerPercentage } = decodeArc4<SubscriptionFees>(Bytes(value))
    frame_dig 2
    dup
    pushint 2 // 2
    extract_uint64
    dig 1
    pushint 10 // 10
    extract_uint64
    uncover 2
    pushint 18 // 18
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1100
    // assert(serviceCreationFee > 0, ERR_INVALID_SERVICE_CREATION_FEE)
    uncover 2
    assert // Invalid service creation fee
    // smart_contracts/dao/contract.algo.ts:1101
    // assert(paymentPercentage >= MIN_PAYMENT_PERCENTAGE, ERR_INVALID_PAYMENT_PERCENTAGE)
    dig 1
    // smart_contracts/utils/constants.ts:28
    // export const MIN_PAYMENT_PERCENTAGE: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1101
    // assert(paymentPercentage >= MIN_PAYMENT_PERCENTAGE, ERR_INVALID_PAYMENT_PERCENTAGE)
    >=
    assert // Invalid payment percentage
    // smart_contracts/dao/contract.algo.ts:1102
    // assert(triggerPercentage >= MIN_TRIGGER_PERCENTAGE, ERR_INVALID_TRIGGER_PERCENTAGE)
    dup
    // smart_contracts/utils/constants.ts:29
    // export const MIN_TRIGGER_PERCENTAGE: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1102
    // assert(triggerPercentage >= MIN_TRIGGER_PERCENTAGE, ERR_INVALID_TRIGGER_PERCENTAGE)
    >=
    assert // Invalid trigger percentage
    // smart_contracts/dao/contract.algo.ts:1103
    // assert((paymentPercentage + triggerPercentage) < DIVISOR, ERR_INVALID_TOTAL_PERCENTAGE_FEES)
    +
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1103
    // assert((paymentPercentage + triggerPercentage) < DIVISOR, ERR_INVALID_TOTAL_PERCENTAGE_FEES)
    <
    assert // Invalid subscription total percentage fees
    // smart_contracts/dao/contract.algo.ts:1104
    // break
    b finalizeProposal_while_top@33

finalizeProposal_after_if_else@62:
    // smart_contracts/dao/constants.ts:14
    // export const AkitaDAOGlobalStateKeysNFTFees = 'nft_fees'
    frame_dig 1
    bytec 22 // "nft_fees"
    ==
    // smart_contracts/dao/contract.algo.ts:1106-1168
    // case AkitaDAOGlobalStateKeysNFTFees: {
    //   const {
    //     marketplaceSalePercentageMin,
    //     marketplaceSalePercentageMax,
    //     marketplaceComposablePercentage,
    //     marketplaceRoyaltyDefaultPercentage,
    //     shuffleSalePercentage,
    //     auctionSaleImpactTaxMin,
    //     auctionSaleImpactTaxMax,
    //     auctionComposablePercentage,
    //     auctionRafflePercentage,
    //     raffleSaleImpactTaxMin,
    //     raffleSaleImpactTaxMax,
    //     raffleComposablePercentage,
    //   } = decodeArc4<NFTFees>(Bytes(value))
    // 
    //   assert(marketplaceSalePercentageMin > MIN_MARKETPLACE_SALE_PERCENTAGE_MINIMUM, ERR_INVALID_MARKETPLACE_SALE_PERCENTAGE_MINIMUM)
    //   assert(
    //     marketplaceSalePercentageMax > marketplaceSalePercentageMin &&
    //     marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    //     ERR_INVALID_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM
    //   )
    //   assert(
    //     marketplaceComposablePercentage >= MIN_MARKETPLACE_COMPOSABLE_PERCENTAGE,
    //     ERR_INVALID_MARKETPLACE_COMPOSABLE_PERCENTAGE
    //   )
    //   assert(
    //     marketplaceRoyaltyDefaultPercentage >= MIN_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE,
    //     ERR_INVALID_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE
    //   )
    //   assert(
    //     (marketplaceSalePercentageMax + marketplaceComposablePercentage + marketplaceRoyaltyDefaultPercentage) <= DIVISOR,
    //     ERR_INVALID_TOTAL_PERCENTAGE_FEES
    //   )
    //   // ensure total marketplace fees are less than 100%
    //   assert(shuffleSalePercentage <= DIVISOR, ERR_INVALID_SHUFFLE_SALE_PERCENTAGE)
    //   assert(auctionSaleImpactTaxMin >= MIN_AUCTION_SALE_IMPACT_TAX_MIN, ERR_INVALID_AUCTION_SALE_IMPACT_TAX_MIN)
    //   assert(
    //     auctionSaleImpactTaxMax > auctionSaleImpactTaxMin
    //     && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    //     ERR_INVALID_AUCTION_SALE_IMPACT_TAX_MAX
    //   )
    //   // ensure total auction fees are less than 100%
    //   assert(
    //     (auctionSaleImpactTaxMax + auctionComposablePercentage) <= DIVISOR,
    //     ERR_INVALID_TOTAL_PERCENTAGE_FEES
    //   )
    //   // ensure total auction raffle fees are less than 100%
    //   assert(auctionRafflePercentage <= DIVISOR, ERR_INVALID_AUCTION_RAFFLE_PERCENTAGE)
    //   assert(raffleSaleImpactTaxMin >= MIN_RAFFLE_SALE_IMPACT_TAX_MIN, ERR_INVALID_RAFFLE_SALE_IMPACT_TAX_MIN)
    //   assert(
    //     raffleSaleImpactTaxMax > raffleSaleImpactTaxMin
    //     && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    //     ERR_INVALID_RAFFLE_SALE_IMPACT_TAX_MAX
    //   )
    //   // ensure total raffle fees are less than 100%
    //   assert(
    //     (raffleSaleImpactTaxMax + raffleComposablePercentage) < DIVISOR,
    //     ERR_INVALID_TOTAL_PERCENTAGE_FEES
    //   )
    // 
    //   break
    // }
    bz finalizeProposal_after_if_else@76
    // smart_contracts/dao/contract.algo.ts:1120
    // } = decodeArc4<NFTFees>(Bytes(value))
    frame_dig 2
    dup
    pushint 2 // 2
    extract_uint64
    dig 1
    pushint 10 // 10
    extract_uint64
    dup
    cover 3
    frame_bury 21
    dig 1
    pushint 18 // 18
    extract_uint64
    frame_bury 19
    dig 1
    pushint 26 // 26
    extract_uint64
    frame_bury 20
    dig 1
    pushint 34 // 34
    extract_uint64
    frame_bury 31
    dig 1
    pushint 58 // 58
    extract_uint64
    frame_bury 12
    dig 1
    pushint 66 // 66
    extract_uint64
    frame_bury 11
    dig 1
    pushint 74 // 74
    extract_uint64
    frame_bury 9
    dig 1
    pushint 82 // 82
    extract_uint64
    frame_bury 10
    dig 1
    pushint 98 // 98
    extract_uint64
    frame_bury 29
    dig 1
    pushint 106 // 106
    extract_uint64
    frame_bury 28
    swap
    pushint 114 // 114
    extract_uint64
    frame_bury 27
    // smart_contracts/dao/contract.algo.ts:1122
    // assert(marketplaceSalePercentageMin > MIN_MARKETPLACE_SALE_PERCENTAGE_MINIMUM, ERR_INVALID_MARKETPLACE_SALE_PERCENTAGE_MINIMUM)
    dup
    // smart_contracts/utils/constants.ts:30
    // export const MIN_MARKETPLACE_SALE_PERCENTAGE_MINIMUM: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1122
    // assert(marketplaceSalePercentageMin > MIN_MARKETPLACE_SALE_PERCENTAGE_MINIMUM, ERR_INVALID_MARKETPLACE_SALE_PERCENTAGE_MINIMUM)
    >
    assert // Invalid marketplace sale percentage minimum
    // smart_contracts/dao/contract.algo.ts:1124
    // marketplaceSalePercentageMax > marketplaceSalePercentageMin &&
    >
    // smart_contracts/dao/contract.algo.ts:1124-1125
    // marketplaceSalePercentageMax > marketplaceSalePercentageMin &&
    // marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    bz finalizeProposal_bool_false@66
    // smart_contracts/dao/contract.algo.ts:1125
    // marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    frame_dig 21
    // smart_contracts/utils/constants.ts:31
    // export const MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1125
    // marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    >=
    // smart_contracts/dao/contract.algo.ts:1124-1125
    // marketplaceSalePercentageMax > marketplaceSalePercentageMin &&
    // marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    bz finalizeProposal_bool_false@66
    intc_1 // 1

finalizeProposal_bool_merge@67:
    // smart_contracts/dao/contract.algo.ts:1123-1127
    // assert(
    //   marketplaceSalePercentageMax > marketplaceSalePercentageMin &&
    //   marketplaceSalePercentageMax >= MIN_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM,
    //   ERR_INVALID_MARKETPLACE_SALE_PERCENTAGE_MAXIMUM
    // )
    assert // Invalid marketplace sale percentage maximum
    // smart_contracts/dao/contract.algo.ts:1129
    // marketplaceComposablePercentage >= MIN_MARKETPLACE_COMPOSABLE_PERCENTAGE,
    frame_dig 19
    dup
    // smart_contracts/utils/constants.ts:32
    // export const MIN_MARKETPLACE_COMPOSABLE_PERCENTAGE: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1129
    // marketplaceComposablePercentage >= MIN_MARKETPLACE_COMPOSABLE_PERCENTAGE,
    >=
    // smart_contracts/dao/contract.algo.ts:1128-1131
    // assert(
    //   marketplaceComposablePercentage >= MIN_MARKETPLACE_COMPOSABLE_PERCENTAGE,
    //   ERR_INVALID_MARKETPLACE_COMPOSABLE_PERCENTAGE
    // )
    assert // Invalid marketplace composable percentage
    // smart_contracts/dao/contract.algo.ts:1133
    // marketplaceRoyaltyDefaultPercentage >= MIN_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE,
    frame_dig 20
    dup
    // smart_contracts/utils/constants.ts:33
    // export const MIN_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1133
    // marketplaceRoyaltyDefaultPercentage >= MIN_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE,
    >=
    // smart_contracts/dao/contract.algo.ts:1132-1135
    // assert(
    //   marketplaceRoyaltyDefaultPercentage >= MIN_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE,
    //   ERR_INVALID_MARKETPLACE_ROYALTY_DEFAULT_PERCENTAGE
    // )
    assert // Invalid marketplace royalty default percentage
    // smart_contracts/dao/contract.algo.ts:1137
    // (marketplaceSalePercentageMax + marketplaceComposablePercentage + marketplaceRoyaltyDefaultPercentage) <= DIVISOR,
    frame_dig 21
    uncover 2
    +
    +
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1137
    // (marketplaceSalePercentageMax + marketplaceComposablePercentage + marketplaceRoyaltyDefaultPercentage) <= DIVISOR,
    <=
    // smart_contracts/dao/contract.algo.ts:1136-1139
    // assert(
    //   (marketplaceSalePercentageMax + marketplaceComposablePercentage + marketplaceRoyaltyDefaultPercentage) <= DIVISOR,
    //   ERR_INVALID_TOTAL_PERCENTAGE_FEES
    // )
    assert // Invalid subscription total percentage fees
    // smart_contracts/dao/contract.algo.ts:1141
    // assert(shuffleSalePercentage <= DIVISOR, ERR_INVALID_SHUFFLE_SALE_PERCENTAGE)
    frame_dig 31
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1141
    // assert(shuffleSalePercentage <= DIVISOR, ERR_INVALID_SHUFFLE_SALE_PERCENTAGE)
    <=
    assert // Invalid shuffle sale percentage
    // smart_contracts/dao/contract.algo.ts:1142
    // assert(auctionSaleImpactTaxMin >= MIN_AUCTION_SALE_IMPACT_TAX_MIN, ERR_INVALID_AUCTION_SALE_IMPACT_TAX_MIN)
    frame_dig 12
    dup
    // smart_contracts/utils/constants.ts:34
    // export const MIN_AUCTION_SALE_IMPACT_TAX_MIN: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1142
    // assert(auctionSaleImpactTaxMin >= MIN_AUCTION_SALE_IMPACT_TAX_MIN, ERR_INVALID_AUCTION_SALE_IMPACT_TAX_MIN)
    >=
    assert // Invalid auction sale impact tax minimum
    // smart_contracts/dao/contract.algo.ts:1144
    // auctionSaleImpactTaxMax > auctionSaleImpactTaxMin
    frame_dig 11
    <
    // smart_contracts/dao/contract.algo.ts:1144-1145
    // auctionSaleImpactTaxMax > auctionSaleImpactTaxMin
    // && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    bz finalizeProposal_bool_false@70
    // smart_contracts/dao/contract.algo.ts:1145
    // && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    frame_dig 11
    // smart_contracts/utils/constants.ts:35
    // export const MIN_AUCTION_SALE_IMPACT_TAX_MAX: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1145
    // && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    >=
    // smart_contracts/dao/contract.algo.ts:1144-1145
    // auctionSaleImpactTaxMax > auctionSaleImpactTaxMin
    // && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    bz finalizeProposal_bool_false@70
    intc_1 // 1

finalizeProposal_bool_merge@71:
    // smart_contracts/dao/contract.algo.ts:1143-1147
    // assert(
    //   auctionSaleImpactTaxMax > auctionSaleImpactTaxMin
    //   && auctionSaleImpactTaxMax >= MIN_AUCTION_SALE_IMPACT_TAX_MAX,
    //   ERR_INVALID_AUCTION_SALE_IMPACT_TAX_MAX
    // )
    assert // Invalid auction sale impact tax maximum
    // smart_contracts/dao/contract.algo.ts:1150
    // (auctionSaleImpactTaxMax + auctionComposablePercentage) <= DIVISOR,
    frame_dig 11
    frame_dig 9
    +
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1150
    // (auctionSaleImpactTaxMax + auctionComposablePercentage) <= DIVISOR,
    <=
    // smart_contracts/dao/contract.algo.ts:1149-1152
    // assert(
    //   (auctionSaleImpactTaxMax + auctionComposablePercentage) <= DIVISOR,
    //   ERR_INVALID_TOTAL_PERCENTAGE_FEES
    // )
    assert // Invalid subscription total percentage fees
    // smart_contracts/dao/contract.algo.ts:1154
    // assert(auctionRafflePercentage <= DIVISOR, ERR_INVALID_AUCTION_RAFFLE_PERCENTAGE)
    frame_dig 10
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1154
    // assert(auctionRafflePercentage <= DIVISOR, ERR_INVALID_AUCTION_RAFFLE_PERCENTAGE)
    <=
    assert // Invalid auction raffle percentage
    // smart_contracts/dao/contract.algo.ts:1155
    // assert(raffleSaleImpactTaxMin >= MIN_RAFFLE_SALE_IMPACT_TAX_MIN, ERR_INVALID_RAFFLE_SALE_IMPACT_TAX_MIN)
    frame_dig 29
    dup
    // smart_contracts/utils/constants.ts:36
    // export const MIN_RAFFLE_SALE_IMPACT_TAX_MIN: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1155
    // assert(raffleSaleImpactTaxMin >= MIN_RAFFLE_SALE_IMPACT_TAX_MIN, ERR_INVALID_RAFFLE_SALE_IMPACT_TAX_MIN)
    >=
    assert // Invalid raffle sale impact tax minimum
    // smart_contracts/dao/contract.algo.ts:1157
    // raffleSaleImpactTaxMax > raffleSaleImpactTaxMin
    frame_dig 28
    <
    // smart_contracts/dao/contract.algo.ts:1157-1158
    // raffleSaleImpactTaxMax > raffleSaleImpactTaxMin
    // && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    bz finalizeProposal_bool_false@74
    // smart_contracts/dao/contract.algo.ts:1158
    // && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    frame_dig 28
    // smart_contracts/utils/constants.ts:37
    // export const MIN_RAFFLE_SALE_IMPACT_TAX_MAX: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1158
    // && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    >=
    // smart_contracts/dao/contract.algo.ts:1157-1158
    // raffleSaleImpactTaxMax > raffleSaleImpactTaxMin
    // && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    bz finalizeProposal_bool_false@74
    intc_1 // 1

finalizeProposal_bool_merge@75:
    // smart_contracts/dao/contract.algo.ts:1156-1160
    // assert(
    //   raffleSaleImpactTaxMax > raffleSaleImpactTaxMin
    //   && raffleSaleImpactTaxMax >= MIN_RAFFLE_SALE_IMPACT_TAX_MAX,
    //   ERR_INVALID_RAFFLE_SALE_IMPACT_TAX_MAX
    // )
    assert // Invalid raffle sale impact tax maximum
    // smart_contracts/dao/contract.algo.ts:1163
    // (raffleSaleImpactTaxMax + raffleComposablePercentage) < DIVISOR,
    frame_dig 28
    frame_dig 27
    +
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1163
    // (raffleSaleImpactTaxMax + raffleComposablePercentage) < DIVISOR,
    <
    // smart_contracts/dao/contract.algo.ts:1162-1165
    // assert(
    //   (raffleSaleImpactTaxMax + raffleComposablePercentage) < DIVISOR,
    //   ERR_INVALID_TOTAL_PERCENTAGE_FEES
    // )
    assert // Invalid subscription total percentage fees
    // smart_contracts/dao/contract.algo.ts:1167
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@74:
    intc_0 // 0
    b finalizeProposal_bool_merge@75

finalizeProposal_bool_false@70:
    intc_0 // 0
    b finalizeProposal_bool_merge@71

finalizeProposal_bool_false@66:
    intc_0 // 0
    b finalizeProposal_bool_merge@67

finalizeProposal_after_if_else@76:
    // smart_contracts/dao/constants.ts:13
    // export const AkitaDAOGlobalStateKeysSwapFees = 'swap_fees'
    frame_dig 1
    bytec 32 // "swap_fees"
    ==
    // smart_contracts/dao/contract.algo.ts:1169-1179
    // case AkitaDAOGlobalStateKeysSwapFees: {
    //   const swapFees = decodeArc4<SwapFees>(Bytes(value))
    //   assert(swapFees.impactTaxMin >= MIN_SWAP_IMPACT_TAX_MIN, ERR_INVALID_SWAP_IMPACT_TAX_MIN)
    //   assert(
    //     swapFees.impactTaxMax > swapFees.impactTaxMin
    //     && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    //     && swapFees.impactTaxMax <= DIVISOR,
    //     ERR_INVALID_SWAP_IMPACT_TAX_MAX
    //   )
    //   break
    // }
    bz finalizeProposal_after_if_else@83
    // smart_contracts/dao/contract.algo.ts:1170
    // const swapFees = decodeArc4<SwapFees>(Bytes(value))
    frame_dig 2
    dup
    pushint 2 // 2
    extract_uint64
    swap
    pushint 10 // 10
    extract_uint64
    dup
    cover 2
    frame_bury 32
    // smart_contracts/dao/contract.algo.ts:1171
    // assert(swapFees.impactTaxMin >= MIN_SWAP_IMPACT_TAX_MIN, ERR_INVALID_SWAP_IMPACT_TAX_MIN)
    dup
    // smart_contracts/utils/constants.ts:38
    // export const MIN_SWAP_IMPACT_TAX_MIN: uint64 = 10 // 0.01%
    pushint 10 // 10
    // smart_contracts/dao/contract.algo.ts:1171
    // assert(swapFees.impactTaxMin >= MIN_SWAP_IMPACT_TAX_MIN, ERR_INVALID_SWAP_IMPACT_TAX_MIN)
    >=
    assert // Invalid swap impact tax minimum
    // smart_contracts/dao/contract.algo.ts:1173
    // swapFees.impactTaxMax > swapFees.impactTaxMin
    >
    // smart_contracts/dao/contract.algo.ts:1173-1174
    // swapFees.impactTaxMax > swapFees.impactTaxMin
    // && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@81
    // smart_contracts/dao/contract.algo.ts:1174
    // && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    frame_dig 32
    // smart_contracts/utils/constants.ts:39
    // export const MIN_SWAP_IMPACT_TAX_MAX: uint64 = 1_000 // 1%
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1174
    // && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    >=
    // smart_contracts/dao/contract.algo.ts:1173-1174
    // swapFees.impactTaxMax > swapFees.impactTaxMin
    // && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    bz finalizeProposal_bool_false@81
    // smart_contracts/dao/contract.algo.ts:1175
    // && swapFees.impactTaxMax <= DIVISOR,
    frame_dig 32
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1175
    // && swapFees.impactTaxMax <= DIVISOR,
    <=
    // smart_contracts/dao/contract.algo.ts:1173-1175
    // swapFees.impactTaxMax > swapFees.impactTaxMin
    // && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    // && swapFees.impactTaxMax <= DIVISOR,
    bz finalizeProposal_bool_false@81
    intc_1 // 1

finalizeProposal_bool_merge@82:
    // smart_contracts/dao/contract.algo.ts:1172-1177
    // assert(
    //   swapFees.impactTaxMax > swapFees.impactTaxMin
    //   && swapFees.impactTaxMax >= MIN_SWAP_IMPACT_TAX_MAX
    //   && swapFees.impactTaxMax <= DIVISOR,
    //   ERR_INVALID_SWAP_IMPACT_TAX_MAX
    // )
    assert // Invalid swap impact tax maximum
    // smart_contracts/dao/contract.algo.ts:1178
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@81:
    intc_0 // 0
    b finalizeProposal_bool_merge@82

finalizeProposal_after_if_else@83:
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    frame_dig 1
    bytec 7 // "krby_percentage"
    ==
    // smart_contracts/dao/contract.algo.ts:1180-1184
    // case AkitaDAOGlobalStateKeysKrbyPercentage: {
    //   const krbyPercentage = btoi(Bytes(value))
    //   assert(krbyPercentage >= ONE_PERCENT && krbyPercentage < (DIVISOR - this.moderatorPercentage.value), ERR_INVALID_KRBY_PERCENTAGE)
    //   break
    // }
    bz finalizeProposal_after_if_else@89
    // smart_contracts/dao/contract.algo.ts:1181
    // const krbyPercentage = btoi(Bytes(value))
    frame_dig 5
    btoi
    dup
    frame_bury 18
    // smart_contracts/utils/constants.ts:41
    // export const ONE_PERCENT: uint64 = 1_000
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1182
    // assert(krbyPercentage >= ONE_PERCENT && krbyPercentage < (DIVISOR - this.moderatorPercentage.value), ERR_INVALID_KRBY_PERCENTAGE)
    >=
    bz finalizeProposal_bool_false@87
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    intc_0 // 0
    bytec 8 // "mod_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1182
    // assert(krbyPercentage >= ONE_PERCENT && krbyPercentage < (DIVISOR - this.moderatorPercentage.value), ERR_INVALID_KRBY_PERCENTAGE)
    swap
    -
    frame_dig 18
    >
    bz finalizeProposal_bool_false@87
    intc_1 // 1

finalizeProposal_bool_merge@88:
    // smart_contracts/dao/contract.algo.ts:1182
    // assert(krbyPercentage >= ONE_PERCENT && krbyPercentage < (DIVISOR - this.moderatorPercentage.value), ERR_INVALID_KRBY_PERCENTAGE)
    assert // Invalid krby percentage
    // smart_contracts/dao/contract.algo.ts:1183
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@87:
    intc_0 // 0
    b finalizeProposal_bool_merge@88

finalizeProposal_after_if_else@89:
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    frame_dig 1
    bytec 8 // "mod_percentage"
    ==
    // smart_contracts/dao/contract.algo.ts:1185-1189
    // case AkitaDAOGlobalStateKeysModeratorPercentage: {
    //   const modPercentage = btoi(Bytes(value))
    //   assert(modPercentage >= ONE_PERCENT && modPercentage < (DIVISOR - this.krbyPercentage.value), ERR_INVALID_MOD_PERCENTAGE)
    //   break
    // }
    bz finalizeProposal_after_if_else@95
    // smart_contracts/dao/contract.algo.ts:1186
    // const modPercentage = btoi(Bytes(value))
    frame_dig 5
    btoi
    dup
    frame_bury 22
    // smart_contracts/utils/constants.ts:41
    // export const ONE_PERCENT: uint64 = 1_000
    intc 6 // 1000
    // smart_contracts/dao/contract.algo.ts:1187
    // assert(modPercentage >= ONE_PERCENT && modPercentage < (DIVISOR - this.krbyPercentage.value), ERR_INVALID_MOD_PERCENTAGE)
    >=
    bz finalizeProposal_bool_false@93
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    intc_0 // 0
    bytec 7 // "krby_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/dao/contract.algo.ts:1187
    // assert(modPercentage >= ONE_PERCENT && modPercentage < (DIVISOR - this.krbyPercentage.value), ERR_INVALID_MOD_PERCENTAGE)
    swap
    -
    frame_dig 22
    >
    bz finalizeProposal_bool_false@93
    intc_1 // 1

finalizeProposal_bool_merge@94:
    // smart_contracts/dao/contract.algo.ts:1187
    // assert(modPercentage >= ONE_PERCENT && modPercentage < (DIVISOR - this.krbyPercentage.value), ERR_INVALID_MOD_PERCENTAGE)
    assert // Invalid moderator percentage
    // smart_contracts/dao/contract.algo.ts:1188
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@93:
    intc_0 // 0
    b finalizeProposal_bool_merge@94

finalizeProposal_after_if_else@95:
    // smart_contracts/dao/constants.ts:17
    // export const AkitaDAOGlobalStateKeysProposalFee = 'proposal_fee'
    frame_dig 1
    bytec 36 // "proposal_fee"
    ==
    // smart_contracts/dao/contract.algo.ts:1190-1194
    // case AkitaDAOGlobalStateKeysProposalFee: {
    //   const proposalFee = btoi(Bytes(value))
    //   assert(proposalFee >= FIVE_ALGO, ERR_INVALID_PROPOSAL_FEE)
    //   break
    // }
    bz finalizeProposal_after_if_else@97
    // smart_contracts/dao/contract.algo.ts:1191
    // const proposalFee = btoi(Bytes(value))
    frame_dig 5
    btoi
    // smart_contracts/utils/constants.ts:47
    // export const FIVE_ALGO: uint64 = 5_000_000
    pushint 5000000 // 5000000
    // smart_contracts/dao/contract.algo.ts:1192
    // assert(proposalFee >= FIVE_ALGO, ERR_INVALID_PROPOSAL_FEE)
    >=
    assert // Invalid proposal fee
    // smart_contracts/dao/contract.algo.ts:1193
    // break
    b finalizeProposal_while_top@33

finalizeProposal_after_if_else@97:
    // smart_contracts/dao/constants.ts:27
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    frame_dig 1
    bytec 13 // "revocation_address"
    ==
    // smart_contracts/dao/contract.algo.ts:1195-1200
    // case AkitaDAOGlobalStateKeysRevocationAddress: {
    //   assert(Bytes(value).length === ACCOUNT_LENGTH, ERR_INVALID_CONTENT_POLICY)
    //   const revocationAddress = Account(Bytes(value))
    //   assert(revocationAddress !== this.revocationAddress.value && revocationAddress !== Global.zeroAddress, ERR_INVALID_REVOCATION_ADDRESS)
    //   break
    // }
    assert // Invalid field
    // smart_contracts/dao/contract.algo.ts:1196
    // assert(Bytes(value).length === ACCOUNT_LENGTH, ERR_INVALID_CONTENT_POLICY)
    frame_dig 5
    dup
    len
    // smart_contracts/utils/constants.ts:53
    // export const ACCOUNT_LENGTH: uint64 = 58
    pushint 58 // 58
    // smart_contracts/dao/contract.algo.ts:1196
    // assert(Bytes(value).length === ACCOUNT_LENGTH, ERR_INVALID_CONTENT_POLICY)
    ==
    assert // Invalid content policy
    // smart_contracts/dao/constants.ts:27
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    intc_0 // 0
    bytec 13 // "revocation_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1198
    // assert(revocationAddress !== this.revocationAddress.value && revocationAddress !== Global.zeroAddress, ERR_INVALID_REVOCATION_ADDRESS)
    !=
    bz finalizeProposal_bool_false@101
    frame_dig 5
    global ZeroAddress
    !=
    bz finalizeProposal_bool_false@101
    intc_1 // 1

finalizeProposal_bool_merge@102:
    // smart_contracts/dao/contract.algo.ts:1198
    // assert(revocationAddress !== this.revocationAddress.value && revocationAddress !== Global.zeroAddress, ERR_INVALID_REVOCATION_ADDRESS)
    assert // Invalid revocation address
    // smart_contracts/dao/contract.algo.ts:1199
    // break
    b finalizeProposal_while_top@33

finalizeProposal_bool_false@101:
    intc_0 // 0
    b finalizeProposal_bool_merge@102


// smart_contracts/dao/contract.algo.ts::AkitaDAO.createDailyDisbursement() -> void:
createDailyDisbursement:
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    intc_0 // 0
    bytec 12 // "akita_assets"
    app_global_get_ex
    bury 1
    assert // check GlobalState exists
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_pluginOptinEscrow(plugin: uint64, caller: bytes, assets: bytes, mbrPayment: uint64) -> void:
arc58_pluginOptinEscrow:
    // smart_contracts/dao/contract.algo.ts:1618-1623
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    proto 4 0
    intc_0 // 0
    bytec_1 // ""
    dup
    // smart_contracts/dao/contract.algo.ts:1624
    // const key: PluginKey = { application: plugin, allowedCaller: caller.native };
    frame_dig -4
    itob
    // smart_contracts/dao/contract.algo.ts:1626
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    frame_dig -3
    concat
    // smart_contracts/arc58/account/constants.ts:15
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec 6 // "p"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1626
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/dao/contract.algo.ts:1627
    // const pluginInfo = decodeArc4<PluginInfo>(this.plugins(key).value.copy().bytes);
    box_get
    assert // Box must have value
    pushint 2 // 2
    extract_uint64
    dup
    // smart_contracts/dao/contract.algo.ts:1628
    // assert(pluginInfo.escrow !== 0, ERR_NOT_USING_ESCROW);
    assert // Not using escrow for this plugin
    // smart_contracts/dao/contract.algo.ts:1630
    // Txn.sender === Application(plugin).address ||
    txn Sender
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/dao/contract.algo.ts:1630-1631
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3
    // smart_contracts/dao/contract.algo.ts:1631
    // Txn.sender === caller.native ||
    txn Sender
    frame_dig -3
    ==
    // smart_contracts/dao/contract.algo.ts:1630-1631
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3
    // smart_contracts/dao/contract.algo.ts:1632
    // caller.native === Global.zeroAddress,
    frame_dig -3
    global ZeroAddress
    ==
    // smart_contracts/dao/contract.algo.ts:1630-1632
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    // caller.native === Global.zeroAddress,
    bz arc58_pluginOptinEscrow_bool_false@4

arc58_pluginOptinEscrow_bool_true@3:
    intc_1 // 1

arc58_pluginOptinEscrow_bool_merge@5:
    // smart_contracts/dao/contract.algo.ts:1629-1634
    // assert(
    //   Txn.sender === Application(plugin).address ||
    //   Txn.sender === caller.native ||
    //   caller.native === Global.zeroAddress,
    //   ERR_FORBIDDEN
    // );
    assert // only the creator wallet can delete a spending account
    // smart_contracts/dao/contract.algo.ts:1636
    // const escrowAddress = Application(pluginInfo.escrow).address
    frame_dig 3
    app_params_get AppAddress
    swap
    frame_bury 0
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:1638-1645
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -1
    gtxns Receiver
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1638-1645
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz arc58_pluginOptinEscrow_bool_false@8
    frame_dig -1
    gtxns Amount
    // smart_contracts/dao/contract.algo.ts:1642
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    *
    // smart_contracts/dao/contract.algo.ts:1638-1645
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz arc58_pluginOptinEscrow_bool_false@8
    intc_1 // 1

arc58_pluginOptinEscrow_bool_merge@9:
    // smart_contracts/dao/contract.algo.ts:1638-1645
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/dao/contract.algo.ts:1647-1654
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length,
    //     fee,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/constants.ts:4
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1651
    // amount: Global.assetOptInMinBalance * assets.length,
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    *
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1647-1653
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1647-1654
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length,
    //     fee,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/dao/contract.algo.ts:1656
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 1

arc58_pluginOptinEscrow_while_top@11:
    // smart_contracts/dao/contract.algo.ts:1656
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 1
    frame_dig 2
    <
    bz arc58_pluginOptinEscrow_after_while@14
    // smart_contracts/dao/contract.algo.ts:1658
    // this.allowances({ escrow: pluginInfo.escrow, asset: assets[i] }).exists,
    frame_dig -2
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    frame_dig 3
    itob
    dig 1
    itob
    concat
    // smart_contracts/arc58/account/constants.ts:18
    // export const AbstractAccountBoxPrefixAllowances = 'a'
    pushbytes "a"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1658
    // this.allowances({ escrow: pluginInfo.escrow, asset: assets[i] }).exists,
    box_len
    bury 1
    // smart_contracts/dao/contract.algo.ts:1657-1660
    // assert(
    //   this.allowances({ escrow: pluginInfo.escrow, asset: assets[i] }).exists,
    //   ERR_ALLOWANCE_DOES_NOT_EXIST
    // );
    assert // allowance does not exist
    // smart_contracts/dao/contract.algo.ts:1662-1670
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i],
    //     fee,
    //   })
    //   .submit();
    itxn_begin
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:1666
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    frame_dig 0
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1662-1669
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i],
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1662-1670
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i],
    //     fee,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/dao/contract.algo.ts:1656
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 1
    b arc58_pluginOptinEscrow_while_top@11

arc58_pluginOptinEscrow_after_while@14:
    retsub

arc58_pluginOptinEscrow_bool_false@8:
    intc_0 // 0
    b arc58_pluginOptinEscrow_bool_merge@9

arc58_pluginOptinEscrow_bool_false@4:
    intc_0 // 0
    b arc58_pluginOptinEscrow_bool_merge@5


// smart_contracts/dao/contract.algo.ts::AkitaDAO.optinReceiveEscrow(payment: uint64, name: bytes, asset: uint64) -> void:
optinReceiveEscrow:
    // smart_contracts/dao/contract.algo.ts:1679
    // optinReceiveEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    proto 3 0
    intc_0 // 0
    dupn 2
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 27 // "e"
    frame_dig -2
    concat
    // smart_contracts/dao/contract.algo.ts:1681
    // const eid = this.escrows(name).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1682
    // assert(this.receiveEscrows(eid).exists, ERR_ESCROW_DOES_NOT_EXIST)
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    dupn 2
    // smart_contracts/dao/contract.algo.ts:1682
    // assert(this.receiveEscrows(eid).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/dao/contract.algo.ts:1684
    // const escrow = this.receiveEscrows(eid).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    extract 8 32 // on error: Index access is out of bounds
    uncover 2
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/dao/contract.algo.ts:1685
    // const escrowAccount = Application(escrow.escrow).address
    uncover 2
    app_params_get AppAddress
    swap
    cover 3
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:1687
    // assert(escrow.caller.native === Txn.sender, ERR_INCORRECT_SENDER)
    txn Sender
    uncover 2
    ==
    assert // Incorrect sender
    // smart_contracts/dao/contract.algo.ts:1688
    // assert(escrow.optinAllowed === true, ERR_ESCROW_NOT_ALLOWED_TO_OPTIN)
    intc_1 // 1
    ==
    assert // Escrow is not allowed to opt-in
    // smart_contracts/dao/contract.algo.ts:1690-1697
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (Global.assetOptInMinBalance * 4),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    // smart_contracts/dao/contract.algo.ts:1693
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:1690-1697
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (Global.assetOptInMinBalance * 4),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optinReceiveEscrow_bool_false@3
    frame_dig -3
    gtxns Amount
    // smart_contracts/dao/contract.algo.ts:1694
    // amount: (Global.assetOptInMinBalance * 4),
    global AssetOptInMinBalance
    pushint 4 // 4
    *
    // smart_contracts/dao/contract.algo.ts:1690-1697
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (Global.assetOptInMinBalance * 4),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optinReceiveEscrow_bool_false@3
    intc_1 // 1

optinReceiveEscrow_bool_merge@4:
    // smart_contracts/dao/contract.algo.ts:1690-1697
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (Global.assetOptInMinBalance * 4),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/dao/contract.algo.ts:1699-1705
    // itxnCompose.begin(
    //   itxn.payment({
    //     receiver: escrowAccount,
    //     amount: Global.assetOptInMinBalance,
    //     fee,
    //   })
    // )
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:1702
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    itxn_field Amount
    frame_dig 4
    dup
    itxn_field Receiver
    // smart_contracts/dao/contract.algo.ts:1700-1704
    // itxn.payment({
    //   receiver: escrowAccount,
    //   amount: Global.assetOptInMinBalance,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1707-1715
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender: escrowAccount,
    //     assetReceiver: escrowAccount,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    // )
    itxn_next
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:1711
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1708-1714
    // itxn.assetTransfer({
    //   sender: escrowAccount,
    //   assetReceiver: escrowAccount,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1719
    // optinCount: this.receiveEscrows(eid).value.optinCount + 1,
    frame_dig 3
    dup
    box_get
    assert // Box must have value
    dup
    intc 7 // 320
    getbit
    dig 1
    intc 5 // 321
    getbit
    dig 2
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    +
    // smart_contracts/dao/contract.algo.ts:1718
    // ...this.receiveEscrows(eid).value,
    dig 3
    intc_0 // 0
    extract_uint64
    dig 4
    extract 8 32 // on error: Index access is out of bounds
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    dig 5
    extract 49 1 // on error: Index access is out of bounds
    dig 6
    pushint 50 // 50
    extract_uint64
    dig 7
    pushint 58 // 58
    extract_uint64
    uncover 8
    pushint 66 // 66
    extract_uint64
    uncover 7
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:1719
    // optinCount: this.receiveEscrows(eid).value.optinCount + 1,
    uncover 8
    itob
    // smart_contracts/dao/contract.algo.ts:1718
    // ...this.receiveEscrows(eid).value,
    uncover 6
    itob
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1717
    // this.receiveEscrows(eid).value = {
    uncover 6
    uncover 8
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1717-1720
    // this.receiveEscrows(eid).value = {
    //   ...this.receiveEscrows(eid).value,
    //   optinCount: this.receiveEscrows(eid).value.optinCount + 1,
    // }
    box_put
    // smart_contracts/dao/contract.algo.ts:1722
    // const daoNeedsToOptIn = !Global.currentApplicationAddress.isOptedIn(Asset(asset))
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/dao/contract.algo.ts:1723
    // if (daoNeedsToOptIn) {
    bnz optinReceiveEscrow_after_if_else@6
    // smart_contracts/dao/contract.algo.ts:1724-1732
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/dao/contract.algo.ts:1726
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:1727
    // assetReceiver: Global.currentApplicationAddress,
    dup
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:1728
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1725-1731
    // itxn.assetTransfer({
    //   sender: Global.currentApplicationAddress,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee

optinReceiveEscrow_after_if_else@6:
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 28 // "emoderators"
    // smart_contracts/dao/contract.algo.ts:1735
    // const modEid = this.escrows(AkitaDAOEscrowAccountModerators).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1736
    // const modAccount = this.receiveEscrows(modEid).value.caller.native
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1736
    // const modAccount = this.receiveEscrows(modEid).value.caller.native
    box_get
    assert // Box must have value
    extract 8 32 // on error: Index access is out of bounds
    dup
    frame_bury 2
    // smart_contracts/dao/contract.algo.ts:1737
    // const modFundNeedsToOptIn = !modAccount.isOptedIn(Asset(asset))
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/dao/contract.algo.ts:1738
    // if (modFundNeedsToOptIn) {
    bnz optinReceiveEscrow_after_if_else@8
    // smart_contracts/dao/contract.algo.ts:1739-1745
    // itxnCompose.next(
    //   itxn.payment({
    //     receiver: modAccount,
    //     amount: Global.assetOptInMinBalance,
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/dao/contract.algo.ts:1742
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    itxn_field Amount
    frame_dig 2
    dup
    itxn_field Receiver
    // smart_contracts/dao/contract.algo.ts:1740-1744
    // itxn.payment({
    //   receiver: modAccount,
    //   amount: Global.assetOptInMinBalance,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1747-1755
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender: modAccount,
    //     assetReceiver: modAccount,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    // )
    itxn_next
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:1751
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1748-1754
    // itxn.assetTransfer({
    //   sender: modAccount,
    //   assetReceiver: modAccount,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 28 // "emoderators"
    // smart_contracts/dao/contract.algo.ts:1757
    // const modEscrow = this.escrows(AkitaDAOEscrowAccountModerators).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1761
    // optinCount: this.receiveEscrows(modEscrow).value.optinCount + 1,
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1761
    // optinCount: this.receiveEscrows(modEscrow).value.optinCount + 1,
    dup
    box_get
    assert // Box must have value
    dup
    intc 7 // 320
    getbit
    dig 1
    intc 5 // 321
    getbit
    dig 2
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    +
    // smart_contracts/dao/contract.algo.ts:1760
    // ...this.receiveEscrows(modEscrow).value,
    dig 3
    intc_0 // 0
    extract_uint64
    dig 4
    extract 8 32 // on error: Index access is out of bounds
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    dig 5
    extract 49 1 // on error: Index access is out of bounds
    dig 6
    pushint 50 // 50
    extract_uint64
    dig 7
    pushint 58 // 58
    extract_uint64
    uncover 8
    pushint 66 // 66
    extract_uint64
    uncover 7
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:1761
    // optinCount: this.receiveEscrows(modEscrow).value.optinCount + 1,
    uncover 8
    itob
    // smart_contracts/dao/contract.algo.ts:1760
    // ...this.receiveEscrows(modEscrow).value,
    uncover 6
    itob
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1759
    // this.receiveEscrows(modEscrow).value = {
    uncover 6
    uncover 8
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1759-1762
    // this.receiveEscrows(modEscrow).value = {
    //   ...this.receiveEscrows(modEscrow).value,
    //   optinCount: this.receiveEscrows(modEscrow).value.optinCount + 1,
    // }
    box_put

optinReceiveEscrow_after_if_else@8:
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 38 // "ekrby"
    // smart_contracts/dao/contract.algo.ts:1765
    // const krbyEscrow = this.escrows(AkitaDAOEscrowAccountKrby).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1766
    // const krbyAccount = this.receiveEscrows(krbyEscrow).value.caller.native
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:1766
    // const krbyAccount = this.receiveEscrows(krbyEscrow).value.caller.native
    box_get
    assert // Box must have value
    extract 8 32 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:1767
    // const krbyFundNeedsToOptIn = !krbyAccount.isOptedIn(Asset(asset))
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/dao/contract.algo.ts:1768
    // if (krbyFundNeedsToOptIn) {
    bnz optinReceiveEscrow_after_if_else@10
    // smart_contracts/dao/contract.algo.ts:1769-1775
    // itxnCompose.next(
    //   itxn.payment({
    //     receiver: krbyAccount,
    //     amount: Global.assetOptInMinBalance,
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/dao/contract.algo.ts:1772
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    itxn_field Amount
    frame_dig 1
    dup
    itxn_field Receiver
    // smart_contracts/dao/contract.algo.ts:1770-1774
    // itxn.payment({
    //   receiver: krbyAccount,
    //   amount: Global.assetOptInMinBalance,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1777-1785
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender: krbyAccount,
    //     assetReceiver: krbyAccount,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    // )
    itxn_next
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:1781
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1778-1784
    // itxn.assetTransfer({
    //   sender: krbyAccount,
    //   assetReceiver: krbyAccount,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1789
    // optinCount: this.receiveEscrows(krbyEscrow).value.optinCount + 1,
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    dup
    intc 7 // 320
    getbit
    dig 1
    intc 5 // 321
    getbit
    dig 2
    pushint 41 // 41
    extract_uint64
    intc_1 // 1
    +
    // smart_contracts/dao/contract.algo.ts:1788
    // ...this.receiveEscrows(krbyEscrow).value,
    dig 3
    intc_0 // 0
    extract_uint64
    dig 4
    extract 8 32 // on error: Index access is out of bounds
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 6
    setbit
    intc_0 // 0
    getbit
    dig 5
    extract 49 1 // on error: Index access is out of bounds
    dig 6
    pushint 50 // 50
    extract_uint64
    dig 7
    pushint 58 // 58
    extract_uint64
    uncover 8
    pushint 66 // 66
    extract_uint64
    uncover 7
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    // smart_contracts/dao/contract.algo.ts:1789
    // optinCount: this.receiveEscrows(krbyEscrow).value.optinCount + 1,
    uncover 8
    itob
    // smart_contracts/dao/contract.algo.ts:1788
    // ...this.receiveEscrows(krbyEscrow).value,
    uncover 6
    itob
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1787
    // this.receiveEscrows(krbyEscrow).value = {
    uncover 6
    uncover 8
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1787-1790
    // this.receiveEscrows(krbyEscrow).value = {
    //   ...this.receiveEscrows(krbyEscrow).value,
    //   optinCount: this.receiveEscrows(krbyEscrow).value.optinCount + 1,
    // }
    box_put

optinReceiveEscrow_after_if_else@10:
    // smart_contracts/dao/contract.algo.ts:1793
    // itxnCompose.submit()
    itxn_submit
    retsub

optinReceiveEscrow_bool_false@3:
    intc_0 // 0
    b optinReceiveEscrow_bool_merge@4


// smart_contracts/dao/contract.algo.ts::AkitaDAO.startEscrowDisbursement(escrow: bytes) -> void:
startEscrowDisbursement:
    // smart_contracts/dao/contract.algo.ts:1796
    // startEscrowDisbursement(escrow: string): void {
    proto 1 0
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 27 // "e"
    frame_dig -1
    concat
    // smart_contracts/dao/contract.algo.ts:1797
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/dao/contract.algo.ts:1798
    // assert(this.receiveEscrows(this.escrows(escrow).value).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_get
    assert // Box must have value
    btoi
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1798
    // assert(this.receiveEscrows(this.escrows(escrow).value).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/dao/contract.algo.ts:1801
    // const info = this.receiveEscrows(name).value
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    extract 8 32 // on error: Index access is out of bounds
    dig 2
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 3
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 4
    pushint 41 // 41
    extract_uint64
    dig 5
    extract 49 1 // on error: Index access is out of bounds
    dig 6
    pushint 50 // 50
    extract_uint64
    dig 7
    pushint 58 // 58
    extract_uint64
    uncover 8
    pushint 66 // 66
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1802
    // assert(info.phase === EscrowDisbursementPhaseIdle, ERR_ESCROW_NOT_IDLE)
    uncover 3
    // smart_contracts/dao/constants.ts:51
    // export const EscrowDisbursementPhaseIdle = new UintN8(0)
    bytec_0 // 0x00
    // smart_contracts/dao/contract.algo.ts:1802
    // assert(info.phase === EscrowDisbursementPhaseIdle, ERR_ESCROW_NOT_IDLE)
    ==
    assert // Escrow is not in idle phase
    // smart_contracts/dao/contract.algo.ts:1803
    // assert(info.allocatable, ERR_ESCROW_NOT_ALLOCATABLE)
    dig 5
    assert // Escrow is not allocatable
    // smart_contracts/dao/contract.algo.ts:1805
    // const latestWindow: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - info.creationDate) % ONE_DAY)
    global LatestTimestamp
    dup
    dig 2
    -
    // smart_contracts/gates/plugins/staking-power/constants.ts:3
    // export const ONE_DAY: uint64 = 86400
    intc 12 // 86400
    // smart_contracts/dao/contract.algo.ts:1805
    // const latestWindow: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - info.creationDate) % ONE_DAY)
    %
    -
    // smart_contracts/dao/contract.algo.ts:1806
    // assert(latestWindow >= info.lastDisbursement, ERR_ESCROW_NOT_READY_FOR_DISBURSEMENT)
    dup
    uncover 3
    >=
    assert // Escrow is not ready for disbursement
    // smart_contracts/dao/contract.algo.ts:1801
    // const info = this.receiveEscrows(name).value
    uncover 7
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1811
    // lastDisbursement: latestWindow,
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:1801
    // const info = this.receiveEscrows(name).value
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1808
    // this.receiveEscrows(name).value = {
    uncover 6
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    // smart_contracts/dao/constants.ts:53
    // export const EscrowDisbursementPhaseAllocation = new UintN8(20)
    bytec 9 // 0x14
    // smart_contracts/dao/contract.algo.ts:1808
    // this.receiveEscrows(name).value = {
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1808-1812
    // this.receiveEscrows(name).value = {
    //   ...info,
    //   phase: EscrowDisbursementPhaseAllocation,
    //   lastDisbursement: latestWindow,
    // }
    box_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.processEscrowAllocation(escrow: bytes, ids: bytes) -> void:
processEscrowAllocation:
    // smart_contracts/dao/contract.algo.ts:1815
    // processEscrowAllocation(escrow: string, ids: uint64[]): void {
    proto 2 0
    intc_0 // 0
    bytec_1 // ""
    dupn 3
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 27 // "e"
    frame_dig -2
    concat
    // smart_contracts/dao/contract.algo.ts:1816
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/dao/contract.algo.ts:1817
    // const eid = this.escrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1818
    // const info = this.receiveEscrows(eid).value
    itob
    dup
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    dup
    // smart_contracts/dao/contract.algo.ts:1818
    // const info = this.receiveEscrows(eid).value
    box_get
    assert // Box must have value
    dup
    extract 8 32 // on error: Index access is out of bounds
    swap
    dup
    pushint 41 // 41
    extract_uint64
    swap
    extract 49 1 // on error: Index access is out of bounds
    // smart_contracts/dao/constants.ts:53
    // export const EscrowDisbursementPhaseAllocation = new UintN8(20)
    bytec 9 // 0x14
    // smart_contracts/dao/contract.algo.ts:1819
    // assert(info.phase === EscrowDisbursementPhaseAllocation, ERR_ESCROW_NOT_IN_ALLOCATION_PHASE)
    ==
    assert // Escrow is not in allocation phase
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 38 // "ekrby"
    // smart_contracts/dao/contract.algo.ts:1822
    // const krbyEid = this.escrows(AkitaDAOEscrowAccountKrby).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1823
    // const krby = this.receiveEscrows(krbyEid).value.caller.native
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1823
    // const krby = this.receiveEscrows(krbyEid).value.caller.native
    box_get
    assert // Box must have value
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/dao/constants.ts:33
    // export const AkitDAOBoxPrefixEscrows = 'e'
    bytec 28 // "emoderators"
    // smart_contracts/dao/contract.algo.ts:1824
    // const modEid = this.escrows(AkitaDAOEscrowAccountModerators).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/dao/contract.algo.ts:1825
    // const moderators = this.receiveEscrows(modEid).value.caller.native
    itob
    // smart_contracts/dao/constants.ts:35
    // export const AkitaDAOBoxPrefixReceiveEscrows = 'r'
    bytec 4 // "r"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1825
    // const moderators = this.receiveEscrows(modEid).value.caller.native
    box_get
    assert // Box must have value
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/dao/contract.algo.ts:1827
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    intc_0 // 0

processEscrowAllocation_while_top@1:
    // smart_contracts/dao/contract.algo.ts:1827
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 4
    frame_dig 11
    >
    bz processEscrowAllocation_after_while@18
    // smart_contracts/dao/contract.algo.ts:1828
    // const asset = ids[i]
    frame_dig -1
    extract 2 0
    frame_dig 11
    intc_2 // 8
    *
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:1829
    // assert(!this.receiveAssets({ escrow: eid, asset }).exists, ERR_ASSET_ALREADY_ALLOCATED)
    dup
    itob
    frame_dig 5
    swap
    concat
    // smart_contracts/dao/constants.ts:34
    // export const AkitDAOBoxPrefixEscrowAssets = 's'
    pushbytes "s"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:1829
    // assert(!this.receiveAssets({ escrow: eid, asset }).exists, ERR_ASSET_ALREADY_ALLOCATED)
    box_len
    bury 1
    !
    assert // Asset is already allocated
    // smart_contracts/dao/contract.algo.ts:1830
    // assert(sender.isOptedIn(Asset(asset)), ERR_ESCROW_NOT_OPTED_IN)
    frame_dig 7
    dup
    dig 2
    asset_holding_get AssetBalance
    bury 1
    assert // Escrow is not opted in to the asset
    // smart_contracts/dao/contract.algo.ts:1832
    // const [balance] = AssetHolding.assetBalance(sender, asset)
    dig 1
    asset_holding_get AssetBalance
    pop
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    intc_0 // 0
    bytec 7 // "krby_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:70
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/utils/functions.ts:70
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:71
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 1
    mulw
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/utils/functions.ts:71
    // return op.divw(...op.mulw(a, p), DIVISOR)
    divw
    dup
    cover 2
    cover 3
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    intc_0 // 0
    bytec 8 // "mod_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:70
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/utils/functions.ts:70
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:71
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 1
    mulw
    // smart_contracts/utils/constants.ts:18
    // export const DIVISOR: uint64 = 100_000 // 100%
    intc 4 // 100000
    // smart_contracts/utils/functions.ts:71
    // return op.divw(...op.mulw(a, p), DIVISOR)
    divw
    dup
    frame_bury 3
    // smart_contracts/dao/contract.algo.ts:1836
    // const leftover: uint64 = balance - (krbyAmount + moderatorAmount)
    uncover 2
    +
    -
    frame_bury 2
    // smart_contracts/dao/contract.algo.ts:1839
    // if (asset === 0) {
    bnz processEscrowAllocation_else_body@5
    // smart_contracts/dao/contract.algo.ts:1840-1847
    // itxn
    //   .payment({
    //     sender,
    //     receiver: krby,
    //     amount: krbyAmount,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    itxn_field Amount
    frame_dig 9
    itxn_field Receiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1840-1846
    // itxn
    //   .payment({
    //     sender,
    //     receiver: krby,
    //     amount: krbyAmount,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1840-1847
    // itxn
    //   .payment({
    //     sender,
    //     receiver: krby,
    //     amount: krbyAmount,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

processEscrowAllocation_after_if_else@7:
    // smart_contracts/dao/contract.algo.ts:1861
    // if (asset === 0) {
    frame_dig 1
    bnz processEscrowAllocation_else_body@10
    // smart_contracts/dao/contract.algo.ts:1862-1869
    // itxn
    //   .payment({
    //     sender,
    //     receiver: moderators,
    //     amount: moderatorAmount,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig 3
    itxn_field Amount
    frame_dig 10
    itxn_field Receiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1862-1868
    // itxn
    //   .payment({
    //     sender,
    //     receiver: moderators,
    //     amount: moderatorAmount,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1862-1869
    // itxn
    //   .payment({
    //     sender,
    //     receiver: moderators,
    //     amount: moderatorAmount,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

processEscrowAllocation_after_if_else@12:
    // smart_contracts/dao/contract.algo.ts:1883
    // if (asset === 0) {
    frame_dig 1
    bnz processEscrowAllocation_else_body@15
    // smart_contracts/dao/contract.algo.ts:1884-1891
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: leftover,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:1887
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1884-1890
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: leftover,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1884-1891
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: leftover,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

processEscrowAllocation_after_if_else@17:
    // smart_contracts/dao/contract.algo.ts:1904
    // this.receiveAssets({ escrow: eid, asset }).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    // smart_contracts/dao/contract.algo.ts:1827
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    frame_dig 11
    intc_1 // 1
    +
    frame_bury 11
    b processEscrowAllocation_while_top@1

processEscrowAllocation_else_body@15:
    // smart_contracts/dao/contract.algo.ts:1893-1901
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: leftover,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:1896
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig 1
    itxn_field XferAsset
    frame_dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1893-1900
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: leftover,
    //     xferAsset: asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1893-1901
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: leftover,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    b processEscrowAllocation_after_if_else@17

processEscrowAllocation_else_body@10:
    // smart_contracts/dao/contract.algo.ts:1871-1879
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: moderators,
    //     assetAmount: moderatorAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig 1
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    frame_dig 10
    itxn_field AssetReceiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1871-1878
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: moderators,
    //     assetAmount: moderatorAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1871-1879
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: moderators,
    //     assetAmount: moderatorAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    b processEscrowAllocation_after_if_else@12

processEscrowAllocation_else_body@5:
    // smart_contracts/dao/contract.algo.ts:1849-1857
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: krby,
    //     assetAmount: krbyAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig 1
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig 9
    itxn_field AssetReceiver
    frame_dig 7
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1849-1856
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: krby,
    //     assetAmount: krbyAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1849-1857
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: krby,
    //     assetAmount: krbyAmount,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    b processEscrowAllocation_after_if_else@7

processEscrowAllocation_after_while@18:
    // smart_contracts/dao/contract.algo.ts:1907
    // const allocationCounter: uint64 = this.receiveEscrows(eid).value.allocationCounter + ids.length
    frame_dig 6
    box_get
    assert // Box must have value
    pushint 50 // 50
    extract_uint64
    frame_dig 4
    +
    dup
    // smart_contracts/dao/contract.algo.ts:1909
    // if (allocationCounter === (info.optinCount + 1)) {
    frame_dig 8
    intc_1 // 1
    +
    ==
    bz processEscrowAllocation_else_body@20
    // smart_contracts/dao/contract.algo.ts:1911
    // ...this.receiveEscrows(eid).value,
    frame_dig 6
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc 7 // 320
    getbit
    dig 2
    intc 5 // 321
    getbit
    dig 3
    extract 8 32 // on error: Index access is out of bounds
    bytec_0 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_0 // 0
    getbit
    dig 4
    pushint 41 // 41
    extract_uint64
    dig 5
    pushint 58 // 58
    extract_uint64
    uncover 6
    pushint 66 // 66
    extract_uint64
    uncover 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 7
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 7
    setbit
    uncover 5
    itob
    // smart_contracts/dao/contract.algo.ts:1912
    // allocationCounter,
    uncover 8
    itob
    // smart_contracts/dao/contract.algo.ts:1911
    // ...this.receiveEscrows(eid).value,
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1910
    // this.receiveEscrows(eid).value = {
    uncover 6
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    // smart_contracts/dao/constants.ts:54
    // export const EscrowDisbursementPhaseFinalization = new UintN8(30)
    bytec 26 // 0x1e
    // smart_contracts/dao/contract.algo.ts:1910
    // this.receiveEscrows(eid).value = {
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1910-1914
    // this.receiveEscrows(eid).value = {
    //   ...this.receiveEscrows(eid).value,
    //   allocationCounter,
    //   phase: EscrowDisbursementPhaseFinalization,
    // }
    box_put
    retsub

processEscrowAllocation_else_body@20:
    // smart_contracts/dao/contract.algo.ts:1917
    // ...this.receiveEscrows(eid).value,
    frame_dig 6
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc 7 // 320
    getbit
    dig 2
    intc 5 // 321
    getbit
    dig 3
    extract 8 32 // on error: Index access is out of bounds
    bytec_0 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_0 // 0
    getbit
    dig 4
    pushint 41 // 41
    extract_uint64
    dig 5
    extract 49 1 // on error: Index access is out of bounds
    dig 6
    pushint 58 // 58
    extract_uint64
    uncover 7
    pushint 66 // 66
    extract_uint64
    uncover 7
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 8
    setbit
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1918
    // allocationCounter,
    uncover 9
    itob
    // smart_contracts/dao/contract.algo.ts:1917
    // ...this.receiveEscrows(eid).value,
    uncover 6
    itob
    uncover 6
    itob
    // smart_contracts/dao/contract.algo.ts:1916
    // this.receiveEscrows(eid).value = {
    uncover 6
    uncover 8
    concat
    uncover 6
    concat
    uncover 5
    intc_0 // 0
    getbit
    intc 5 // 321
    swap
    setbit
    uncover 4
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1916-1919
    // this.receiveEscrows(eid).value = {
    //   ...this.receiveEscrows(eid).value,
    //   allocationCounter,
    // }
    box_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.getState() -> uint64, bytes, bytes, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, bytes:
getState:
    // smart_contracts/dao/constants.ts:4
    // export const AkitaDAOGlobalStateKeysStatus = 'status'
    intc_0 // 0
    bytec 31 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    intc_0 // 0
    bytec 11 // "version"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:5
    // export const AkitaDAOGlobalStateKeysContentPolicy = 'content_policy'
    intc_0 // 0
    bytec 17 // "content_policy"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysMinRewardsImpact = 'min_rewards_impact'
    intc_0 // 0
    bytec 18 // "min_rewards_impact"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    intc_0 // 0
    bytec 37 // "akita_al"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    pushint 48 // 48
    extract_uint64
    dig 7
    pushint 56 // 56
    extract_uint64
    dig 8
    pushint 64 // 64
    extract_uint64
    dig 9
    pushint 72 // 72
    extract_uint64
    dig 10
    pushint 80 // 80
    extract_uint64
    uncover 11
    pushint 88 // 88
    extract_uint64
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    intc_0 // 0
    pushbytes "other_al"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    uncover 2
    intc_3 // 16
    extract_uint64
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    intc_0 // 0
    bytec 19 // "social_fees"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    uncover 3
    pushint 24 // 24
    extract_uint64
    // smart_contracts/dao/constants.ts:11
    // export const AkitaDAOGlobalStateKeysStakingFees = 'staking_fees'
    intc_0 // 0
    bytec 20 // "staking_fees"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    uncover 2
    intc_3 // 16
    extract_uint64
    // smart_contracts/dao/constants.ts:12
    // export const AkitaDAOGlobalStateKeysSubscriptionFees = 'subscription_fees'
    intc_0 // 0
    bytec 21 // "subscription_fees"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    uncover 2
    intc_3 // 16
    extract_uint64
    // smart_contracts/dao/constants.ts:14
    // export const AkitaDAOGlobalStateKeysNFTFees = 'nft_fees'
    intc_0 // 0
    bytec 22 // "nft_fees"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    pushint 48 // 48
    extract_uint64
    dig 7
    pushint 56 // 56
    extract_uint64
    dig 8
    pushint 64 // 64
    extract_uint64
    dig 9
    pushint 72 // 72
    extract_uint64
    dig 10
    pushint 80 // 80
    extract_uint64
    dig 11
    pushint 88 // 88
    extract_uint64
    dig 12
    pushint 96 // 96
    extract_uint64
    dig 13
    pushint 104 // 104
    extract_uint64
    uncover 14
    pushint 112 // 112
    extract_uint64
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    intc_0 // 0
    bytec 7 // "krby_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    intc_0 // 0
    bytec 8 // "mod_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:22
    // export const AkitaDAOGlobalStateKeysProposalCreationSettings = 'proposal_creation_settings'
    intc_0 // 0
    bytec_3 // "proposal_creation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    // smart_contracts/dao/constants.ts:23
    // export const AkitaDAOGlobalStateKeysProposalParticipationSettings = 'proposal_participation_settings'
    intc_0 // 0
    bytec 33 // "proposal_participation_settings"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    // smart_contracts/dao/constants.ts:24
    // export const AkitaDAOGlobalStateKeysProposalApprovalThresholdSettings = 'proposal_approval_threshold_settings'
    intc_0 // 0
    bytec 34 // "proposal_approval_threshold_settings"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    // smart_contracts/dao/constants.ts:25
    // export const AkitaDAOGlobalStateKeysProposalVotingDurationSettings = 'proposal_voting_duration_settings'
    intc_0 // 0
    bytec 35 // "proposal_voting_duration_settings"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    intc_3 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    pushint 32 // 32
    extract_uint64
    uncover 5
    pushint 40 // 40
    extract_uint64
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    intc_0 // 0
    bytec 12 // "akita_assets"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/dao/constants.ts:27
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    intc_0 // 0
    bytec 13 // "revocation_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1927-1948
    // return {
    //   status: this.status.value,
    //   version: this.version.value,
    //   contentPolicy: this.contentPolicy.value,
    //   minRewardsImpact: this.minRewardsImpact.value,
    //   akitaAppList: this.akitaAppList.value,
    //   otherAppList: this.otherAppList.value,
    //   socialFees: this.socialFees.value,
    //   stakingFees: this.stakingFees.value,
    //   subscriptionFees: this.subscriptionFees.value,
    //   nftFees: this.nftFees.value,
    //   krbyPercentage: this.krbyPercentage.value,
    //   moderatorPercentage: this.moderatorPercentage.value,
    //   proposalSettings: {
    //     creation: this.proposalCreationSettings.value,
    //     participation: this.proposalParticipationSettings.value,
    //     approval: this.proposalApprovalThresholdSettings.value,
    //     duration: this.proposalVotingDurationSettings.value,
    //   },
    //   akitaAssets: this.akitaAssets.value,
    //   revocationAddress: new Address(this.revocationAddress.value),
    // }
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    cover 72
    uncover 48
    uncover 48
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    uncover 72
    retsub
