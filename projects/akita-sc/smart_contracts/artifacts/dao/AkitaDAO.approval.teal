#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 25 8 392
    bytecblock "spending_address" "" 0x00 "version" "controlled_address"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:162
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    pushbytes "initialized"
    intc_0 // 0
    app_global_put
    // smart_contracts/dao/contract.algo.ts:164
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec_3 // "version"
    bytec_1 // ""
    app_global_put
    // smart_contracts/dao/contract.algo.ts:216
    // proposalID = GlobalState<uint64>({ initialValue: 0, key: AkitaDAOGlobalStateKeysProposalID })
    pushbytes "proposal_id"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txn NumAppArgs
    bz main_after_if_else@16
    pushbytess 0x240d2f67 0xd380c4f0 0x8339d8f1 0x0f885493 0x682fdbf8 0xde300fe9 0xbe39d3c8 0x854dede0 // method "create(uint64)void", method "update(uint64)void", method "init(string,uint64,byte[36],uint64,address,address,uint64,(address,string),uint64)void", method "arc58_verifyAuthAddr()void", method "arc58_canCall(uint64,bool,address,byte[4])bool", method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void", method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void", method "opUp()void"
    txna ApplicationArgs 0
    match main_create_route@5 main_update_route@6 main_init_route@7 main_arc58_verifyAuthAddr_route@8 main_arc58_canCall_route@9 main_arc58_rekeyToPlugin_route@10 main_arc58_rekeyToNamedPlugin_route@11 main_opUp_route@12

main_after_if_else@16:
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    intc_0 // 0
    return

main_opUp_route@12:
    // smart_contracts/dao/contract.algo.ts:1961
    // opUp(): void { }
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@11:
    // smart_contracts/dao/contract.algo.ts:1500
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1500
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@10:
    // smart_contracts/dao/contract.algo.ts:1458-1463
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1458-1463
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    callsub arc58_rekeyToPlugin
    popn 2
    intc_1 // 1
    return

main_arc58_canCall_route@9:
    // smart_contracts/dao/contract.algo.ts:1436
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/dao/contract.algo.ts:1436
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_verifyAuthAddr_route@8:
    // smart_contracts/dao/contract.algo.ts:1424
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    return

main_init_route@7:
    // smart_contracts/dao/contract.algo.ts:1178-1196
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   // apps: AkitaDAOApps,
    //   // fees: AkitaDAOFees,
    //   // proposalSettings: {
    //   //   creation: ProposalSettings,
    //   //   participation: ProposalSettings,
    //   //   approval: ProposalSettings,
    //   //   duration: ProposalSettings,
    //   // },
    //   revocationAddress: Address,
    //   krbyPayoutAddress: Address,
    //   moderatorGateID: uint64,
    //   govStakeKey: RootKey,
    //   govGateID: uint64,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    txna ApplicationArgs 9
    btoi
    // smart_contracts/dao/contract.algo.ts:1178-1196
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   // apps: AkitaDAOApps,
    //   // fees: AkitaDAOFees,
    //   // proposalSettings: {
    //   //   creation: ProposalSettings,
    //   //   participation: ProposalSettings,
    //   //   approval: ProposalSettings,
    //   //   duration: ProposalSettings,
    //   // },
    //   revocationAddress: Address,
    //   krbyPayoutAddress: Address,
    //   moderatorGateID: uint64,
    //   govStakeKey: RootKey,
    //   govGateID: uint64,
    // ): void {
    callsub init
    intc_1 // 1
    return

main_update_route@6:
    // smart_contracts/dao/contract.algo.ts:1166
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dao/contract.algo.ts:1166
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/dao/contract.algo.ts:1160
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/dao/contract.algo.ts:157
    // export class AkitaDAO extends Contract  { // implements AkitaDAOInterface
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dao/contract.algo.ts:1160
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/dao/contract.algo.ts::AkitaDAO.pluginCallAllowed(application: uint64, allowedCaller: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/dao/contract.algo.ts:377
    // private pluginCallAllowed(application: uint64, allowedCaller: Account, method: bytes<4>): boolean {
    proto 3 1
    intc_0 // 0
    bytec_1 // ""
    dupn 6
    // smart_contracts/dao/contract.algo.ts:378
    // const key: PluginKey = { application, allowedCaller }
    frame_dig -3
    itob
    frame_dig -2
    concat
    // smart_contracts/dao/contract.algo.ts:221
    // plugins = BoxMap<PluginKey, DAOPluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    pushbytes "p"
    swap
    concat
    dup
    // smart_contracts/dao/contract.algo.ts:380
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:381
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:384
    // if (this.plugins(key).value.useExecutionKey) {
    frame_dig 8
    box_get
    assert // Box must have value
    pushint 352 // 352
    getbit
    bz pluginCallAllowed_after_if_else@4
    // smart_contracts/dao/contract.algo.ts:385
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@4:
    // smart_contracts/dao/contract.algo.ts:388
    // const { useRounds, lastCalled, cooldown, methods } = clone(this.plugins(key).value)
    frame_dig 8
    box_get
    assert // Box must have value
    dup
    pushint 216 // 216
    getbit
    frame_bury 7
    dup
    pushint 28 // 28
    extract_uint64
    frame_bury 5
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 2
    dup
    intc_2 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:389
    // let methodAllowed = methods.length > 0 ? false : true;
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 1
    !
    frame_bury 6
    // smart_contracts/dao/contract.algo.ts:390
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 4

pluginCallAllowed_while_top@5:
    // smart_contracts/dao/contract.algo.ts:390
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 4
    frame_dig 1
    <
    bz pluginCallAllowed_block@10
    // smart_contracts/dao/contract.algo.ts:391
    // if (methods[i].selector === method) {
    frame_dig 0
    extract 2 0
    frame_dig 4
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: index access is out of bounds
    extract 0 4
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@8
    // smart_contracts/dao/contract.algo.ts:392
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 6

pluginCallAllowed_block@10:
    // smart_contracts/dao/contract.algo.ts:397
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 7
    bz pluginCallAllowed_ternary_false@12
    global Round
    frame_bury 3

pluginCallAllowed_ternary_merge@13:
    // smart_contracts/dao/contract.algo.ts:400
    // lastCalled >= epochRef &&
    frame_dig 5
    frame_dig 3
    >=
    // smart_contracts/dao/contract.algo.ts:400-401
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    // smart_contracts/dao/contract.algo.ts:401
    // (epochRef - lastCalled) >= cooldown &&
    frame_dig 3
    frame_dig 5
    -
    frame_dig 2
    >=
    // smart_contracts/dao/contract.algo.ts:400-401
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    intc_1 // 1

pluginCallAllowed_bool_merge@17:
    // smart_contracts/dao/contract.algo.ts:400-402
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    // methodAllowed
    frame_dig 6
    &&
    // smart_contracts/dao/contract.algo.ts:399-403
    // return (
    //   lastCalled >= epochRef &&
    //   (epochRef - lastCalled) >= cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@16:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@17

pluginCallAllowed_ternary_false@12:
    // smart_contracts/dao/contract.algo.ts:397
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 3
    b pluginCallAllowed_ternary_merge@13

pluginCallAllowed_after_if_else@8:
    // smart_contracts/dao/contract.algo.ts:390
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b pluginCallAllowed_while_top@5


// smart_contracts/dao/contract.algo.ts::AkitaDAO.create(escrowFactoryApp: uint64) -> void:
create:
    // smart_contracts/dao/contract.algo.ts:1160-1161
    // @abimethod({ onCreate: 'require' })
    // create(escrowFactoryApp: uint64): void {
    proto 1 0
    // smart_contracts/dao/contract.algo.ts:164
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec_3 // "version"
    // smart_contracts/dao/contract.algo.ts:1162
    // this.version.value = ''
    bytec_1 // ""
    app_global_put
    // smart_contracts/dao/contract.algo.ts:212
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    pushbytes "escrow_factory"
    // smart_contracts/dao/contract.algo.ts:1163
    // this.escrowFactory.value = Application(escrowFactoryApp)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.update(proposalID: uint64) -> void:
update:
    // smart_contracts/dao/contract.algo.ts:1166-1167
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(proposalID: uint64): void {
    proto 1 0
    // smart_contracts/dao/contract.algo.ts:1168
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    frame_dig -1
    itob
    // smart_contracts/dao/contract.algo.ts:235
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    pushbytes "l"
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1168
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/dao/contract.algo.ts:1169
    // const { status, action, data } = this.proposals(proposalID).value
    box_get
    pop
    dup
    extract 0 1
    dig 1
    extract 1 1
    dig 2
    pushint 86 // 86
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    // smart_contracts/dao/contract.algo.ts:1170
    // assert(status === ProposalStatusApproved, ERR_PROPOSAL_NOT_APPROVED)
    uncover 2
    pushbytes 0x28
    ==
    assert // Proposal is not approved
    // smart_contracts/dao/contract.algo.ts:1171
    // assert(action === ProposalActionUpgradeApp, ERR_PROPOSAL_NOT_UPGRADE_APP)
    swap
    pushbytes 0x0a
    ==
    assert // Proposal is not an upgrade app
    // smart_contracts/dao/contract.algo.ts:1173
    // const { app, executionKey } = decodeArc4<ProposalUpgradeApp>(data)
    dup
    pushint 2 // 2
    extract_uint64
    swap
    extract 10 32
    // smart_contracts/dao/contract.algo.ts:1174
    // assert(app === Global.currentApplicationId.id, ERR_PROPOSAL_NOT_UPGRADE_APP)
    global CurrentApplicationID
    uncover 2
    ==
    assert // Proposal is not an upgrade app
    // smart_contracts/dao/contract.algo.ts:1175
    // assert(Global.groupId === executionKey, ERR_EXECUTION_KEY_MISMATCH)
    global GroupID
    ==
    assert // Execution key mismatch
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.init(version: bytes, akta: uint64, contentPolicy: bytes, minRewardsImpact: uint64, revocationAddress: bytes, krbyPayoutAddress: bytes, moderatorGateID: uint64, govStakeKey: bytes, govGateID: uint64) -> void:
init:
    // smart_contracts/dao/contract.algo.ts:1178-1196
    // init(
    //   version: string,
    //   akta: uint64,
    //   contentPolicy: CID,
    //   minRewardsImpact: uint64,
    //   // apps: AkitaDAOApps,
    //   // fees: AkitaDAOFees,
    //   // proposalSettings: {
    //   //   creation: ProposalSettings,
    //   //   participation: ProposalSettings,
    //   //   approval: ProposalSettings,
    //   //   duration: ProposalSettings,
    //   // },
    //   revocationAddress: Address,
    //   krbyPayoutAddress: Address,
    //   moderatorGateID: uint64,
    //   govStakeKey: RootKey,
    //   govGateID: uint64,
    // ): void {
    proto 9 0
    // smart_contracts/dao/contract.algo.ts:164
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    intc_0 // 0
    bytec_3 // "version"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1197
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    bytec_1 // ""
    ==
    assert // Already initialized
    // smart_contracts/dao/contract.algo.ts:1198
    // assert(version !== '', ERR_VERSION_CANNOT_BE_EMPTY)
    frame_dig -9
    bytec_1 // ""
    !=
    assert // Version cannot be empty
    // smart_contracts/dao/contract.algo.ts:164
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec_3 // "version"
    // smart_contracts/dao/contract.algo.ts:1200
    // this.version.value = version
    frame_dig -9
    app_global_put
    // smart_contracts/dao/contract.algo.ts:166
    // contentPolicy = GlobalState<CID>({ key: AkitaDAOGlobalStateKeysContentPolicy })
    pushbytes "content_policy"
    // smart_contracts/dao/contract.algo.ts:1201
    // this.contentPolicy.value = contentPolicy
    frame_dig -7
    app_global_put
    // smart_contracts/dao/contract.algo.ts:168
    // minRewardsImpact = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysMinRewardsImpact })
    pushbytes "min_rewards_impact"
    // smart_contracts/dao/contract.algo.ts:1202
    // this.minRewardsImpact.value = minRewardsImpact
    frame_dig -6
    app_global_put
    // smart_contracts/dao/contract.algo.ts:214
    // revocationAddress = GlobalState<Account>({ key: AkitaDAOGlobalStateKeysRevocationAddress })
    pushbytes "revocation_address"
    // smart_contracts/dao/contract.algo.ts:1282
    // this.revocationAddress.value = revocationAddress.native
    frame_dig -5
    app_global_put
    // smart_contracts/dao/contract.algo.ts:1284-1297
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:1290
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:1291
    // reserve: Global.currentApplicationAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:1292
    // freeze: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/dao/contract.algo.ts:1293
    // clawback: Global.zeroAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:1295
    // url: Bytes('https://akita.community'),
    pushbytes "https://akita.community"
    itxn_field ConfigAssetURL
    // smart_contracts/dao/contract.algo.ts:1294
    // defaultFrozen: false,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/dao/contract.algo.ts:1289
    // decimals: 6,
    pushint 6 // 6
    itxn_field ConfigAssetDecimals
    // smart_contracts/dao/contract.algo.ts:1288
    // total: 1_000_000_000_000_000, // 1 billion
    pushint 1000000000000000 // 1000000000000000
    itxn_field ConfigAssetTotal
    // smart_contracts/dao/contract.algo.ts:1287
    // unitName: Bytes('BONES'),
    pushbytes "BONES"
    itxn_field ConfigAssetUnitName
    // smart_contracts/dao/contract.algo.ts:1286
    // assetName: Bytes('Bones'),
    pushbytes "Bones"
    itxn_field ConfigAssetName
    // smart_contracts/dao/contract.algo.ts:1284-1296
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1284-1297
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 1_000_000_000_000_000, // 1 billion
    //     decimals: 6,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes('https://akita.community'),
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/dao/contract.algo.ts:1300
    // this.akitaAssets.value = { akta, bones }
    frame_dig -8
    itob
    swap
    itob
    concat
    // smart_contracts/dao/contract.algo.ts:195
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    pushbytes "akita_assets"
    // smart_contracts/dao/contract.algo.ts:1300
    // this.akitaAssets.value = { akta, bones }
    swap
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:
    // smart_contracts/dao/contract.algo.ts:1424
    // arc58_verifyAuthAddr(): void {
    proto 0 0
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec_0 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1425
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    dup
    acct_params_get AcctAuthAddr
    swap
    cover 2
    assert // account funded
    // smart_contracts/dao/contract.algo.ts:206
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress })
    intc_0 // 0
    bytec 4 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:706
    // return this.spendingAddress.value === this.controlledAddress.value
    ==
    // smart_contracts/dao/contract.algo.ts:706-708
    // return this.spendingAddress.value === this.controlledAddress.value
    //   ? Global.zeroAddress
    //   : Global.currentApplicationAddress
    bz arc58_verifyAuthAddr_ternary_false@3
    // smart_contracts/dao/contract.algo.ts:707
    // ? Global.zeroAddress
    global ZeroAddress

arc58_verifyAuthAddr_ternary_merge@4:
    // smart_contracts/dao/contract.algo.ts:1425
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    frame_dig 0
    ==
    assert
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec_0 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1426
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    app_global_put
    retsub

arc58_verifyAuthAddr_ternary_false@3:
    // smart_contracts/dao/contract.algo.ts:708
    // : Global.currentApplicationAddress
    global CurrentApplicationAddress
    b arc58_verifyAuthAddr_ternary_merge@4


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_canCall(plugin: uint64, global: uint64, address: bytes, method: bytes) -> uint64:
arc58_canCall:
    // smart_contracts/dao/contract.algo.ts:1436-1442
    // @abimethod({ readonly: true })
    // arc58_canCall(
    //   plugin: uint64,
    //   global: boolean,
    //   address: Address,
    //   method: bytes<4>
    // ): boolean {
    proto 4 1
    // smart_contracts/dao/contract.algo.ts:1443
    // if (global) {
    frame_dig -3
    bz arc58_canCall_after_if_else@2
    // smart_contracts/dao/contract.algo.ts:1444
    // this.pluginCallAllowed(plugin, Global.zeroAddress, method);
    frame_dig -4
    global ZeroAddress
    frame_dig -1
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@2:
    // smart_contracts/dao/contract.algo.ts:1446
    // return this.pluginCallAllowed(plugin, address.native, method);
    frame_dig -4
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_rekeyToPlugin(plugin: uint64, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> bytes, bytes:
arc58_rekeyToPlugin:
    // smart_contracts/dao/contract.algo.ts:1458-1463
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    proto 4 2
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dupn 9
    // smart_contracts/dao/contract.algo.ts:1465
    // const caller = global ? Global.zeroAddress : Txn.sender
    frame_dig -3
    bz arc58_rekeyToPlugin_ternary_false@2
    global ZeroAddress

arc58_rekeyToPlugin_ternary_merge@3:
    // smart_contracts/dao/contract.algo.ts:1466
    // const key = { application: plugin, allowedCaller: caller }
    frame_dig -4
    itob
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:1468
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    intc_0 // 0
    extract_uint64
    swap
    extract 8 32
    swap
    itob
    swap
    concat
    // smart_contracts/dao/contract.algo.ts:221
    // plugins = BoxMap<PluginKey, DAOPluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    pushbytes "p"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/dao/contract.algo.ts:1468
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/dao/contract.algo.ts:1472
    // if (this.plugins(key).value.escrow !== 0) {
    box_get
    pop
    intc_1 // 1
    extract_uint64
    bz arc58_rekeyToPlugin_else_body@7
    // smart_contracts/dao/contract.algo.ts:1473
    // const spendingApp = Application(this.plugins(key).value.escrow)
    frame_dig 0
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1474
    // this.spendingAddress.value = spendingApp.address;
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec_0 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1474
    // this.spendingAddress.value = spendingApp.address;
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:601
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0
    frame_bury 5

arc58_rekeyToPlugin_while_top@11:
    // smart_contracts/dao/contract.algo.ts:601
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 5
    >
    bz arc58_rekeyToPlugin_after_if_else@8
    // smart_contracts/dao/contract.algo.ts:602
    // const { escrow } = this.plugins(key).value
    frame_dig 0
    box_get
    assert // Box must have value
    intc_1 // 1
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:606
    // asset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    frame_dig 5
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 2
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 13
    // smart_contracts/dao/contract.algo.ts:604-607
    // const allowanceKey: AllowanceKey = {
    //   escrow,
    //   asset: fundsRequests[i].asset
    // }
    swap
    itob
    swap
    itob
    concat
    // smart_contracts/dao/contract.algo.ts:233
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    pushbytes "a"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/dao/contract.algo.ts:636
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/dao/contract.algo.ts:637
    // const { type, spent, allowed, last, max, interval, start, useRounds } = this.allowances(key).value
    box_get
    pop
    dup
    extract 0 1
    frame_bury 3
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 10
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 4
    dup
    pushint 33 // 33
    extract_uint64
    frame_bury 7
    dup
    intc_1 // 1
    extract_uint64
    frame_bury 8
    dup
    intc_2 // 25
    extract_uint64
    frame_bury 6
    dup
    pushint 41 // 41
    extract_uint64
    frame_bury 11
    intc 4 // 392
    getbit
    dup
    frame_bury 12
    // smart_contracts/dao/contract.algo.ts:638
    // const newLast = useRounds ? Global.round : Global.latestTimestamp
    bz arc58_rekeyToPlugin_ternary_false@14
    global Round
    frame_bury 9

arc58_rekeyToPlugin_ternary_merge@15:
    // smart_contracts/dao/contract.algo.ts:640
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 3
    pushbytes 0x01
    ==
    bz arc58_rekeyToPlugin_else_body@17
    // smart_contracts/dao/contract.algo.ts:641
    // const leftover: uint64 = allowed - spent;
    frame_dig 4
    frame_dig 10
    dup
    cover 2
    -
    // smart_contracts/dao/contract.algo.ts:643
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 2
    intc_3 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:646
    // ...this.allowances(key).value,
    frame_dig 1
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    intc_2 // 25
    extract_uint64
    dig 4
    pushint 33 // 33
    extract_uint64
    dig 5
    pushint 41 // 41
    extract_uint64
    uncover 6
    intc 4 // 392
    getbit
    // smart_contracts/dao/contract.algo.ts:647
    // spent: (spent + fundRequest.amount)
    uncover 8
    uncover 8
    +
    // smart_contracts/dao/contract.algo.ts:645-648
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount)
    // }
    uncover 6
    itob
    uncover 7
    swap
    concat
    uncover 6
    itob
    concat
    swap
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put

arc58_rekeyToPlugin_after_if_else@26:
    // smart_contracts/dao/contract.algo.ts:611
    // if (fundsRequests[i].asset !== 0) {
    frame_dig 13
    bz arc58_rekeyToPlugin_else_body@28
    // smart_contracts/dao/contract.algo.ts:612-619
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:206
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress })
    intc_0 // 0
    bytec 4 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec_0 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:616
    // assetAmount: fundsRequests[i].amount,
    frame_dig 2
    intc_3 // 8
    extract_uint64
    frame_dig 13
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:612-618
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:612-619
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_submit

arc58_rekeyToPlugin_after_if_else@29:
    // smart_contracts/dao/contract.algo.ts:601
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    b arc58_rekeyToPlugin_while_top@11

arc58_rekeyToPlugin_else_body@28:
    // smart_contracts/dao/contract.algo.ts:621-627
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:206
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress })
    intc_0 // 0
    bytec 4 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec_0 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:625
    // amount: fundsRequests[i].amount
    frame_dig 2
    intc_3 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:621-626
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:621-627
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_submit
    b arc58_rekeyToPlugin_after_if_else@29

arc58_rekeyToPlugin_else_body@17:
    // smart_contracts/dao/contract.algo.ts:649
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 3
    pushbytes 0x02
    ==
    bz arc58_rekeyToPlugin_else_body@21
    // smart_contracts/dao/contract.algo.ts:695
    // if (useRounds) {
    frame_dig 12
    bz arc58_rekeyToPlugin_after_if_else@32
    // smart_contracts/dao/contract.algo.ts:696
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig 11
    -
    frame_dig 6
    %
    -

arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.getLatestWindowStart@33:
    // smart_contracts/dao/contract.algo.ts:652
    // if (currentWindowStart > last) {
    frame_dig 7
    >
    bz arc58_rekeyToPlugin_else_body@20
    // smart_contracts/dao/contract.algo.ts:653
    // assert(allowed >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 2
    intc_3 // 8
    extract_uint64
    frame_dig 4
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:656
    // ...this.allowances(key).value,
    frame_dig 1
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    intc_2 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 4 // 392
    getbit
    // smart_contracts/dao/contract.algo.ts:655-659
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: fundRequest.amount,
    //   last: newLast
    // }
    uncover 4
    itob
    uncover 5
    swap
    concat
    uncover 4
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 9
    itob
    concat
    uncover 2
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@26

arc58_rekeyToPlugin_else_body@20:
    // smart_contracts/dao/contract.algo.ts:662
    // const leftover: uint64 = allowed - spent;
    frame_dig 4
    frame_dig 10
    dup
    cover 2
    -
    // smart_contracts/dao/contract.algo.ts:663
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 2
    intc_3 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:666
    // ...this.allowances(key).value,
    frame_dig 1
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    intc_2 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 4 // 392
    getbit
    // smart_contracts/dao/contract.algo.ts:667
    // spent: (spent + fundRequest.amount),
    uncover 7
    uncover 7
    +
    // smart_contracts/dao/contract.algo.ts:665-669
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount),
    //   last: newLast
    // }
    uncover 5
    itob
    uncover 6
    swap
    concat
    uncover 5
    itob
    concat
    swap
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 9
    itob
    concat
    uncover 2
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@26

arc58_rekeyToPlugin_after_if_else@32:
    // smart_contracts/dao/contract.algo.ts:698
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig 11
    -
    frame_dig 6
    %
    -
    // smart_contracts/dao/contract.algo.ts:650
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/dao/contract.algo.ts::AkitaDAO.getLatestWindowStart@33

arc58_rekeyToPlugin_else_body@21:
    // smart_contracts/dao/contract.algo.ts:672
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 3
    pushbytes 0x03
    ==
    bz arc58_rekeyToPlugin_after_if_else@26
    // smart_contracts/dao/contract.algo.ts:673
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 12
    bz arc58_rekeyToPlugin_ternary_false@24
    global Round

arc58_rekeyToPlugin_ternary_merge@25:
    // smart_contracts/dao/contract.algo.ts:675
    // const amount = fundRequest.amount
    frame_dig 2
    intc_3 // 8
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:679
    // const passed: uint64 = epochRef - last
    swap
    frame_dig 7
    -
    // smart_contracts/dao/contract.algo.ts:680
    // const accrued: uint64 = lastLeftover + ((passed / interval) * accrualRate)
    frame_dig 6
    /
    frame_dig 4
    *
    frame_dig 10
    +
    // smart_contracts/dao/contract.algo.ts:682
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 8
    dup
    cover 3
    >
    swap
    cover 2
    select
    // smart_contracts/dao/contract.algo.ts:684
    // assert(available >= amount, ERR_ALLOWANCE_EXCEEDED);
    dup
    dig 2
    >=
    assert // Allowance exceeded
    // smart_contracts/dao/contract.algo.ts:687
    // ...this.allowances(key).value,
    frame_dig 1
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    intc_2 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 4 // 392
    getbit
    // smart_contracts/dao/contract.algo.ts:688
    // spent: (available - amount),
    uncover 6
    uncover 7
    -
    // smart_contracts/dao/contract.algo.ts:686-690
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (available - amount),
    //   last: newLast
    // }
    uncover 5
    itob
    uncover 6
    swap
    concat
    uncover 5
    itob
    concat
    swap
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 9
    itob
    concat
    uncover 2
    itob
    concat
    bytec_2 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@26

arc58_rekeyToPlugin_ternary_false@24:
    // smart_contracts/dao/contract.algo.ts:673
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_rekeyToPlugin_ternary_merge@25

arc58_rekeyToPlugin_ternary_false@14:
    // smart_contracts/dao/contract.algo.ts:638
    // const newLast = useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    frame_bury 9
    b arc58_rekeyToPlugin_ternary_merge@15

arc58_rekeyToPlugin_after_if_else@8:
    // smart_contracts/dao/contract.algo.ts:1480-1487
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec_0 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:1484
    // rekeyTo: pluginApp.address,
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:1485
    // note: 'rekeying to plugin app'
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:1480-1486
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:1480-1487
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_submit
    frame_dig -2
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

arc58_rekeyToPlugin_else_body@7:
    // smart_contracts/dao/contract.algo.ts:206
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress })
    intc_0 // 0
    bytec 4 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:210
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec_0 // "spending_address"
    // smart_contracts/dao/contract.algo.ts:1477
    // this.spendingAddress.value = this.controlledAddress.value;
    swap
    app_global_put
    b arc58_rekeyToPlugin_after_if_else@8

arc58_rekeyToPlugin_ternary_false@2:
    // smart_contracts/dao/contract.algo.ts:1465
    // const caller = global ? Global.zeroAddress : Txn.sender
    txn Sender
    b arc58_rekeyToPlugin_ternary_merge@3


// smart_contracts/dao/contract.algo.ts::AkitaDAO.arc58_rekeyToNamedPlugin(name: bytes, global: uint64, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/dao/contract.algo.ts:1500
    // arc58_rekeyToNamedPlugin(name: string, global: boolean, methodOffsets: uint64[], fundsRequest: FundsRequest[]): void {
    proto 4 0
    // smart_contracts/dao/contract.algo.ts:223
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins })
    pushbytes "n"
    frame_dig -4
    concat
    // smart_contracts/dao/contract.algo.ts:1502
    // this.namedPlugins(name).value.application,
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/dao/contract.algo.ts:1501-1506
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.application,
    //   global,
    //   methodOffsets,
    //   fundsRequest
    // );
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub arc58_rekeyToPlugin
    frame_bury -1
    frame_bury -2
    retsub
