#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4
    bytecblock "" "proposal_id" "version" "akita_assets" "status" "content_policy" "minimum_rewards_impact" "social_fees" "staking_fees" "subscription_fees" "nft_fees" "krby_percentage" "mod_percentage" "proposal_settings" "revocation_address"
    // smart_contracts/dao/contract.algo.ts:84
    // export class AkitaDAO extends Contract {
    txn NumAppArgs
    bz main_after_if_else@13
    pushbytess 0xb8447b36 0x46f76533 0x839eb09f 0x9023b90f 0x56fd2375 0xb4236b33 0x63c65697 // method "createApplication()void", method "updateApplication()void", method "init(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64),address)void", method "newProposal(uint64)void", method "createDailyDisbursement()void", method "optinEscrow(pay,string,uint64)void", method "getState()(uint64,string,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),uint64,uint64,(uint64,uint64),(uint64,uint64),address)"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_updateApplication_route@4 main_init_route@5 main_newProposal_route@6 main_createDailyDisbursement_route@7 main_optinEscrow_route@8 main_getState_route@9

main_after_if_else@13:
    // smart_contracts/dao/contract.algo.ts:84
    // export class AkitaDAO extends Contract {
    intc_0 // 0
    return

main_getState_route@9:
    // smart_contracts/dao/contract.algo.ts:306
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getState
    uncover 14
    pushbytes 0x01be
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_optinEscrow_route@8:
    // smart_contracts/dao/contract.algo.ts:276
    // optinEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:84
    // export class AkitaDAO extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dao/contract.algo.ts:276
    // optinEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    callsub optinEscrow
    intc_1 // 1
    return

main_createDailyDisbursement_route@7:
    // smart_contracts/dao/contract.algo.ts:253
    // createDailyDisbursement(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub createDailyDisbursement
    intc_1 // 1
    return

main_newProposal_route@6:
    // smart_contracts/dao/contract.algo.ts:249
    // newProposal(proposalType: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:84
    // export class AkitaDAO extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dao/contract.algo.ts:249
    // newProposal(proposalType: uint64): void {
    callsub newProposal
    intc_1 // 1
    return

main_init_route@5:
    // smart_contracts/dao/contract.algo.ts:157-165
    // init(
    //   version: arc4.Str,
    //   akta: arc4.UintN64,
    //   contentPolicy: arc4.StaticBytes<36>,
    //   minimumRewardsImpact: arc4.UintN64,
    //   fees: arc4Fees,
    //   proposalSettings: arc4ProposalSettings,
    //   revocationAddress: Address
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dao/contract.algo.ts:84
    // export class AkitaDAO extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    dup
    extract 0 8 // on error: Index access is out of bounds
    dig 1
    extract 8 8 // on error: Index access is out of bounds
    dig 2
    extract 16 8 // on error: Index access is out of bounds
    dig 3
    extract 24 8 // on error: Index access is out of bounds
    dig 4
    extract 32 8 // on error: Index access is out of bounds
    dig 5
    extract 40 8 // on error: Index access is out of bounds
    dig 6
    extract 48 8 // on error: Index access is out of bounds
    dig 7
    extract 56 8 // on error: Index access is out of bounds
    dig 8
    extract 64 8 // on error: Index access is out of bounds
    dig 9
    extract 72 8 // on error: Index access is out of bounds
    dig 10
    extract 80 8 // on error: Index access is out of bounds
    dig 11
    extract 88 8 // on error: Index access is out of bounds
    dig 12
    extract 96 8 // on error: Index access is out of bounds
    dig 13
    extract 104 8 // on error: Index access is out of bounds
    dig 14
    extract 112 8 // on error: Index access is out of bounds
    dig 15
    extract 120 8 // on error: Index access is out of bounds
    dig 16
    extract 128 8 // on error: Index access is out of bounds
    dig 17
    extract 136 8 // on error: Index access is out of bounds
    dig 18
    extract 144 8 // on error: Index access is out of bounds
    dig 19
    extract 152 8 // on error: Index access is out of bounds
    dig 20
    extract 160 8 // on error: Index access is out of bounds
    dig 21
    extract 168 8 // on error: Index access is out of bounds
    dig 22
    extract 176 8 // on error: Index access is out of bounds
    dig 23
    extract 184 8 // on error: Index access is out of bounds
    dig 24
    extract 192 8 // on error: Index access is out of bounds
    dig 25
    extract 200 8 // on error: Index access is out of bounds
    dig 26
    extract 208 8 // on error: Index access is out of bounds
    dig 27
    extract 216 8 // on error: Index access is out of bounds
    dig 28
    extract 224 8 // on error: Index access is out of bounds
    uncover 29
    extract 232 8 // on error: Index access is out of bounds
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    // smart_contracts/dao/contract.algo.ts:157-165
    // init(
    //   version: arc4.Str,
    //   akta: arc4.UintN64,
    //   contentPolicy: arc4.StaticBytes<36>,
    //   minimumRewardsImpact: arc4.UintN64,
    //   fees: arc4Fees,
    //   proposalSettings: arc4ProposalSettings,
    //   revocationAddress: Address
    // ): void {
    callsub init
    intc_1 // 1
    return

main_updateApplication_route@4:
    // smart_contracts/dao/contract.algo.ts:154
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_2 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/dao/contract.algo.ts:149
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/dao/contract.algo.ts::AkitaDAO.init(version: bytes, akta: bytes, contentPolicy: bytes, minimumRewardsImpact: bytes, fees.postFee: bytes, fees.reactFee: bytes, fees.impactTaxMin: bytes, fees.impactTaxMax: bytes, fees.poolCreationFee: bytes, fees.poolImpactTaxMin: bytes, fees.poolImpactTaxMax: bytes, fees.subscriptionServiceCreationFee: bytes, fees.subscriptionPaymentPercentage: bytes, fees.subscriptionTriggerPercentage: bytes, fees.marketplaceSalePercentageMinimum: bytes, fees.marketplaceSalePercentageMaximum: bytes, fees.marketplaceComposablePercentage: bytes, fees.marketplaceRoyaltyDefaultPercentage: bytes, fees.omnigemSaleFee: bytes, fees.auctionCreationFee: bytes, fees.auctionSaleImpactTaxMin: bytes, fees.auctionSaleImpactTaxMax: bytes, fees.auctionComposablePercentage: bytes, fees.auctionRafflePercentage: bytes, fees.raffleCreationFee: bytes, fees.raffleSaleImpactTaxMin: bytes, fees.raffleSaleImpactTaxMax: bytes, fees.raffleComposablePercentage: bytes, fees.swapFeeImpactTaxMin: bytes, fees.swapFeeImpactTaxMax: bytes, fees.swapComposablePercentage: bytes, fees.swapLiquidityPercentage: bytes, fees.krbyPercentage: bytes, fees.moderatorPercentage: bytes, proposalSettings: bytes, revocationAddress: bytes) -> void:
init:
    // smart_contracts/dao/contract.algo.ts:157-165
    // init(
    //   version: arc4.Str,
    //   akta: arc4.UintN64,
    //   contentPolicy: arc4.StaticBytes<36>,
    //   minimumRewardsImpact: arc4.UintN64,
    //   fees: arc4Fees,
    //   proposalSettings: arc4ProposalSettings,
    //   revocationAddress: Address
    // ): void {
    proto 36 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    intc_0 // 0
    bytec_2 // "version"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:166
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    bytec_0 // ""
    ==
    assert // Already initialized
    // smart_contracts/dao/contract.algo.ts:167
    // assert(version.native !== '', ERR_VERSION_CANNOT_BE_EMPTY)
    frame_dig -36
    extract 2 0
    dup
    bytec_0 // ""
    !=
    assert // Version cannot be empty
    // smart_contracts/dao/contract.algo.ts:169-184
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     configAsset: 0,
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 100_000_000_000_000,
    //     decimals: 2,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes(''), // TODO: figure out the URL we should have here
    //     metadataHash: Bytes(''), // TODO: figure out the metadata hash we should have here
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:176
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/dao/contract.algo.ts:177
    // reserve: Global.currentApplicationAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:178
    // freeze: Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/dao/contract.algo.ts:179
    // clawback: Global.zeroAddress,
    dup
    // smart_contracts/dao/contract.algo.ts:182
    // metadataHash: Bytes(''), // TODO: figure out the metadata hash we should have here
    bytec_0 // ""
    itxn_field ConfigAssetMetadataHash
    // smart_contracts/dao/contract.algo.ts:181
    // url: Bytes(''), // TODO: figure out the URL we should have here
    bytec_0 // ""
    itxn_field ConfigAssetURL
    // smart_contracts/dao/contract.algo.ts:180
    // defaultFrozen: false,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/dao/contract.algo.ts:175
    // decimals: 2,
    pushint 2 // 2
    itxn_field ConfigAssetDecimals
    // smart_contracts/dao/contract.algo.ts:174
    // total: 100_000_000_000_000,
    pushint 100000000000000 // 100000000000000
    itxn_field ConfigAssetTotal
    // smart_contracts/dao/contract.algo.ts:173
    // unitName: Bytes('BONES'),
    pushbytes "BONES"
    itxn_field ConfigAssetUnitName
    // smart_contracts/dao/contract.algo.ts:172
    // assetName: Bytes('Bones'),
    pushbytes "Bones"
    itxn_field ConfigAssetName
    // smart_contracts/dao/contract.algo.ts:171
    // configAsset: 0,
    intc_0 // 0
    itxn_field ConfigAsset
    // smart_contracts/dao/contract.algo.ts:169-183
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     configAsset: 0,
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 100_000_000_000_000,
    //     decimals: 2,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes(''), // TODO: figure out the URL we should have here
    //     metadataHash: Bytes(''), // TODO: figure out the metadata hash we should have here
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:169-184
    // const bonesCreateTxn = itxn
    //   .assetConfig({
    //     configAsset: 0,
    //     assetName: Bytes('Bones'),
    //     unitName: Bytes('BONES'),
    //     total: 100_000_000_000_000,
    //     decimals: 2,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.zeroAddress,
    //     clawback: Global.zeroAddress,
    //     defaultFrozen: false,
    //     url: Bytes(''), // TODO: figure out the URL we should have here
    //     metadataHash: Bytes(''), // TODO: figure out the metadata hash we should have here
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/dao/constants.ts:3
    // export const AkitaDAOGlobalStateKeysStatus = 'status'
    bytec 4 // "status"
    // smart_contracts/dao/constants.ts:33
    // export const STATUS_INIT: uint64 = 0
    intc_0 // 0
    // smart_contracts/dao/contract.algo.ts:186
    // this.status.value = STATUS_INIT
    app_global_put
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec_2 // "version"
    // smart_contracts/dao/contract.algo.ts:187
    // this.version.value = version.native
    uncover 2
    app_global_put
    // smart_contracts/dao/constants.ts:4
    // export const AkitaDAOGlobalStateKeysContentPolicy = 'content_policy'
    bytec 5 // "content_policy"
    // smart_contracts/dao/contract.algo.ts:188
    // this.contentPolicy.value = contentPolicy.native
    frame_dig -34
    app_global_put
    // smart_contracts/dao/contract.algo.ts:189
    // this.minimumRewardsImpact.value = minimumRewardsImpact.native
    frame_dig -33
    btoi
    // smart_contracts/dao/constants.ts:5
    // export const AkitaDAOGlobalStateKeysMinimumRewardsImpact = 'minimum_rewards_impact'
    bytec 6 // "minimum_rewards_impact"
    // smart_contracts/dao/contract.algo.ts:189
    // this.minimumRewardsImpact.value = minimumRewardsImpact.native
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:191-196
    // this.socialFees.value = new arc4SocialFees({
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // })
    frame_dig -32
    frame_dig -31
    concat
    frame_dig -30
    concat
    frame_dig -29
    concat
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 7 // "social_fees"
    // smart_contracts/dao/contract.algo.ts:191-196
    // this.socialFees.value = new arc4SocialFees({
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:198-202
    // this.stakingFees.value = new arc4StakingFees({
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // })
    frame_dig -28
    frame_dig -27
    concat
    frame_dig -26
    concat
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysStakingFees = 'staking_fees'
    bytec 8 // "staking_fees"
    // smart_contracts/dao/contract.algo.ts:198-202
    // this.stakingFees.value = new arc4StakingFees({
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:204-208
    // this.subscriptionFees.value = new arc4SubscriptionFees({
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // })
    frame_dig -25
    frame_dig -24
    concat
    frame_dig -23
    concat
    // smart_contracts/dao/constants.ts:11
    // export const AkitaDAOGlobalStateKeysSubscriptionFees = 'subscription_fees'
    bytec 9 // "subscription_fees"
    // smart_contracts/dao/contract.algo.ts:204-208
    // this.subscriptionFees.value = new arc4SubscriptionFees({
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:210-225
    // this.nftFees.value = new arc4NFTFees({
    //   marketplaceSalePercentageMinimum: fees.marketplaceSalePercentageMinimum,
    //   marketplaceSalePercentageMaximum: fees.marketplaceSalePercentageMaximum,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // })
    frame_dig -22
    frame_dig -21
    concat
    frame_dig -20
    concat
    frame_dig -19
    concat
    frame_dig -18
    concat
    frame_dig -17
    concat
    frame_dig -16
    concat
    frame_dig -15
    concat
    frame_dig -14
    concat
    frame_dig -13
    concat
    frame_dig -12
    concat
    frame_dig -11
    concat
    frame_dig -10
    concat
    frame_dig -9
    concat
    // smart_contracts/dao/constants.ts:13
    // export const AkitaDAOGlobalStateKeysNFTFees = 'nft_fees'
    bytec 10 // "nft_fees"
    // smart_contracts/dao/contract.algo.ts:210-225
    // this.nftFees.value = new arc4NFTFees({
    //   marketplaceSalePercentageMinimum: fees.marketplaceSalePercentageMinimum,
    //   marketplaceSalePercentageMaximum: fees.marketplaceSalePercentageMaximum,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:227-230
    // this.swapFees.value = new arc4SwapFees({
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // })
    frame_dig -8
    frame_dig -7
    concat
    // smart_contracts/dao/constants.ts:12
    // export const AkitaDAOGlobalStateKeysSwapFees = 'swap_fees'
    pushbytes "swap_fees"
    // smart_contracts/dao/contract.algo.ts:227-230
    // this.swapFees.value = new arc4SwapFees({
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:232
    // this.krbyPercentage.value = fees.krbyPercentage.native
    frame_dig -4
    btoi
    // smart_contracts/dao/constants.ts:14
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    bytec 11 // "krby_percentage"
    // smart_contracts/dao/contract.algo.ts:232
    // this.krbyPercentage.value = fees.krbyPercentage.native
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:233
    // this.moderatorPercentage.value = fees.moderatorPercentage.native
    frame_dig -3
    btoi
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    bytec 12 // "mod_percentage"
    // smart_contracts/dao/contract.algo.ts:233
    // this.moderatorPercentage.value = fees.moderatorPercentage.native
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:236
    // minimumProposalThreshold: proposalSettings.minimumProposalThreshold,
    frame_dig -2
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/dao/contract.algo.ts:237
    // minimumVoteThreshold: proposalSettings.minimumVoteThreshold,
    frame_dig -2
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/dao/contract.algo.ts:235-238
    // this.proposalSettings.value = new arc4ProposalSettings({
    //   minimumProposalThreshold: proposalSettings.minimumProposalThreshold,
    //   minimumVoteThreshold: proposalSettings.minimumVoteThreshold,
    // })
    concat
    // smart_contracts/dao/constants.ts:17
    // export const AkitaDAOGlobalStateKeysProposalSettings = 'proposal_settings'
    bytec 13 // "proposal_settings"
    // smart_contracts/dao/contract.algo.ts:235-238
    // this.proposalSettings.value = new arc4ProposalSettings({
    //   minimumProposalThreshold: proposalSettings.minimumProposalThreshold,
    //   minimumVoteThreshold: proposalSettings.minimumVoteThreshold,
    // })
    swap
    app_global_put
    // smart_contracts/dao/contract.algo.ts:240
    // const bones = new UintN64(bonesCreateTxn.createdAsset.id)
    itob
    // smart_contracts/dao/contract.algo.ts:241
    // this.akitaAssets.value = new arc4AkitaAssets({ akta, bones })
    frame_dig -35
    swap
    concat
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec_3 // "akita_assets"
    // smart_contracts/dao/contract.algo.ts:241
    // this.akitaAssets.value = new arc4AkitaAssets({ akta, bones })
    swap
    app_global_put
    // smart_contracts/dao/constants.ts:18
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    bytec 14 // "revocation_address"
    // smart_contracts/dao/contract.algo.ts:243
    // this.revocationAddress.value = revocationAddress.native
    frame_dig -1
    app_global_put
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    bytec_1 // "proposal_id"
    // smart_contracts/dao/contract.algo.ts:244
    // this.proposalID.value = 0
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.newProposal(proposalType: uint64) -> void:
newProposal:
    // smart_contracts/dao/contract.algo.ts:249
    // newProposal(proposalType: uint64): void {
    proto 1 0
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    intc_0 // 0
    bytec_1 // "proposal_id"
    app_global_get_ex
    bury 1
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "proposal_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:143
    // this.proposalID.value += 1
    intc_1 // 1
    +
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysProposalID = 'proposal_id'
    bytec_1 // "proposal_id"
    // smart_contracts/dao/contract.algo.ts:143
    // this.proposalID.value += 1
    swap
    app_global_put
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.createDailyDisbursement() -> void:
createDailyDisbursement:
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    intc_0 // 0
    bytec_3 // "akita_assets"
    app_global_get_ex
    bury 1
    assert // check GlobalState exists
    retsub


// smart_contracts/dao/contract.algo.ts::AkitaDAO.optinEscrow(payment: uint64, name: bytes, asset: uint64) -> void:
optinEscrow:
    // smart_contracts/dao/contract.algo.ts:276
    // optinEscrow(payment: gtxn.PaymentTxn, name: string, asset: uint64): void {
    proto 3 0
    // smart_contracts/dao/constants.ts:24
    // export const AkitDAOBoxPrefixEscrows = 'r'
    pushbytes "r"
    frame_dig -2
    concat
    // smart_contracts/dao/contract.algo.ts:278
    // assert(this.escrows(name).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/dao/contract.algo.ts:280
    // const escrow = this.escrows(name).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    extract 8 32 // on error: Index access is out of bounds
    uncover 2
    pushint 320 // 320
    getbit
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/dao/contract.algo.ts:281
    // const escrowAccount = Application(escrow.escrow).address
    uncover 2
    app_params_get AppAddress
    swap
    dup
    cover 3
    cover 4
    assert // application exists
    // smart_contracts/dao/contract.algo.ts:283
    // assert(escrow.account.native === Txn.sender, ERR_INCORRECT_SENDER)
    txn Sender
    uncover 3
    ==
    assert // Incorrect sender
    // smart_contracts/dao/contract.algo.ts:284
    // assert(escrow.optinAllowed === true, ERR_ESCROW_NOT_ALLOWED_TO_OPTIN)
    intc_1 // 1
    ==
    assert // Escrow is not allowed to opt-in
    // smart_contracts/dao/contract.algo.ts:286-293
    // assertMatch(
    //   payment,
    //   {
    //     receiver: escrowAccount,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -3
    gtxns Receiver
    ==
    bz optinEscrow_bool_false@3
    frame_dig -3
    gtxns Amount
    // smart_contracts/dao/contract.algo.ts:290
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/dao/contract.algo.ts:286-293
    // assertMatch(
    //   payment,
    //   {
    //     receiver: escrowAccount,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optinEscrow_bool_false@3
    intc_1 // 1

optinEscrow_bool_merge@4:
    // smart_contracts/dao/contract.algo.ts:286-293
    // assertMatch(
    //   payment,
    //   {
    //     receiver: escrowAccount,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/dao/contract.algo.ts:295-301
    // itxn.assetTransfer({
    //   sender: escrowAccount,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // }).submit()
    itxn_begin
    // smart_contracts/dao/contract.algo.ts:297
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/dao/contract.algo.ts:298
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 0
    itxn_field Sender
    // smart_contracts/dao/contract.algo.ts:295-301
    // itxn.assetTransfer({
    //   sender: escrowAccount,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // }).submit()
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/dao/contract.algo.ts:295-301
    // itxn.assetTransfer({
    //   sender: escrowAccount,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset,
    //   fee,
    // }).submit()
    itxn_submit
    retsub

optinEscrow_bool_false@3:
    intc_0 // 0
    b optinEscrow_bool_merge@4


// smart_contracts/dao/contract.algo.ts::AkitaDAO.getState() -> bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes, bytes:
getState:
    // smart_contracts/dao/constants.ts:3
    // export const AkitaDAOGlobalStateKeysStatus = 'status'
    intc_0 // 0
    bytec 4 // "status"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:309
    // status: new UintN64(this.status.value),
    itob
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    intc_0 // 0
    bytec_2 // "version"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:310
    // version: new arc4.Str(this.version.value),
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/dao/constants.ts:4
    // export const AkitaDAOGlobalStateKeysContentPolicy = 'content_policy'
    intc_0 // 0
    bytec 5 // "content_policy"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:311
    // contentPolicy: new arc4.StaticBytes<36>(this.contentPolicy.value),
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/dao/constants.ts:5
    // export const AkitaDAOGlobalStateKeysMinimumRewardsImpact = 'minimum_rewards_impact'
    intc_0 // 0
    bytec 6 // "minimum_rewards_impact"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:312
    // minimumRewardsImpact: new UintN64(this.minimumRewardsImpact.value),
    itob
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    intc_0 // 0
    pushbytes "akita_al"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    intc_0 // 0
    pushbytes "other_al"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    intc_0 // 0
    bytec 7 // "social_fees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysStakingFees = 'staking_fees'
    intc_0 // 0
    bytec 8 // "staking_fees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:11
    // export const AkitaDAOGlobalStateKeysSubscriptionFees = 'subscription_fees'
    intc_0 // 0
    bytec 9 // "subscription_fees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:13
    // export const AkitaDAOGlobalStateKeysNFTFees = 'nft_fees'
    intc_0 // 0
    bytec 10 // "nft_fees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:14
    // export const AkitaDAOGlobalStateKeysKrbyPercentage = 'krby_percentage'
    intc_0 // 0
    bytec 11 // "krby_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:319
    // krbyPercentage: new UintN64(this.krbyPercentage.value),
    itob
    // smart_contracts/dao/constants.ts:15
    // export const AkitaDAOGlobalStateKeysModeratorPercentage = 'mod_percentage'
    intc_0 // 0
    bytec 12 // "mod_percentage"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:320
    // moderatorPercentage: new UintN64(this.moderatorPercentage.value),
    itob
    // smart_contracts/dao/constants.ts:17
    // export const AkitaDAOGlobalStateKeysProposalSettings = 'proposal_settings'
    intc_0 // 0
    bytec 13 // "proposal_settings"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    intc_0 // 0
    bytec_3 // "akita_assets"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:18
    // export const AkitaDAOGlobalStateKeysRevocationAddress = 'revocation_address'
    intc_0 // 0
    bytec 14 // "revocation_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/contract.algo.ts:308-324
    // return {
    //   status: new UintN64(this.status.value),
    //   version: new arc4.Str(this.version.value),
    //   contentPolicy: new arc4.StaticBytes<36>(this.contentPolicy.value),
    //   minimumRewardsImpact: new UintN64(this.minimumRewardsImpact.value),
    //   akitaAppList: this.akitaAppList.value.copy(),
    //   otherAppList: this.otherAppList.value.copy(),
    //   socialFees: this.socialFees.value.copy(),
    //   stakingFees: this.stakingFees.value.copy(),
    //   subscriptionFees: this.subscriptionFees.value.copy(),
    //   nftFees: this.nftFees.value.copy(),
    //   krbyPercentage: new UintN64(this.krbyPercentage.value),
    //   moderatorPercentage: new UintN64(this.moderatorPercentage.value),
    //   proposalSettings: this.proposalSettings.value.copy(),
    //   akitaAssets: this.akitaAssets.value.copy(),
    //   revocationAddress: new Address(this.revocationAddress.value),
    // }
    cover 14
    cover 14
    cover 14
    uncover 13
    uncover 14
    uncover 14
    retsub
