#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 4 1 32
    bytecblock 0x151f7c75 0x0001 0x0000
    // smart_contracts/app-registry/contract.algo.ts:7
    // export class AppRegistry extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x607e7046 0x4c9fb656 0x89e79924 0x40e65262 0xb561c256 0x82b435f8 // method "register(pay,uint64)void", method "exists(address)bool", method "get(address)uint64", method "mustGet(address)uint64", method "getList(address[])uint64[]", method "mustGetList(address[])uint64[]"
    txna ApplicationArgs 0
    match register exists get mustGet getList mustGetList
    err

main___algots__.defaultCreate@13:
    // smart_contracts/app-registry/contract.algo.ts:7
    // export class AppRegistry extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.register[routing]() -> void:
register:
    // smart_contracts/app-registry/contract.algo.ts:25-28
    // register(
    //   payment: gtxn.PaymentTxn,
    //   app: uint64,
    // ): void {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    // smart_contracts/app-registry/contract.algo.ts:29
    // const key = Application(app).address.bytes.slice(0, 4).toFixed({ length: 4 })
    app_params_get AppAddress
    assert // application exists
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    cover 2
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:30
    // if (!this.apps(key).exists) {
    box_len
    bury 1
    bnz register_else_body@3
    // smart_contracts/app-registry/contract.algo.ts:31-38
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 7_300,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dup
    gtxns Receiver
    // smart_contracts/app-registry/contract.algo.ts:34
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/app-registry/contract.algo.ts:31-38
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 7_300,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/app-registry/contract.algo.ts:35
    // amount: 7_300,
    pushint 7300 // 7300
    // smart_contracts/app-registry/contract.algo.ts:31-38
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 7_300,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/app-registry/contract.algo.ts:40
    // this.apps(key).value = [app]
    dig 1
    itob
    bytec_1 // 0x0001
    swap
    concat
    dig 1
    dup
    box_del
    pop
    swap
    box_put

register_after_if_else@4:
    // smart_contracts/app-registry/contract.algo.ts:25-28
    // register(
    //   payment: gtxn.PaymentTxn,
    //   app: uint64,
    // ): void {
    intc_2 // 1
    return

register_else_body@3:
    // smart_contracts/app-registry/contract.algo.ts:42-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 4_800,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dup
    gtxns Receiver
    // smart_contracts/app-registry/contract.algo.ts:45
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/app-registry/contract.algo.ts:42-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 4_800,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/app-registry/contract.algo.ts:46
    // amount: 4_800,
    pushint 4800 // 4800
    // smart_contracts/app-registry/contract.algo.ts:42-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: 4_800,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/app-registry/contract.algo.ts:51
    // this.apps(key).value.push(app)
    dupn 2
    box_get
    assert // Box must have value
    dig 3
    itob
    dig 1
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_2 // 1
    +
    itob
    extract 6 2
    replace2 0
    dig 1
    box_del
    pop
    box_put
    b register_after_if_else@4


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.exists[routing]() -> void:
exists:
    // smart_contracts/app-registry/contract.algo.ts:55
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/app-registry/contract.algo.ts:57
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:59
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz exists_after_if_else@3
    // smart_contracts/app-registry/contract.algo.ts:60
    // return false
    intc_0 // 0

exists_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.exists@4:
    // smart_contracts/app-registry/contract.algo.ts:55
    // @abimethod({ readonly: true })
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

exists_after_if_else@3:
    // smart_contracts/app-registry/contract.algo.ts:63
    // const apps = clone(this.apps(addr4).value)
    dup
    box_get
    assert // Box must have value
    // smart_contracts/app-registry/contract.algo.ts:64
    // const matchingAppID = this.findMatch(address, apps)
    dig 2
    swap
    callsub findMatch
    pop
    // smart_contracts/app-registry/contract.algo.ts:66
    // return matchingAppID !== 0
    intc_0 // 0
    !=
    // smart_contracts/app-registry/contract.algo.ts:55
    // @abimethod({ readonly: true })
    b exists_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.exists@4


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.get[routing]() -> void:
get:
    // smart_contracts/app-registry/contract.algo.ts:69
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/app-registry/contract.algo.ts:71
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:73
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz get_after_if_else@3
    // smart_contracts/app-registry/contract.algo.ts:74
    // return 0
    intc_0 // 0

get_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.get@4:
    // smart_contracts/app-registry/contract.algo.ts:69
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

get_after_if_else@3:
    // smart_contracts/app-registry/contract.algo.ts:77
    // const apps = clone(this.apps(addr4).value)
    dup
    box_get
    assert // Box must have value
    // smart_contracts/app-registry/contract.algo.ts:78
    // const matchingAppID = this.findMatch(address, apps)
    dig 2
    swap
    callsub findMatch
    pop
    // smart_contracts/app-registry/contract.algo.ts:69
    // @abimethod({ readonly: true })
    b get_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.get@4


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.mustGet[routing]() -> void:
mustGet:
    // smart_contracts/app-registry/contract.algo.ts:83
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/app-registry/contract.algo.ts:85
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dupn 2
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:87
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz mustGet_after_if_else@3
    // smart_contracts/app-registry/contract.algo.ts:88
    // return 0
    intc_0 // 0

mustGet_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.mustGet@4:
    // smart_contracts/app-registry/contract.algo.ts:83
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

mustGet_after_if_else@3:
    // smart_contracts/app-registry/contract.algo.ts:91
    // const apps = clone(this.apps(addr4).value)
    dup
    box_get
    assert // Box must have value
    // smart_contracts/app-registry/contract.algo.ts:92
    // const matchingAppID = this.findMatch(address, apps)
    dig 2
    swap
    callsub findMatch
    pop
    // smart_contracts/app-registry/contract.algo.ts:94
    // assert(matchingAppID !== 0, ERR_APP_NOT_REGISTERED)
    dup
    assert // App not registered
    // smart_contracts/app-registry/contract.algo.ts:83
    // @abimethod({ readonly: true })
    b mustGet_after_inlined_smart_contracts/app-registry/contract.algo.ts::AppRegistry.mustGet@4


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.getList[routing]() -> void:
getList:
    intc_0 // 0
    dup
    // smart_contracts/app-registry/contract.algo.ts:99
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    intc_3 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/app-registry/contract.algo.ts:101
    // let apps: uint64[] = []
    bytec_2 // 0x0000
    intc_0 // 0

getList_for_header@2:
    // smart_contracts/app-registry/contract.algo.ts:103
    // for (const address of addresses) {
    dup
    dig 3
    <
    bz getList_after_for@8
    dig 3
    extract 2 0
    dig 1
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 6
    // smart_contracts/app-registry/contract.algo.ts:104
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    substring3
    dup
    bury 7
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:106
    // if (!this.apps(addr4).exists) {
    box_len
    bury 1
    bnz getList_after_if_else@5
    // smart_contracts/app-registry/contract.algo.ts:107
    // apps = [...apps, zero]
    dig 1
    pushbytes 0x0000000000000000
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 2

getList_block@6:
    dup
    intc_2 // 1
    +
    bury 1
    b getList_for_header@2

getList_after_if_else@5:
    // smart_contracts/app-registry/contract.algo.ts:111
    // const appList = clone(this.apps(addr4).value)
    dig 5
    box_get
    assert // Box must have value
    // smart_contracts/app-registry/contract.algo.ts:114
    // this.findMatch(address, appList)
    dig 5
    swap
    callsub findMatch
    pop
    // smart_contracts/app-registry/contract.algo.ts:112-115
    // apps = [
    //   ...apps,
    //   this.findMatch(address, appList)
    // ]
    itob
    bytec_1 // 0x0001
    swap
    concat
    extract 2 0
    dig 2
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 2
    b getList_block@6

getList_after_for@8:
    // smart_contracts/app-registry/contract.algo.ts:99
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    dig 2
    concat
    log
    intc_2 // 1
    return


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.mustGetList[routing]() -> void:
mustGetList:
    // smart_contracts/app-registry/contract.algo.ts:120
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    intc_3 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/app-registry/contract.algo.ts:122
    // let apps: uint64[] = []
    bytec_2 // 0x0000
    intc_0 // 0

mustGetList_for_header@2:
    // smart_contracts/app-registry/contract.algo.ts:123
    // for (const address of addresses) {
    dup
    dig 3
    <
    bz mustGetList_after_for@7
    dig 3
    extract 2 0
    dig 1
    dup
    cover 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/app-registry/contract.algo.ts:124
    // const addr4 = address.bytes.slice(0, 4).toFixed({ length: 4 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_1 // 4
    dig 2
    >=
    intc_1 // 4
    uncover 3
    uncover 2
    select
    dig 2
    cover 2
    substring3
    dup
    len
    intc_1 // 4
    ==
    assert // Length must be 4
    // smart_contracts/app-registry/contract.algo.ts:126
    // if (!this.apps(addr4).exists) {
    dup
    box_len
    bury 1
    assert // App not registered
    // smart_contracts/app-registry/contract.algo.ts:130
    // const appList = clone(this.apps(addr4).value)
    box_get
    pop
    // smart_contracts/app-registry/contract.algo.ts:131
    // const matchingAppID = this.findMatch(address, appList)
    callsub findMatch
    pop
    // smart_contracts/app-registry/contract.algo.ts:133
    // assert(matchingAppID !== 0, ERR_APP_NOT_REGISTERED)
    dup
    assert // App not registered
    // smart_contracts/app-registry/contract.algo.ts:134-137
    // apps = [
    //   ...apps,
    //   matchingAppID
    // ]
    itob
    bytec_1 // 0x0001
    swap
    concat
    extract 2 0
    dig 3
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    replace2 0
    bury 3
    intc_2 // 1
    +
    bury 1
    b mustGetList_for_header@2

mustGetList_after_for@7:
    // smart_contracts/app-registry/contract.algo.ts:120
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    dig 2
    concat
    log
    intc_2 // 1
    return


// smart_contracts/app-registry/contract.algo.ts::AppRegistry.findMatch(address: bytes, apps: bytes) -> uint64, bytes:
findMatch:
    // smart_contracts/app-registry/contract.algo.ts:11
    // private findMatch(address: Address, apps: uint64[]): uint64 {
    proto 2 2
    pushbytes ""
    // smart_contracts/app-registry/contract.algo.ts:12
    // for (let i: uint64 = 0; i < apps.length; i++) {
    intc_0 // 0

findMatch_while_top@1:
    // smart_contracts/app-registry/contract.algo.ts:12
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz findMatch_after_while@5
    // smart_contracts/app-registry/contract.algo.ts:13
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -1
    extract 2 0
    frame_dig 1
    pushint 8 // 8
    *
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/app-registry/contract.algo.ts:22
    // return Application(app).address.bytes
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/app-registry/contract.algo.ts:13
    // if (address.native.bytes === this.deriveAddr(apps[i])) {
    frame_dig -2
    ==
    bz findMatch_after_if_else@4
    // smart_contracts/app-registry/contract.algo.ts:14
    // return apps[i]
    frame_dig 0
    frame_dig -1
    uncover 3
    uncover 3
    retsub

findMatch_after_if_else@4:
    // smart_contracts/app-registry/contract.algo.ts:12
    // for (let i: uint64 = 0; i < apps.length; i++) {
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b findMatch_while_top@1

findMatch_after_while@5:
    // smart_contracts/app-registry/contract.algo.ts:18
    // return 0
    intc_0 // 0
    frame_dig -1
    uncover 3
    uncover 3
    retsub
