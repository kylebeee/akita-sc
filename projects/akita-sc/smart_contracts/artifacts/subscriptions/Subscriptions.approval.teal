#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 100000 60500 479400 18900
    bytecblock "o" 0x151f7c75 "akita_dao" "s" "akita_escrow" 0x00 "b" 0x0000 0x0a 0x1e "wallet" 0x281b891b 0x3ea11832 "akita_al" 0x0001 "version" "subscription_fees"
    // smart_contracts/subscriptions/contract.algo.ts:86-90
    // export class Subscriptions extends classes(
    //   BaseSubscriptions,
    //   AkitaBaseFeeGeneratorContract,
    //   ContractWithOptIn
    // ) {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/subscriptions/contract.algo.ts:86-90
    // export class Subscriptions extends classes(
    //   BaseSubscriptions,
    //   AkitaBaseFeeGeneratorContract,
    //   ContractWithOptIn
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@40
    pushbytess 0x4bd621d8 0x366d5b27 0x8c5e86d5 0x17c8730b 0x4cdf0cd7 0x87e055c6 0xb59c8a54 0xaeebb378 0x5355da6d 0x10f00c3a 0xa68e6963 0xb10a306e 0xf2355b55 0x1ac4a758 0xe3aeb25c 0xeaaaa4d3 // method "newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64", method "setServiceDescription(uint64,uint64,byte[])void", method "activateService(uint64)void", method "pauseService(uint64)void", method "unpauseService(uint64)void", method "shutdownService(uint64)void", method "block(pay,address)void", method "unblock(address)void", method "gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64", method "subscribe(pay,address,uint64,uint64,uint64)uint64", method "gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64", method "subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64", method "deposit(pay,uint64)void", method "depositAsa(axfer,uint64)void", method "withdraw(uint64,uint64)void", method "unsubscribe(uint64)void"
    bytec 11 // method "gatedTriggerPayment(appl,(address,uint64))void"
    pushbytess 0xc3d9f1dc 0xc0ff2730 0x275203af 0x1269d87e 0x4303668e 0x0d6a47a3 0x1a136f7c 0xe2d3700a 0x7fbe9ab3 0x9bcf8ebc 0x603d7297 // method "triggerPayment((address,uint64))void", method "streakCheck((address,uint64))void", method "setPasses(uint64,address[])void", method "triggerList((address,uint64[])[])bool[]", method "isBlocked(address,address)bool", method "isShutdown(address,uint64)bool", method "getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])", method "getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]", method "getSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "getSubscriptionWithPasses((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])", method "isFirstSubscription(address)bool"
    bytec 12 // method "optin(pay,uint64)void"
    pushbytess 0x1ead20a9 0x33e92c94 0x854dede0 // method "updateAkitaDAOEscrow(uint64)void", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match newService setServiceDescription activateService pauseService unpauseService shutdownService block unblock gatedSubscribe subscribe gatedSubscribeAsa subscribeAsa deposit depositAsa withdraw unsubscribe gatedTriggerPayment triggerPayment streakCheck setPasses triggerList isBlocked isShutdown getService getServicesByAddress getSubscription getSubscriptionWithPasses isFirstSubscription optin updateAkitaDAOEscrow updateAkitaDAO main_opUp_route@38
    err

main_opUp_route@38:
    // smart_contracts/utils/base-contracts/base.ts:41
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@40:
    // smart_contracts/subscriptions/contract.algo.ts:86-90
    // export class Subscriptions extends classes(
    //   BaseSubscriptions,
    //   AkitaBaseFeeGeneratorContract,
    //   ContractWithOptIn
    // ) {
    pushbytes 0x88c940f8 // method "create(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/utils/functions.ts::originOrTxnSender(walletID: uint64) -> bytes:
originOrTxnSender:
    // smart_contracts/utils/functions.ts:133
    // export function originOrTxnSender(walletID: Application): Account {
    proto 1 1
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    txn Sender
    // smart_contracts/utils/functions.ts:127
    // if (walletID.id === 0) {
    frame_dig -1
    bnz originOrTxnSender_after_if_else@3
    frame_dig 0

originOrTxnSender_after_inlined_smart_contracts/utils/functions.ts::originOr@4:
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    swap
    retsub

originOrTxnSender_after_if_else@3:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:134
    // return originOr(walletID, Txn.sender)
    b originOrTxnSender_after_inlined_smart_contracts/utils/functions.ts::originOr@4


// smart_contracts/utils/functions.ts::getWalletIDUsingAkitaDAO(akitaDAO: uint64, address: bytes) -> uint64:
getWalletIDUsingAkitaDAO:
    // smart_contracts/utils/functions.ts:164
    // export function getWalletIDUsingAkitaDAO(akitaDAO: Application, address: Account): Application {
    proto 2 1
    // smart_contracts/utils/functions.ts:53
    // return op.AppGlobal.getExUint64(akitaDAO, Bytes(AbstractAccountGlobalStateKeysEscrowFactory))[0]
    frame_dig -2
    pushbytes "escrow_factory"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:170-173
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:175
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getWalletIDUsingAkitaDAO_if_body@6
    frame_dig 1
    intc_2 // 8
    !=
    bz getWalletIDUsingAkitaDAO_after_if_else@7

getWalletIDUsingAkitaDAO_if_body@6:
    // smart_contracts/utils/functions.ts:176
    // return 0
    intc_0 // 0

getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8:
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    frame_bury 0
    retsub

getWalletIDUsingAkitaDAO_after_if_else@7:
    // smart_contracts/utils/functions.ts:179
    // return btoi(data)
    frame_dig 0
    btoi
    // smart_contracts/utils/functions.ts:166
    // return Application(getWalletID(escrowFactory, address))
    b getWalletIDUsingAkitaDAO_after_inlined_smart_contracts/utils/functions.ts::getWalletID@8


// smart_contracts/utils/functions.ts::gateCheck(gateTxn: uint64, akitaDAO: uint64, caller: bytes, id: uint64) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:203
    // export function gateCheck(gateTxn: gtxn.ApplicationCallTxn, akitaDAO: Application, caller: Account, id: uint64): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:205
    // gateTxn.sender === Txn.sender &&
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    // smart_contracts/utils/functions.ts:205-206
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:206
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    frame_dig -4
    gtxns ApplicationID
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 13 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:206
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    pushint 40 // 40
    extract_uint64
    ==
    // smart_contracts/utils/functions.ts:205-206
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:207
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -4
    gtxns OnCompletion
    // smart_contracts/utils/functions.ts:205-207
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    bnz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:208
    // gateTxn.numAppArgs === 4 &&
    frame_dig -4
    gtxns NumAppArgs
    pushint 4 // 4
    ==
    // smart_contracts/utils/functions.ts:205-208
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:210
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    frame_dig -4
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x00b6e80e // method "mustCheck(address,uint64,byte[])"
    ==
    // smart_contracts/utils/functions.ts:205-210
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:211
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    frame_dig -4
    intc_1 // 1
    gtxnsas ApplicationArgs
    frame_dig -2
    ==
    // smart_contracts/utils/functions.ts:205-211
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    bz gateCheck_bool_false@8
    // smart_contracts/utils/functions.ts:212
    // gateTxn.appArgs(2) === itob(id)
    frame_dig -4
    pushint 2 // 2
    gtxnsas ApplicationArgs
    frame_dig -1
    itob
    ==
    // smart_contracts/utils/functions.ts:205-212
    // gateTxn.sender === Txn.sender &&
    // gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    // gateTxn.onCompletion === OnCompleteAction.NoOp &&
    // gateTxn.numAppArgs === 4 &&
    // // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    // gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    // gateTxn.appArgs(1) === new Address(caller).bytes &&
    // gateTxn.appArgs(2) === itob(id)
    bz gateCheck_bool_false@8
    intc_1 // 1
    // smart_contracts/utils/functions.ts:204-213
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    //   gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub

gateCheck_bool_false@8:
    intc_0 // 0
    // smart_contracts/utils/functions.ts:204-213
    // return (
    //   gateTxn.sender === Txn.sender &&
    //   gateTxn.appId === Application(getAkitaAppList(akitaDAO).gate) &&
    //   gateTxn.onCompletion === OnCompleteAction.NoOp &&
    //   gateTxn.numAppArgs === 4 &&
    //   // gateTxn.appArgs(0) === methodSelector(Gate.prototype.mustCheck) &&
    //   gateTxn.appArgs(0) === methodSelector('mustCheck(address,uint64,byte[])') &&
    //   gateTxn.appArgs(1) === new Address(caller).bytes &&
    //   gateTxn.appArgs(2) === itob(id)
    // )
    retsub


// smart_contracts/utils/functions.ts::sendReferralPayment(akitaDAO: uint64, asset: uint64, amount: uint64) -> bytes:
sendReferralPayment:
    // smart_contracts/utils/functions.ts:524
    // export function sendReferralPayment(akitaDAO: Application, asset: uint64, amount: uint64): ReferralPaymentInfo {
    proto 3 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 4
    // smart_contracts/utils/functions.ts:525
    // const wallet = getWalletIDUsingAkitaDAO(akitaDAO, Txn.sender)
    frame_dig -3
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    dup
    // smart_contracts/utils/functions.ts:145
    // return referrerOr(walletID, Global.zeroAddress)
    global ZeroAddress
    swap
    // smart_contracts/utils/functions.ts:138
    // if (walletID.id === 0) {
    bnz sendReferralPayment_after_if_else@18
    frame_dig 8
    frame_bury 1

sendReferralPayment_after_inlined_smart_contracts/utils/functions.ts::referrerOr@19:
    // smart_contracts/utils/functions.ts:529
    // if (amount > 0 && referrer !== Global.zeroAddress) {
    frame_dig -1
    bz sendReferralPayment_after_if_else@6
    frame_dig 1
    global ZeroAddress
    !=
    bz sendReferralPayment_after_if_else@6
    // smart_contracts/utils/functions.ts:57
    // const [walletFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysWalletFees))
    frame_dig -3
    pushbytes "wallet_fees"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:531
    // const { referrerPercentage } = getWalletFees(akitaDAO)
    intc_2 // 8
    extract_uint64
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 4
    // smart_contracts/utils/functions.ts:534
    // if (referralFee === 0 && amount > 0) {
    bnz sendReferralPayment_after_if_else@5
    frame_dig -1
    bz sendReferralPayment_after_if_else@5
    // smart_contracts/utils/functions.ts:535
    // referralFee = 1
    intc_1 // 1
    frame_bury 4

sendReferralPayment_after_if_else@5:
    // smart_contracts/utils/functions.ts:541
    // Global.latestTimestamp,
    global LatestTimestamp
    frame_bury 6
    // smart_contracts/utils/functions.ts:542
    // (Global.latestTimestamp + ONE_WEEK),
    global LatestTimestamp
    pushint 604800 // 604800
    +
    frame_bury 3
    // smart_contracts/utils/functions.ts:543
    // [{ address: referrer, amount: referralFee }],
    frame_dig 4
    itob
    frame_dig 1
    swap
    concat
    bytec 14 // 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:38
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -3
    bytec 13 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:459
    // const rewardsApp = getAkitaAppList(akitaDAO).rewards
    intc_2 // 8
    extract_uint64
    frame_bury 5
    // smart_contracts/utils/functions.ts:462
    // let cost: uint64 = MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    intc_0 // 0
    extract_uint16
    pushint 25300 // 25300
    *
    pushint 35300 // 35300
    +
    frame_bury 2
    // smart_contracts/utils/functions.ts:463
    // if (asset === 0) {
    frame_dig -2
    bnz sendReferralPayment_else_body@9
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:468
    // receiver: Application(rewardsApp).address,
    frame_dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:469
    // amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    frame_dig 2
    frame_dig 4
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:467-470
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:471
    // timeToUnlock,
    frame_dig 6
    itob
    // smart_contracts/utils/functions.ts:472
    // expiration,
    frame_dig 3
    itob
    // smart_contracts/utils/functions.ts:464-475
    // id = abiCall<typeof Rewards.prototype.createInstantDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length) + sum
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0x7b7dc5fc // method "createInstantDisbursement(pay,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi

sendReferralPayment_after_if_else@12:
    // smart_contracts/utils/functions.ts:510
    // return { id, cost }
    itob
    frame_dig 2
    itob
    concat
    // smart_contracts/utils/functions.ts:538-545
    // const { cost: referralMbr } = createInstantDisbursement(
    //   akitaDAO,
    //   asset,
    //   Global.latestTimestamp,
    //   (Global.latestTimestamp + ONE_WEEK),
    //   [{ address: referrer, amount: referralFee }],
    //   referralFee
    // )
    extract 8 8
    // smart_contracts/utils/functions.ts:547
    // return { leftover: (amount - referralFee), referralMbr }
    frame_dig -1
    frame_dig 4
    -
    itob
    swap
    concat
    frame_bury 0
    retsub

sendReferralPayment_else_body@9:
    // smart_contracts/utils/functions.ts:477
    // if (!Application(rewardsApp).address.isOptedIn(Asset(asset))) {
    frame_dig 5
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bz sendReferralPayment_if_body@10
    frame_dig 2

sendReferralPayment_after_if_else@11:
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:495
    // receiver: Application(rewardsApp).address,
    frame_dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:494-497
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:498-502
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/utils/functions.ts:499
    // assetReceiver: Application(rewardsApp).address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/functions.ts:498-502
    // itxn.assetTransfer({
    //   assetReceiver: Application(rewardsApp).address,
    //   assetAmount: sum,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/utils/functions.ts:503
    // timeToUnlock,
    frame_dig 6
    itob
    // smart_contracts/utils/functions.ts:504
    // expiration,
    frame_dig 3
    itob
    // smart_contracts/utils/functions.ts:491-507
    // id = abiCall<typeof Rewards.prototype.createInstantAsaDisbursement>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: MinDisbursementsMBR + (UserAllocationMBR * allocations.length)
    //     }),
    //     itxn.assetTransfer({
    //       assetReceiver: Application(rewardsApp).address,
    //       assetAmount: sum,
    //       xferAsset: asset
    //     }),
    //     timeToUnlock,
    //     expiration,
    //     allocations
    //   ]
    // }).returnValue
    pushbytes 0xaf1a14f2 // method "createInstantAsaDisbursement(pay,axfer,uint64,uint64,(address,uint64)[])uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 2 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    frame_bury 2
    b sendReferralPayment_after_if_else@12

sendReferralPayment_if_body@10:
    // smart_contracts/utils/functions.ts:478
    // cost += Global.assetOptInMinBalance
    frame_dig 2
    global AssetOptInMinBalance
    +
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    itxn_begin
    // smart_contracts/utils/functions.ts:483
    // receiver: Application(rewardsApp).address,
    frame_dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:484
    // amount: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:482-485
    // itxn.payment({
    //   receiver: Application(rewardsApp).address,
    //   amount: Global.assetOptInMinBalance
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    itxn_next
    // smart_contracts/utils/functions.ts:486
    // asset
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:479-488
    // abiCall<typeof Rewards.prototype.optin>({
    //   appId: rewardsApp,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(rewardsApp).address,
    //       amount: Global.assetOptInMinBalance
    //     }),
    //     asset
    //   ]
    // })
    bytec 12 // method "optin(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b sendReferralPayment_after_if_else@11

sendReferralPayment_after_if_else@6:
    // smart_contracts/utils/functions.ts:550
    // return { leftover: amount, referralMbr: 0 }
    frame_dig -1
    itob
    intc_0 // 0
    itob
    concat
    frame_bury 0
    retsub

sendReferralPayment_after_if_else@18:
    // smart_contracts/utils/functions.ts:157-160
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig 7
    // smart_contracts/utils/functions.ts:159
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:157-160
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    frame_bury 1
    // smart_contracts/utils/functions.ts:145
    // return referrerOr(walletID, Global.zeroAddress)
    b sendReferralPayment_after_inlined_smart_contracts/utils/functions.ts::referrerOr@19


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.create[routing]() -> void:
create:
    // smart_contracts/subscriptions/contract.algo.ts:457
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 15 // "version"
    // smart_contracts/subscriptions/contract.algo.ts:459
    // this.version.value = version
    uncover 3
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:460
    // this.akitaDAO.value = akitaDAO
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:461
    // this.akitaDAOEscrow.value = akitaDAOEscrow
    swap
    app_global_put
    // smart_contracts/subscriptions/contract.algo.ts:457
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.newService[routing]() -> void:
newService:
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // smart_contracts/subscriptions/contract.algo.ts:477-488
    // newService(
    //   payment: gtxn.PaymentTxn,
    //   interval: uint64,
    //   asset: uint64,
    //   amount: uint64,
    //   passes: uint64,
    //   gateID: uint64,
    //   title: string,
    //   bannerImage: CID,
    //   highlightMessage: Uint8,
    //   highlightColor: bytes<3>
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 7
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 8
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 9
    dup
    len
    pushint 3 // 3
    ==
    assert // invalid number of bytes for uint8[3]
    // smart_contracts/subscriptions/contract.algo.ts:109
    // serviceslist = BoxMap<Account, uint64>({ keyPrefix: SubscriptionsBoxPrefixServicesList })
    pushbytes "m"
    // smart_contracts/subscriptions/contract.algo.ts:489
    // const id = this.newServiceID(Txn.sender)
    txn Sender
    // smart_contracts/subscriptions/contract.algo.ts:109
    // serviceslist = BoxMap<Account, uint64>({ keyPrefix: SubscriptionsBoxPrefixServicesList })
    concat
    dup
    // smart_contracts/subscriptions/contract.algo.ts:183
    // const id: uint64 = this.serviceslist(address).exists
    box_len
    bury 1
    // smart_contracts/subscriptions/contract.algo.ts:183-185
    // const id: uint64 = this.serviceslist(address).exists
    //   ? this.serviceslist(address).value
    //   : 0
    bz newService_ternary_false@6
    // smart_contracts/subscriptions/contract.algo.ts:184
    // ? this.serviceslist(address).value
    dup
    box_get
    assert // Box must have value
    btoi

newService_ternary_merge@7:
    // smart_contracts/subscriptions/contract.algo.ts:186
    // this.serviceslist(address).value = id + 1
    dup
    intc_1 // 1
    +
    itob
    dig 2
    swap
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:490
    // const boxKey: ServicesKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    dup
    bury 17
    concat
    bury 14
    // smart_contracts/subscriptions/contract.algo.ts:493
    // assert(amount >= MIN_AMOUNT, ERR_MIN_AMOUNT_IS_THREE)
    dig 7
    pushint 4 // 4
    >=
    assert // Minimum amount is 3 base units
    // smart_contracts/subscriptions/contract.algo.ts:495
    // assert(interval >= MIN_INTERVAL, ERR_MIN_INTERVAL_IS_SIXTY)
    dig 9
    pushint 60 // 60
    >=
    assert // Minimum interval is 60 seconds
    // smart_contracts/subscriptions/contract.algo.ts:497
    // assert(passes <= MAX_PASSES, ERR_MAX_PASSES_IS_FIVE)
    dig 6
    pushint 5 // 5
    <=
    assert // Maximum number of passes is five
    // smart_contracts/subscriptions/contract.algo.ts:498
    // assert(Bytes(title).length <= MAX_TITLE_LENGTH, ERR_TITLE_TOO_LONG)
    dig 4
    len
    dup
    bury 13
    pushint 128 // 128
    <=
    assert // Title exceeds maximum length
    // smart_contracts/subscriptions/contract.algo.ts:500
    // const serviceCreationFee = getSubscriptionFees(this.akitaDAO.value).serviceCreationFee
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:500
    // const serviceCreationFee = getSubscriptionFees(this.akitaDAO.value).serviceCreationFee
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:72
    // const [subscriptionFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSubscriptionFees))
    bytec 16 // "subscription_fees"
    app_global_get_ex
    pop
    // smart_contracts/subscriptions/contract.algo.ts:500
    // const serviceCreationFee = getSubscriptionFees(this.akitaDAO.value).serviceCreationFee
    intc_0 // 0
    extract_uint64
    dup
    bury 14
    // smart_contracts/subscriptions/contract.algo.ts:503
    // let requiredAmount: uint64 = serviceCreationFee + costs.services
    pushint 49700 // 49700
    +
    // smart_contracts/subscriptions/contract.algo.ts:504
    // if (asset !== 0) {
    dig 9
    bz newService_after_if_else@3
    // smart_contracts/subscriptions/contract.algo.ts:505
    // requiredAmount += Global.assetOptInMinBalance
    global AssetOptInMinBalance
    +

newService_after_if_else@3:
    // smart_contracts/subscriptions/contract.algo.ts:508
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, asset, serviceCreationFee)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:508
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, asset, serviceCreationFee)
    app_global_get_ex
    assert // check GlobalState exists
    dig 10
    dup
    cover 2
    dig 16
    callsub sendReferralPayment
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/subscriptions/contract.algo.ts:510-517
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: requiredAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 14
    dup
    gtxns Receiver
    // smart_contracts/subscriptions/contract.algo.ts:513
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:510-517
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: requiredAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/subscriptions/contract.algo.ts:514
    // amount: requiredAmount + referralMbr,
    uncover 5
    uncover 3
    +
    // smart_contracts/subscriptions/contract.algo.ts:510-517
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: requiredAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/subscriptions/contract.algo.ts:519-524
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:521
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:521
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/subscriptions/contract.algo.ts:519-523
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:519-524
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:526-538
    // this.services(boxKey).value = {
    //   status: ServiceStatusDraft,
    //   interval,
    //   asset,
    //   amount,
    //   passes,
    //   gateID,
    //   title,
    //   description: '',
    //   bannerImage,
    //   highlightMessage,
    //   highlightColor
    // }
    dig 10
    itob
    // smart_contracts/subscriptions/contract.algo.ts:527
    // status: ServiceStatusDraft,
    bytec 5 // 0x00
    // smart_contracts/subscriptions/contract.algo.ts:526-538
    // this.services(boxKey).value = {
    //   status: ServiceStatusDraft,
    //   interval,
    //   asset,
    //   amount,
    //   passes,
    //   gateID,
    //   title,
    //   description: '',
    //   bannerImage,
    //   highlightMessage,
    //   highlightColor
    // }
    swap
    concat
    swap
    itob
    concat
    dig 8
    itob
    concat
    dig 7
    itob
    concat
    dig 6
    itob
    concat
    dig 12
    itob
    extract 6 2
    dig 6
    concat
    swap
    pushbytes 0x0055
    concat
    dig 1
    len
    pushint 85 // 85
    +
    itob
    extract 6 2
    concat
    dig 5
    concat
    dig 4
    concat
    dig 3
    concat
    swap
    concat
    bytec 7 // 0x0000
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    dig 15
    concat
    // smart_contracts/subscriptions/contract.algo.ts:526-538
    // this.services(boxKey).value = {
    //   status: ServiceStatusDraft,
    //   interval,
    //   asset,
    //   amount,
    //   passes,
    //   gateID,
    //   title,
    //   description: '',
    //   bannerImage,
    //   highlightMessage,
    //   highlightColor
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:477-488
    // newService(
    //   payment: gtxn.PaymentTxn,
    //   interval: uint64,
    //   asset: uint64,
    //   amount: uint64,
    //   passes: uint64,
    //   gateID: uint64,
    //   title: string,
    //   bannerImage: CID,
    //   highlightMessage: Uint8,
    //   highlightColor: bytes<3>
    // ): uint64 {
    bytec_1 // 0x151f7c75
    dig 15
    concat
    log
    intc_1 // 1
    return

newService_ternary_false@6:
    // smart_contracts/subscriptions/contract.algo.ts:185
    // : 0
    intc_0 // 0
    b newService_ternary_merge@7


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.setServiceDescription[routing]() -> void:
setServiceDescription:
    // smart_contracts/subscriptions/contract.algo.ts:543
    // setServiceDescription(id: ServiceID, offset: uint64, data: bytes): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    uncover 2
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 2 0
    dup
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:544
    // const key: ServicesKey = { address: Txn.sender, id }
    txn Sender
    uncover 2
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    dup
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:546
    // assert(this.services(key).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:547
    // assert(this.services(key).value.status === ServiceStatusDraft, ERR_SERVICE_IS_NOT_DRAFT)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 5 // 0x00
    ==
    assert // Service offering is not in draft status
    // smart_contracts/subscriptions/contract.algo.ts:548
    // assert(offset + data.length <= MAX_DESCRIPTION_LENGTH, ERR_BAD_DESCRIPTION_LENGTH)
    swap
    len
    dig 2
    +
    pushint 3152 // 3152
    <=
    assert // Description length exceeds maximum
    // smart_contracts/subscriptions/contract.algo.ts:550
    // let descBytes = Bytes(this.services(key).value.description)
    box_get
    pop
    dup
    pushint 43 // 43
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    cover 2
    // smart_contracts/subscriptions/contract.algo.ts:552
    // assert(offset <= descBytes.length, ERR_BAD_OFFSET)
    len
    dup
    cover 3
    dup2
    <=
    assert // Invalid description offset
    // smart_contracts/subscriptions/contract.algo.ts:554
    // if (offset < descBytes.length) {
    <
    bz setServiceDescription_after_if_else@3
    // smart_contracts/subscriptions/contract.algo.ts:555
    // descBytes = descBytes.slice(0, offset)
    intc_0 // 0
    dig 2
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    dig 6
    dup
    dig 3
    >=
    swap
    uncover 3
    uncover 2
    select
    substring3

setServiceDescription_after_if_else@3:
    // smart_contracts/subscriptions/contract.algo.ts:558
    // this.services(key).value.description = String(descBytes.concat(data))
    dig 3
    concat
    dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    dig 1
    pushint 43 // 43
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:543
    // setServiceDescription(id: ServiceID, offset: uint64, data: bytes): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.activateService[routing]() -> void:
activateService:
    // smart_contracts/subscriptions/contract.algo.ts:566
    // activateService(id: ServiceID): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:567
    // const boxKey: ServicesKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:569
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:570
    // assert(this.services(boxKey).value.status === ServiceStatusDraft, ERR_SERVICE_IS_NOT_DRAFT)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 5 // 0x00
    ==
    assert // Service offering is not in draft status
    // smart_contracts/subscriptions/contract.algo.ts:572
    // this.services(boxKey).value.status = ServiceStatusActive
    intc_0 // 0
    bytec 8 // 0x0a
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:566
    // activateService(id: ServiceID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.pauseService[routing]() -> void:
pauseService:
    // smart_contracts/subscriptions/contract.algo.ts:582
    // pauseService(id: ServiceID): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:583
    // const boxKey: ServicesKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:585
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:587
    // assert(this.services(boxKey).value.status === ServiceStatusActive, ERR_SERVICE_IS_NOT_ACTIVE)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 8 // 0x0a
    ==
    assert // Service offering is not active
    // smart_contracts/subscriptions/contract.algo.ts:589
    // this.services(boxKey).value.status = ServiceStatusPaused
    intc_0 // 0
    pushbytes 0x14
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:582
    // pauseService(id: ServiceID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.unpauseService[routing]() -> void:
unpauseService:
    // smart_contracts/subscriptions/contract.algo.ts:597
    // unpauseService(id: ServiceID): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:598
    // const boxKey: ServicesKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:601
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:603
    // assert(this.services(boxKey).value.status === ServiceStatusPaused, ERR_SERVICE_IS_NOT_PAUSED)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    pushbytes 0x14
    ==
    assert // Service offering is not paused
    // smart_contracts/subscriptions/contract.algo.ts:605
    // this.services(boxKey).value.status = ServiceStatusActive
    intc_0 // 0
    bytec 8 // 0x0a
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:597
    // unpauseService(id: ServiceID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.shutdownService[routing]() -> void:
shutdownService:
    // smart_contracts/subscriptions/contract.algo.ts:613
    // shutdownService(id: ServiceID): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:614
    // const boxKey: ServicesKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:616
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:618
    // assert(this.services(boxKey).value.status !== ServiceStatusShutdown, ERR_SERVICE_IS_SHUTDOWN)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 9 // 0x1e
    !=
    assert // Service offering is shutdown
    // smart_contracts/subscriptions/contract.algo.ts:620
    // this.services(boxKey).value.status = ServiceStatusShutdown
    intc_0 // 0
    bytec 9 // 0x1e
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:613
    // shutdownService(id: ServiceID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.block[routing]() -> void:
block:
    // smart_contracts/subscriptions/contract.algo.ts:628
    // block(payment: gtxn.PaymentTxn, blocked: Account): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/subscriptions/contract.algo.ts:630
    // const boxKey = this.getBlockKey(Txn.sender, blocked)
    txn Sender
    swap
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:633
    // assert(!this.blocks(boxKey).exists, ERR_USER_ALREADY_BLOCKED)
    dup
    box_len
    bury 1
    !
    assert // User is already blocked
    // smart_contracts/subscriptions/contract.algo.ts:636-643
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.blocks,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/subscriptions/contract.algo.ts:639
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:636-643
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.blocks,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/subscriptions/contract.algo.ts:640
    // amount: costs.blocks,
    pushint 15700 // 15700
    // smart_contracts/subscriptions/contract.algo.ts:636-643
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.blocks,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/subscriptions/contract.algo.ts:645
    // this.blocks(boxKey).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/subscriptions/contract.algo.ts:628
    // block(payment: gtxn.PaymentTxn, blocked: Account): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.unblock[routing]() -> void:
unblock:
    // smart_contracts/subscriptions/contract.algo.ts:652
    // unblock(blocked: Account): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/subscriptions/contract.algo.ts:653
    // const boxKey = this.getBlockKey(Txn.sender, blocked)
    txn Sender
    swap
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:656
    // assert(this.blocks(boxKey).exists, ERR_USER_NOT_BLOCKED)
    dup
    box_len
    bury 1
    assert // User is not blocked
    // smart_contracts/subscriptions/contract.algo.ts:658
    // this.blocks(boxKey).delete()
    box_del
    pop
    // smart_contracts/subscriptions/contract.algo.ts:662-665
    // itxn.payment({
    //   receiver: Txn.sender,
    //   amount: costs.blocks
    // }).submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:663
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/subscriptions/contract.algo.ts:664
    // amount: costs.blocks
    pushint 15700 // 15700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:662-665
    // itxn.payment({
    //   receiver: Txn.sender,
    //   amount: costs.blocks
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:652
    // unblock(blocked: Account): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.gatedSubscribe[routing]() -> void:
gatedSubscribe:
    // smart_contracts/subscriptions/contract.algo.ts:668-675
    // gatedSubscribe(
    //   payment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:677
    // assert(amount >= MIN_AMOUNT, ERR_MIN_AMOUNT_IS_THREE)
    dig 2
    pushint 4 // 4
    >=
    assert // Minimum amount is 3 base units
    // smart_contracts/subscriptions/contract.algo.ts:679
    // assert(interval >= MIN_INTERVAL, ERR_MIN_INTERVAL_IS_SIXTY)
    dig 1
    pushint 60 // 60
    >=
    assert // Minimum interval is 60 seconds
    // smart_contracts/subscriptions/contract.algo.ts:681
    // assert(serviceID !== 0, ERR_NOT_A_SERVICE)
    dup
    assert // Not a service
    // smart_contracts/subscriptions/contract.algo.ts:682
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    itob
    dig 4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:682
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:683
    // const gateID = this.services({ address: recipient, id: serviceID }).value.gateID
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:685
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:685
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/subscriptions/contract.algo.ts:686
    // const origin = originOrTxnSender(wallet)
    callsub originOrTxnSender
    // smart_contracts/subscriptions/contract.algo.ts:687
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:687
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    uncover 7
    swap
    uncover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/subscriptions/contract.algo.ts:689
    // return this.createSubscription(payment, recipient, amount, interval, serviceID)
    callsub createSubscription
    // smart_contracts/subscriptions/contract.algo.ts:668-675
    // gatedSubscribe(
    //   payment: gtxn.PaymentTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.subscribe[routing]() -> void:
subscribe:
    // smart_contracts/subscriptions/contract.algo.ts:692-698
    // subscribe(
    //   payment: gtxn.PaymentTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:700
    // assert(amount >= MIN_AMOUNT, ERR_MIN_AMOUNT_IS_THREE)
    uncover 2
    pushint 4 // 4
    >=
    assert // Minimum amount is 3 base units
    // smart_contracts/subscriptions/contract.algo.ts:702
    // assert(interval >= MIN_INTERVAL, ERR_MIN_INTERVAL_IS_SIXTY)
    swap
    pushint 60 // 60
    >=
    assert // Minimum interval is 60 seconds
    // smart_contracts/subscriptions/contract.algo.ts:704
    // if (serviceID !== 0) {
    bz subscribe_after_if_else@3
    // smart_contracts/subscriptions/contract.algo.ts:705
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    itob
    dig 4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:705
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:706
    // const gateID = this.services({ address: recipient, id: serviceID }).value.gateID
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:707
    // assert(gateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

subscribe_after_if_else@3:
    // smart_contracts/subscriptions/contract.algo.ts:710
    // return this.createSubscription(payment, recipient, amount, interval, serviceID)
    dig 4
    dig 4
    dig 4
    dig 4
    dig 4
    callsub createSubscription
    // smart_contracts/subscriptions/contract.algo.ts:692-698
    // subscribe(
    //   payment: gtxn.PaymentTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.gatedSubscribeAsa[routing]() -> void:
gatedSubscribeAsa:
    // smart_contracts/subscriptions/contract.algo.ts:713-721
    // gatedSubscribeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:723
    // assert(amount >= MIN_AMOUNT, ERR_MIN_AMOUNT_IS_THREE)
    dig 2
    pushint 4 // 4
    >=
    assert // Minimum amount is 3 base units
    // smart_contracts/subscriptions/contract.algo.ts:725
    // assert(interval >= MIN_INTERVAL, ERR_MIN_INTERVAL_IS_SIXTY)
    dig 1
    pushint 60 // 60
    >=
    assert // Minimum interval is 60 seconds
    // smart_contracts/subscriptions/contract.algo.ts:727
    // assert(serviceID !== 0, ERR_NOT_A_SERVICE)
    dup
    assert // Not a service
    // smart_contracts/subscriptions/contract.algo.ts:728
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    itob
    dig 4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:728
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:729
    // const gateID = this.services({ address: recipient, id: serviceID }).value.gateID
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:731
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:731
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/subscriptions/contract.algo.ts:732
    // const origin = originOrTxnSender(wallet)
    callsub originOrTxnSender
    // smart_contracts/subscriptions/contract.algo.ts:733
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:733
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    uncover 7
    swap
    uncover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/subscriptions/contract.algo.ts:735-742
    // return this.createAsaSubscription(
    //   payment,
    //   assetXfer,
    //   recipient,
    //   amount,
    //   interval,
    //   serviceID
    // )
    callsub createAsaSubscription
    // smart_contracts/subscriptions/contract.algo.ts:713-721
    // gatedSubscribeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   gateTxn: gtxn.ApplicationCallTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.subscribeAsa[routing]() -> void:
subscribeAsa:
    // smart_contracts/subscriptions/contract.algo.ts:745-752
    // subscribeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:754
    // assert(amount >= MIN_AMOUNT, ERR_MIN_AMOUNT_IS_THREE)
    uncover 2
    pushint 4 // 4
    >=
    assert // Minimum amount is 3 base units
    // smart_contracts/subscriptions/contract.algo.ts:756
    // assert(interval >= MIN_INTERVAL, ERR_MIN_INTERVAL_IS_SIXTY)
    swap
    pushint 60 // 60
    >=
    assert // Minimum interval is 60 seconds
    // smart_contracts/subscriptions/contract.algo.ts:758
    // if (serviceID !== 0) {
    bz subscribeAsa_after_if_else@3
    // smart_contracts/subscriptions/contract.algo.ts:759
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    itob
    dig 4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:759
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:760
    // const gateID = this.services({ address: recipient, id: serviceID }).value.gateID
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:761
    // assert(gateID === 0, ERR_HAS_GATE)
    !
    assert // This has a gate

subscribeAsa_after_if_else@3:
    // smart_contracts/subscriptions/contract.algo.ts:764-771
    // return this.createAsaSubscription(
    //   payment,
    //   assetXfer,
    //   recipient,
    //   amount,
    //   interval,
    //   serviceID
    // )
    dig 5
    dig 5
    dig 5
    dig 5
    dig 5
    dig 5
    callsub createAsaSubscription
    // smart_contracts/subscriptions/contract.algo.ts:745-752
    // subscribeAsa(
    //   payment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.deposit[routing]() -> void:
deposit:
    // smart_contracts/subscriptions/contract.algo.ts:774
    // deposit(payment: gtxn.PaymentTxn, id: SubscriptionID): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:775
    // const subKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:777
    // assert(this.subscriptions(subKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:777
    // assert(this.subscriptions(subKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:779
    // const sub = clone(this.subscriptions(subKey).value)
    dup
    box_get
    pop
    // smart_contracts/subscriptions/contract.algo.ts:781
    // assert(sub.asset === 0, ERR_ASA_MISMATCH)
    dup
    pushint 64 // 64
    extract_uint64
    !
    assert // Asset mismatch
    // smart_contracts/subscriptions/contract.algo.ts:783-787
    // assertMatch(
    //   payment,
    //   { receiver: Global.currentApplicationAddress },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/subscriptions/contract.algo.ts:785
    // { receiver: Global.currentApplicationAddress },
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:783-787
    // assertMatch(
    //   payment,
    //   { receiver: Global.currentApplicationAddress },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    assert // Invalid payment
    // smart_contracts/subscriptions/contract.algo.ts:789
    // this.subscriptions(subKey).value.escrowed += payment.amount
    pushint 96 // 96
    extract_uint64
    uncover 2
    gtxns Amount
    +
    itob
    pushint 96 // 96
    swap
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:774
    // deposit(payment: gtxn.PaymentTxn, id: SubscriptionID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.depositAsa[routing]() -> void:
depositAsa:
    // smart_contracts/subscriptions/contract.algo.ts:792
    // depositAsa(assetXfer: gtxn.AssetTransferTxn, id: SubscriptionID): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:793
    // const subKey: SubscriptionKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:795
    // assert(this.subscriptions(subKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:797
    // const { asset } = this.subscriptions(subKey).value
    dup
    box_get
    pop
    dup
    pushint 64 // 64
    extract_uint64
    // smart_contracts/subscriptions/contract.algo.ts:799
    // assert(asset === assetXfer.xferAsset.id, ERR_ASA_MISMATCH)
    dig 3
    gtxns XferAsset
    ==
    assert // Asset mismatch
    // smart_contracts/subscriptions/contract.algo.ts:801
    // assert(assetXfer.assetReceiver === Global.currentApplicationAddress, ERR_INVALID_ASSET_RECEIVER)
    dig 2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Invalid asset receiver
    // smart_contracts/subscriptions/contract.algo.ts:803
    // this.subscriptions(subKey).value.escrowed += assetXfer.assetAmount
    pushint 96 // 96
    extract_uint64
    uncover 2
    gtxns AssetAmount
    +
    itob
    pushint 96 // 96
    swap
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:792
    // depositAsa(assetXfer: gtxn.AssetTransferTxn, id: SubscriptionID): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.withdraw[routing]() -> void:
withdraw:
    // smart_contracts/subscriptions/contract.algo.ts:806
    // withdraw(id: SubscriptionID, amount: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    uncover 2
    // smart_contracts/subscriptions/contract.algo.ts:807
    // const subKey: SubscriptionKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    dup
    cover 2
    // smart_contracts/subscriptions/contract.algo.ts:809
    // assert(this.subscriptions(subKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:811
    // const sub = clone(this.subscriptions(subKey).value)
    box_get
    pop
    // smart_contracts/subscriptions/contract.algo.ts:813
    // assert(sub.escrowed >= amount, ERR_NOT_ENOUGH_FUNDS)
    dup
    pushint 96 // 96
    extract_uint64
    uncover 2
    >=
    assert // Not enough funds in escrow
    // smart_contracts/subscriptions/contract.algo.ts:815
    // if (sub.asset !== 0) {
    pushint 64 // 64
    extract_uint64
    dup
    bz withdraw_else_body@4
    // smart_contracts/subscriptions/contract.algo.ts:816-822
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: amount
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:818
    // assetReceiver: Txn.sender,
    txn Sender
    dig 3
    itxn_field AssetAmount
    dig 1
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:816-821
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: amount
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:816-822
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: amount
    //   })
    //   .submit()
    itxn_submit

withdraw_after_if_else@6:
    // smart_contracts/subscriptions/contract.algo.ts:832
    // this.subscriptions(subKey).value.escrowed -= amount
    dig 1
    dup
    box_get
    assert // Box must have value
    pushint 96 // 96
    extract_uint64
    dig 4
    -
    itob
    pushint 96 // 96
    swap
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:806
    // withdraw(id: SubscriptionID, amount: uint64): void {
    intc_1 // 1
    return

withdraw_else_body@4:
    // smart_contracts/subscriptions/contract.algo.ts:824-829
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amount
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:826
    // receiver: Txn.sender,
    txn Sender
    dig 3
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:824-828
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:824-829
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amount
    //   })
    //   .submit()
    itxn_submit
    b withdraw_after_if_else@6


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.unsubscribe[routing]() -> void:
unsubscribe:
    pushbytes ""
    dup
    // smart_contracts/subscriptions/contract.algo.ts:835
    // unsubscribe(id: SubscriptionID): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:836
    // const subKey: SubscriptionKey = { address: Txn.sender, id }
    txn Sender
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    dupn 2
    // smart_contracts/subscriptions/contract.algo.ts:838
    // assert(this.subscriptions(subKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:840
    // const sub = clone(this.subscriptions(subKey).value)
    box_get
    pop
    dup
    // smart_contracts/subscriptions/contract.algo.ts:843
    // let mbrRefund: uint64 = costs.subscriptions
    intc 5 // 60500
    swap
    // smart_contracts/subscriptions/contract.algo.ts:844
    // if (sub.serviceID > 0) {
    intc_3 // 32
    extract_uint64
    dup
    bz unsubscribe_after_if_else@5
    // smart_contracts/subscriptions/contract.algo.ts:845
    // const { passes } = this.services({ address: sub.recipient, id: sub.serviceID }).value
    dig 2
    extract 0 32
    dig 1
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:845
    // const { passes } = this.services({ address: sub.recipient, id: sub.serviceID }).value
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:846
    // if (passes > 0) {
    bz unsubscribe_after_if_else@5
    // smart_contracts/subscriptions/contract.algo.ts:847
    // mbrRefund += costs.passes
    intc 6 // 479400
    bury 2

unsubscribe_after_if_else@5:
    // smart_contracts/subscriptions/contract.algo.ts:851
    // if (sub.asset !== 0) {
    dig 2
    pushint 64 // 64
    extract_uint64
    dup
    bury 7
    bz unsubscribe_else_body@11
    // smart_contracts/subscriptions/contract.algo.ts:852
    // if (sub.escrowed > 0) {
    dig 2
    pushint 96 // 96
    extract_uint64
    dup
    bury 6
    bz unsubscribe_after_if_else@9
    // smart_contracts/subscriptions/contract.algo.ts:853-859
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: sub.escrowed
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:855
    // assetReceiver: Txn.sender,
    txn Sender
    dig 5
    itxn_field AssetAmount
    dig 6
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:853-858
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: sub.escrowed
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:853-859
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: sub.asset,
    //     assetAmount: sub.escrowed
    //   })
    //   .submit()
    itxn_submit

unsubscribe_after_if_else@9:
    // smart_contracts/subscriptions/contract.algo.ts:862-867
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: mbrRefund
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:864
    // receiver: Txn.sender,
    txn Sender
    dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:862-866
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: mbrRefund
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:862-867
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: mbrRefund
    //   })
    //   .submit()
    itxn_submit

unsubscribe_after_if_else@13:
    // smart_contracts/subscriptions/contract.algo.ts:877
    // this.subscriptions(subKey).delete()
    dig 3
    box_del
    pop
    // smart_contracts/subscriptions/contract.algo.ts:835
    // unsubscribe(id: SubscriptionID): void {
    intc_1 // 1
    return

unsubscribe_else_body@11:
    // smart_contracts/subscriptions/contract.algo.ts:869-874
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: sub.escrowed + mbrRefund
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:871
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/subscriptions/contract.algo.ts:872
    // amount: sub.escrowed + mbrRefund
    dig 3
    pushint 96 // 96
    extract_uint64
    dig 3
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:869-873
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: sub.escrowed + mbrRefund
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:869-874
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: sub.escrowed + mbrRefund
    //   })
    //   .submit()
    itxn_submit
    b unsubscribe_after_if_else@13


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.gatedTriggerPayment[routing]() -> void:
gatedTriggerPayment:
    // smart_contracts/subscriptions/contract.algo.ts:880
    // gatedTriggerPayment(gateTxn: gtxn.ApplicationCallTxn, key: SubscriptionKey): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    txna ApplicationArgs 1
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    dig 1
    concat
    // smart_contracts/subscriptions/contract.algo.ts:882
    // assert(this.subscriptions(key).exists)
    dup
    box_len
    bury 1
    assert
    // smart_contracts/subscriptions/contract.algo.ts:884
    // const { serviceID, recipient } = this.subscriptions(key).value
    box_get
    pop
    dup
    intc_3 // 32
    extract_uint64
    swap
    extract 0 32
    // smart_contracts/subscriptions/contract.algo.ts:886
    // assert(serviceID !== 0, ERR_NOT_A_SERVICE)
    dig 1
    assert // Not a service
    // smart_contracts/subscriptions/contract.algo.ts:887
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:887
    // assert(this.services({ address: recipient, id: serviceID }).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:888
    // const gateID = this.services({ address: recipient, id: serviceID }).value.gateID
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:890
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:890
    // const wallet = getWalletIDUsingAkitaDAO(this.akitaDAO.value, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    txn Sender
    callsub getWalletIDUsingAkitaDAO
    // smart_contracts/subscriptions/contract.algo.ts:891
    // const origin = originOrTxnSender(wallet)
    callsub originOrTxnSender
    // smart_contracts/subscriptions/contract.algo.ts:892
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:892
    // assert(gateCheck(gateTxn, this.akitaDAO.value, origin, gateID), ERR_FAILED_GATE)
    app_global_get_ex
    assert // check GlobalState exists
    uncover 4
    swap
    uncover 2
    uncover 3
    callsub gateCheck
    assert // Gate check failed
    // smart_contracts/subscriptions/contract.algo.ts:894
    // this.triggerPayment(key)
    callsub smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment
    pop
    // smart_contracts/subscriptions/contract.algo.ts:880
    // gatedTriggerPayment(gateTxn: gtxn.ApplicationCallTxn, key: SubscriptionKey): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment[routing]() -> void:
triggerPayment:
    // smart_contracts/subscriptions/contract.algo.ts:897
    // triggerPayment(key: SubscriptionKey): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    callsub smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment
    pop
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.streakCheck[routing]() -> void:
streakCheck:
    // smart_contracts/subscriptions/contract.algo.ts:971
    // streakCheck(key: SubscriptionKey): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    // smart_contracts/subscriptions/contract.algo.ts:972
    // this.updateStreak(key, 0)
    intc_0 // 0
    callsub updateStreak
    pop
    // smart_contracts/subscriptions/contract.algo.ts:971
    // streakCheck(key: SubscriptionKey): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.setPasses[routing]() -> void:
setPasses:
    // smart_contracts/subscriptions/contract.algo.ts:975
    // setPasses(id: SubscriptionID, addresses: Account[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    dup
    intc_3 // 32
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/subscriptions/contract.algo.ts:976
    // const subscriptionsKey: SubscriptionKey = { address: Txn.sender, id }
    txn Sender
    uncover 2
    itob
    dup
    cover 3
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:978
    // assert(this.subscriptions(subscriptionsKey).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:980
    // const { serviceID, recipient } = clone(this.subscriptions(subscriptionsKey).value)
    box_get
    pop
    dup
    intc_3 // 32
    extract_uint64
    swap
    extract 0 32
    dup
    cover 2
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:982
    // assert(serviceID > 0, ERR_NO_DONATIONS)
    dup
    assert // Donations aren't applicable to passes
    // smart_contracts/subscriptions/contract.algo.ts:984
    // const serviceKey: ServicesKey = { address: recipient, id: serviceID }
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:986
    // assert(this.services(serviceKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:988
    // const { status, passes } = this.services(serviceKey).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    swap
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:990
    // assert(status !== ServiceStatusShutdown, ERR_SERVICE_IS_SHUTDOWN)
    swap
    bytec 9 // 0x1e
    !=
    assert // Service offering is shutdown
    // smart_contracts/subscriptions/contract.algo.ts:991
    // assert(passes >= addresses.length, ERR_PASS_COUNT_OVERFLOW)
    <=
    assert // More addresses than available passes
    // smart_contracts/subscriptions/contract.algo.ts:993
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    intc_0 // 0

setPasses_while_top@2:
    // smart_contracts/subscriptions/contract.algo.ts:993
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    dup
    dig 4
    <
    bz setPasses_after_while@4
    // smart_contracts/subscriptions/contract.algo.ts:994
    // assert(!this.blocks(this.getBlockKey(recipient, addresses[i])).exists, ERR_BLOCKED)
    dig 4
    extract 2 0
    dig 1
    dup
    cover 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    dig 3
    swap
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:994
    // assert(!this.blocks(this.getBlockKey(recipient, addresses[i])).exists, ERR_BLOCKED)
    box_len
    bury 1
    !
    assert // This account is blocked by the recipient
    // smart_contracts/subscriptions/contract.algo.ts:993
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    intc_1 // 1
    +
    bury 1
    b setPasses_while_top@2

setPasses_after_while@4:
    // smart_contracts/subscriptions/contract.algo.ts:997
    // this.passes({ address: Txn.sender, id }).value = clone(addresses)
    txn Sender
    dig 3
    concat
    // smart_contracts/subscriptions/contract.algo.ts:119
    // passes = BoxMap<SubscriptionKey, Account[]>({ keyPrefix: SubscriptionsBoxPrefixPasses })
    pushbytes "p"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:997
    // this.passes({ address: Txn.sender, id }).value = clone(addresses)
    dup
    box_del
    pop
    dig 5
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:975
    // setPasses(id: SubscriptionID, addresses: Account[]): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerList[routing]() -> void:
triggerList:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 8
    // smart_contracts/subscriptions/contract.algo.ts:1002
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // smart_contracts/subscriptions/contract.algo.ts:1004
    // const results: boolean[] = []
    bytec 7 // 0x0000
    // smart_contracts/subscriptions/contract.algo.ts:1005
    // for (let i: uint64 = 0; i < req.length; i += 1) {
    intc_0 // 0

triggerList_while_top@2:
    // smart_contracts/subscriptions/contract.algo.ts:1005
    // for (let i: uint64 = 0; i < req.length; i += 1) {
    dig 2
    intc_0 // 0
    extract_uint16
    dup
    bury 13
    dig 1
    >
    bz triggerList_after_while@7
    // smart_contracts/subscriptions/contract.algo.ts:1006
    // for (let j: uint64 = 0; j < req[i].ids.length; j += 1) {
    intc_0 // 0
    bury 8

triggerList_while_top@4:
    // smart_contracts/subscriptions/contract.algo.ts:1006
    // for (let j: uint64 = 0; j < req[i].ids.length; j += 1) {
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    bury 12
    dig 14
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    pushint 2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    bury 17
    dup
    intc_3 // 32
    extract_uint16
    dig 1
    len
    substring3
    dup
    bury 16
    intc_0 // 0
    extract_uint16
    dig 8
    >
    bz triggerList_after_while@6
    // smart_contracts/subscriptions/contract.algo.ts:1006-1007
    // for (let j: uint64 = 0; j < req[i].ids.length; j += 1) {
    //   const key: SubscriptionKey = { address: req[i].address, id: req[i].ids[j] }
    dig 15
    extract 0 32
    dig 15
    extract 2 0
    dig 9
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    // smart_contracts/subscriptions/contract.algo.ts:1007
    // const key: SubscriptionKey = { address: req[i].address, id: req[i].ids[j] }
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1008
    // results.push(this.canTrigger(key))
    callsub canTrigger
    pop
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bury 14
    dig 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    bury 13
    dup
    // smart_contracts/subscriptions/contract.algo.ts:1008
    // results.push(this.canTrigger(key))
    intc_1 // 1
    +
    dup
    itob
    extract 6 0
    uncover 3
    swap
    replace2 0
    bury 15
    swap
    pushint 7 // 7
    +
    intc_2 // 8
    /
    dup
    bury 12
    swap
    pushint 7 // 7
    +
    intc_2 // 8
    /
    dup
    bury 8
    <
    bz triggerList_after_if_else@10
    dig 5
    dig 10
    -
    bzero
    dig 13
    swap
    concat
    bury 13

triggerList_after_if_else@10:
    intc_0 // 0
    bury 7
    dig 10
    pushint 16 // 16
    +
    dup
    bury 5
    // smart_contracts/subscriptions/contract.algo.ts:1008
    // results.push(this.canTrigger(key))
    intc_1 // 1
    +
    bury 5

triggerList_while_top@11:
    dig 3
    dig 5
    <
    bz triggerList_after_while@13
    dig 13
    dig 7
    dup
    cover 2
    getbit
    dig 14
    dig 6
    dup
    cover 3
    uncover 2
    setbit
    bury 15
    intc_1 // 1
    +
    bury 5
    // smart_contracts/subscriptions/contract.algo.ts:1008
    // results.push(this.canTrigger(key))
    intc_2 // 8
    +
    bury 7
    b triggerList_while_top@11

triggerList_after_while@13:
    // smart_contracts/subscriptions/contract.algo.ts:1006
    // for (let j: uint64 = 0; j < req[i].ids.length; j += 1) {
    dig 7
    intc_1 // 1
    +
    bury 8
    dig 12
    bury 2
    b triggerList_while_top@4

triggerList_after_while@6:
    dig 8
    bury 1
    b triggerList_while_top@2

triggerList_after_while@7:
    // smart_contracts/subscriptions/contract.algo.ts:1002
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.isBlocked[routing]() -> void:
isBlocked:
    // smart_contracts/subscriptions/contract.algo.ts:1019
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/subscriptions/contract.algo.ts:1021
    // return this.blocks(this.getBlockKey(address, blocked)).exists
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1021
    // return this.blocks(this.getBlockKey(address, blocked)).exists
    box_len
    bury 1
    // smart_contracts/subscriptions/contract.algo.ts:1019
    // @abimethod({ readonly: true })
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.isShutdown[routing]() -> void:
isShutdown:
    // smart_contracts/subscriptions/contract.algo.ts:1027
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:1030
    // this.services({ address, id }).exists &&
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    dup
    // smart_contracts/subscriptions/contract.algo.ts:1030
    // this.services({ address, id }).exists &&
    box_len
    bury 1
    // smart_contracts/subscriptions/contract.algo.ts:1030-1031
    // this.services({ address, id }).exists &&
    // this.services({ address, id }).value.status === ServiceStatusShutdown
    bz isShutdown_bool_false@4
    // smart_contracts/subscriptions/contract.algo.ts:1031
    // this.services({ address, id }).value.status === ServiceStatusShutdown
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 9 // 0x1e
    ==
    // smart_contracts/subscriptions/contract.algo.ts:1030-1031
    // this.services({ address, id }).exists &&
    // this.services({ address, id }).value.status === ServiceStatusShutdown
    bz isShutdown_bool_false@4
    intc_1 // 1

isShutdown_bool_merge@5:
    // smart_contracts/subscriptions/contract.algo.ts:1027
    // @abimethod({ readonly: true })
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

isShutdown_bool_false@4:
    intc_0 // 0
    b isShutdown_bool_merge@5


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getService[routing]() -> void:
getService:
    // smart_contracts/subscriptions/contract.algo.ts:1035
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/subscriptions/contract.algo.ts:1037
    // const key: ServicesKey = { address, id }
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1038
    // assert(this.services(key).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:1039
    // return this.services(key).value
    box_get
    pop
    // smart_contracts/subscriptions/contract.algo.ts:1035
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getServicesByAddress[routing]() -> void:
getServicesByAddress:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 3
    // smart_contracts/subscriptions/contract.algo.ts:1042
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1044
    // const services: Service[] = []
    bytec 7 // 0x0000
    swap

getServicesByAddress_while_top@2:
    // smart_contracts/subscriptions/contract.algo.ts:1045
    // for (let i: uint64 = start; i < start + windowSize; i += 1) {
    dig 3
    dig 3
    +
    dig 1
    >
    bz getServicesByAddress_block@8
    // smart_contracts/subscriptions/contract.algo.ts:1046
    // const key: ServicesKey = { address, id: i }
    dup
    itob
    dig 5
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    dup
    bury 13
    // smart_contracts/subscriptions/contract.algo.ts:1047
    // if (this.services(key).exists) {
    box_len
    bury 1
    bz getServicesByAddress_block@8
    // smart_contracts/subscriptions/contract.algo.ts:1048
    // services.push(this.services(key).value)
    dig 11
    box_get
    assert // Box must have value
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    bury 12
    extract 2 0
    bury 15
    pushbytes 0x0002
    uncover 2
    concat
    bury 11
    pushbytes 0x
    bury 12
    pushint 2 // 2
    *
    bury 6
    intc_0 // 0
    bury 7

getServicesByAddress_for_header@10:
    dig 6
    dig 6
    <
    bz getServicesByAddress_after_for@12
    dig 12
    dig 7
    dup
    cover 2
    extract_uint16
    pushint 2 // 2
    +
    itob
    extract 6 2
    dig 12
    swap
    concat
    bury 12
    pushint 2 // 2
    +
    bury 7
    b getServicesByAddress_for_header@10

getServicesByAddress_after_for@12:
    dig 12
    len
    bury 8
    intc_0 // 0
    bury 7

getServicesByAddress_for_header@13:
    dig 6
    pushint 2 // 2
    <
    bz getServicesByAddress_after_for@15
    dig 9
    dig 7
    dup
    cover 2
    extract_uint16
    dig 9
    +
    itob
    extract 6 2
    dig 12
    swap
    concat
    bury 12
    pushint 2 // 2
    +
    bury 7
    b getServicesByAddress_for_header@13

getServicesByAddress_after_for@15:
    dig 8
    // smart_contracts/subscriptions/contract.algo.ts:1048
    // services.push(this.services(key).value)
    intc_1 // 1
    +
    itob
    extract 6 2
    dig 11
    concat
    dig 13
    dig 7
    dig 10
    substring3
    concat
    dig 10
    extract 2 0
    concat
    bury 2
    // smart_contracts/subscriptions/contract.algo.ts:1045
    // for (let i: uint64 = start; i < start + windowSize; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b getServicesByAddress_while_top@2

getServicesByAddress_block@8:
    // smart_contracts/subscriptions/contract.algo.ts:1042
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getSubscription[routing]() -> void:
getSubscription:
    // smart_contracts/subscriptions/contract.algo.ts:1056
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1058
    // assert(this.subscriptions(key).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:1059
    // return this.subscriptions(key).value
    box_get
    pop
    // smart_contracts/subscriptions/contract.algo.ts:1056
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getSubscriptionWithPasses[routing]() -> void:
getSubscriptionWithPasses:
    intc_0 // 0
    dup
    // smart_contracts/subscriptions/contract.algo.ts:1062
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    len
    pushint 40 // 40
    ==
    assert // invalid number of bytes for (uint8[32],uint64)
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1064
    // assert(this.subscriptions(key).exists, ERR_SUBSCRIPTION_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Subscription does not exist
    // smart_contracts/subscriptions/contract.algo.ts:1066
    // const sub = clone(this.subscriptions(key).value)
    box_get
    pop
    dup
    // smart_contracts/subscriptions/contract.algo.ts:1068
    // let title: string = ''
    pushbytes ""
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1069
    // let description: string = ''
    pushbytes ""
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1070
    // let bannerImage: CID = op.bzero(36)
    pushint 36 // 36
    bzero
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1071
    // let highlightMessage: Uint8 = HighlightMessageNone
    bytec 5 // 0x00
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1072
    // let highlightColor: bytes<3> = Bytes('000').toFixed({ length: 3 })
    pushbytes "000"
    swap
    // smart_contracts/subscriptions/contract.algo.ts:1073
    // if (sub.serviceID !== 0) {
    intc_3 // 32
    extract_uint64
    dup
    bz getSubscriptionWithPasses_after_if_else@3
    // smart_contracts/subscriptions/contract.algo.ts:1074
    // const serviceKey: ServicesKey = { address: sub.recipient, id: sub.serviceID }
    dig 6
    extract 0 32
    dig 1
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1075
    // assert(this.services(serviceKey).exists, ERR_SERVICE_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:1076
    // ({ title, description, bannerImage, highlightMessage, highlightColor } = clone(this.services(serviceKey).value))
    dup
    box_get
    pop
    dup
    pushint 41 // 41
    extract_uint16
    dig 1
    pushint 43 // 43
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    bury 9
    dig 1
    len
    substring3
    extract 2 0
    bury 6
    dup
    pushints 45 36 // 45, 36
    box_extract
    bury 5
    dup
    pushint 81 // 81
    intc_1 // 1
    box_extract
    bury 4
    pushints 82 3 // 82, 3
    box_extract
    bury 2

getSubscriptionWithPasses_after_if_else@3:
    // smart_contracts/subscriptions/contract.algo.ts:1079
    // let passes: Account[] = []
    bytec 7 // 0x0000
    bury 9
    // smart_contracts/subscriptions/contract.algo.ts:119
    // passes = BoxMap<SubscriptionKey, Account[]>({ keyPrefix: SubscriptionsBoxPrefixPasses })
    pushbytes "p"
    dig 8
    concat
    dup
    bury 11
    // smart_contracts/subscriptions/contract.algo.ts:1080
    // if (this.passes(key).exists) {
    box_len
    bury 1
    bz getSubscriptionWithPasses_after_if_else@5
    // smart_contracts/subscriptions/contract.algo.ts:1081
    // passes = [...passes, ...this.passes(key).value]
    dig 9
    box_get
    assert // Box must have value
    extract 2 0
    // smart_contracts/subscriptions/contract.algo.ts:1079
    // let passes: Account[] = []
    bytec 7 // 0x0000
    // smart_contracts/subscriptions/contract.algo.ts:1081
    // passes = [...passes, ...this.passes(key).value]
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 32
    /
    itob
    extract 6 2
    replace2 0
    bury 9

getSubscriptionWithPasses_after_if_else@5:
    // smart_contracts/subscriptions/contract.algo.ts:1085
    // ...sub,
    dig 6
    dup
    extract 0 32
    dig 1
    extract 40 8
    dig 2
    extract 48 8
    dig 3
    extract 56 8
    dig 4
    extract 64 8
    dig 5
    extract 72 8
    dig 6
    extract 80 8
    dig 7
    extract 88 8
    uncover 8
    extract 96 8
    // smart_contracts/subscriptions/contract.algo.ts:1084-1092
    // return {
    //   ...sub,
    //   title,
    //   description,
    //   bannerImage,
    //   highlightMessage,
    //   highlightColor,
    //   passes
    // }
    dig 9
    itob
    uncover 9
    swap
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    dig 9
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    pushbytes 0x0096
    concat
    dig 1
    len
    pushint 150 // 150
    +
    dig 10
    dup
    len
    itob
    extract 6 2
    swap
    concat
    dig 1
    itob
    extract 6 2
    uncover 3
    swap
    concat
    dig 1
    len
    uncover 3
    +
    dig 10
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid size
    uncover 2
    swap
    concat
    dig 9
    concat
    dig 8
    dup
    cover 2
    len
    pushint 3 // 3
    ==
    assert // invalid size
    swap
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    dig 9
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1062
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.isFirstSubscription[routing]() -> void:
isFirstSubscription:
    // smart_contracts/subscriptions/contract.algo.ts:1095
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/subscriptions/contract.algo.ts:99
    // subscriptionslist = BoxMap<Account, uint64>({ keyPrefix: SubscriptionsBoxPrefixSubscriptionsList })
    pushbytes "l"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:1097
    // return !this.subscriptionslist(address).exists
    box_len
    bury 1
    !
    // smart_contracts/subscriptions/contract.algo.ts:1095
    // @abimethod({ readonly: true })
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/optin.ts::ContractWithOptIn.optin[routing]() -> void:
optin:
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/utils/base-contracts/optin.ts:27
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/utils/base-contracts/optin.ts:28
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/utils/base-contracts/optin.ts:24-31
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/utils/base-contracts/optin.ts:33-37
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset
    // }).submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/optin.ts:34
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/utils/base-contracts/optin.ts:35
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/optin.ts:33-37
    // itxn.assetTransfer({
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    //   xferAsset: asset
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/utils/base-contracts/optin.ts:22
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseFeeGeneratorContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 10 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:112
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:113
    // this.akitaDAOEscrow.value = app
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:111
    // updateAkitaDAOEscrow(app: Application): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::UpgradeableAkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 10 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:48
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:52
    // args: [Txn.lease, Global.currentApplicationId.id],
    txn Lease
    global CurrentApplicationID
    itob
    // smart_contracts/utils/base-contracts/base.ts:50-53
    // const valid = abiCall<typeof MockDAO.prototype.isValidUpgrade>({
    //   appId: this.akitaDAO.value,
    //   args: [Txn.lease, Global.currentApplicationId.id],
    // }).returnValue
    pushbytes 0x2c2f51c3 // method "isValidUpgrade(byte[32],uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/base-contracts/base.ts:55
    // assert(valid, ERR_INVALID_UPGRADE)
    assert // Invalid app upgrade
    // smart_contracts/utils/base-contracts/base.ts:25
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 15 // "version"
    // smart_contracts/utils/base-contracts/base.ts:57
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:46
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    bytec 10 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:37
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:38
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:36
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getLatestWindowStart(startDate: uint64, interval: uint64) -> uint64:
getLatestWindowStart:
    // smart_contracts/subscriptions/contract.algo.ts:123
    // private getLatestWindowStart(startDate: uint64, interval: uint64): uint64 {
    proto 2 1
    // smart_contracts/subscriptions/contract.algo.ts:124
    // return Global.latestTimestamp - ((Global.latestTimestamp - startDate) % interval)
    global LatestTimestamp
    dup
    frame_dig -2
    -
    frame_dig -1
    %
    -
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getBlockKey(address: bytes, blocked: bytes) -> bytes:
getBlockKey:
    // smart_contracts/subscriptions/contract.algo.ts:127
    // private getBlockKey(address: Account, blocked: Account): BlockListKey {
    proto 2 1
    // smart_contracts/subscriptions/contract.algo.ts:129
    // address: address.bytes.slice(0, 16).toFixed({ length: 16 }),
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/subscriptions/contract.algo.ts:130
    // blocked: blocked.bytes.slice(0, 16).toFixed({ length: 16 }),
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    // smart_contracts/subscriptions/contract.algo.ts:128-131
    // return {
    //   address: address.bytes.slice(0, 16).toFixed({ length: 16 }),
    //   blocked: blocked.bytes.slice(0, 16).toFixed({ length: 16 }),
    // }
    concat
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.updateStreak(key: bytes, elseStreak: uint64) -> bytes:
updateStreak:
    // smart_contracts/subscriptions/contract.algo.ts:134
    // private updateStreak(key: SubscriptionKey, elseStreak: uint64): void {
    proto 2 1
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    frame_dig -2
    concat
    dup
    // smart_contracts/subscriptions/contract.algo.ts:135
    // const sub = clone(this.subscriptions(key).value)
    box_get
    assert // Box must have value
    // smart_contracts/subscriptions/contract.algo.ts:137
    // const currentWindowStart: uint64 = this.getLatestWindowStart(sub.startDate, sub.interval)
    dup
    pushint 40 // 40
    extract_uint64
    dig 1
    pushint 56 // 56
    extract_uint64
    swap
    dig 1
    callsub getLatestWindowStart
    dup
    cover 3
    // smart_contracts/subscriptions/contract.algo.ts:138
    // const lastWindowStart: uint64 = currentWindowStart - sub.interval
    swap
    -
    dup
    uncover 2
    // smart_contracts/subscriptions/contract.algo.ts:140
    // if (sub.lastPayment < lastWindowStart) {
    pushint 80 // 80
    extract_uint64
    dup
    uncover 2
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/subscriptions/contract.algo.ts:142
    // this.subscriptions(key).value.streak = elseStreak
    frame_dig -1
    itob
    frame_dig 0
    pushint 88 // 88
    uncover 2
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:143
    // return
    frame_dig -2
    frame_bury 0
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/subscriptions/contract.algo.ts:149
    // if (sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)) {
    frame_dig 3
    frame_dig 2
    >=
    bz updateStreak_after_if_else@5
    frame_dig 3
    frame_dig 1
    >=
    bnz updateStreak_after_if_else@5
    // smart_contracts/subscriptions/contract.algo.ts:150
    // this.subscriptions(key).value.streak += 1
    frame_dig 0
    dup
    box_get
    assert // Box must have value
    pushint 88 // 88
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 88 // 88
    swap
    box_replace

updateStreak_after_if_else@5:
    frame_dig -2
    frame_bury 0
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.getAmounts(amount: uint64) -> bytes:
getAmounts:
    // smart_contracts/subscriptions/contract.algo.ts:154
    // private getAmounts(amount: uint64): Amounts {
    proto 1 1
    pushbytes ""
    // smart_contracts/subscriptions/contract.algo.ts:155
    // const fees = getSubscriptionFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:155
    // const fees = getSubscriptionFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:72
    // const [subscriptionFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSubscriptionFees))
    bytec 16 // "subscription_fees"
    app_global_get_ex
    pop
    dup
    // smart_contracts/subscriptions/contract.algo.ts:157
    // let akitaFee: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/subscriptions/contract.algo.ts:158
    // if (fees.paymentPercentage > 0) {
    intc_2 // 8
    extract_uint64
    dup
    bz getAmounts_after_if_else@5
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    frame_dig 3
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 2
    // smart_contracts/subscriptions/contract.algo.ts:160
    // if (akitaFee === 0 && amount > 0) {
    bnz getAmounts_after_if_else@5
    frame_dig -1
    bz getAmounts_after_if_else@5
    // smart_contracts/subscriptions/contract.algo.ts:161
    // akitaFee = 2
    pushint 2 // 2
    frame_bury 2

getAmounts_after_if_else@5:
    // smart_contracts/subscriptions/contract.algo.ts:165
    // let triggerFee: uint64 = 0
    intc_0 // 0
    frame_bury 0
    // smart_contracts/subscriptions/contract.algo.ts:166
    // if (fees.triggerPercentage > 0) {
    frame_dig 1
    pushint 16 // 16
    extract_uint64
    dup
    frame_bury 3
    bz getAmounts_after_if_else@10
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    frame_dig 3
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig -1
    mulw
    intc 4 // 100000
    divw
    dup
    frame_bury 0
    // smart_contracts/subscriptions/contract.algo.ts:168
    // if (triggerFee === 0 && amount > 0) {
    bnz getAmounts_after_if_else@10
    frame_dig -1
    bz getAmounts_after_if_else@10
    // smart_contracts/subscriptions/contract.algo.ts:169
    // triggerFee = 1
    intc_1 // 1
    frame_bury 0

getAmounts_after_if_else@10:
    // smart_contracts/subscriptions/contract.algo.ts:173
    // const leftOver: uint64 = amount - (akitaFee + triggerFee)
    frame_dig 2
    dup
    frame_dig 0
    dup
    cover 3
    +
    frame_dig -1
    swap
    -
    // smart_contracts/subscriptions/contract.algo.ts:175-179
    // return {
    //   akitaFee: akitaFee,
    //   triggerFee: triggerFee,
    //   leftOver: leftOver,
    // }
    swap
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.newSubscriptionID(address: bytes) -> uint64:
newSubscriptionID:
    // smart_contracts/subscriptions/contract.algo.ts:190
    // private newSubscriptionID(address: Account): SubscriptionID {
    proto 1 1
    // smart_contracts/subscriptions/contract.algo.ts:99
    // subscriptionslist = BoxMap<Account, uint64>({ keyPrefix: SubscriptionsBoxPrefixSubscriptionsList })
    pushbytes "l"
    frame_dig -1
    concat
    dup
    // smart_contracts/subscriptions/contract.algo.ts:191
    // const id: uint64 = this.subscriptionslist(address).exists
    box_len
    bury 1
    // smart_contracts/subscriptions/contract.algo.ts:191-193
    // const id: uint64 = this.subscriptionslist(address).exists
    //   ? this.subscriptionslist(address).value
    //   : 0
    bz newSubscriptionID_ternary_false@2
    // smart_contracts/subscriptions/contract.algo.ts:192
    // ? this.subscriptionslist(address).value
    frame_dig 0
    box_get
    assert // Box must have value
    btoi

newSubscriptionID_ternary_merge@3:
    // smart_contracts/subscriptions/contract.algo.ts:194
    // this.subscriptionslist(address).value = id + 1
    dup
    intc_1 // 1
    +
    itob
    frame_dig 0
    swap
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:195
    // return id
    swap
    retsub

newSubscriptionID_ternary_false@2:
    // smart_contracts/subscriptions/contract.algo.ts:193
    // : 0
    intc_0 // 0
    b newSubscriptionID_ternary_merge@3


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.createSubscription(payment: uint64, recipient: bytes, amount: uint64, interval: uint64, serviceID: uint64) -> uint64:
createSubscription:
    // smart_contracts/subscriptions/contract.algo.ts:198-204
    // private createSubscription(
    //   payment: gtxn.PaymentTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID
    // ): uint64 {
    proto 5 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/subscriptions/contract.algo.ts:205
    // const blocksKey = this.getBlockKey(recipient, Txn.sender)
    frame_dig -4
    txn Sender
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:207
    // assert(!this.blocks(blocksKey).exists, ERR_BLOCKED)
    box_len
    bury 1
    !
    assert // This account is blocked by the recipient
    // smart_contracts/subscriptions/contract.algo.ts:209
    // let gateID: uint64 = 0
    intc_0 // 0
    // smart_contracts/subscriptions/contract.algo.ts:212
    // let mbrAmount = costs.subscriptions
    intc 5 // 60500
    // smart_contracts/subscriptions/contract.algo.ts:215
    // if (!isDonation) {
    frame_dig -1
    bz createSubscription_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:216
    // const boxKey: ServicesKey = { address: recipient, id: serviceID }
    frame_dig -1
    itob
    frame_dig -4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:218
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:222
    // assert(service.status === ServiceStatusActive, ERR_SERVICE_IS_NOT_ACTIVE)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 8 // 0x0a
    ==
    assert // Service offering is not active
    // smart_contracts/subscriptions/contract.algo.ts:224
    // assert(service.asset === 0, ERR_ASA_MISMATCH)
    dup
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    !
    assert // Asset mismatch
    // smart_contracts/subscriptions/contract.algo.ts:226
    // amount = service.amount
    dup
    pushint 17 // 17
    intc_2 // 8
    box_extract
    btoi
    frame_bury -3
    // smart_contracts/subscriptions/contract.algo.ts:227
    // interval = service.interval
    dup
    intc_1 // 1
    intc_2 // 8
    box_extract
    btoi
    frame_bury -2
    // smart_contracts/subscriptions/contract.algo.ts:228
    // gateID = service.gateID
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    frame_bury 2
    // smart_contracts/subscriptions/contract.algo.ts:230
    // if (service.passes > 0) {
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    bz createSubscription_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:231
    // mbrAmount += costs.passes
    intc 6 // 479400
    frame_bury 3

createSubscription_after_if_else@4:
    // smart_contracts/subscriptions/contract.algo.ts:235
    // const subscriptionID = this.newSubscriptionID(Txn.sender)
    txn Sender
    callsub newSubscriptionID
    dup
    frame_bury 1
    // smart_contracts/subscriptions/contract.algo.ts:236
    // const subscriptionKey: SubscriptionKey = { address: Txn.sender, id: subscriptionID }
    txn Sender
    dig 1
    itob
    concat
    frame_bury 0
    // smart_contracts/subscriptions/contract.algo.ts:237
    // if (subscriptionID === 0) {
    bnz createSubscription_after_if_else@6
    // smart_contracts/subscriptions/contract.algo.ts:238
    // mbrAmount += costs.subscriptionslist
    frame_dig 3
    intc 7 // 18900
    +
    frame_bury 3

createSubscription_after_if_else@6:
    // smart_contracts/subscriptions/contract.algo.ts:241
    // const amounts = this.getAmounts(amount)
    frame_dig -3
    callsub getAmounts
    // smart_contracts/subscriptions/contract.algo.ts:242
    // const akitaFees: uint64 = amounts.akitaFee + amounts.triggerFee
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    +
    // smart_contracts/subscriptions/contract.algo.ts:243
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, 0, akitaFees)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:243
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, 0, akitaFees)
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    uncover 2
    callsub sendReferralPayment
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    // smart_contracts/subscriptions/contract.algo.ts:245-254
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: (amount + mbrAmount + referralMbr)
    //     },
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -5
    gtxns Receiver
    // smart_contracts/subscriptions/contract.algo.ts:248
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:245-254
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: (amount + mbrAmount + referralMbr)
    //     },
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -5
    gtxns Amount
    // smart_contracts/subscriptions/contract.algo.ts:250
    // greaterThanEq: (amount + mbrAmount + referralMbr)
    frame_dig -3
    frame_dig 3
    +
    uncover 3
    +
    // smart_contracts/subscriptions/contract.algo.ts:245-254
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       greaterThanEq: (amount + mbrAmount + referralMbr)
    //     },
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dup2
    >=
    uncover 3
    &&
    assert // Invalid payment
    // smart_contracts/subscriptions/contract.algo.ts:256-261
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:258
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:258
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    uncover 3
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:256-260
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:256-261
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: leftover,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:263-268
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:266
    // amount: amounts.leftOver
    uncover 2
    pushint 16 // 16
    extract_uint64
    itxn_field Amount
    frame_dig -4
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:263-267
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:263-268
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:274
    // const paymentDifference: uint64 = payment.amount - (amount + mbrAmount + referralMbr)
    -
    // smart_contracts/subscriptions/contract.algo.ts:279
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/subscriptions/contract.algo.ts:284
    // lastPayment: Global.latestTimestamp,
    dup
    // smart_contracts/subscriptions/contract.algo.ts:276-287
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: 0,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    frame_dig -1
    itob
    frame_dig -4
    swap
    concat
    uncover 2
    itob
    concat
    frame_dig -3
    itob
    concat
    frame_dig -2
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:282
    // asset: 0,
    intc_0 // 0
    // smart_contracts/subscriptions/contract.algo.ts:276-287
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: 0,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    itob
    concat
    frame_dig 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:285
    // streak: 1,
    intc_1 // 1
    // smart_contracts/subscriptions/contract.algo.ts:276-287
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: 0,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    frame_dig 0
    concat
    // smart_contracts/subscriptions/contract.algo.ts:276-287
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: 0,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    swap
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:289
    // return subscriptionID
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.createAsaSubscription(mbrPayment: uint64, assetXfer: uint64, recipient: bytes, amount: uint64, interval: uint64, serviceID: uint64) -> uint64:
createAsaSubscription:
    // smart_contracts/subscriptions/contract.algo.ts:292-299
    // private createAsaSubscription(
    //   mbrPayment: gtxn.PaymentTxn,
    //   assetXfer: gtxn.AssetTransferTxn,
    //   recipient: Account,
    //   amount: uint64,
    //   interval: uint64,
    //   serviceID: ServiceID,
    // ): uint64 {
    proto 6 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 3
    // smart_contracts/subscriptions/contract.algo.ts:300
    // const blocksKey = this.getBlockKey(recipient, Txn.sender)
    frame_dig -4
    txn Sender
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:302
    // assert(!this.blocks(blocksKey).exists, ERR_BLOCKED)
    box_len
    bury 1
    !
    assert // This account is blocked by the recipient
    // smart_contracts/subscriptions/contract.algo.ts:304
    // let gateID: uint64 = 0
    intc_0 // 0
    // smart_contracts/subscriptions/contract.algo.ts:307
    // let mbrAmount = costs.subscriptions
    intc 5 // 60500
    // smart_contracts/subscriptions/contract.algo.ts:310
    // if (!isDonation) {
    frame_dig -1
    bz createAsaSubscription_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:311
    // const boxKey: ServicesKey = { address: recipient, id: serviceID }
    frame_dig -1
    itob
    frame_dig -4
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:313
    // assert(this.services(boxKey).exists, ERR_SERVICE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Service does not exist
    // smart_contracts/subscriptions/contract.algo.ts:317
    // assert(service.status === ServiceStatusActive, ERR_SERVICE_IS_NOT_ACTIVE)
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 8 // 0x0a
    ==
    assert // Service offering is not active
    // smart_contracts/subscriptions/contract.algo.ts:319
    // assert(service.asset === assetXfer.xferAsset.id, ERR_ASA_MISMATCH)
    dup
    pushint 9 // 9
    intc_2 // 8
    box_extract
    btoi
    frame_dig -5
    gtxns XferAsset
    ==
    assert // Asset mismatch
    // smart_contracts/subscriptions/contract.algo.ts:321
    // amount = service.amount
    dup
    pushint 17 // 17
    intc_2 // 8
    box_extract
    btoi
    frame_bury -3
    // smart_contracts/subscriptions/contract.algo.ts:322
    // interval = service.interval
    dup
    intc_1 // 1
    intc_2 // 8
    box_extract
    btoi
    frame_bury -2
    // smart_contracts/subscriptions/contract.algo.ts:323
    // gateID = service.gateID
    dup
    pushint 33 // 33
    intc_2 // 8
    box_extract
    btoi
    frame_bury 6
    // smart_contracts/subscriptions/contract.algo.ts:325
    // if (service.passes > 0) {
    pushint 25 // 25
    intc_2 // 8
    box_extract
    btoi
    bz createAsaSubscription_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:326
    // mbrAmount += costs.passes
    intc 6 // 479400
    frame_bury 7

createAsaSubscription_after_if_else@4:
    // smart_contracts/subscriptions/contract.algo.ts:330
    // const subscriptionID = this.newSubscriptionID(Txn.sender)
    txn Sender
    callsub newSubscriptionID
    dup
    frame_bury 5
    // smart_contracts/subscriptions/contract.algo.ts:331
    // const subscriptionKey = { address: Txn.sender, id: subscriptionID }
    txn Sender
    dig 1
    itob
    concat
    frame_bury 1
    // smart_contracts/subscriptions/contract.algo.ts:333
    // if (subscriptionID === 0) {
    bnz createAsaSubscription_after_if_else@6
    // smart_contracts/subscriptions/contract.algo.ts:334
    // mbrAmount += costs.subscriptionslist
    frame_dig 7
    intc 7 // 18900
    +
    frame_bury 7

createAsaSubscription_after_if_else@6:
    // smart_contracts/subscriptions/contract.algo.ts:337
    // const amounts = this.getAmounts(amount)
    frame_dig -3
    callsub getAmounts
    dup
    frame_bury 0
    // smart_contracts/subscriptions/contract.algo.ts:338
    // const akitaFees: uint64 = amounts.akitaFee + amounts.triggerFee
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_2 // 8
    extract_uint64
    +
    // smart_contracts/subscriptions/contract.algo.ts:339
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, assetXfer.xferAsset.id, akitaFees)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/subscriptions/contract.algo.ts:339
    // const { leftover, referralMbr } = sendReferralPayment(this.akitaDAO.value, assetXfer.xferAsset.id, akitaFees)
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -5
    gtxns XferAsset
    dup
    frame_bury 2
    swap
    dig 1
    uncover 3
    callsub sendReferralPayment
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 3
    intc_2 // 8
    extract_uint64
    frame_bury 4
    // smart_contracts/subscriptions/contract.algo.ts:341
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(assetXfer.xferAsset)) {
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:341
    // if (!this.akitaDAOEscrow.value.address.isOptedIn(assetXfer.xferAsset)) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz createAsaSubscription_else_body@8
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_2 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:30
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    dup
    bytec 10 // "wallet"
    app_global_get_ex
    pop
    swap
    bytec 10 // "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:69-72
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    itxn_begin
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:71
    // args: [[name]],
    pushbytes 0x00010002000d737562736372697074696f6e73
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:69-72
    // const escrow = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId,
    //   args: [[name]],
    // }).returnValue[0]
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/utils/base-contracts/base.ts:74
    // assert(escrow.id !== 0, ERR_ESCROW_DOES_NOT_EXIST)
    extract 6 9
    intc_0 // 0
    extract_uint64
    dup
    assert // Escrow does not exist
    // smart_contracts/utils/base-contracts/base.ts:84
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:84
    // assert(id === this.akitaDAOEscrow.value.id, ERR_WRONG_ESCROW_FOR_OPERATION)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Wrong escrow for this operation
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:94
    // receiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/base-contracts/base.ts:95
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/utils/base-contracts/base.ts:93-96
    // itxn.payment({
    //   receiver: this.akitaDAOEscrow.value.address,
    //   amount: Global.assetOptInMinBalance,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    itxn_next
    // smart_contracts/utils/base-contracts/base.ts:89
    // Global.currentApplicationId.id,
    global CurrentApplicationID
    itob
    // smart_contracts/utils/base-contracts/base.ts:90
    // Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/utils/base-contracts/base.ts:92
    // [asset.id],
    frame_dig 2
    itob
    bytec 14 // 0x0001
    swap
    concat
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    pushbytes 0x9d3f8918 // method "arc58_pluginOptinEscrow(uint64,address,string,uint64[],pay)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/utils/base-contracts/base.ts:91
    // name,
    pushbytes 0x000d737562736372697074696f6e73
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/utils/base-contracts/base.ts:86-98
    // abiCall<typeof AbstractedAccount.prototype.arc58_pluginOptinEscrow>({
    //   appId,
    //   args: [
    //     Global.currentApplicationId.id,
    //     Global.currentApplicationAddress,
    //     name,
    //     [asset.id],
    //     itxn.payment({
    //       receiver: this.akitaDAOEscrow.value.address,
    //       amount: Global.assetOptInMinBalance,
    //     })
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/utils/base-contracts/base.ts:100
    // if (amount > 0) {
    frame_dig 3
    bz createAsaSubscription_after_if_else@17
    // smart_contracts/utils/base-contracts/base.ts:101-107
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/utils/base-contracts/base.ts:103
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:103
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 2
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/utils/base-contracts/base.ts:101-106
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/base-contracts/base.ts:101-107
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit

createAsaSubscription_after_if_else@17:
    // smart_contracts/subscriptions/contract.algo.ts:347
    // mbrAmount += Global.assetOptInMinBalance
    frame_dig 7
    global AssetOptInMinBalance
    +
    frame_bury 7

createAsaSubscription_after_if_else@10:
    // smart_contracts/subscriptions/contract.algo.ts:359-366
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -6
    gtxns Receiver
    // smart_contracts/subscriptions/contract.algo.ts:362
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:359-366
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -6
    gtxns Amount
    // smart_contracts/subscriptions/contract.algo.ts:363
    // amount: mbrAmount + referralMbr,
    frame_dig 7
    frame_dig 4
    +
    // smart_contracts/subscriptions/contract.algo.ts:359-366
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: mbrAmount + referralMbr,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/subscriptions/contract.algo.ts:369-378
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: {
    //       greaterThanEq: amount,
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    frame_dig -5
    gtxns AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:372
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/subscriptions/contract.algo.ts:369-378
    // assertMatch(
    //   assetXfer,
    //   {
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: {
    //       greaterThanEq: amount,
    //     }
    //   },
    //   ERR_INVALID_TRANSFER
    // )
    ==
    frame_dig -5
    gtxns AssetAmount
    dup
    frame_dig -3
    >=
    uncover 2
    &&
    assert // Invalid transfer
    // smart_contracts/subscriptions/contract.algo.ts:380-386
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: amounts.leftOver
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:384
    // assetAmount: amounts.leftOver
    frame_dig 0
    pushint 16 // 16
    extract_uint64
    itxn_field AssetAmount
    frame_dig 2
    dup
    cover 2
    itxn_field XferAsset
    frame_dig -4
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:380-385
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: amounts.leftOver
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:380-386
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: amounts.leftOver
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:392
    // const paymentDifference: uint64 = assetXfer.assetAmount - amount
    frame_dig -3
    -
    // smart_contracts/subscriptions/contract.algo.ts:397
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/subscriptions/contract.algo.ts:402
    // lastPayment: Global.latestTimestamp,
    dup
    // smart_contracts/subscriptions/contract.algo.ts:394-405
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: assetXfer.xferAsset.id,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    frame_dig -1
    itob
    frame_dig -4
    swap
    concat
    uncover 2
    itob
    concat
    frame_dig -3
    itob
    concat
    frame_dig -2
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 6
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:403
    // streak: 1,
    intc_1 // 1
    // smart_contracts/subscriptions/contract.algo.ts:394-405
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: assetXfer.xferAsset.id,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/subscriptions/contract.algo.ts:394
    // this.subscriptions(subscriptionKey).value = {
    frame_dig 1
    dup
    extract 0 32
    swap
    extract 32 8
    concat
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:394-405
    // this.subscriptions(subscriptionKey).value = {
    //   recipient: recipient,
    //   serviceID,
    //   startDate: Global.latestTimestamp,
    //   amount,
    //   interval,
    //   asset: assetXfer.xferAsset.id,
    //   gateID,
    //   lastPayment: Global.latestTimestamp,
    //   streak: 1,
    //   escrowed: paymentDifference,
    // }
    swap
    box_put
    // smart_contracts/subscriptions/contract.algo.ts:407
    // return subscriptionID
    frame_dig 5
    frame_bury 0
    retsub

createAsaSubscription_else_body@8:
    // smart_contracts/subscriptions/contract.algo.ts:349-355
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: leftover
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:351
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:351
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    frame_dig 3
    itxn_field AssetAmount
    frame_dig 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:349-354
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: leftover
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:349-355
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: assetXfer.xferAsset,
    //     assetAmount: leftover
    //   })
    //   .submit()
    itxn_submit
    b createAsaSubscription_after_if_else@10


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.canTrigger(key: bytes) -> uint64, bytes:
canTrigger:
    // smart_contracts/subscriptions/contract.algo.ts:410
    // private canTrigger(key: SubscriptionKey): boolean {
    proto 1 2
    intc_0 // 0
    dup
    pushbytes ""
    dupn 5
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    frame_dig -1
    concat
    dup
    // smart_contracts/subscriptions/contract.algo.ts:411
    // if (!this.subscriptions(key).exists) {
    box_len
    bury 1
    bnz canTrigger_after_if_else@2
    // smart_contracts/subscriptions/contract.algo.ts:412
    // return false
    intc_0 // 0
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

canTrigger_after_if_else@2:
    // smart_contracts/subscriptions/contract.algo.ts:423
    // } = this.subscriptions(key).value
    frame_dig 8
    box_get
    assert // Box must have value
    dup
    extract 0 32
    dup
    cover 2
    frame_bury 1
    dup
    intc_3 // 32
    extract_uint64
    frame_bury 6
    dup
    pushint 80 // 80
    extract_uint64
    frame_bury 5
    dup
    pushint 40 // 40
    extract_uint64
    frame_bury 7
    dup
    pushint 56 // 56
    extract_uint64
    frame_bury 4
    dup
    pushint 96 // 96
    extract_uint64
    frame_bury 3
    pushint 48 // 48
    extract_uint64
    frame_bury 2
    // smart_contracts/subscriptions/contract.algo.ts:425
    // const blocksKey = this.getBlockKey(recipient, key.address)
    frame_dig -1
    extract 0 32
    callsub getBlockKey
    // smart_contracts/subscriptions/contract.algo.ts:117
    // blocks = BoxMap<BlockListKey, bytes<0>>({ keyPrefix: SubscriptionsBoxPrefixBlocks })
    bytec 6 // "b"
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:428
    // if (this.blocks(blocksKey).exists) {
    box_len
    bury 1
    bz canTrigger_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:429
    // return false
    intc_0 // 0
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

canTrigger_after_if_else@4:
    // smart_contracts/subscriptions/contract.algo.ts:434-438
    // serviceID > 0 &&
    // (
    //   !this.services({ address: recipient, id: serviceID }).exists ||
    //   this.services({ address: recipient, id: serviceID }).value.status === ServiceStatusShutdown
    // )
    frame_dig 6
    bz canTrigger_after_if_else@8
    // smart_contracts/subscriptions/contract.algo.ts:436
    // !this.services({ address: recipient, id: serviceID }).exists ||
    frame_dig 6
    itob
    frame_dig 1
    swap
    concat
    // smart_contracts/subscriptions/contract.algo.ts:107
    // services = BoxMap<ServicesKey, Service>({ keyPrefix: SubscriptionsBoxPrefixServices })
    bytec_0 // "o"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/subscriptions/contract.algo.ts:436
    // !this.services({ address: recipient, id: serviceID }).exists ||
    box_len
    bury 1
    bz canTrigger_if_body@7
    // smart_contracts/subscriptions/contract.algo.ts:437
    // this.services({ address: recipient, id: serviceID }).value.status === ServiceStatusShutdown
    frame_dig 0
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 9 // 0x1e
    ==
    // smart_contracts/subscriptions/contract.algo.ts:436-437
    // !this.services({ address: recipient, id: serviceID }).exists ||
    // this.services({ address: recipient, id: serviceID }).value.status === ServiceStatusShutdown
    bz canTrigger_after_if_else@8

canTrigger_if_body@7:
    // smart_contracts/subscriptions/contract.algo.ts:440
    // return false
    intc_0 // 0
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

canTrigger_after_if_else@8:
    // smart_contracts/subscriptions/contract.algo.ts:444
    // if (lastPayment >= this.getLatestWindowStart(startDate, interval)) {
    frame_dig 7
    frame_dig 4
    callsub getLatestWindowStart
    frame_dig 5
    <=
    bz canTrigger_after_if_else@10
    // smart_contracts/subscriptions/contract.algo.ts:445
    // return false
    intc_0 // 0
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

canTrigger_after_if_else@10:
    // smart_contracts/subscriptions/contract.algo.ts:448
    // if (amount > escrowed) {
    frame_dig 2
    frame_dig 3
    >
    bz canTrigger_after_if_else@12
    // smart_contracts/subscriptions/contract.algo.ts:449
    // return false
    intc_0 // 0
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

canTrigger_after_if_else@12:
    // smart_contracts/subscriptions/contract.algo.ts:452
    // return true
    intc_1 // 1
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment(key: bytes) -> bytes:
smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment:
    // smart_contracts/subscriptions/contract.algo.ts:897
    // triggerPayment(key: SubscriptionKey): void {
    proto 1 1
    // smart_contracts/subscriptions/contract.algo.ts:899
    // assert(this.canTrigger(key), ERR_CANNOT_TRIGGER)
    frame_dig -1
    callsub canTrigger
    frame_bury -1
    assert // Cannot trigger payment at this time
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    frame_dig -1
    concat
    // smart_contracts/subscriptions/contract.algo.ts:906
    // } = this.subscriptions(key).value
    box_get
    assert // Box must have value
    dup
    extract 0 32
    swap
    dup
    pushint 48 // 48
    extract_uint64
    swap
    dup
    pushint 64 // 64
    extract_uint64
    swap
    pushint 72 // 72
    extract_uint64
    // smart_contracts/subscriptions/contract.algo.ts:908
    // if (gateID !== 0) {
    bz smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_after_if_else@4
    // smart_contracts/subscriptions/contract.algo.ts:909
    // assert(Txn.applicationArgs(0) === methodSelector(this.gatedTriggerPayment))
    intc_0 // 0
    txnas ApplicationArgs
    bytec 11 // method "gatedTriggerPayment(appl,(address,uint64))void"
    ==
    assert

smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_after_if_else@4:
    // smart_contracts/subscriptions/contract.algo.ts:913
    // const amounts = this.getAmounts(amount)
    frame_dig 1
    callsub getAmounts
    // smart_contracts/subscriptions/contract.algo.ts:915
    // if (isAsa) {
    frame_dig 2
    bz smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_else_body@9
    // smart_contracts/subscriptions/contract.algo.ts:918-924
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: asset,
    //     assetAmount: amounts.akitaFee
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:920
    // assetReceiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:920
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/subscriptions/contract.algo.ts:922
    // assetAmount: amounts.akitaFee
    dig 1
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    frame_dig 2
    dup
    cover 3
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:918-923
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: asset,
    //     assetAmount: amounts.akitaFee
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:918-924
    // itxn
    //   .assetTransfer({
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     xferAsset: asset,
    //     assetAmount: amounts.akitaFee
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:926-932
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: asset,
    //     assetAmount: amounts.triggerFee
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:928
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/subscriptions/contract.algo.ts:930
    // assetAmount: amounts.triggerFee
    dig 1
    intc_2 // 8
    extract_uint64
    itxn_field AssetAmount
    dig 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:926-931
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: asset,
    //     assetAmount: amounts.triggerFee
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:926-932
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: asset,
    //     assetAmount: amounts.triggerFee
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:934-940
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: asset,
    //     assetAmount: amounts.leftOver
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:938
    // assetAmount: amounts.leftOver
    pushint 16 // 16
    extract_uint64
    itxn_field AssetAmount
    itxn_field XferAsset
    frame_dig 0
    itxn_field AssetReceiver
    // smart_contracts/subscriptions/contract.algo.ts:934-939
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: asset,
    //     assetAmount: amounts.leftOver
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:934-940
    // itxn
    //   .assetTransfer({
    //     assetReceiver: recipient,
    //     xferAsset: asset,
    //     assetAmount: amounts.leftOver
    //   })
    //   .submit()
    itxn_submit

smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_after_if_else@13:
    // smart_contracts/subscriptions/contract.algo.ts:965
    // this.updateStreak(key, 1)
    frame_dig -1
    intc_1 // 1
    callsub updateStreak
    frame_bury -1
    // smart_contracts/subscriptions/contract.algo.ts:94-96
    // subscriptions = BoxMap<SubscriptionKey, SubscriptionInfo>({
    //   keyPrefix: SubscriptionsBoxPrefixSubscriptions,
    // })
    bytec_3 // "s"
    frame_dig -1
    concat
    // smart_contracts/subscriptions/contract.algo.ts:967
    // this.subscriptions(key).value.escrowed -= amount
    dup
    box_get
    assert // Box must have value
    pushint 96 // 96
    extract_uint64
    frame_dig 1
    -
    itob
    dig 1
    pushint 96 // 96
    uncover 2
    box_replace
    // smart_contracts/subscriptions/contract.algo.ts:968
    // this.subscriptions(key).value.lastPayment = Global.latestTimestamp
    global LatestTimestamp
    itob
    pushint 80 // 80
    swap
    box_replace
    frame_dig -1
    frame_bury 0
    retsub

smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_else_body@9:
    // smart_contracts/subscriptions/contract.algo.ts:943-948
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: amounts.akitaFee
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:945
    // receiver: this.akitaDAOEscrow.value.address,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:64
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    bytec 4 // "akita_escrow"
    // smart_contracts/subscriptions/contract.algo.ts:945
    // receiver: this.akitaDAOEscrow.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/subscriptions/contract.algo.ts:946
    // amount: amounts.akitaFee
    dig 1
    intc_0 // 0
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:943-947
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: amounts.akitaFee
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:943-948
    // itxn
    //   .payment({
    //     receiver: this.akitaDAOEscrow.value.address,
    //     amount: amounts.akitaFee
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:950-955
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amounts.triggerFee
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:952
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/subscriptions/contract.algo.ts:953
    // amount: amounts.triggerFee
    dig 1
    intc_2 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:950-954
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amounts.triggerFee
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:950-955
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: amounts.triggerFee
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/subscriptions/contract.algo.ts:957-962
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/subscriptions/contract.algo.ts:960
    // amount: amounts.leftOver
    pushint 16 // 16
    extract_uint64
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    // smart_contracts/subscriptions/contract.algo.ts:957-961
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/subscriptions/contract.algo.ts:957-962
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: amounts.leftOver
    //   })
    //   .submit()
    itxn_submit
    b smart_contracts/subscriptions/contract.algo.ts::Subscriptions.triggerPayment_after_if_else@13
