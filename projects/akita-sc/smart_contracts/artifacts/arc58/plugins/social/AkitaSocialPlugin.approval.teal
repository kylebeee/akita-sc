#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 16 32 385 384 19300 18900 15700 63072000 86400 35700 31700 29700
    bytecblock 0x00 "akita_dao" "controlled_address" "spending_address" "m" 0x151f7c75 "p" 0x0000 "akita_assets" "akita_escrow" "social_fees" "plugn_al" 0x0033 0x80 "d" "a" "n" "b" "o" "f" 0x27ece5e6 "version" 0x3e6ee3d6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txn NumAppArgs
    bz main_after_if_else@43
    pushbytess 0x88c940f8 0xc13990ec 0xcef15f6b 0x6744e866 0xa3682229 0x832fbd39 0x65b69865 0x693f6dc8 0x21288fbc 0x5db7232d 0x192a62af 0x28e9d866 0xec5bceb1 0x7e9c7af0 0x5801c36b 0x4a1a352f 0x3f2752de 0x7fd4cab7 0xb0202e9e 0x92b8899d 0xbec86c34 0x9f59a970 0xaa765601 0x9091dca5 0x493e908f 0x0d8b6771 0x68e8db78 0x25498229 0x5cf7e0a5 0x47d682fc 0xe869934d 0x70e5c48b 0x2882bb8a 0x3172ca9d 0xea9180dd 0x33e92c94 0x1ead20a9 // method "create(string,uint64,uint64)void", method "post(uint64,bool,byte[36],uint64)void", method "editPost(uint64,bool,byte[36],uint64,byte[32])void", method "replyPost(uint64,bool,byte[36],byte[32],uint64,byte[][])void", method "replyAsset(uint64,bool,byte[36],uint64,uint64)void", method "replyAddress(uint64,bool,byte[36],address,uint64,byte[][])void", method "replyApp(uint64,bool,byte[36],uint64,uint64)void", method "editReply(uint64,bool,byte[36],uint64,byte[][],byte[32])void", method "votePost(uint64,bool,byte[32],bool)void", method "voteAsset(uint64,bool,uint64,bool)void", method "voteAddress(uint64,bool,address,bool)void", method "voteApp(uint64,bool,uint64,bool)void", method "editVote(uint64,bool,byte[32],bool)void", method "reactPost(uint64,bool,byte[32],uint64,byte[][])void", method "reactAsset(uint64,bool,uint64,uint64)void", method "reactAddress(uint64,bool,address,uint64,byte[][])void", method "reactApp(uint64,bool,uint64,uint64)void", method "deleteReaction(uint64,bool,byte[32],uint64)void", method "follow(uint64,bool,address,byte[][])void", method "unfollow(uint64,bool,address,uint64)void", method "block(uint64,bool,address)void", method "unblock(uint64,bool,address)void", method "addModerator(uint64,bool,address)void", method "removeModerator(uint64,bool,address)void", method "ban(uint64,bool,address,uint64)void", method "flagPost(uint64,bool,byte[32])void", method "unban(uint64,bool,address)void", method "addAction(uint64,bool,uint64,byte[36])void", method "removeAction(uint64,bool,uint64)void", method "initMeta(uint64,bool,bool,uint64,uint64,uint64)uint64", method "getUserSocialImpact(address)uint64", method "isFollower(address,uint64,address)bool", method "getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)", method "gas()void", method "update(string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@3 main_post_route@4 main_editPost_route@5 main_replyPost_route@6 main_replyAsset_route@7 main_replyAddress_route@8 main_replyApp_route@9 main_editReply_route@10 main_votePost_route@11 main_voteAsset_route@12 main_voteAddress_route@13 main_voteApp_route@14 main_editVote_route@15 main_reactPost_route@16 main_reactAsset_route@17 main_reactAddress_route@18 main_reactApp_route@19 main_deleteReaction_route@20 main_follow_route@21 main_unfollow_route@22 main_block_route@23 main_unblock_route@24 main_addModerator_route@25 main_removeModerator_route@26 main_ban_route@27 main_flagPost_route@28 main_unban_route@29 main_addAction_route@30 main_removeAction_route@31 main_initMeta_route@32 main_getUserSocialImpact_route@33 main_isFollower_route@34 main_getMeta_route@35 main_gas_route@36 main_update_route@37 main_updateAkitaDAO_route@38 main_updateAkitaDAOEscrow_route@39

main_after_if_else@43:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    intc_0 // 0
    return

main_updateAkitaDAOEscrow_route@39:
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_1 // 1
    return

main_updateAkitaDAO_route@38:
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@37:
    // smart_contracts/utils/base-contracts/base.ts:78
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:78
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_gas_route@36:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1304
    // gas(): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_getMeta_route@35:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1298
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1298
    // @abimethod({ readonly: true })
    callsub getMeta
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 10
    setbit
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isFollower_route@34:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1293
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1293
    // @abimethod({ readonly: true })
    callsub isFollower
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserSocialImpact_route@33:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1288
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1288
    // @abimethod({ readonly: true })
    callsub getUserSocialImpact
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initMeta_route@32:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1216-1223
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    intc_0 // 0
    getbit
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1216-1223
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    callsub initMeta
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeAction_route@31:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1194
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1194
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    callsub removeAction
    intc_1 // 1
    return

main_addAction_route@30:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1174
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1174
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    callsub addAction
    intc_1 // 1
    return

main_unban_route@29:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1154
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1154
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub unban
    intc_1 // 1
    return

main_flagPost_route@28:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1135
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1135
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    callsub flagPost
    intc_1 // 1
    return

main_ban_route@27:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1116
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1116
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    callsub ban
    intc_1 // 1
    return

main_removeModerator_route@26:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1094
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1094
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub removeModerator
    intc_1 // 1
    return

main_addModerator_route@25:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1074
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1074
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub addModerator
    intc_1 // 1
    return

main_unblock_route@24:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1052
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1052
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub unblock
    intc_1 // 1
    return

main_block_route@23:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub block
    intc_1 // 1
    return

main_unfollow_route@22:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:999
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:999
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    callsub unfollow
    intc_1 // 1
    return

main_follow_route@21:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:962
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:962
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    callsub follow
    intc_1 // 1
    return

main_deleteReaction_route@20:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:934
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:934
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    callsub deleteReaction
    intc_1 // 1
    return

main_reactApp_route@19:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    callsub reactApp
    intc_1 // 1
    return

main_reactAddress_route@18:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:910
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:910
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    callsub reactAddress
    intc_1 // 1
    return

main_reactAsset_route@17:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:902
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:902
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    callsub reactAsset
    intc_1 // 1
    return

main_reactPost_route@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:898
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:898
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64, args: GateArgs): void {
    callsub reactPost
    intc_1 // 1
    return

main_editVote_route@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // editVote(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, flip: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // editVote(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, flip: boolean): void {
    callsub editVote
    intc_1 // 1
    return

main_voteApp_route@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:871
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:871
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    callsub voteApp
    intc_1 // 1
    return

main_voteAddress_route@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:865
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:865
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    callsub voteAddress
    intc_1 // 1
    return

main_voteAsset_route@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:857
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:857
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    callsub voteAsset
    intc_1 // 1
    return

main_votePost_route@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:853
    // votePost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:853
    // votePost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    callsub votePost
    intc_1 // 1
    return

main_editReply_route@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:819-826
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: bytes<32>
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:819-826
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: bytes<32>
    // ): void {
    callsub editReply
    intc_1 // 1
    return

main_replyApp_route@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:811
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:811
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    callsub replyApp
    intc_1 // 1
    return

main_replyAddress_route@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    callsub replyAddress
    intc_1 // 1
    return

main_replyAsset_route@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    callsub replyAsset
    intc_1 // 1
    return

main_replyPost_route@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:784
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: bytes<32>, gateID: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:784
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: bytes<32>, gateID: uint64, args: GateArgs): void {
    callsub replyPost
    intc_1 // 1
    return

main_editPost_route@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:758
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: bytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:758
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: bytes<32>): void {
    callsub editPost
    intc_1 // 1
    return

main_post_route@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:754
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:754
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    callsub post
    intc_1 // 1
    return

main_create_route@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:745
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // export class AkitaSocialPlugin extends AkitaBaseEscrow implements AkitaSocialPluginInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:745
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:85
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:86
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:87
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    // smart_contracts/utils/constants.ts:15
    // export const MAX_IMPACT: uint64 = 1_000
    pushint 1000 // 1000
    // smart_contracts/utils/functions.ts:87
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:86
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes, id: uint64, args: bytes) -> uint64:
gateCheck:
    // smart_contracts/utils/functions.ts:130
    // export function gateCheck(akitaDAO: Application, caller: Address, id: uint64, args: GateArgs): boolean {
    proto 4 1
    // smart_contracts/utils/functions.ts:131
    // if (id === 0) {
    frame_dig -2
    bnz gateCheck_after_if_else@2
    // smart_contracts/utils/functions.ts:132
    // return true
    intc_1 // 1
    retsub

gateCheck_after_if_else@2:
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -4
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    pushbytes "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 40 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:137
    // args: [caller, id, args],
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:138
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:135-139
    // return abiCall(GateInterface.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    retsub


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:166
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    intc_0 // 0
    dup
    // smart_contracts/utils/functions.ts:167
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:168
    // return Global.zeroAddress
    global ZeroAddress
    frame_bury 0
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -1
    app_params_get AppAddress
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/utils/functions.ts:172
    // if (sender !== origin) {
    !=
    bz rekeyAddress_after_if_else@4
    // smart_contracts/utils/functions.ts:173
    // return sender
    retsub

rekeyAddress_after_if_else@4:
    // smart_contracts/utils/functions.ts:176
    // return walletAddress
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(address: bytes) -> uint64:
controls:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:71
    // private controls(address: Account): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:72
    // return address.authAddress === Global.currentApplicationAddress
    frame_dig -1
    acct_params_get AcctAuthAddr
    assert // account funded
    global CurrentApplicationAddress
    ==
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(wallet: uint64) -> void:
rekeyBack:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:75
    // private rekeyBack(wallet: Application) {
    proto 1 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:78-86
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:83
    // rekeyTo: rekeyAddress(true, wallet),
    intc_1 // 1
    frame_dig -1
    callsub rekeyAddress
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:81
    // amount: 0,
    intc_0 // 0
    itxn_field Amount
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:78-85
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:78-86
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isReply(ref: bytes) -> uint64:
isReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:94
    // private isReply(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:95
    // return ref.length === 68 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 68 // 68
    ==
    bnz isReply_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1

isReply_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:95
    // return ref.length === 68 || ref.length === 101
    swap
    retsub

isReply_bool_false@3:
    intc_0 // 0
    b isReply_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isAmended(ref: bytes) -> uint64:
isAmended:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:98
    // private isAmended(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:99
    // return ref.length === 69 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 69 // 69
    ==
    bnz isAmended_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isAmended_bool_false@3

isAmended_bool_true@2:
    intc_1 // 1

isAmended_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:99
    // return ref.length === 69 || ref.length === 101
    swap
    retsub

isAmended_bool_false@3:
    intc_0 // 0
    b isAmended_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(account: bytes) -> uint64:
isBanned:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:102
    // private isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 16 // "n"
    frame_dig -1
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:103
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    box_len
    bury 1
    bz isBanned_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    global LatestTimestamp
    >
    bz isBanned_bool_false@3
    intc_1 // 1

isBanned_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:103
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    swap
    retsub

isBanned_bool_false@3:
    intc_0 // 0
    b isBanned_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.blk(userAddress: bytes, blockedAddress: bytes) -> bytes, bytes:
blk:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:107
    // private blk(userAddress: Account, blockedAddress: Account): BlockListKey {
    proto 2 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:108
    // const user = userAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:109
    // const blocked = blockedAddress.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:110
    // return { user, blocked }
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rlk(user: bytes, ref: bytes, NFT: uint64) -> bytes, bytes, uint64:
rlk:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:114
    // private rlk(user: Account, ref: bytes<32>, NFT: uint64): ReactionListKey {
    proto 3 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:115
    // const userKey = user.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -3
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -3
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:116
    // const refKey = ref.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:117
    // return { user: userKey, ref: refKey, NFT }
    frame_dig -1
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.vlk(account: bytes, r: bytes) -> bytes, bytes:
vlk:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:121
    // private vlk(account: Account, r: bytes<32>): VoteListKey {
    proto 2 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:122
    // const user = account.bytes.slice(0, 16).toFixed({ length: 16 })
    frame_dig -2
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -2
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:123
    // const ref = r.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // Length must be 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:124
    // return { user, ref }
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(user: bytes, blocked: bytes) -> uint64:
isBlocked:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:127
    // private isBlocked(user: Account, blocked: Account): boolean {
    proto 2 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:128
    // const blocksKey = this.blk(user, blocked)
    frame_dig -2
    frame_dig -1
    callsub blk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:129
    // return this.blocks(blocksKey).exists
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 17 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:129
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:132
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    dupn 4
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:134
    // const meta = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    pushint 8 // 8
    extract_uint64
    dup
    uncover 2
    intc_2 // 16
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:137
    // if (meta.streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:138
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:146
    // const accountAge: uint64 = Global.latestTimestamp - meta.startDate
    global LatestTimestamp
    frame_dig 7
    -
    dup
    frame_bury 1
    // smart_contracts/arc58/plugins/social/constants.ts:30
    // export const TWO_YEARS: uint64 = 63_072_000
    intc 9 // 63072000
    // smart_contracts/arc58/plugins/social/contract.algo.ts:148
    // if (accountAge >= TWO_YEARS) {
    >=
    bz getSocialImpactScore_else_body@5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:149
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@6:
    // smart_contracts/arc58/plugins/social/constants.ts:6
    // export const AkitaSocialBoxPrefixVotes = 'v'
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:156
    // if (this.votes(account.bytes).exists) {
    box_len
    bury 1
    frame_dig 4
    frame_bury 5
    bz getSocialImpactScore_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:157
    // const score = this.votes(account.bytes).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:159
    // let impact: uint64 = (score.voteCount * 75) / 100_000
    pushint 75 // 75
    *
    pushint 100000 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:160
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:161
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:164
    // if (score.isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:166
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:167
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@15:
    frame_dig 4
    frame_bury 5

getSocialImpactScore_after_if_else@16:
    frame_dig 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:177
    // return socialImpact
    frame_bury 0
    retsub

getSocialImpactScore_else_body@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:169
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:173
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:152
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    // smart_contracts/arc58/plugins/social/constants.ts:30
    // export const TWO_YEARS: uint64 = 63_072_000
    intc 9 // 63072000
    // smart_contracts/arc58/plugins/social/contract.algo.ts:152
    // socialImpact += (accountAge * 75) / TWO_YEARS
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@6

getSocialImpactScore_else_body@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:141
    // socialImpact += (meta.streak * 100) / 60
    frame_dig 6
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@3


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:180
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:181-188
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:181-188
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:181-188
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:190
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(sender: bytes, appId: uint64) -> uint64:
canCallArc58OptIn:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:193
    // private canCallArc58OptIn(sender: Account, appId: Application): boolean {
    proto 2 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:194-207
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       methodSelector(OptInPlugin.prototype.optInToAsset)
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:200
    // getPluginAppList(this.akitaDAO.value).optin,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:194-207
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       methodSelector(OptInPlugin.prototype.optInToAsset)
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0x682fdbf8 // method "arc58_canCall(uint64,bool,address,byte[4])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:201
    // true,
    bytec 13 // 0x80
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:203
    // methodSelector(OptInPlugin.prototype.optInToAsset)
    bytec 20 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    frame_dig -2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:194-207
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       methodSelector(OptInPlugin.prototype.optInToAsset)
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:194-207
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       methodSelector(OptInPlugin.prototype.optInToAsset)
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
arc58OptInAndSendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:210-216
    // private arc58OptInAndSendReactionPayments(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   recipientWallet: Application,
    //   mbrAmount: uint64,
    //   tax: uint64
    // ): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:221-228
    // itxnCompose.begin(
    //   itxn.payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:225
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:222-227
    // itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:230-243
    // itxnCompose.next(
    //   AbstractedAccount.prototype.arc58_rekeyToPlugin,
    //   {
    //     sender,
    //     appId: recipientWallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       [],
    //       []
    //     ],
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dig 3
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:236
    // getPluginAppList(this.akitaDAO.value).optin,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:230-243
    // itxnCompose.next(
    //   AbstractedAccount.prototype.arc58_rekeyToPlugin,
    //   {
    //     sender,
    //     appId: recipientWallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       [],
    //       []
    //     ],
    //     fee,
    //   }
    // )
    pushbytes 0xde300fe9 // method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:237
    // true,
    bytec 13 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:238
    // [],
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:239
    // []
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:230-243
    // itxnCompose.next(
    //   AbstractedAccount.prototype.arc58_rekeyToPlugin,
    //   {
    //     sender,
    //     appId: recipientWallet,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       [],
    //       []
    //     ],
    //     fee,
    //   }
    // )
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-263
    // itxnCompose.next(
    //   OptInPlugin.prototype.optInToAsset,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       recipientWallet.id,
    //       true,
    //       [akta],
    //       itxn.payment({
    //         sender,
    //         amount: Global.assetOptInMinBalance,
    //         receiver: recipientOrigin,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:256
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    dig 3
    itxn_field Receiver
    itxn_field Amount
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:254-259
    // itxn.payment({
    //   sender,
    //   amount: Global.assetOptInMinBalance,
    //   receiver: recipientOrigin,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-263
    // itxnCompose.next(
    //   OptInPlugin.prototype.optInToAsset,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       recipientWallet.id,
    //       true,
    //       [akta],
    //       itxn.payment({
    //         sender,
    //         amount: Global.assetOptInMinBalance,
    //         receiver: recipientOrigin,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    dig 3
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:251
    // recipientWallet.id,
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:253
    // [akta],
    dig 3
    itob
    pushbytes 0x0001
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-263
    // itxnCompose.next(
    //   OptInPlugin.prototype.optInToAsset,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       recipientWallet.id,
    //       true,
    //       [akta],
    //       itxn.payment({
    //         sender,
    //         amount: Global.assetOptInMinBalance,
    //         receiver: recipientOrigin,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    bytec 20 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:252
    // true,
    bytec 13 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-263
    // itxnCompose.next(
    //   OptInPlugin.prototype.optInToAsset,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).optin,
    //     args: [
    //       recipientWallet.id,
    //       true,
    //       [akta],
    //       itxn.payment({
    //         sender,
    //         amount: Global.assetOptInMinBalance,
    //         receiver: recipientOrigin,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:265-272
    // itxnCompose.next(
    //   AbstractedAccount.prototype.arc58_verifyAuthAddr,
    //   {
    //     sender,
    //     appId: recipientWallet,
    //     fee,
    //   }
    // )
    itxn_next
    pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    dup
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:274-282
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 9 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:277
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    dig 2
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:275-281
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: akta,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    uncover 3
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:286-295
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     sender,
    //     assetReceiver: recipientOrigin,
    //     assetAmount: reactFee - tax,
    //     xferAsset: akta,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:290
    // assetAmount: reactFee - tax,
    frame_dig -1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:292
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    itxn_field RekeyTo
    uncover 2
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:287-294
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: recipientOrigin,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:297
    // itxnCompose.submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
arc59OptInAndSendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:300-306
    // private arc59OptInAndSendReactionPayments(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   recipientWallet: Application,
    //   mbrAmount: uint64,
    //   tax: uint64
    // ): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:35
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    dup
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    pushbytes "other_al"
    // smart_contracts/utils/functions.ts:35
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:36
    // return decodeArc4<OtherAppList>(otherAppListBytes)
    intc_2 // 16
    extract_uint64
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:308
    // const inboxAddress = Application(assetInbox).address
    dup
    app_params_get AppAddress
    swap
    cover 3
    assert // application exists
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    swap
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:313-320
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:317
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:313-319
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:313-320
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:322-333
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:329
    // akta,
    uncover 2
    itob
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:322-333
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:322-333
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dig 1
    pushint 12 // 12
    extract_uint64
    dup
    cover 3
    cover 3
    pushint 128 // 128
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    cover 2
    pushint 21 // 21
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:339
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz arc59OptInAndSendReactionPayments_if_body@4
    frame_dig 8
    bz arc59OptInAndSendReactionPayments_after_if_else@6

arc59OptInAndSendReactionPayments_if_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:340-347
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:344
    // amount: mbr + receiverAlgoNeededForClaim,
    frame_dig 6
    frame_dig 8
    +
    itxn_field Amount
    frame_dig 1
    itxn_field Receiver
    frame_dig 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:340-346
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:340-347
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

arc59OptInAndSendReactionPayments_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:350
    // if (!routerOptedIn) {
    frame_dig 7
    bnz arc59OptInAndSendReactionPayments_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:351-356
    // abiCall(AssetInbox.prototype.arc59_optRouterIn, {
    //   sender,
    //   appId: assetInbox,
    //   args: [akta],
    //   fee,
    // })
    itxn_begin
    pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
    itxn_field ApplicationArgs
    frame_dig 5
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationID
    frame_dig 3
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:351-356
    // abiCall(AssetInbox.prototype.arc59_optRouterIn, {
    //   sender,
    //   appId: assetInbox,
    //   args: [akta],
    //   fee,
    // })
    itxn_submit

arc59OptInAndSendReactionPayments_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:359-367
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 9 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:362
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    frame_dig 2
    dup
    cover 2
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:359-366
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:359-367
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:371-390
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:380
    // assetAmount: reactFee - tax,
    frame_dig -1
    -
    itxn_field AssetAmount
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:377-383
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: inboxAddress,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   fee,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:371-390
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:387
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:385
    // receiverAlgoNeededForClaim
    frame_dig 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:371-390
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    frame_dig 0
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:371-390
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    gitxn 1 LastLog
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientAccount: bytes, mbrAmount: uint64, tax: uint64) -> void:
sendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:393
    // private sendReactionPayments(wallet: Application, rekeyBack: boolean, recipientAccount: Account, mbrAmount: uint64, tax: uint64): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    uncover 2
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:401
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 9 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:407
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:416
    // assetAmount: reactFee - tax,
    uncover 2
    frame_dig -1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:418
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:422
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_begin
    uncover 3
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dig 4
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:398-403
    // const mbrPayment = itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:422
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_next
    dig 3
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    dig 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:405-411
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: akta,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:422
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_next
    itxn_field RekeyTo
    itxn_field AssetAmount
    itxn_field XferAsset
    frame_dig -3
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:413-420
    // const xferTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: recipientAccount,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:422
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref: bytes, creator: bytes) -> void:
createEmptyPostIfNecessary:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // private createEmptyPostIfNecessary(ref: bytes<32>, creator: Account): void {
    proto 2 0
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:426
    // if (!this.posts(ref).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:437
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427-441
    // this.posts(ref).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    frame_dig 0
    dup
    cover 2
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:437
    // timestamp: Global.latestTimestamp,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:438
    // gateID: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // this.posts(ref).value = {
    frame_dig -1
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:439
    // againstContentPolicy: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // this.posts(ref).value = {
    concat
    intc 4 // 385
    intc_0 // 0
    setbit
    bytec 12 // 0x0033
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:428
    // ref: op.bzero(0),
    bytec 7 // 0x0000
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // this.posts(ref).value = {
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427-441
    // this.posts(ref).value = {
    //   ref: op.bzero(0),
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    box_put

createEmptyPostIfNecessary_after_if_else@2:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:445
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:446
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    pushint 8 // 8
    extract_uint64
    swap
    dup
    intc_2 // 16
    extract_uint64
    dup
    uncover 2
    dup
    pushint 24 // 24
    extract_uint64
    dup
    cover 3
    cover 3
    dup
    intc_3 // 32
    extract_uint64
    cover 3
    dup
    pushint 40 // 40
    extract_uint64
    cover 3
    dup
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    cover 3
    dup
    pushint 49 // 49
    extract_uint64
    cover 3
    pushint 57 // 57
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:450
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - meta.startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 10 // 86400
    // smart_contracts/arc58/plugins/social/contract.algo.ts:450
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - meta.startDate) % ONE_DAY)
    %
    -
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 10 // 86400
    // smart_contracts/arc58/plugins/social/contract.algo.ts:451
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:455
    // if (lastWindowStart > meta.lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:459
    // lastActive: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:458
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:459
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 5
    itob
    frame_dig 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    frame_dig 8
    itob
    frame_dig 9
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:456
    // this.meta(account).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:456-460
    // this.meta(account).value = {
    //   ...meta,
    //   streak: 1,
    //   lastActive: Global.latestTimestamp,
    // }
    frame_dig 0
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:461
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:466
    // if (meta.lastActive < thisWindowStart) {
    frame_dig 4
    frame_dig 10
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:469
    // streak: (meta.streak + 1),
    frame_dig 2
    intc_1 // 1
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:470
    // lastActive: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:469
    // streak: (meta.streak + 1),
    uncover 2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:470
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:448
    // const meta = this.meta(account).value
    frame_dig 5
    itob
    frame_dig 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    frame_dig 8
    itob
    frame_dig 9
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:467
    // this.meta(account).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:467-471
    // this.meta(account).value = {
    //   ...meta,
    //   streak: (meta.streak + 1),
    //   lastActive: Global.latestTimestamp,
    // }
    frame_dig 0
    swap
    box_put

updateStreak_after_if_else@4:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:498
    // private updateVotes(ref: bytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/social/constants.ts:6
    // export const AkitaSocialBoxPrefixVotes = 'v'
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:478
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:479
    // return { newCount: impact, isNegative: false }
    intc_0 // 0
    frame_bury 1
    frame_dig -1
    frame_bury 2

updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:500
    // this.votes(ref).value = { voteCount, isNegative }
    frame_dig 2
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 2
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:485
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:485
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:488
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/arc58/plugins/social/contract.algo.ts:489
    // if (flip) {
    bz updateVotes_after_if_else@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:490
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:491
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    frame_bury 1
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:499
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15

updateVotes_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:494
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@13
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@14:
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:499
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15

updateVotes_ternary_false@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:494
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@14

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:503
    // private createVoteList(ref: bytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:504
    // const voteListKey = this.vlk(account, ref)
    frame_dig -2
    frame_dig -4
    callsub vlk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:505
    // this.votelist(voteListKey).value = { impact, isUp }
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:505
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    box_put
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createPost(wallet: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, isAmendment: uint64) -> void:
createPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:508
    // private createPost(wallet: Application, rekeyBack: boolean, cid: CID, gateID: uint64, isAmendment: boolean): void {
    proto 5 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:511
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:515
    // this.updateStreak(origin)
    dup
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/contract.algo.ts:517
    // const impact = this.getUserImpact(origin)
    dup
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:59
    // posts: 35_700 + (400 * ref.length),
    frame_dig -3
    len
    pushint 400 // 400
    dig 1
    *
    intc 11 // 35700
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votes: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:524
    // amount: (posts + votes + votelist),
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:524
    // amount: (posts + votes + votelist),
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:525
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 9 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:531
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:534
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:538
    // submitGroup(mbrTxn, taxTxn)
    itxn_begin
    uncover 2
    itxn_field Receiver
    uncover 2
    itxn_field Amount
    dig 7
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:522-527
    // const mbrTxn = itxn.payment({
    //   sender,
    //   amount: (posts + votes + votelist),
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:538
    // submitGroup(mbrTxn, taxTxn)
    itxn_next
    itxn_field RekeyTo
    uncover 3
    itxn_field XferAsset
    uncover 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    uncover 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:529-536
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: postFee,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:538
    // submitGroup(mbrTxn, taxTxn)
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:540
    // const postID = Txn.txId
    txn TxID
    // smart_contracts/arc58/plugins/social/contract.algo.ts:544
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    dig 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:541-548
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:544
    // timestamp: Global.latestTimestamp,
    swap
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:545
    // gateID: gateID,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:547
    // isAmendment: isAmendment,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:542
    // ref: Bytes(cid),
    uncover 5
    itob
    extract 6 2
    frame_dig -3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:541
    // this.posts(postID).value = {
    dig 7
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:546
    // againstContentPolicy: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:541
    // this.posts(postID).value = {
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:541-548
    // this.posts(postID).value = {
    //   ref: Bytes(cid),
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:549
    // this.updateVotes(postID, true, impact)
    dup
    intc_1 // 1
    dig 3
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:550
    // this.createVoteList(postID, true, origin, impact)
    intc_1 // 1
    uncover 3
    uncover 3
    callsub createVoteList
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(wallet: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes, isAmendment: uint64) -> void:
createReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:553-561
    // private createReply(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   args: GateArgs,
    //   isAmendment: boolean
    // ): void {
    proto 7 0
    intc_0 // 0
    pushbytes ""
    dupn 3
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:565
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:566
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:567
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    cover 3
    pushint 40 // 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:568
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    uncover 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:570
    // if (post.gateID !== 0) {
    bz createReply_after_if_else@2
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:571
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), post.gateID, args), ERR_FAILED_GATE)
    frame_dig 5
    frame_dig 8
    frame_dig -2
    callsub gateCheck
    assert // Gate check failed

createReply_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:576
    // this.updateStreak(origin)
    frame_dig 5
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/contract.algo.ts:578
    // const replyRef = cid.concat(ref)
    frame_dig -5
    frame_dig -4
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 7
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:579
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:580
    // const postCreatorImpact = this.getUserImpact(post.creator)
    dup
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    intc_2 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:81
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    frame_bury 3
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:59
    // posts: 35_700 + (400 * ref.length),
    uncover 2
    len
    dup
    frame_bury 4
    pushint 400 // 400
    *
    intc 11 // 35700
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votes: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:584
    // const mbrAmount: uint64 = posts + votes + votelist
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:584
    // const mbrAmount: uint64 = posts + votes + votelist
    +
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:586
    // if (!post.creator.isOptedIn(Asset(akta))) {
    asset_holding_get AssetBalance
    bury 1
    bnz createReply_else_body@7
    // smart_contracts/arc58/plugins/social/contract.algo.ts:588
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 6
    frame_dig 1
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:589
    // if (canCallArc58OptIn) {
    bz createReply_else_body@5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:591
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    frame_dig 1
    frame_dig 2
    frame_dig 3
    callsub arc58OptInAndSendReactionPayments

createReply_after_if_else@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:602
    // const replyPostID = Txn.txId
    txn TxID
    // smart_contracts/arc58/plugins/social/contract.algo.ts:606
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    dig 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:612
    // this.posts(replyPostID).value = replyPost
    dup
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:603
    // const replyPost: PostValue = {
    swap
    itob
    frame_dig -3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    frame_dig 4
    itob
    extract 6 2
    frame_dig 0
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:612
    // this.posts(replyPostID).value = replyPost
    frame_dig 5
    dup
    cover 5
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:603
    // const replyPost: PostValue = {
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:612
    // this.posts(replyPostID).value = replyPost
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:614
    // const senderImpact = this.getUserImpact(origin)
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:615
    // this.updateVotes(replyPostID, true, senderImpact)
    dig 2
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:616
    // this.createVoteList(replyPostID, true, origin, senderImpact)
    uncover 2
    intc_1 // 1
    uncover 3
    uncover 3
    callsub createVoteList
    retsub

createReply_else_body@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:594
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    frame_dig 1
    frame_dig 2
    frame_dig 3
    callsub arc59OptInAndSendReactionPayments
    b createReply_after_if_else@8

createReply_else_body@7:
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 1
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:599
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    uncover 2
    frame_dig 2
    frame_dig 3
    callsub sendReactionPayments
    b createReply_after_if_else@8


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(wallet: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:619
    // private createVote(wallet: Application, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    proto 4 0
    pushbytes ""
    dup
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:622
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:623
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:625
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:626
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dup
    dig 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:628
    // const voteListKey = this.vlk(origin, ref)
    dig 1
    frame_dig -2
    callsub vlk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:629
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:629
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/arc58/plugins/social/contract.algo.ts:630
    // assert(origin !== post.creator, ERR_NO_SELF_VOTE)
    dig 1
    !=
    assert // Cannot vote on your own content
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:632
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:633
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:639
    // this.updateStreak(origin)
    callsub updateStreak
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    pushint 8 // 8
    extract_uint64
    cover 2
    dup
    intc_2 // 16
    extract_uint64
    cover 2
    pushint 24 // 24
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:643
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@8
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 4
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:644
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:646
    // const recipientImpact = this.getUserImpact(post.creator)
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:647
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 6
    frame_dig 7
    callsub impactRange
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:649
    // if (!post.creator.isOptedIn(Asset(akta))) {
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz createVote_else_body@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:651
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 3
    frame_dig 0
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:652
    // if (canCallArc58OptIn) {
    bz createVote_else_body@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:654
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    frame_dig 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:654
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig 1
    callsub arc58OptInAndSendReactionPayments

createVote_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:685
    // const senderImpact = this.getUserImpact(origin)
    frame_dig 2
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:686
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:687
    // this.createVoteList(ref, isUp, origin, senderImpact)
    frame_dig -2
    frame_dig -1
    uncover 3
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:657
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    frame_dig 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:657
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig 1
    callsub arc59OptInAndSendReactionPayments
    b createVote_after_if_else@11

createVote_else_body@6:
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:662
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    uncover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:662
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig 1
    callsub sendReactionPayments
    b createVote_after_if_else@11

createVote_else_body@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:668
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 9 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:674
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:677
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:681
    // submitGroup(mbrTxn, taxTxn)
    itxn_begin
    uncover 2
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:61
    // votelist: 19_300,
    intc 6 // 19300
    itxn_field Amount
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:665-670
    // const mbrTxn = itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:681
    // submitGroup(mbrTxn, taxTxn)
    itxn_next
    itxn_field RekeyTo
    uncover 2
    itxn_field XferAsset
    frame_dig 5
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:672-679
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: reactFee,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:681
    // submitGroup(mbrTxn, taxTxn)
    itxn_submit
    b createVote_after_if_else@11


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(wallet: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> void:
createReaction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:690
    // private createReaction(wallet: Application, rekeyBack: boolean, ref: bytes<32>, NFT: uint64, args: GateArgs): void {
    proto 5 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 5
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -5
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:692
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:693
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:694
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    cover 3
    pushint 40 // 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:695
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dig 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:696
    // const senderHasNFT = AssetHolding.assetBalance(origin, NFT)[0] > 0
    swap
    frame_dig -2
    asset_holding_get AssetBalance
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:697
    // assert(senderHasNFT, ERR_USER_DOES_NOT_OWN_NFT)
    assert // User does not own this NFT
    // smart_contracts/arc58/plugins/social/contract.algo.ts:699
    // if (post.gateID !== 0) {
    bz createReaction_after_if_else@2
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:700
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), post.gateID, args), ERR_FAILED_GATE)
    frame_dig 8
    frame_dig 11
    frame_dig -1
    callsub gateCheck
    assert // Gate check failed

createReaction_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:703
    // const reactionListKey = this.rlk(origin, ref, NFT)
    frame_dig 8
    dup
    frame_dig -3
    frame_dig -2
    callsub rlk
    dig 2
    len
    intc_2 // 16
    ==
    assert // invalid size
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:704
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:9
    // export const AkitaSocialBoxPrefixReactionList = 'e'
    pushbytes "e"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:704
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/arc58/plugins/social/contract.algo.ts:708
    // this.updateStreak(origin)
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 10
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:710
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:711
    // const recipientImpact = this.getUserImpact(post.creator)
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:10
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 10 // "social_fees"
    // smart_contracts/utils/functions.ts:40
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:41
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    intc_2 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:713
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    callsub impactRange
    frame_bury 7
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:19
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 8 // "akita_assets"
    // smart_contracts/utils/functions.ts:65
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:66
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:59
    // posts: 35_700 + (400 * ref.length),
    frame_dig -3
    len
    // smart_contracts/arc58/plugins/social/contract.algo.ts:63
    // reactionlist: 18_900,
    intc 7 // 18900
    frame_bury 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:717
    // const reactionKey: ReactionsKey = { ref, NFT }
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:718
    // const reactionExists = this.reactions(reactionKey).exists
    frame_dig -3
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:8
    // export const AkitaSocialBoxPrefixReactions = 'r'
    pushbytes "r"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:718
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    frame_bury 5
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:720
    // const mbrAmount: uint64 = reactionExists ? reactionlist : reactions + reactionlist
    bz createReaction_ternary_false@4
    frame_dig 6
    frame_bury 4

createReaction_ternary_merge@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:722
    // if (!post.creator.isOptedIn(Asset(akta))) {
    frame_dig 10
    frame_dig 2
    asset_holding_get AssetBalance
    bury 1
    bnz createReaction_else_body@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:723
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 9
    frame_dig 3
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:724
    // if (canCallArc58OptIn) {
    bz createReaction_else_body@8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:725
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    frame_dig 3
    frame_dig 4
    frame_dig 7
    callsub arc58OptInAndSendReactionPayments

createReaction_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:734
    // if (reactionExists) {
    frame_dig 5
    bz createReaction_else_body@13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:735
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:740
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    retsub

createReaction_else_body@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:737
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@14

createReaction_else_body@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:727
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    frame_dig 3
    frame_dig 4
    frame_dig 7
    callsub arc59OptInAndSendReactionPayments
    b createReaction_after_if_else@11

createReaction_else_body@10:
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:731
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    uncover 2
    frame_dig 4
    frame_dig 7
    callsub sendReactionPayments
    b createReaction_after_if_else@11

createReaction_ternary_false@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:720
    // const mbrAmount: uint64 = reactionExists ? reactionlist : reactions + reactionlist
    pushint 41000 // 41000
    frame_bury 4
    b createReaction_ternary_merge@5


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.create(version: bytes, akitaDAO: uint64, escrow: uint64) -> void:
create:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:745-746
    // @abimethod({ onCreate: 'require' })
    // create(version: string, akitaDAO: uint64, escrow: uint64): void {
    proto 3 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 21 // "version"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:747
    // this.version.value = version
    frame_dig -3
    app_global_put
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_1 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:748
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -2
    app_global_put
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    bytec 9 // "akita_escrow"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749
    // this.akitaDAOEscrow.value = Application(escrow)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.post(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64) -> void:
post:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:754
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:755
    // this.createPost(Application(walletID), rekeyBack, cid, gateID, false)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createPost
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editPost(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, amendment: bytes) -> void:
editPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:758
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: bytes<32>): void {
    proto 5 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:761
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:762
    // const post = this.posts(amendment).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 49 // 49
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:91
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:763
    // assert(this.isCreator(post.creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:764
    // assert(!this.isReply(post.ref), ERR_IS_A_REPLY)
    dup
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/arc58/plugins/social/contract.algo.ts:765
    // assert(!this.isAmended(post.ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/arc58/plugins/social/contract.algo.ts:769
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    bytec 15 // "a"
    txn TxID
    concat
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:768
    // ...this.posts(amendment).value,
    dig 1
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    intc 5 // 384
    getbit
    dig 2
    intc 4 // 385
    getbit
    dig 3
    intc_3 // 32
    extract_uint64
    uncover 4
    pushint 40 // 40
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:767-770
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    dig 6
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:768
    // ...this.posts(amendment).value,
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:769
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:767
    // this.posts(amendment).value = {
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:767-770
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:772-779
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:775
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:776
    // amount: 13_200, // (400 * 33) 'a' + txid
    pushint 13200 // 13200
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:772-778
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:772-779
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:781
    // this.createPost(Application(walletID), rekeyBack, cid, gateID, true)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    intc_1 // 1
    callsub createPost
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyPost(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes) -> void:
replyPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:784
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: bytes<32>, gateID: uint64, args: GateArgs): void {
    proto 6 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:785
    // this.createReply(Application(walletID), rekeyBack, cid, ref, gateID, args, false)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAsset(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:789
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:790
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:791
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:792
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:793
    // this.createReply(Application(walletID), rekeyBack, cid, paddedRef, gateID, [], false)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    uncover 3
    frame_dig -1
    bytec 7 // 0x0000
    intc_0 // 0
    callsub createReply
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAddress(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes) -> void:
replyAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    proto 6 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:798
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz replyAddress_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:799
    // const meta = this.meta(ref.native).value
    frame_dig 2
    box_get
    assert // Box must have value
    pushint 57 // 57
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:801
    // if (meta.addressGateID !== 0) {
    bz replyAddress_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:802
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), meta.addressGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 1
    frame_dig -1
    callsub gateCheck
    assert // Gate check failed

replyAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:807
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -3
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:808
    // this.createReply(wallet, rekeyBack, cid, r, gateID, [], false)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    bytec 7 // 0x0000
    intc_0 // 0
    callsub createReply
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyApp(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:811
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:812
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:813
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:814
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:815
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:816
    // this.createReply(Application(walletID), rekeyBack, cid, paddedRef, gateID, [], false)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    uncover 3
    frame_dig -1
    bytec 7 // 0x0000
    intc_0 // 0
    callsub createReply
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editReply(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, args: bytes, amendment: bytes) -> void:
editReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:819-826
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: bytes<32>
    // ): void {
    proto 6 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:829
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:830
    // const post = this.posts(amendment).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 49 // 49
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:91
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:831
    // assert(this.isCreator(post.creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:832
    // assert(this.isReply(post.ref), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/arc58/plugins/social/contract.algo.ts:833
    // assert(!this.isAmended(post.ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/arc58/plugins/social/contract.algo.ts:837
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    bytec 15 // "a"
    txn TxID
    concat
    dig 1
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:836
    // ...this.posts(amendment).value,
    dig 2
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    intc 5 // 384
    getbit
    dig 2
    intc 4 // 385
    getbit
    dig 3
    intc_3 // 32
    extract_uint64
    uncover 4
    pushint 40 // 40
    extract_uint64
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_0 // 0
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:835-838
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    dig 7
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:836
    // ...this.posts(amendment).value,
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:837
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:835
    // this.posts(amendment).value = {
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:835-838
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:840-847
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:843
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:844
    // amount: 13_200, // (400 * 33) 'a' + txid
    pushint 13200 // 13200
    itxn_field Amount
    itxn_field Receiver
    swap
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:840-846
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:840-847
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:849
    // const originalPostRef = post.ref.slice(0, 32).toFixed({ length: 32 })
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_3 // 32
    dig 2
    >=
    intc_3 // 32
    uncover 3
    uncover 2
    select
    substring3
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:850
    // this.createReply(wallet, rekeyBack, cid, originalPostRef, gateID, args, true)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    uncover 3
    frame_dig -3
    frame_dig -2
    intc_1 // 1
    callsub createReply
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.votePost(walletID: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
votePost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:853
    // votePost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:854
    // this.createVote(Application(walletID), rekeyBack, ref, isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAsset(walletID: uint64, rekeyBack: uint64, ref: uint64, isUp: uint64) -> void:
voteAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:857
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:858
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:859
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:860
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:861
    // this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:862
    // this.createVote(Application(walletID), rekeyBack, paddedRef, isUp)
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAddress(walletID: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
voteAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:865
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:867
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:868
    // this.createVote(Application(walletID), rekeyBack, r, isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteApp(walletID: uint64, rekeyBack: uint64, ref: uint64, isUp: uint64) -> void:
voteApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:871
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:872
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:873
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:874
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:875
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:876
    // this.createVote(Application(walletID), rekeyBack, paddedRef, isUp)
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editVote(walletID: uint64, rekeyBack: uint64, ref: bytes, flip: uint64) -> void:
editVote:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // editVote(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, flip: boolean): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:881
    // const voteListKey = this.vlk(senderAccount, ref)
    frame_dig -2
    callsub vlk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:882
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:882
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/arc58/plugins/social/contract.algo.ts:884
    // const { impact, isUp } = this.votelist(voteListKey).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:887
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    cover 2
    frame_dig -2
    swap
    uncover 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:888
    // if (!flip) {
    frame_dig -1
    bnz editVote_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:890
    // this.votelist(voteListKey).delete()
    frame_dig 0
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:891
    // return
    retsub

editVote_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:895
    // this.createVote(Application(walletID), rekeyBack, ref, !isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig 1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactPost(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> void:
reactPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:898
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64, args: GateArgs): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:899
    // this.createReaction(Application(walletID), rekeyBack, ref, NFT, args)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createReaction
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAsset(walletID: uint64, rekeyBack: uint64, ref: uint64, NFT: uint64) -> void:
reactAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:902
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:903
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:904
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:905
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:906
    // this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:907
    // this.createReaction(Application(walletID), rekeyBack, paddedRef, NFT, [])
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    bytec 7 // 0x0000
    callsub createReaction
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAddress(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> void:
reactAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:910
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    proto 5 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:912
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz reactAddress_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:913
    // const meta = this.meta(ref.native).value
    frame_dig 2
    box_get
    assert // Box must have value
    pushint 57 // 57
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:916
    // if (meta.addressGateID !== 0) {
    bz reactAddress_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:917
    // assert(gateCheck(this.akitaDAO.value, new Address(senderAccount), meta.addressGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 1
    frame_dig -1
    callsub gateCheck
    assert // Gate check failed

reactAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:922
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -3
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:923
    // this.createReaction(wallet, rekeyBack, r, NFT, [])
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    bytec 7 // 0x0000
    callsub createReaction
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactApp(walletID: uint64, rekeyBack: uint64, ref: uint64, NFT: uint64) -> void:
reactApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:927
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:928
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:929
    // const paddedRef = itob(ref).concat(op.bzero(24)).toFixed({ length: 32 })
    frame_dig -2
    itob
    pushint 24 // 24
    bzero
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:930
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:931
    // this.createReaction(Application(walletID), rekeyBack, paddedRef, NFT, [])
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    bytec 7 // 0x0000
    callsub createReaction
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.deleteReaction(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64) -> void:
deleteReaction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:934
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:937
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:938
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:940
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/arc58/plugins/social/contract.algo.ts:941
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dig 1
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:943
    // const reactionListKey = this.rlk(origin, ref, NFT)
    dup
    frame_dig -2
    frame_dig -1
    callsub rlk
    dig 2
    len
    intc_2 // 16
    ==
    assert // invalid size
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:944
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:9
    // export const AkitaSocialBoxPrefixReactionList = 'e'
    pushbytes "e"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:944
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/arc58/plugins/social/contract.algo.ts:946
    // this.reactions({ ref, NFT }).value -= 1
    frame_dig -2
    len
    intc_3 // 32
    ==
    assert // invalid size
    frame_dig -1
    itob
    frame_dig -2
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:8
    // export const AkitaSocialBoxPrefixReactions = 'r'
    pushbytes "r"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:946
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:947
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949-955
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:63
    // reactionlist: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949-954
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949-955
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:957
    // if (rekeyBack) {
    frame_dig -3
    bz deleteReaction_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:958
    // this.rekeyBack(wallet)
    frame_dig -4
    callsub rekeyBack

deleteReaction_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.follow(walletID: uint64, rekeyBack: uint64, address: bytes, args: bytes) -> void:
follow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:962
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:965
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:966
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:967
    // assert(!this.isBlocked(address.native, origin), ERR_BLOCKED)
    frame_dig -2
    dig 1
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:969
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:970
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -2
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:972
    // const meta = this.meta(address.native).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    pushint 8 // 8
    extract_uint64
    swap
    dup
    intc_2 // 16
    extract_uint64
    swap
    dup
    pushint 24 // 24
    extract_uint64
    swap
    dup
    intc_3 // 32
    extract_uint64
    swap
    dup
    pushint 40 // 40
    extract_uint64
    swap
    dup
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    dup
    pushint 49 // 49
    extract_uint64
    dup
    uncover 2
    pushint 57 // 57
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:974
    // if (meta.followGateID !== 0) {
    bz follow_after_if_else@2
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:975
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), meta.followGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 10
    frame_dig -1
    callsub gateCheck
    assert // Gate check failed

follow_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:979
    // const followsKey: FollowsKey = { user: address.native, index: (followerIndex + 1) }
    frame_dig 7
    intc_1 // 1
    +
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:980
    // this.follows(followsKey).value = origin
    frame_dig -2
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:980
    // this.follows(followsKey).value = origin
    frame_dig 0
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:985
    // followerCount: (meta.followerCount + 1),
    frame_dig 8
    intc_1 // 1
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:972
    // const meta = this.meta(address.native).value
    frame_dig 3
    itob
    frame_dig 4
    itob
    frame_dig 5
    itob
    frame_dig 6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:985
    // followerCount: (meta.followerCount + 1),
    uncover 4
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:972
    // const meta = this.meta(address.native).value
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 9
    setbit
    frame_dig 10
    itob
    frame_dig 11
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:982
    // this.meta(address.native).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:982-986
    // this.meta(address.native).value = {
    //   ...meta,
    //   followerIndex: (followerIndex + 1),
    //   followerCount: (meta.followerCount + 1),
    // }
    frame_dig 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:988-996
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:991
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:993
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:57
    // follows: 31_700,
    intc 12 // 31700
    itxn_field Amount
    itxn_field Receiver
    frame_dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:988-995
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:988-996
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unfollow(walletID: uint64, rekeyBack: uint64, address: bytes, index: uint64) -> void:
unfollow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:999
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1003
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1004
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1006
    // const followsKey = { user: address.native, index }
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1007
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    frame_dig -2
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1007
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    box_get
    assert // Box must have value
    dig 2
    ==
    assert // Wrong follower key
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // const meta = this.meta(address.native).value
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    dig 2
    intc_2 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    intc_3 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 7
    pushint 49 // 49
    extract_uint64
    uncover 8
    pushint 57 // 57
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1012
    // followerCount: (meta.followerCount - 1)
    uncover 3
    intc_1 // 1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // const meta = this.meta(address.native).value
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1012
    // followerCount: (meta.followerCount - 1)
    uncover 5
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // const meta = this.meta(address.native).value
    bytec_0 // 0x00
    intc_0 // 0
    uncover 10
    setbit
    uncover 8
    itob
    uncover 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1010
    // this.meta(address.native).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1010-1013
    // this.meta(address.native).value = {
    //   ...meta,
    //   followerCount: (meta.followerCount - 1)
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1015
    // this.follows(followsKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1017-1023
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:57
    // follows: 31_700,
    intc 12 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1017-1022
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1017-1023
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1025
    // if (rekeyBack) {
    frame_dig -3
    bz unfollow_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1026
    // this.rekeyBack(wallet)
    frame_dig -4
    callsub rekeyBack

unfollow_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.block(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
block:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1035
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1036
    // assert(!this.isBanned(origin), ERR_BANNED)
    dig 1
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1038
    // const blocksKey = this.blk(origin, address.native)
    swap
    frame_dig -1
    callsub blk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1039
    // this.blocks(blocksKey).create()
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 17 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1039
    // this.blocks(blocksKey).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1041-1049
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1046
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -2
    frame_dig -3
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:58
    // blocks: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1041-1048
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1041-1049
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unblock(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
unblock:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1052
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1055
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1056
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1058
    // const blocksKey = this.blk(origin, address.native)
    dup
    frame_dig -1
    callsub blk
    dig 1
    len
    intc_2 // 16
    ==
    assert // invalid size
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1059
    // this.blocks(blocksKey).delete()
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 17 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1059
    // this.blocks(blocksKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1061-1067
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:58
    // blocks: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1061-1066
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1061-1067
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1069
    // if (rekeyBack) {
    frame_dig -2
    bz unblock_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1070
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

unblock_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addModerator(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
addModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1074
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1077
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1078
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 14 // "d"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1079
    // assert(!this.moderators(address.native).exists, ERR_ALREADY_A_MODERATOR)
    dup
    box_len
    bury 1
    !
    assert // Already a moderator
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1081
    // this.moderators(address.native).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1083-1091
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1086
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1088
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -2
    frame_dig -3
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:65
    // moderators: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1083-1090
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1083-1091
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeModerator(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
removeModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1094
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1097
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1098
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 14 // "d"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1099
    // assert(this.moderators(address.native).exists, ERR_NOT_A_MODERATOR)
    dup
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1101
    // this.moderators(address.native).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1109
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:65
    // moderators: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1108
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1109
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1111
    // if (rekeyBack) {
    frame_dig -2
    bz removeModerator_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1112
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

removeModerator_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.ban(walletID: uint64, rekeyBack: uint64, address: bytes, expiration: uint64) -> void:
ban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1116
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1119
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 14 // "d"
    uncover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1120
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 16 // "n"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1121
    // assert(!this.banned(address.native).exists, ERR_ALREADY_BANNED)
    dup
    box_len
    bury 1
    !
    assert // This account is already banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1122
    // this.banned(address.native).value = expiration
    frame_dig -1
    itob
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1124-1132
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1129
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:66
    // banned: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1124-1131
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1124-1132
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.flagPost(walletID: uint64, rekeyBack: uint64, ref: bytes) -> void:
flagPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1135
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1138
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 14 // "d"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1139
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1140
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1141
    // const post = this.posts(ref).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    intc_3 // 32
    extract_uint64
    dig 2
    pushint 40 // 40
    extract_uint64
    dig 3
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 4
    intc 4 // 385
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 5
    pushint 49 // 49
    extract_uint16
    dig 6
    len
    uncover 7
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1142
    // assert(!post.againstContentPolicy, ERR_ALREADY_FLAGGED)
    uncover 2
    !
    assert // Already flagged
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144-1147
    // this.posts(ref).value = {
    //   ...post,
    //   againstContentPolicy: true
    // }
    dig 5
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1141
    // const post = this.posts(ref).value
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144
    // this.posts(ref).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1146
    // againstContentPolicy: true
    bytec 13 // 0x80
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144
    // this.posts(ref).value = {
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144-1147
    // this.posts(ref).value = {
    //   ...post,
    //   againstContentPolicy: true
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1149
    // if (rekeyBack) {
    frame_dig -2
    bz flagPost_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1150
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

flagPost_after_if_else@2:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unban(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
unban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1154
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1157
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 14 // "d"
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1158
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 16 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1159
    // this.banned(address.native).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1161-1167
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:66
    // banned: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1161-1166
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1161-1167
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1169
    // if (rekeyBack) {
    frame_dig -2
    bz unban_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1170
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

unban_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addAction(walletID: uint64, rekeyBack: uint64, actionAppID: uint64, content: bytes) -> void:
addAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1174
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    proto 4 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1177
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1178
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -4
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1179
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/constants.ts:13
    // export const AkitaSocialBoxPrefixActions = 'a'
    bytec 15 // "a"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1179
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    !
    assert // Already an action
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1181
    // this.actions(actionAppID).value = { content }
    frame_dig -1
    len
    pushint 36 // 36
    ==
    assert // invalid size
    frame_dig -1
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1183-1191
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1186
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1188
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:67
    // actions: 29_700
    intc 13 // 29700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1183-1190
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1183-1191
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeAction(walletID: uint64, rekeyBack: uint64, actionAppID: uint64) -> void:
removeAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1194
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    proto 3 0
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1197
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1198
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/constants.ts:13
    // export const AkitaSocialBoxPrefixActions = 'a'
    bytec 15 // "a"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    assert // Already an action
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1201
    // this.actions(actionAppID).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1203-1209
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:67
    // actions: 29_700
    intc 13 // 29700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1203-1208
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1203-1209
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1211
    // if (rekeyBack) {
    frame_dig -2
    bz removeAction_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1212
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

removeAction_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.initMeta(walletID: uint64, rekeyBack: uint64, automated: uint64, subscriptionIndex: uint64, NFD: uint64, akitaNFT: uint64) -> uint64:
initMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1216-1223
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    proto 6 1
    pushbytes ""
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -6
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    swap
    concat
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1228
    // assert(!this.meta(origin).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1231
    // if (automated) {
    frame_dig -4
    bz initMeta_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1235
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1236
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1233
    // walletID: walletID,
    frame_dig -6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1234
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1235
    // startDate: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1236
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1237
    // followerIndex: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1232
    // this.meta(origin).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1239
    // automated: true,
    bytec 13 // 0x80
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1232
    // this.meta(origin).value = {
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1232-1242
    // this.meta(origin).value = {
    //   walletID: walletID,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    uncover 3
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1244-1252
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1244-1252
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    bytec 22 // method "cacheMeta(uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1244-1252
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    itxn_submit
    itxn LastLog
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1254
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

initMeta_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1260
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1261
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1258
    // walletID: walletID,
    frame_dig -6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1259
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1260
    // startDate: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1261
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1262
    // followerIndex: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1257
    // this.meta(origin).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1264
    // automated: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1257
    // this.meta(origin).value = {
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1257-1267
    // this.meta(origin).value = {
    //   walletID: walletID,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1269-1277
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1274
    // args: [subscriptionIndex, NFD, akitaNFT],
    frame_dig -3
    itob
    frame_dig -2
    itob
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1269-1277
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    bytec 22 // method "cacheMeta(uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1269-1277
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1279
    // if (rekeyBack) {
    frame_dig -5
    bz initMeta_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1280
    // this.rekeyBack(wallet)
    frame_dig -6
    callsub rekeyBack

initMeta_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1283
    // return impact + this.getSocialImpactScore(origin)
    frame_dig 1
    callsub getSocialImpactScore
    frame_dig 0
    +
    frame_bury 0
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserSocialImpact(user: bytes) -> uint64:
getUserSocialImpact:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1288-1289
    // @abimethod({ readonly: true })
    // getUserSocialImpact(user: Address): uint64 {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1290
    // return this.getSocialImpactScore(user.native)
    frame_dig -1
    callsub getSocialImpactScore
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isFollower(user: bytes, index: uint64, follower: bytes) -> uint64:
isFollower:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1293-1294
    // @abimethod({ readonly: true })
    // isFollower(user: Address, index: uint64, follower: Address): boolean {
    proto 3 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1295
    // return this.follows({ user: user.native, index }).value === follower.native
    frame_dig -2
    itob
    frame_dig -3
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1295
    // return this.follows({ user: user.native, index }).value === follower.native
    box_get
    assert // Box must have value
    frame_dig -1
    ==
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getMeta(user: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64:
getMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1298-1299
    // @abimethod({ readonly: true })
    // getMeta(user: Address): MetaValue {
    proto 1 9
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1300
    // return this.meta(user.native).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    dig 2
    intc_2 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    intc_3 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 7
    pushint 49 // 49
    extract_uint64
    uncover 8
    pushint 57 // 57
    extract_uint64
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:78-79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:80
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:80
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 21 // "version"
    // smart_contracts/utils/base-contracts/base.ts:81
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:87
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:87
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_1 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:88
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:92
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:92
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    bytec 9 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:93
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
