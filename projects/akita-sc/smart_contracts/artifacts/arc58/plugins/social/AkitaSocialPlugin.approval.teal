#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 6
    bytecblock "akita_dao" "akita_al" "spending_address" 0x151f7c75 "akita_assets" "social_fees" 0x14 0x1e 0x14641fbd 0x43922655 0x0008 0x81b7159e 0xbb32bb70 0xa2efa6fe "version" 0x1e4a6763 0x603f9fc2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:14
    // export class AkitaSocialPlugin extends classes(BaseSocial, AkitaBaseContract) {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:14
    // export class AkitaSocialPlugin extends classes(BaseSocial, AkitaBaseContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@47
    pushbytess 0xc13990ec 0xcef15f6b 0x73352088 0x61f61878 0xa3682229 0x728ccfad 0x3f3fdb89 0x65b69865 0x27804774 0x0ad14ac9 0x21288fbc 0x5db7232d 0x192a62af 0x28e9d866 0xec5bceb1 0x9d1e8cbf 0x753e4a67 0x5801c36b 0x1fb18bb9 0x796785bb 0x3f2752de 0x7fd4cab7 0x3fd85f4d 0xb46549fa 0x92b8899d 0xbec86c34 0x9f59a970 0xaa765601 0x9091dca5 0x493e908f 0x0d8b6771 0x1b2d08e2 0x68e8db78 0x25498229 0x5cf7e0a5 0x47d682fc 0x2e49f1df 0x854dede0 0x33e92c94 // method "post(uint64,bool,byte[36],uint64)void", method "editPost(uint64,bool,byte[36],uint64,byte[32])void", method "gatedReplyPost(uint64,bool,byte[36],byte[32],uint64,byte[][])void", method "replyPost(uint64,bool,byte[36],byte[32],uint64)void", method "replyAsset(uint64,bool,byte[36],uint64,uint64)void", method "gatedReplyAddress(uint64,bool,byte[36],address,uint64,byte[][])void", method "replyAddress(uint64,bool,byte[36],address,uint64)void", method "replyApp(uint64,bool,byte[36],uint64,uint64)void", method "gatedEditReply(uint64,bool,byte[36],uint64,byte[32],byte[][])void", method "editReply(uint64,bool,byte[36],uint64,byte[32])void", method "votePost(uint64,bool,byte[32],bool)void", method "voteAsset(uint64,bool,uint64,bool)void", method "voteAddress(uint64,bool,address,bool)void", method "voteApp(uint64,bool,uint64,bool)void", method "editVote(uint64,bool,byte[32],bool)void", method "gatedReactPost(uint64,bool,byte[32],uint64,byte[][])void", method "reactPost(uint64,bool,byte[32],uint64)void", method "reactAsset(uint64,bool,uint64,uint64)void", method "gatedReactAddress(uint64,bool,address,uint64,byte[][])void", method "reactAddress(uint64,bool,address,uint64)void", method "reactApp(uint64,bool,uint64,uint64)void", method "deleteReaction(uint64,bool,byte[32],uint64)void", method "gatedFollow(uint64,bool,address,byte[][])void", method "follow(uint64,bool,address)void", method "unfollow(uint64,bool,address,uint64)void", method "block(uint64,bool,address)void", method "unblock(uint64,bool,address)void", method "addModerator(uint64,bool,address)void", method "removeModerator(uint64,bool,address)void", method "ban(uint64,bool,address,uint64)void", method "flagPost(uint64,bool,byte[32])void", method "unflagPost(uint64,bool,byte[32])void", method "unban(uint64,bool,address)void", method "addAction(uint64,bool,uint64,byte[36])void", method "removeAction(uint64,bool,uint64)void", method "initMeta(uint64,bool,bool,uint64,uint64,uint64)uint64", method "updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64)void", method "opUp()void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match post editPost gatedReplyPost replyPost replyAsset gatedReplyAddress replyAddress replyApp gatedEditReply editReply votePost voteAsset voteAddress voteApp editVote gatedReactPost reactPost reactAsset gatedReactAddress reactAddress reactApp deleteReaction gatedFollow follow unfollow block unblock addModerator removeModerator ban flagPost unflagPost unban addAction removeAction initMeta updateMeta main_opUp_route@44 updateAkitaDAO
    err

main_opUp_route@44:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1926
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@47:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:14
    // export class AkitaSocialPlugin extends classes(BaseSocial, AkitaBaseContract) {
    pushbytes 0x88c940f8 // method "create(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/utils/functions.ts::getAccounts(wallet: uint64) -> bytes:
getAccounts:
    // smart_contracts/utils/functions.ts:222
    // export function getAccounts(wallet: Application): Arc58Accounts {
    proto 1 1
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:145
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:151-154
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:153
    // Bytes(AbstractAccountGlobalStateKeysReferrer)
    pushbytes "referrer"
    // smart_contracts/utils/functions.ts:151-154
    // const [referrerBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysReferrer)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:227
    // walletAddress: wallet.address,
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/functions.ts:226-231
    // return {
    //   walletAddress: wallet.address,
    //   origin,
    //   sender,
    //   referrer
    // }
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:289
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:290
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:291
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:294
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.create[routing]() -> void:
create:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:18
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/base-contracts/base.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 14 // "version"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:20
    // this.version.value = version
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:21
    // this.akitaDAO.value = Application(akitaDAO)
    swap
    app_global_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:18
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.post[routing]() -> void:
post:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:30
    // const akitaSocial = Application(getAkitaAppList(this.akitaDAO.value).social)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:30
    // const akitaSocial = Application(getAkitaAppList(this.akitaDAO.value).social)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:30
    // const akitaSocial = Application(getAkitaAppList(this.akitaDAO.value).social)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:31
    // const { posts, votes, votelist } = this.mbr(cid)
    dig 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:32
    // const mbrAmount: uint64 = posts + votes + votelist + AmendmentMBR
    cover 2
    +
    +
    pushint 13200 // 13200
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:35
    // receiver: akitaSocial.address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:39
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:39
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:39
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:40
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:43
    // assetReceiver: akitaSocial.address,
    dig 4
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:48-61
    // abiCall(
    //   AkitaSocial.prototype.post,
    //   {
    //     sender,
    //     appId: akitaSocial,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    uncover 4
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 5
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:33-37
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: akitaSocial.address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:55
    // tip,
    itxn_next
    itxn_field AssetReceiver
    itxn_field AssetAmount
    itxn_field XferAsset
    dig 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:41-46
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: akitaSocial.address,
    //   xferAsset: akta,
    //   assetAmount: postFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:48-61
    // abiCall(
    //   AkitaSocial.prototype.post,
    //   {
    //     sender,
    //     appId: akitaSocial,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:59
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:48-61
    // abiCall(
    //   AkitaSocial.prototype.post,
    //   {
    //     sender,
    //     appId: akitaSocial,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x7f9a73c6 // method "post(pay,axfer,byte[36],uint64)void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:26
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editPost[routing]() -> void:
editPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:64-70
    // editPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:74
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:74
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:74
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:75
    // const { posts, votes, votelist } = this.mbr(cid)
    dig 4
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:76
    // const mbrAmount: uint64 = posts + votes + votelist + AmendmentMBR
    cover 2
    +
    +
    pushint 13200 // 13200
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:79
    // receiver: Application(social).address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:83
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:83
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:83
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:84
    // const { postFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:87
    // assetReceiver: Application(social).address,
    dig 4
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:92-106
    // abiCall(
    //   AkitaSocial.prototype.editPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    uncover 4
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 5
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:77-81
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:99
    // tip,
    itxn_next
    itxn_field AssetReceiver
    itxn_field AssetAmount
    itxn_field XferAsset
    dig 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:85-90
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: postFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:92-106
    // abiCall(
    //   AkitaSocial.prototype.editPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:104
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 5
    uncover 6
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:92-106
    // abiCall(
    //   AkitaSocial.prototype.editPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x92bc9f09 // method "editPost(pay,axfer,byte[36],uint64,byte[32])void"
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:64-70
    // editPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedReplyPost[routing]() -> void:
gatedReplyPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:109-116
    // gatedReplyPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   args: GateArgs
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:118
    // const { origin, sender } = getAccounts(wallet)
    uncover 2
    callsub getAccounts
    dup
    extract 32 32
    cover 3
    extract 64 32
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:120
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:120
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:120
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    dup
    cover 2
    cover 5
    pushint 40 // 40
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:121
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:122
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:124-131
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:133
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    dup
    cover 2
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:134
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:135
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:135
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:137
    // switch (tipInfo.type) {
    extract 0 1
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:138
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:138-141
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz gatedReplyPost_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:139
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 1
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 4
    +
    bury 4

gatedReplyPost_block@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:150
    // receiver: Application(social).address,
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:154
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:154
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:154
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:155
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:158
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:169
    // info.post.gateID,
    dig 7
    extract 40 8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:174-189
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 9
    itxn_field Amount
    uncover 4
    itxn_field Receiver
    dig 11
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:148-152
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:181
    // tip,
    itxn_next
    uncover 3
    itxn_field AssetAmount
    uncover 3
    itxn_field XferAsset
    uncover 2
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:156-161
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:182
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:167
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:163-172
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     info.post.gateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:174-189
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:187
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 14
    dig 16
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:174-189
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xb480e3a6 // method "gatedReplyPost(pay,axfer,appl,byte[36],byte[32],uint64)void"
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    dig 13
    itxn_field ApplicationArgs
    dig 12
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:109-116
    // gatedReplyPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64,
    //   args: GateArgs
    // ): void {
    intc_1 // 1
    return

gatedReplyPost_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:142
    // case TipSendTypeARC58: {
    dup
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:142-145
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz gatedReplyPost_block@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:143
    // mbrAmount += tipInfo.arc58
    dig 1
    pushint 26 // 26
    extract_uint64
    dig 4
    +
    bury 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:144
    // break
    b gatedReplyPost_block@11


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyPost[routing]() -> void:
replyPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:192-198
    // replyPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:202
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:202
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:202
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:203
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:204
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:206-213
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:215
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:216
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:217
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:217
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:219
    // switch (tipInfo.type) {
    extract 0 1
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:220
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:220-223
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz replyPost_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:221
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 1
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 3
    +
    bury 3

replyPost_block@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:232
    // receiver: Application(social).address,
    dig 3
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:236
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:236
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:236
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:237
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:240
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-259
    // abiCall(
    //   AkitaSocial.prototype.replyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 7
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 8
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:230-234
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:252
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:238-243
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-259
    // abiCall(
    //   AkitaSocial.prototype.replyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:257
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 10
    dig 12
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:245-259
    // abiCall(
    //   AkitaSocial.prototype.replyPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x21e03db3 // method "replyPost(pay,axfer,byte[36],byte[32],uint64)void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:192-198
    // replyPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: bytes<32>,
    //   gateID: uint64
    // ): void {
    intc_1 // 1
    return

replyPost_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:224
    // case TipSendTypeARC58: {
    dup
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:224-227
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz replyPost_block@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:225
    // mbrAmount += tipInfo.arc58
    dig 1
    pushint 26 // 26
    extract_uint64
    dig 3
    +
    bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:226
    // break
    b replyPost_block@11


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAsset[routing]() -> void:
replyAsset:
    intc_0 // 0
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:262-268
    // replyAsset(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    cover 3
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:272
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:272
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:272
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:273
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 2
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dup
    cover 2
    cover 5
    dup
    pushint 24 // 24
    extract_uint64
    swap
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:274
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:276-283
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:281
    // args: [itob(ref)]
    uncover 2
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:276-283
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:285
    // if (!postExists) {
    bnz replyAsset_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:286
    // mbrAmount += posts
    dup
    dig 2
    +
    bury 1

replyAsset_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:289
    // const creator = Asset(ref).creator
    dig 5
    asset_params_get AssetCreator
    assert // asset exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:290-297
    // const creatorWallet = abiCall(
    //   AkitaSocial.prototype.getMetaWallet,
    //   {
    //     sender,
    //     appId: social,
    //     args: [new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    bytec 12 // method "getMetaWallet(address)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    dig 4
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:299
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:299
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:300
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:301
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:301-304
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz replyAsset_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:302
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 10
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 1
    +
    bury 1

replyAsset_block@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:313
    // receiver: Application(social).address,
    dig 2
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:317
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:317
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:317
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:318
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:321
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:326-340
    // abiCall(
    //   AkitaSocial.prototype.replyAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 5
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 7
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:311-315
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:333
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:319-324
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:326-340
    // abiCall(
    //   AkitaSocial.prototype.replyAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:338
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 10
    dig 12
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:326-340
    // abiCall(
    //   AkitaSocial.prototype.replyAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x9e42e006 // method "replyAsset(pay,axfer,byte[36],uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:262-268
    // replyAsset(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: uint64,
    //   gateID: uint64
    // ): void {
    intc_1 // 1
    return

replyAsset_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:305
    // case TipSendTypeARC58: {
    dig 11
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:305-308
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz replyAsset_block@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:306
    // mbrAmount += tipInfo.arc58
    dig 10
    pushint 26 // 26
    extract_uint64
    dig 1
    +
    bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:307
    // break
    b replyAsset_block@14


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedReplyAddress[routing]() -> void:
gatedReplyAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:343-350
    // gatedReplyAddress(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64,
    //   args: GateArgs
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:352
    // const { origin, sender } = getAccounts(wallet)
    uncover 2
    callsub getAccounts
    dup
    extract 32 32
    cover 3
    extract 64 32
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:354
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:354
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:354
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    dup
    cover 2
    cover 5
    pushint 40 // 40
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:355
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:356
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:358-365
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:367
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, info.meta.wallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:367
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, info.meta.wallet)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    extract 6 66
    dup
    cover 3
    intc_1 // 1
    extract_uint64
    swap
    cover 2
    callsub checkTipMbrRequirements
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:368
    // switch (tipInfo.type) {
    extract 0 1
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:369
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:369-372
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz gatedReplyAddress_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:370
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 1
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 4
    +
    bury 4

gatedReplyAddress_block@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:381
    // receiver: Application(social).address,
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:385
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:385
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:385
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:386
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:389
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:400
    // info.meta.addressGateID,
    dig 7
    extract 58 8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:405-420
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 9
    itxn_field Amount
    uncover 4
    itxn_field Receiver
    dig 11
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:379-383
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:412
    // tip,
    itxn_next
    uncover 3
    itxn_field AssetAmount
    uncover 3
    itxn_field XferAsset
    uncover 2
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:387-392
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:413
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:398
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:394-403
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     info.meta.addressGateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:405-420
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:418
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 14
    dig 16
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:405-420
    // abiCall(
    //   AkitaSocial.prototype.gatedReplyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xcb5cdec7 // method "gatedReplyAddress(pay,axfer,appl,byte[36],address,uint64)void"
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    dig 13
    itxn_field ApplicationArgs
    dig 12
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:343-350
    // gatedReplyAddress(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: Address,
    //   gateID: uint64,
    //   args: GateArgs
    // ): void {
    intc_1 // 1
    return

gatedReplyAddress_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:373
    // case TipSendTypeARC58: {
    dup
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:373-376
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz gatedReplyAddress_block@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:374
    // mbrAmount += tipInfo.arc58
    dig 1
    pushint 26 // 26
    extract_uint64
    dig 4
    +
    bury 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:375
    // break
    b gatedReplyAddress_block@11


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAddress[routing]() -> void:
replyAddress:
    intc_0 // 0
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:423
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    dup
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 5
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:428
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 4
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:429
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:431-438
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:436
    // args: [ref.native.bytes]
    swap
    itob
    extract 6 2
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:431-438
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:440
    // let creatorWallet: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:441
    // if (!postExists) {
    bnz replyAddress_else_body@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:442
    // mbrAmount += this.mbr(Bytes('')).posts
    pushbytes ""
    callsub mbr
    pushint 16 // 16
    extract_uint64
    dig 2
    +
    bury 2

replyAddress_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:455
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:455
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    dig 2
    callsub checkTipMbrRequirements
    dup
    bury 11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:456
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:457
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:457-460
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz replyAddress_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:458
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 9
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 2
    +
    bury 2

replyAddress_block@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:469
    // receiver: Application(social).address,
    dig 2
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:473
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:473
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:473
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:474
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:477
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482-496
    // abiCall(
    //   AkitaSocial.prototype.replyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 6
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 7
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:467-471
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:489
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:475-480
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482-496
    // abiCall(
    //   AkitaSocial.prototype.replyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:494
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 9
    dig 11
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482-496
    // abiCall(
    //   AkitaSocial.prototype.replyAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0bd6dbf6 // method "replyAddress(pay,axfer,byte[36],address,uint64)void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:423
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64): void {
    intc_1 // 1
    return

replyAddress_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:461
    // case TipSendTypeARC58: {
    dig 10
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:461-464
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz replyAddress_block@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:462
    // mbrAmount += tipInfo.arc58
    dig 9
    pushint 26 // 26
    extract_uint64
    dig 2
    +
    bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:463
    // break
    b replyAddress_block@15

replyAddress_else_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:444-451
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationID
    dig 3
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:452
    // creatorWallet = info.meta.wallet
    extract 6 66
    intc_1 // 1
    extract_uint64
    bury 1
    b replyAddress_after_if_else@6


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyApp[routing]() -> void:
replyApp:
    intc_0 // 0
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:499
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    cover 3
    txna ApplicationArgs 5
    dup
    cover 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:503
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:503
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:503
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:504
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 2
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dup
    cover 2
    cover 5
    dup
    pushint 24 // 24
    extract_uint64
    swap
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:505
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:507-514
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:512
    // args: [itob(ref)]
    uncover 2
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:507-514
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:516
    // if (!postExists) {
    bnz replyApp_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:517
    // mbrAmount += posts
    dup
    dig 2
    +
    bury 1

replyApp_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:520
    // let creator = Application(ref).creator
    dig 5
    app_params_get AppCreator
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:521-528
    // const creatorWallet = abiCall(
    //   AkitaSocial.prototype.getMetaWallet,
    //   {
    //     sender,
    //     appId: social,
    //     args: [new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    bytec 12 // method "getMetaWallet(address)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    dig 4
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:530
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:530
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:531
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:532
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:532-535
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz replyApp_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:533
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 10
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 1
    +
    bury 1

replyApp_block@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:544
    // receiver: Application(social).address,
    dig 2
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:548
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:548
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:548
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:549
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:552
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:557-571
    // abiCall(
    //   AkitaSocial.prototype.replyApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 5
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 7
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:542-546
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:564
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:550-555
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:557-571
    // abiCall(
    //   AkitaSocial.prototype.replyApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:569
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 10
    dig 12
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:557-571
    // abiCall(
    //   AkitaSocial.prototype.replyApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       ref,
    //       gateID
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xbffa2948 // method "replyApp(pay,axfer,byte[36],uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:499
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    intc_1 // 1
    return

replyApp_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:536
    // case TipSendTypeARC58: {
    dig 11
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:536-539
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz replyApp_block@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:537
    // mbrAmount += tipInfo.arc58
    dig 10
    pushint 26 // 26
    extract_uint64
    dig 1
    +
    bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:538
    // break
    b replyApp_block@14


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedEditReply[routing]() -> void:
gatedEditReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:574-581
    // gatedEditReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>,
    //   args: GateArgs
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:583
    // const { origin, sender } = getAccounts(wallet)
    uncover 2
    callsub getAccounts
    dup
    extract 32 32
    cover 3
    extract 64 32
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:585
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:585
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:585
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    dup
    cover 2
    cover 5
    pushint 40 // 40
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:586
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:587
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:589-596
    // const postBeingAmended = abiCall(
    //   AkitaSocial.prototype.getPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [amendment]
    //   }
    // ).returnValue
    itxn_begin
    bytec 15 // method "getPost(byte[32])(address,uint64,uint64,bool,bool,byte[])"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    dig 1
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:598
    // const originalPostRef = postBeingAmended.ref.slice(0, 32).toFixed({ length: 32 })
    dup
    pushint 49 // 49
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 32 // 32
    dig 2
    >=
    pushint 32 // 32
    uncover 3
    uncover 2
    select
    substring3
    dup
    len
    pushint 32 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:600-607
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [originalPostRef]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:609
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    dup
    cover 2
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:610
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:612
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:612
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:613
    // switch (tipInfo.type) {
    extract 0 1
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:614
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:614-617
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz gatedEditReply_after_if_else@7
    // smart_contracts/arc58/plugins/social/contract.algo.ts:615
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 1
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 4
    +
    bury 4

gatedEditReply_block@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:626
    // receiver: Application(social).address,
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:630
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:630
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:630
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:631
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:634
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:645
    // info.post.gateID,
    dig 7
    extract 40 8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:650-665
    // abiCall(
    //   AkitaSocial.prototype.gatedEditReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 9
    itxn_field Amount
    uncover 4
    itxn_field Receiver
    dig 11
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:624-628
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:657
    // tip,
    itxn_next
    uncover 3
    itxn_field AssetAmount
    uncover 3
    itxn_field XferAsset
    uncover 2
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:632-637
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:658
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:643
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:639-648
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     info.post.gateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:650-665
    // abiCall(
    //   AkitaSocial.prototype.gatedEditReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:663
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 14
    dig 16
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:650-665
    // abiCall(
    //   AkitaSocial.prototype.gatedEditReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xbf3c2955 // method "gatedEditReply(pay,axfer,appl,byte[36],uint64,byte[32])void"
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    dig 13
    itxn_field ApplicationArgs
    dig 12
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:574-581
    // gatedEditReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>,
    //   args: GateArgs
    // ): void {
    intc_1 // 1
    return

gatedEditReply_after_if_else@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:618
    // case TipSendTypeARC58: {
    dup
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:618-621
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz gatedEditReply_block@12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:619
    // mbrAmount += tipInfo.arc58
    dig 1
    pushint 26 // 26
    extract_uint64
    dig 4
    +
    bury 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:620
    // break
    b gatedEditReply_block@12


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editReply[routing]() -> void:
editReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:668-674
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    cover 3
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:678
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:678
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:678
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:679
    // const { posts, votes, votelist } = this.mbr(cid)
    uncover 3
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    dig 1
    pushint 24 // 24
    extract_uint64
    uncover 2
    pushint 32 // 32
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:680
    // let mbrAmount: uint64 = posts + votes + votelist
    cover 2
    +
    +
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:682-689
    // const postBeingAmended = abiCall(
    //   AkitaSocial.prototype.getPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [amendment]
    //   }
    // ).returnValue
    itxn_begin
    bytec 15 // method "getPost(byte[32])(address,uint64,uint64,bool,bool,byte[])"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    dig 1
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:691
    // const originalPostRef = postBeingAmended.ref.slice(0, 32).toFixed({ length: 32 })
    dup
    pushint 49 // 49
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 32 // 32
    dig 2
    >=
    pushint 32 // 32
    uncover 3
    uncover 2
    select
    substring3
    dup
    len
    pushint 32 // 32
    ==
    assert // Length must be 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:693-700
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [originalPostRef]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:702
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:703
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:705
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:705
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:706
    // switch (tipInfo.type) {
    extract 0 1
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:707
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:707-710
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz editReply_after_if_else@7
    // smart_contracts/arc58/plugins/social/contract.algo.ts:708
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 1
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 3
    +
    bury 3

editReply_block@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:719
    // receiver: Application(social).address,
    dig 3
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:723
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:723
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:723
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:724
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:727
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:732-746
    // abiCall(
    //   AkitaSocial.prototype.editReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 7
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 8
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:717-721
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:739
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:725-730
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:732-746
    // abiCall(
    //   AkitaSocial.prototype.editReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:744
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 10
    dig 12
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:732-746
    // abiCall(
    //   AkitaSocial.prototype.editReply,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       cid,
    //       gateID,
    //       amendment
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x13ca77b5 // method "editReply(pay,axfer,byte[36],uint64,byte[32])void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:668-674
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   amendment: bytes<32>
    // ): void {
    intc_1 // 1
    return

editReply_after_if_else@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:711
    // case TipSendTypeARC58: {
    dup
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:711-714
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz editReply_block@12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:712
    // mbrAmount += tipInfo.arc58
    dig 1
    pushint 26 // 26
    extract_uint64
    dig 3
    +
    bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:713
    // break
    b editReply_block@12


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.votePost[routing]() -> void:
votePost:
    intc_0 // 0
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749
    // votePost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:753
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:753
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:753
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:754
    // let mbrAmount: uint64 = this.mbr(Bytes('')).votelist
    pushbytes ""
    callsub mbr
    pushint 32 // 32
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:756
    // if (isUp) {
    bz votePost_after_if_else@13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:757-764
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    dig 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:766
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:767
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:768
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:768
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:770
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:771
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:771-774
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz votePost_after_if_else@7
    // smart_contracts/arc58/plugins/social/contract.algo.ts:772
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 7
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 1
    +
    bury 1

votePost_after_if_else@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:784
    // receiver: Application(social).address,
    dig 1
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:789
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:792
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:797-810
    // abiCall(
    //   AkitaSocial.prototype.votePost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 5
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 6
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:782-786
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:804
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:790-795
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:797-810
    // abiCall(
    //   AkitaSocial.prototype.votePost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:808
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 7
    dig 9
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:797-810
    // abiCall(
    //   AkitaSocial.prototype.votePost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x890dbb5b // method "votePost(pay,axfer,byte[32],bool)void"
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749
    // votePost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, isUp: boolean): void {
    intc_1 // 1
    return

votePost_after_if_else@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:775
    // case TipSendTypeARC58: {
    dig 8
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:775-778
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz votePost_after_if_else@13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:776
    // mbrAmount += tipInfo.arc58
    dig 7
    pushint 26 // 26
    extract_uint64
    dig 1
    +
    bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:777
    // break
    b votePost_after_if_else@13


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAsset[routing]() -> void:
voteAsset:
    intc_0 // 0
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:813
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:818
    // let mbrAmount: uint64 = this.mbr(Bytes('')).votelist
    pushbytes ""
    callsub mbr
    pushint 32 // 32
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:820
    // if (isUp) {
    bz voteAsset_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:821-828
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:826
    // args: [itob(ref)]
    dig 4
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:821-828
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    dig 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:830
    // if (!postExists) {
    bnz voteAsset_after_if_else@5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:831
    // mbrAmount += this.mbr(Bytes('')).posts
    pushbytes ""
    callsub mbr
    pushint 16 // 16
    extract_uint64
    dig 1
    +
    bury 1

voteAsset_after_if_else@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:834
    // const creator = Asset(ref).creator
    dig 4
    asset_params_get AssetCreator
    assert // asset exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:835-842
    // const creatorWallet = abiCall(
    //   AkitaSocial.prototype.getMetaWallet,
    //   {
    //     sender,
    //     appId: social,
    //     args: [new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    bytec 12 // method "getMetaWallet(address)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationID
    dig 3
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:844
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:844
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:845
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:846
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:846-849
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz voteAsset_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:847
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 8
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 1
    +
    bury 1

voteAsset_after_if_else@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:859
    // receiver: Application(social).address,
    dig 1
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:863
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:863
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:863
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:864
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:867
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:872-885
    // abiCall(
    //   AkitaSocial.prototype.voteAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 5
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 6
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:857-861
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:865-870
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:872-885
    // abiCall(
    //   AkitaSocial.prototype.voteAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:883
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 8
    dig 10
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:872-885
    // abiCall(
    //   AkitaSocial.prototype.voteAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xeeeb21b1 // method "voteAsset(pay,axfer,uint64,bool)void"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:813
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    intc_1 // 1
    return

voteAsset_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:850
    // case TipSendTypeARC58: {
    dig 9
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:850-853
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz voteAsset_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:851
    // mbrAmount += tipInfo.arc58
    dig 8
    pushint 26 // 26
    extract_uint64
    dig 1
    +
    bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:852
    // break
    b voteAsset_after_if_else@16


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAddress[routing]() -> void:
voteAddress:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:888
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    dup
    cover 2
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:892
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:892
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:892
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:893
    // let mbrAmount: uint64 = this.mbr(Bytes('')).votelist
    pushbytes ""
    callsub mbr
    pushint 32 // 32
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:895
    // if (isUp) {
    bz voteAddress_after_if_else@17
    // smart_contracts/arc58/plugins/social/contract.algo.ts:896-903
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:901
    // args: [ref.native.bytes]
    dig 4
    itob
    extract 6 2
    dig 6
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:896-903
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    dig 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:905
    // let creatorWallet: uint64 = 0
    intc_0 // 0
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:906
    // if (!postExists) {
    bnz voteAddress_else_body@5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:907
    // mbrAmount += this.mbr(Bytes('')).posts
    pushbytes ""
    callsub mbr
    pushint 16 // 16
    extract_uint64
    dig 1
    +
    bury 1

voteAddress_after_if_else@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:920
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:920
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    dig 10
    callsub checkTipMbrRequirements
    dup
    bury 11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:921
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:922
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:922-925
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz voteAddress_after_if_else@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:923
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 9
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 1
    +
    bury 1

voteAddress_after_if_else@17:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:935
    // receiver: Application(social).address,
    dig 1
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:940
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:943
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:948-961
    // abiCall(
    //   AkitaSocial.prototype.voteAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 5
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 6
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:933-937
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:955
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:941-946
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:948-961
    // abiCall(
    //   AkitaSocial.prototype.voteAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:959
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 8
    dig 10
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:948-961
    // abiCall(
    //   AkitaSocial.prototype.voteAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x40798af2 // method "voteAddress(pay,axfer,address,bool)void"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:888
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    intc_1 // 1
    return

voteAddress_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926
    // case TipSendTypeARC58: {
    dig 10
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926-929
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz voteAddress_after_if_else@17
    // smart_contracts/arc58/plugins/social/contract.algo.ts:927
    // mbrAmount += tipInfo.arc58
    dig 9
    pushint 26 // 26
    extract_uint64
    dig 1
    +
    bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:928
    // break
    b voteAddress_after_if_else@17

voteAddress_else_body@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:909-916
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes]
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    dig 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:917
    // creatorWallet = info.meta.wallet
    extract 6 66
    intc_1 // 1
    extract_uint64
    bury 9
    b voteAddress_after_if_else@7


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteApp[routing]() -> void:
voteApp:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:964
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:968
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:968
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:968
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:969
    // const { votelist, posts } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 32 // 32
    extract_uint64
    cover 2
    pushint 16 // 16
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:972
    // if (isUp) {
    bnz voteApp_if_body@2
    dig 1
    bury 10

voteApp_after_if_else@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1011
    // receiver: Application(social).address,
    dig 2
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1015
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1015
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1015
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1016
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1019
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1024-1037
    // abiCall(
    //   AkitaSocial.prototype.voteApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 14
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 7
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009-1013
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1031
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1017-1022
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1024-1037
    // abiCall(
    //   AkitaSocial.prototype.voteApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1035
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 9
    dig 11
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1024-1037
    // abiCall(
    //   AkitaSocial.prototype.voteApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       isUp
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x88eff637 // method "voteApp(pay,axfer,uint64,bool)void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:964
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    intc_1 // 1
    return

voteApp_if_body@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:973-980
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:978
    // args: [itob(ref)]
    dig 5
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:973-980
    // const postExists = abiCall(
    //   AkitaSocial.prototype.postExists,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref)]
    //   }
    // ).returnValue
    bytec 11 // method "postExists(byte[])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationID
    dig 3
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:982
    // if (!postExists) {
    bz voteApp_if_body@4
    dig 1
    bury 10

voteApp_after_if_else@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:986
    // const creator = Asset(ref).creator
    dig 5
    asset_params_get AssetCreator
    assert // asset exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:987-994
    // const creatorWallet = abiCall(
    //   AkitaSocial.prototype.getMetaWallet,
    //   {
    //     sender,
    //     appId: social,
    //     args: [new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    bytec 12 // method "getMetaWallet(address)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationID
    dig 4
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:996
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:996
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:997
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:998
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:998-1001
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz voteApp_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:999
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 10
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 10
    +
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1000
    // break
    b voteApp_after_if_else@16

voteApp_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1002
    // case TipSendTypeARC58: {
    dig 11
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1002-1005
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz voteApp_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1003
    // mbrAmount += tipInfo.arc58
    dig 10
    pushint 26 // 26
    extract_uint64
    dig 10
    +
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1004
    // break
    b voteApp_after_if_else@16

voteApp_if_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:983
    // mbrAmount += posts
    dup2
    +
    bury 10
    b voteApp_after_if_else@5


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editVote[routing]() -> void:
editVote:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1040
    // editVote(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, flip: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    dup
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1046-1053
    // const { isUp: wasUp } = abiCall(
    //   AkitaSocial.prototype.getVote,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0xf4ea50e4 // method "getVote(byte[32])(uint64,bool)"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    uncover 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1053
    // ).returnValue
    pushint 64 // 64
    getbit
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1057
    // receiver: Application(social).address,
    dup
    app_params_get AppAddress
    swap
    cover 4
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1058
    // amount: 0,
    intc_0 // 0
    cover 3
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    swap
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1061
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1065
    // assetReceiver: Application(social).address,
    app_params_get AppAddress
    swap
    cover 2
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1067
    // assetAmount: 0,
    intc_0 // 0
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1070
    // if (flip) {
    bz editVote_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1071
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1071
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1071
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1076
    // if (!wasUp) {
    dig 5
    bnz editVote_after_if_else@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1077-1084
    // const info = abiCall(
    //   AkitaSocial.prototype.getPostAndCreatorMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //   }
    // ).returnValue
    itxn_begin
    bytec 8 // method "getPostAndCreatorMeta(byte[32])((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64))"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationID
    dig 7
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1086
    // const creator = info.post.creator
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1087
    // const creatorWallet = info.meta.wallet
    swap
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1088
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1088
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1090
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1091
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1091-1094
    // case TipSendTypeARC59: {
    //   mbrPayment.set({ amount: (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim) })
    //   break
    // }
    bz editVote_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1092
    // mbrPayment.set({ amount: (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim) })
    dig 13
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    bury 4

editVote_after_if_else@15:
    dig 12
    bury 1

editVote_after_if_else@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1116
    // abiCall(
    //   AkitaSocial.prototype.editVote,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       flip
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   }
    // )
    itxn_begin
    dig 3
    itxn_field Amount
    dig 4
    itxn_field Receiver
    dig 7
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1055-1059
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: 0,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1110
    // tip,
    itxn_next
    dig 1
    itxn_field AssetAmount
    dig 3
    itxn_field XferAsset
    dig 2
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1063-1068
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: 0,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1116
    // abiCall(
    //   AkitaSocial.prototype.editVote,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       flip
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1114
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103-1116
    // abiCall(
    //   AkitaSocial.prototype.editVote,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       flip
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   }
    // )
    pushbytes 0x84fa4b5e // method "editVote(pay,axfer,byte[32],bool)void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    dig 7
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1040
    // editVote(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, flip: boolean): void {
    intc_1 // 1
    return

editVote_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1095
    // case TipSendTypeARC58: {
    dig 14
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1095-1098
    // case TipSendTypeARC58: {
    //   mbrPayment.set({ amount: tipInfo.arc58 })
    //   break
    // }
    bz editVote_after_if_else@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1096
    // mbrPayment.set({ amount: tipInfo.arc58 })
    dig 13
    pushint 26 // 26
    extract_uint64
    bury 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1097
    // break
    b editVote_after_if_else@15


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedReactPost[routing]() -> void:
gatedReactPost:
    intc_0 // 0
    dupn 2
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1119-1125
    // gatedReactPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   ref: bytes<32>,
    //   NFT: uint64,
    //   args: GateArgs
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127
    // const { origin, sender } = getAccounts(wallet)
    uncover 2
    callsub getAccounts
    dup
    extract 32 32
    cover 3
    extract 64 32
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1129
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1129
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1129
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    dup
    cover 2
    cover 5
    pushint 40 // 40
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1131-1138
    // const { post, meta, reactionExists } = abiCall(
    //   AkitaSocial.prototype.getPostMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref, NFT]
    //   }
    // ).returnValue
    itxn_begin
    bytec 16 // method "getPostMeta(byte[32],uint64)((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64),bool)"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    dup
    uncover 2
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1138
    // ).returnValue
    pushint 544 // 544
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1140
    // const { reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 40 // 40
    extract_uint64
    cover 2
    pushint 48 // 48
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1142-1144
    // let mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz gatedReactPost_ternary_false@4
    bury 13

gatedReactPost_ternary_merge@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1146
    // const creator = post.creator
    dig 1
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    dup
    bury 16
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1147
    // const creatorWallet = meta.wallet
    dig 3
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1148
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1148
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1150
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 17
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1151
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1151-1154
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz gatedReactPost_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1152
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 13
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 13
    +
    bury 13

gatedReactPost_block@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1163
    // receiver: Application(social).address,
    dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1167
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1167
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1167
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1168
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1171
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1182
    // post.gateID,
    dig 19
    extract 40 8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1187-1201
    // abiCall(
    //   AkitaSocial.prototype.gatedReactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 18
    itxn_field Amount
    uncover 4
    itxn_field Receiver
    dig 10
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1161-1165
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1194
    // tip,
    itxn_next
    uncover 3
    itxn_field AssetAmount
    uncover 3
    itxn_field XferAsset
    uncover 2
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1169-1174
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1195
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1180
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1176-1185
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     post.gateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1187-1201
    // abiCall(
    //   AkitaSocial.prototype.gatedReactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 12
    dig 14
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1187-1201
    // abiCall(
    //   AkitaSocial.prototype.gatedReactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x5b4e6e2c // method "gatedReactPost(pay,axfer,appl,byte[32],uint64)void"
    itxn_field ApplicationArgs
    dig 12
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1119-1125
    // gatedReactPost(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   ref: bytes<32>,
    //   NFT: uint64,
    //   args: GateArgs
    // ): void {
    intc_1 // 1
    return

gatedReactPost_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1155
    // case TipSendTypeARC58: {
    dig 15
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1155-1158
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz gatedReactPost_block@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1156
    // mbrAmount += tipInfo.arc58
    dig 13
    pushint 26 // 26
    extract_uint64
    dig 13
    +
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1157
    // break
    b gatedReactPost_block@14

gatedReactPost_ternary_false@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144
    // : reactions + reactionlist
    dig 1
    +
    bury 13
    b gatedReactPost_ternary_merge@5


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactPost[routing]() -> void:
reactPost:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1204
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1208
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1208
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1208
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1210-1217
    // const { post, meta, reactionExists } = abiCall(
    //   AkitaSocial.prototype.getPostMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref, NFT]
    //   }
    // ).returnValue
    itxn_begin
    bytec 16 // method "getPostMeta(byte[32],uint64)((address,uint64,uint64,bool,bool,byte[]),(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64),bool)"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    dup
    uncover 2
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1217
    // ).returnValue
    pushint 544 // 544
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1219
    // const { reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 40 // 40
    extract_uint64
    cover 2
    pushint 48 // 48
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1221-1223
    // let mbrAmount: uint64 = reactionExists
    //   ? reactionlist
    //   : reactions + reactionlist
    bz reactPost_ternary_false@4
    bury 10

reactPost_ternary_merge@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1225
    // const creator = post.creator
    dig 1
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 0 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1226
    // const creatorWallet = meta.wallet
    dig 3
    extract 6 66
    intc_1 // 1
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    cover 2
    callsub checkTipMbrRequirements
    dup
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1229
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1230
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1230-1233
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz reactPost_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1231
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 10
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 10
    +
    bury 10

reactPost_block@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1242
    // receiver: Application(social).address,
    dig 3
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1246
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1246
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1246
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1247
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1250
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1255-1268
    // abiCall(
    //   AkitaSocial.prototype.reactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 14
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 8
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1240-1244
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1262
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1248-1253
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1255-1268
    // abiCall(
    //   AkitaSocial.prototype.reactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1266
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 9
    dig 11
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1255-1268
    // abiCall(
    //   AkitaSocial.prototype.reactPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x56536f3e // method "reactPost(pay,axfer,byte[32],uint64)void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1204
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    intc_1 // 1
    return

reactPost_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1234
    // case TipSendTypeARC58: {
    dig 11
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1234-1237
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz reactPost_block@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1235
    // mbrAmount += tipInfo.arc58
    dig 10
    pushint 26 // 26
    extract_uint64
    dig 10
    +
    bury 10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1236
    // break
    b reactPost_block@14

reactPost_ternary_false@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1223
    // : reactions + reactionlist
    dig 1
    +
    bury 10
    b reactPost_ternary_merge@5


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAsset[routing]() -> void:
reactAsset:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1271
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1275
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1275
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1275
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1276
    // const { posts, reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    cover 5
    dup
    pushint 40 // 40
    extract_uint64
    cover 5
    pushint 48 // 48
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1279
    // const creator = Asset(ref).creator
    dig 3
    asset_params_get AssetCreator
    swap
    dup
    cover 3
    cover 7
    assert // asset exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1280-1287
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref), NFT, new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1285
    // args: [itob(ref), NFT, new Address(creator)]
    uncover 4
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1280-1287
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref), NFT, new Address(creator)]
    //   }
    // ).returnValue
    bytec 13 // method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1287
    // ).returnValue
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    cover 3
    swap
    pushint 5 // 5
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1289
    // if (!postExists) {
    bz reactAsset_if_body@3
    bury 12

reactAsset_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1293
    // if (!reactionExists) {
    dig 1
    bnz reactAsset_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1294
    // mbrAmount += reactions
    dig 11
    dig 4
    +
    bury 12

reactAsset_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1297
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1297
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    dig 2
    callsub checkTipMbrRequirements
    dup
    bury 14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1299
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1300
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1300-1303
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz reactAsset_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1301
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 12
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 12
    +
    bury 12

reactAsset_block@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1312
    // receiver: Application(social).address,
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1316
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1316
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1316
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1317
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1320
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1325-1338
    // abiCall(
    //   AkitaSocial.prototype.reactAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 16
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 10
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1310-1314
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1332
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1318-1323
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1325-1338
    // abiCall(
    //   AkitaSocial.prototype.reactAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1336
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1325-1338
    // abiCall(
    //   AkitaSocial.prototype.reactAsset,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x125903c0 // method "reactAsset(pay,axfer,uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1271
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    intc_1 // 1
    return

reactAsset_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1304
    // case TipSendTypeARC58: {
    dig 13
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1304-1307
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz reactAsset_block@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1305
    // mbrAmount += tipInfo.arc58
    dig 12
    pushint 26 // 26
    extract_uint64
    dig 12
    +
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1306
    // break
    b reactAsset_block@15

reactAsset_if_body@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1290
    // mbrAmount += posts
    dig 5
    +
    bury 12
    b reactAsset_after_if_else@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedReactAddress[routing]() -> void:
gatedReactAddress:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1341
    // gatedReactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    dup
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1343
    // const { origin, sender } = getAccounts(wallet)
    uncover 3
    callsub getAccounts
    dup
    extract 32 32
    cover 4
    extract 64 32
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1345
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1345
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1345
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    dup
    cover 2
    cover 6
    pushint 40 // 40
    extract_uint64
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1347
    // const { posts, reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    cover 6
    dup
    pushint 40 // 40
    extract_uint64
    cover 6
    pushint 48 // 48
    extract_uint64
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1350-1357
    // const { postExists, reactionExists, creatorWallet, addressGateID } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes, NFT, ref]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1355
    // args: [ref.native.bytes, NFT, ref]
    uncover 3
    itob
    extract 6 2
    dig 4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1350-1357
    // const { postExists, reactionExists, creatorWallet, addressGateID } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes, NFT, ref]
    //   }
    // ).returnValue
    bytec 13 // method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1357
    // ).returnValue
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    cover 3
    dig 1
    pushint 5 // 5
    extract_uint64
    cover 3
    swap
    extract 13 8
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1359
    // if (!postExists) {
    bz gatedReactAddress_if_body@3
    bury 15

gatedReactAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1363
    // if (!reactionExists) {
    dig 2
    bnz gatedReactAddress_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1364
    // mbrAmount += reactions
    dig 14
    dig 4
    +
    bury 15

gatedReactAddress_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1367
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1367
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 12
    dig 3
    callsub checkTipMbrRequirements
    dup
    bury 17
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1369
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 18
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1370
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1370-1373
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz gatedReactAddress_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1371
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 15
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 15
    +
    bury 15

gatedReactAddress_block@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1382
    // receiver: Application(social).address,
    dig 6
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1386
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1386
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1386
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1387
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1390
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1406-1420
    // abiCall(
    //   AkitaSocial.prototype.gatedReactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 19
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 11
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1380-1384
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1413
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1388-1393
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1414
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1399
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationID
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1395-1404
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     addressGateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1406-1420
    // abiCall(
    //   AkitaSocial.prototype.gatedReactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1418
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 14
    dig 16
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1406-1420
    // abiCall(
    //   AkitaSocial.prototype.gatedReactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       gateTxn,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x6c8b5642 // method "gatedReactAddress(pay,axfer,appl,address,uint64)void"
    itxn_field ApplicationArgs
    dig 14
    itxn_field ApplicationArgs
    dig 13
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1341
    // gatedReactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    intc_1 // 1
    return

gatedReactAddress_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1374
    // case TipSendTypeARC58: {
    dig 16
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1374-1377
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz gatedReactAddress_block@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1375
    // mbrAmount += tipInfo.arc58
    dig 15
    pushint 26 // 26
    extract_uint64
    dig 15
    +
    bury 15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1376
    // break
    b gatedReactAddress_block@15

gatedReactAddress_if_body@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1360
    // mbrAmount += posts
    dig 5
    +
    bury 15
    b gatedReactAddress_after_if_else@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAddress[routing]() -> void:
reactAddress:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1423
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    dup
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    cover 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1427
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1429
    // const { posts, reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    cover 6
    dup
    pushint 40 // 40
    extract_uint64
    cover 6
    pushint 48 // 48
    extract_uint64
    cover 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1432-1439
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes, NFT, ref]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1437
    // args: [ref.native.bytes, NFT, ref]
    uncover 3
    itob
    extract 6 2
    dig 4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1432-1439
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref.native.bytes, NFT, ref]
    //   }
    // ).returnValue
    bytec 13 // method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1439
    // ).returnValue
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    cover 3
    swap
    pushint 5 // 5
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1441
    // if (!postExists) {
    bz reactAddress_if_body@3
    bury 11

reactAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1445
    // if (!reactionExists) {
    dig 1
    bnz reactAddress_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1446
    // mbrAmount += reactions
    dig 10
    dig 3
    +
    bury 11

reactAddress_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1449
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1449
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, ref.native, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 8
    dig 2
    callsub checkTipMbrRequirements
    dup
    bury 13
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1451
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1452
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1452-1455
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz reactAddress_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1453
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 11
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 11
    +
    bury 11

reactAddress_block@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1464
    // receiver: Application(social).address,
    dig 4
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1468
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1468
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1468
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1469
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1472
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1477-1490
    // abiCall(
    //   AkitaSocial.prototype.reactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 15
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 9
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1462-1466
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1484
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1470-1475
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1477-1490
    // abiCall(
    //   AkitaSocial.prototype.reactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1488
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 10
    dig 12
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1477-1490
    // abiCall(
    //   AkitaSocial.prototype.reactAddress,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x1b06bdbc // method "reactAddress(pay,axfer,address,uint64)void"
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1423
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64): void {
    intc_1 // 1
    return

reactAddress_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1456
    // case TipSendTypeARC58: {
    dig 12
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1456-1459
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz reactAddress_block@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1457
    // mbrAmount += tipInfo.arc58
    dig 11
    pushint 26 // 26
    extract_uint64
    dig 11
    +
    bury 11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1458
    // break
    b reactAddress_block@15

reactAddress_if_body@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1442
    // mbrAmount += posts
    dig 4
    +
    bury 11
    b reactAddress_after_if_else@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactApp[routing]() -> void:
reactApp:
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1493-1498
    // reactApp(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1502
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1502
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1502
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1503
    // const { posts, reactions, reactionlist } = this.mbr(Bytes(''))
    pushbytes ""
    callsub mbr
    dup
    pushint 16 // 16
    extract_uint64
    cover 5
    dup
    pushint 40 // 40
    extract_uint64
    cover 5
    pushint 48 // 48
    extract_uint64
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1506
    // const creator = Application(ref).creator
    dig 3
    app_params_get AppCreator
    swap
    dup
    cover 3
    cover 7
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1507-1514
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref), NFT, new Address(creator)]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1512
    // args: [itob(ref), NFT, new Address(creator)]
    uncover 4
    itob
    bytec 10 // 0x0008
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1507-1514
    // const { postExists, reactionExists, creatorWallet } = abiCall(
    //   AkitaSocial.prototype.reactionMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [itob(ref), NFT, new Address(creator)]
    //   }
    // ).returnValue
    bytec 13 // method "reactionMeta(byte[],uint64,address)(bool,bool,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1514
    // ).returnValue
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    cover 3
    swap
    pushint 5 // 5
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1516
    // if (!postExists) {
    bz reactApp_if_body@3
    bury 12

reactApp_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1520
    // if (!reactionExists) {
    dig 1
    bnz reactApp_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1521
    // mbrAmount += reactions
    dig 11
    dig 4
    +
    bury 12

reactApp_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1524
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1524
    // const tipInfo = this.checkTipMbrRequirements(this.akitaDAO.value, creator, creatorWallet)
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    dig 2
    callsub checkTipMbrRequirements
    dup
    bury 14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1526
    // switch (tipInfo.type) {
    extract 0 1
    dup
    bury 15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1527
    // case TipSendTypeARC59: {
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1527-1530
    // case TipSendTypeARC59: {
    //   mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    //   break
    // }
    bz reactApp_after_if_else@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1528
    // mbrAmount += (tipInfo.arc59.mbr + tipInfo.arc59.receiverAlgoNeededForClaim)
    dig 12
    extract 1 25
    dup
    intc_2 // 8
    extract_uint64
    swap
    pushint 17 // 17
    extract_uint64
    +
    dig 12
    +
    bury 12

reactApp_block@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1539
    // receiver: Application(social).address,
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1543
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1543
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    dup
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1543
    // const akta = Asset(getAkitaAssets(this.akitaDAO.value).akta)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:53
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    swap
    bytec 5 // "social_fees"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1544
    // const { reactFee } = getSocialFees(this.akitaDAO.value)
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1547
    // assetReceiver: Application(social).address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1552-1565
    // abiCall(
    //   AkitaSocial.prototype.reactApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    dig 16
    itxn_field Amount
    uncover 3
    itxn_field Receiver
    dig 10
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1537-1541
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: mbrAmount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1559
    // tip,
    itxn_next
    uncover 2
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1545-1550
    // const tip = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: Application(social).address,
    //   xferAsset: akta,
    //   assetAmount: reactFee
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1552-1565
    // abiCall(
    //   AkitaSocial.prototype.reactApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1563
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1552-1565
    // abiCall(
    //   AkitaSocial.prototype.reactApp,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       tip,
    //       ref,
    //       NFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x8b559657 // method "reactApp(pay,axfer,uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1493-1498
    // reactApp(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   ref: uint64,
    //   NFT: uint64
    // ): void {
    intc_1 // 1
    return

reactApp_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1531
    // case TipSendTypeARC58: {
    dig 13
    bytec 7 // 0x1e
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1531-1534
    // case TipSendTypeARC58: {
    //   mbrAmount += tipInfo.arc58
    //   break
    // }
    bz reactApp_block@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1532
    // mbrAmount += tipInfo.arc58
    dig 12
    pushint 26 // 26
    extract_uint64
    dig 12
    +
    bury 12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1533
    // break
    b reactApp_block@15

reactApp_if_body@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1517
    // mbrAmount += posts
    dig 5
    +
    bury 12
    b reactApp_after_if_else@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.deleteReaction[routing]() -> void:
deleteReaction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1568
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1572
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1572
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1572
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1574-1582
    // abiCall(
    //   AkitaSocial.prototype.deleteReaction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref, NFT],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1580
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1574-1582
    // abiCall(
    //   AkitaSocial.prototype.deleteReaction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref, NFT],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x6e5b7702 // method "deleteReaction(byte[32],uint64)void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1568
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: bytes<32>, NFT: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.gatedFollow[routing]() -> void:
gatedFollow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1585
    // gatedFollow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1587
    // const { origin, sender } = getAccounts(wallet)
    dig 3
    callsub getAccounts
    dup
    extract 32 32
    swap
    extract 64 32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1589
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1589
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1589
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    swap
    pushint 40 // 40
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1591-1598
    // const { followGateID } = abiCall(
    //   AkitaSocial.prototype.getMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0x6dc226b4 // method "getMeta(address)(bool,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)"
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    dig 2
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1598
    // ).returnValue
    extract 54 8
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1602
    // receiver: Application(social).address,
    uncover 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1603
    // amount: this.mbr(Bytes('')).follows
    pushbytes ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1617-1629
    // abiCall(
    //   AkitaSocial.prototype.gatedFollow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       gateTxn,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1600-1604
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).follows
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1624
    // gateTxn,
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1610
    // methodSelector(GateInterface.prototype.mustCheck),
    bytec 9 // method "mustCheck(address,uint64,byte[][])void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1606-1615
    // const gateTxn = itxn.applicationCall({
    //   sender,
    //   appId: gate,
    //   appArgs: [
    //     methodSelector(GateInterface.prototype.mustCheck),
    //     new Address(origin),
    //     followGateID,
    //     encodeArc4(args)
    //   ]
    // })
    intc_3 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1617-1629
    // abiCall(
    //   AkitaSocial.prototype.gatedFollow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       gateTxn,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1627
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1617-1629
    // abiCall(
    //   AkitaSocial.prototype.gatedFollow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       gateTxn,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x86675494 // method "gatedFollow(pay,appl,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1585
    // gatedFollow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.follow[routing]() -> void:
follow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1632
    // follow(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1636
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1636
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1636
    // const { social, gate } = getAkitaAppList(this.akitaDAO.value)
    dup
    pushint 96 // 96
    extract_uint64
    swap
    pushint 40 // 40
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1640
    // receiver: Application(social).address,
    swap
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1641
    // amount: this.mbr(Bytes('')).follows
    pushbytes ""
    callsub mbr
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1644-1655
    // abiCall(
    //   AkitaSocial.prototype.follow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1638-1642
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).follows
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1644-1655
    // abiCall(
    //   AkitaSocial.prototype.follow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1653
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1644-1655
    // abiCall(
    //   AkitaSocial.prototype.follow,
    //   {
    //     sender,
    //     appId: gate,
    //     args: [
    //       mbrPayment,
    //       address
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x4b6f907f // method "follow(pay,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1632
    // follow(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unfollow[routing]() -> void:
unfollow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1658
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1662
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1662
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1662
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1664-1672
    // abiCall(
    //   AkitaSocial.prototype.unfollow,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address, index],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1670
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1664-1672
    // abiCall(
    //   AkitaSocial.prototype.unfollow,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address, index],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0aea5a8a // method "unfollow(address,uint64)void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1658
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.block[routing]() -> void:
block:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1677
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1681
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1681
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1681
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1685
    // receiver: Application(social).address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1686
    // amount: this.mbr(Bytes('')).blocks
    pushbytes ""
    callsub mbr
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1689-1697
    // abiCall(
    //   AkitaSocial.prototype.block,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1683-1687
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).blocks
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1689-1697
    // abiCall(
    //   AkitaSocial.prototype.block,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1695
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1689-1697
    // abiCall(
    //   AkitaSocial.prototype.block,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xb59c8a54 // method "block(pay,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1677
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unblock[routing]() -> void:
unblock:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1700
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1704
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1704
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1704
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1706-1714
    // abiCall(
    //   AkitaSocial.prototype.unblock,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1712
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1706-1714
    // abiCall(
    //   AkitaSocial.prototype.unblock,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xaeebb378 // method "unblock(address)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1700
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addModerator[routing]() -> void:
addModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1717
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1721
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1721
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1721
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1725
    // receiver: Application(social).address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1726
    // amount: this.mbr(Bytes('')).moderators
    pushbytes ""
    callsub mbr
    pushint 64 // 64
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1729-1737
    // abiCall(
    //   AkitaSocial.prototype.addModerator,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1723-1727
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).moderators
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1729-1737
    // abiCall(
    //   AkitaSocial.prototype.addModerator,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1735
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1729-1737
    // abiCall(
    //   AkitaSocial.prototype.addModerator,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x77662c8e // method "addModerator(pay,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1717
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeModerator[routing]() -> void:
removeModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1741
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1745
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1745
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1745
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1747-1755
    // abiCall(
    //   AkitaSocial.prototype.removeModerator,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1753
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1747-1755
    // abiCall(
    //   AkitaSocial.prototype.removeModerator,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x03e3ab22 // method "removeModerator(address)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1741
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.ban[routing]() -> void:
ban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1758
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1762
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1762
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1762
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1766
    // receiver: Application(social).address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1767
    // amount: this.mbr(Bytes('')).banned
    pushbytes ""
    callsub mbr
    pushint 72 // 72
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1770-1778
    // abiCall(
    //   AkitaSocial.prototype.ban,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address, expiration],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1764-1768
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).banned
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1770-1778
    // abiCall(
    //   AkitaSocial.prototype.ban,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address, expiration],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1776
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1770-1778
    // abiCall(
    //   AkitaSocial.prototype.ban,
    //   {
    //     sender,
    //     appId: social,
    //     args: [mbrPayment, address, expiration],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x8ebc19b5 // method "ban(pay,address,uint64)void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1758
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.flagPost[routing]() -> void:
flagPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1781
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1785
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1785
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1785
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1787-1795
    // abiCall(
    //   AkitaSocial.prototype.flagPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1793
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1787-1795
    // abiCall(
    //   AkitaSocial.prototype.flagPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x61dcd2ef // method "flagPost(byte[32])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1781
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unflagPost[routing]() -> void:
unflagPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1798
    // unflagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1802
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1802
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1802
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1804-1812
    // abiCall(
    //   AkitaSocial.prototype.unflagPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1810
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1804-1812
    // abiCall(
    //   AkitaSocial.prototype.unflagPost,
    //   {
    //     sender,
    //     appId: social,
    //     args: [ref],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x7960ea76 // method "unflagPost(byte[32])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1798
    // unflagPost(walletID: uint64, rekeyBack: boolean, ref: bytes<32>): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unban[routing]() -> void:
unban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1815
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1819
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1819
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1819
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1821-1829
    // abiCall(
    //   AkitaSocial.prototype.unban,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1827
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1821-1829
    // abiCall(
    //   AkitaSocial.prototype.unban,
    //   {
    //     sender,
    //     appId: social,
    //     args: [address],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xa0d2321d // method "unban(address)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1815
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addAction[routing]() -> void:
addAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1832
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1836
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1836
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1836
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1840
    // receiver: Application(social).address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1841
    // amount: this.mbr(Bytes('')).actions
    pushbytes ""
    callsub mbr
    pushint 80 // 80
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1844-1856
    // abiCall(
    //   AkitaSocial.prototype.addAction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       actionAppID,
    //       content
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1838-1842
    // const mbrPayment = itxn.payment({
    //   sender,
    //   receiver: Application(social).address,
    //   amount: this.mbr(Bytes('')).actions
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1844-1856
    // abiCall(
    //   AkitaSocial.prototype.addAction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       actionAppID,
    //       content
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1854
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1844-1856
    // abiCall(
    //   AkitaSocial.prototype.addAction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       mbrPayment,
    //       actionAppID,
    //       content
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xd90671b6 // method "addAction(pay,uint64,byte[36])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1832
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeAction[routing]() -> void:
removeAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1859
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1863
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1863
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1863
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1865-1873
    // abiCall(
    //   AkitaSocial.prototype.removeAction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [actionAppID],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1871
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1865-1873
    // abiCall(
    //   AkitaSocial.prototype.removeAction,
    //   {
    //     sender,
    //     appId: social,
    //     args: [actionAppID],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xf1492bf4 // method "removeAction(uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1859
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.initMeta[routing]() -> void:
initMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1876-1883
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    txna ApplicationArgs 1
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    txna ApplicationArgs 3
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    txna ApplicationArgs 4
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1887
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1887
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    bury 1
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1876-1883
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    pushbytes 0x151f7c750000000000000000
    log
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateMeta[routing]() -> void:
updateMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1892-1900
    // updateMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_2 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1904
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1904
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_1 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1904
    // const { social } = getAkitaAppList(this.akitaDAO.value)
    pushint 96 // 96
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1906-1920
    // abiCall(
    //   AkitaSocial.prototype.updateMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       followGateID,
    //       addressGateID,
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1918
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1906-1920
    // abiCall(
    //   AkitaSocial.prototype.updateMeta,
    //   {
    //     sender,
    //     appId: social,
    //     args: [
    //       followGateID,
    //       addressGateID,
    //       subscriptionIndex,
    //       NFD,
    //       akitaNFT
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xbdf6879d // method "updateMeta(uint64,uint64,uint64,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1892-1900
    // updateMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   followGateID: uint64,
    //   addressGateID: uint64,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 14 // "version"
    // smart_contracts/utils/base-contracts/base.ts:21
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:28
    // this.akitaDAO.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    intc_1 // 1
    return


// smart_contracts/social/base.ts::BaseSocial.mbr(ref: bytes) -> bytes:
mbr:
    // smart_contracts/social/base.ts:13
    // protected mbr(ref: bytes): AkitaSocialMBRData {
    proto 1 1
    // smart_contracts/social/base.ts:17
    // posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    frame_dig -1
    len
    pushint 400 // 400
    *
    pushint 36500 // 36500
    +
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    pushbytes 0x0000000000007bd40000000000003d54
    swap
    concat
    // smart_contracts/social/base.ts:18
    // votes: VotesMBR,
    pushint 19300 // 19300
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:20
    // reactions: ReactionsMBR,
    pushint 22100 // 22100
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    // smart_contracts/social/base.ts:21
    // reactionlist: ReactionlistMBR,
    pushint 18900 // 18900
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/social/base.ts:22
    // meta: MetaMBR,
    pushint 42100 // 42100
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/social/base.ts:25
    // actions: ActionsMBR
    pushint 29700 // 29700
    // smart_contracts/social/base.ts:14-26
    // return {
    //   follows: FollowsMBR,
    //   blocks: BlocksMBR,
    //   posts: MinPostsMBR + (BoxCostPerByte * ref.length),
    //   votes: VotesMBR,
    //   votelist: VotelistMBR,
    //   reactions: ReactionsMBR,
    //   reactionlist: ReactionlistMBR,
    //   meta: MetaMBR,
    //   moderators: ModeratorsMBR,
    //   banned: BannedMBR,
    //   actions: ActionsMBR
    // }
    itob
    concat
    retsub


// smart_contracts/social/base.ts::BaseSocial.checkTipMbrRequirements(akitaDAO: uint64, creator: bytes, wallet: uint64) -> bytes:
checkTipMbrRequirements:
    // smart_contracts/social/base.ts:45
    // protected checkTipMbrRequirements(akitaDAO: Application, creator: Account, wallet: uint64): tipMBRInfo {
    proto 3 1
    // smart_contracts/utils/functions.ts:78
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    frame_dig -3
    bytec 4 // "akita_assets"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:46
    // const akta = Asset(getAkitaAssets(akitaDAO).akta)
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/social/base.ts:48
    // if (creator.isOptedIn(akta)) {
    frame_dig -2
    swap
    asset_holding_get AssetBalance
    bury 1
    bz checkTipMbrRequirements_after_if_else@2
    // smart_contracts/social/base.ts:49-59
    // return {
    //   type: TipSendTypeDirect,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: 0
    // }
    pushbytes 0x0a000000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub

checkTipMbrRequirements_after_if_else@2:
    // smart_contracts/social/base.ts:62
    // if (wallet !== 0) {
    frame_dig -1
    bz checkTipMbrRequirements_after_if_else@6
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:34
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    frame_dig -3
    pushbytes "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:35
    // getPluginAppList(akitaDAO).optin,
    extract 0 8
    // smart_contracts/social/base.ts:37
    // new Address(Global.zeroAddress),
    global ZeroAddress
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:36
    // true,
    pushbytes 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:38
    // '',
    pushbytes 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/social/base.ts:39
    // methodSelector(OptInPluginInterface.prototype.optInToAsset)
    pushbytes 0x27ece5e6 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    // smart_contracts/social/base.ts:30-42
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_canCall,
    //   {
    //     appId,
    //     args: [
    //       getPluginAppList(akitaDAO).optin,
    //       true,
    //       new Address(Global.zeroAddress),
    //       '',
    //       methodSelector(OptInPluginInterface.prototype.optInToAsset)
    //     ]
    //   }
    // ).returnValue
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/social/base.ts:64
    // if (canCallArc58OptIn) {
    bz checkTipMbrRequirements_after_if_else@6
    // smart_contracts/social/base.ts:74
    // arc58: Global.assetOptInMinBalance
    global AssetOptInMinBalance
    // smart_contracts/social/base.ts:65-75
    // return {
    //   type: TipSendTypeARC58,
    //   arc59: {
    //     itxns: 0,
    //     mbr: 0,
    //     routerOptedIn: false,
    //     receiverOptedIn: false,
    //     receiverAlgoNeededForClaim: 0
    //   },
    //   arc58: Global.assetOptInMinBalance
    // }
    itob
    pushbytes 0x1e00000000000000000000000000000000000000000000000000
    swap
    concat
    swap
    retsub

checkTipMbrRequirements_after_if_else@6:
    // smart_contracts/utils/functions.ts:39
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    frame_dig -3
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/social/base.ts:79
    // const assetInbox = getOtherAppList(akitaDAO).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/social/base.ts:81-90
    // const arc59 = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [
    //       new Address(creator),
    //       akta.id,
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_3 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/social/base.ts:93
    // type: TipSendTypeARC59,
    bytec 6 // 0x14
    // smart_contracts/social/base.ts:92-96
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    swap
    concat
    // smart_contracts/social/base.ts:95
    // arc58: 0
    intc_0 // 0
    // smart_contracts/social/base.ts:92-96
    // return {
    //   type: TipSendTypeARC59,
    //   arc59,
    //   arc58: 0
    // }
    itob
    concat
    swap
    retsub
