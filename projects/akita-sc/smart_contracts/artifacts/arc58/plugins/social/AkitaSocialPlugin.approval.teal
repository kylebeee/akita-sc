#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 16 32 385 384 19300 18900 15700 63072000 86400 31700 29700
    bytecblock 0x00 "akita_dao" "controlled_address" "spending_address" "m" 0x151f7c75 "p" "akita_assets" "akita_escrow" "social_fees" 0x0000 "plugn_al" 0x0033 "d" "a" "n" "b" 0x80 "o" "f" 0xbfcbeee9 "version" 0x3e6ee3d6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txn NumAppArgs
    bz main_after_if_else@43
    pushbytess 0x4eb3dfbc 0xc13990ec 0xcef15f6b 0x6744e866 0xa3682229 0x832fbd39 0x65b69865 0x693f6dc8 0x21288fbc 0x5db7232d 0x192a62af 0x28e9d866 0xec5bceb1 0x7e9c7af0 0x5801c36b 0x4a1a352f 0x3f2752de 0x7fd4cab7 0xb0202e9e 0x92b8899d 0xbec86c34 0x9f59a970 0xaa765601 0x9091dca5 0x493e908f 0x0d8b6771 0x68e8db78 0x25498229 0x5cf7e0a5 0x47d682fc 0xe869934d 0x70e5c48b 0x2882bb8a 0x3172ca9d 0x1747405b 0x33e92c94 0x1ead20a9 // method "createApplication(string,uint64,uint64)void", method "post(uint64,bool,byte[36],uint64)void", method "editPost(uint64,bool,byte[36],uint64,byte[32])void", method "replyPost(uint64,bool,byte[36],byte[32],uint64,byte[][])void", method "replyAsset(uint64,bool,byte[36],uint64,uint64)void", method "replyAddress(uint64,bool,byte[36],address,uint64,byte[][])void", method "replyApp(uint64,bool,byte[36],uint64,uint64)void", method "editReply(uint64,bool,byte[36],uint64,byte[][],byte[32])void", method "votePost(uint64,bool,byte[32],bool)void", method "voteAsset(uint64,bool,uint64,bool)void", method "voteAddress(uint64,bool,address,bool)void", method "voteApp(uint64,bool,uint64,bool)void", method "editVote(uint64,bool,byte[32],bool)void", method "reactPost(uint64,bool,byte[32],uint64,byte[][])void", method "reactAsset(uint64,bool,uint64,uint64)void", method "reactAddress(uint64,bool,address,uint64,byte[][])void", method "reactApp(uint64,bool,uint64,uint64)void", method "deleteReaction(uint64,bool,byte[32],uint64)void", method "follow(uint64,bool,address,byte[][])void", method "unfollow(uint64,bool,address,uint64)void", method "block(uint64,bool,address)void", method "unblock(uint64,bool,address)void", method "addModerator(uint64,bool,address)void", method "removeModerator(uint64,bool,address)void", method "ban(uint64,bool,address,uint64)void", method "flagPost(uint64,bool,byte[32])void", method "unban(uint64,bool,address)void", method "addAction(uint64,bool,uint64,byte[36])void", method "removeAction(uint64,bool,uint64)void", method "initMeta(uint64,bool,bool,uint64,uint64,uint64)uint64", method "getUserSocialImpact(address)uint64", method "isFollower(address,uint64,address)bool", method "getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)", method "gas()void", method "updateApplication(string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_post_route@4 main_editPost_route@5 main_replyPost_route@6 main_replyAsset_route@7 main_replyAddress_route@8 main_replyApp_route@9 main_editReply_route@10 main_votePost_route@11 main_voteAsset_route@12 main_voteAddress_route@13 main_voteApp_route@14 main_editVote_route@15 main_reactPost_route@16 main_reactAsset_route@17 main_reactAddress_route@18 main_reactApp_route@19 main_deleteReaction_route@20 main_follow_route@21 main_unfollow_route@22 main_block_route@23 main_unblock_route@24 main_addModerator_route@25 main_removeModerator_route@26 main_ban_route@27 main_flagPost_route@28 main_unban_route@29 main_addAction_route@30 main_removeAction_route@31 main_initMeta_route@32 main_getUserSocialImpact_route@33 main_isFollower_route@34 main_getMeta_route@35 main_gas_route@36 main_updateApplication_route@37 main_updateAkitaDAO_route@38 main_updateAkitaDAOEscrow_route@39

main_after_if_else@43:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    intc_0 // 0
    return

main_updateAkitaDAOEscrow_route@39:
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_1 // 1
    return

main_updateAkitaDAO_route@38:
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_updateApplication_route@37:
    // smart_contracts/utils/base-contracts/base.ts:78
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:78
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_1 // 1
    return

main_gas_route@36:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1287
    // gas() { }
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_getMeta_route@35:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1281
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1281
    // @abimethod({ readonly: true })
    callsub getMeta
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 10
    setbit
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isFollower_route@34:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1276
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1276
    // @abimethod({ readonly: true })
    callsub isFollower
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserSocialImpact_route@33:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1271
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1271
    // @abimethod({ readonly: true })
    callsub getUserSocialImpact
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initMeta_route@32:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199-1206
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    intc_0 // 0
    getbit
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199-1206
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    callsub initMeta
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeAction_route@31:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1177
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1177
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    callsub removeAction
    intc_1 // 1
    return

main_addAction_route@30:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1157
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1157
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    callsub addAction
    intc_1 // 1
    return

main_unban_route@29:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1137
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1137
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub unban
    intc_1 // 1
    return

main_flagPost_route@28:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1118
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1118
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>): void {
    callsub flagPost
    intc_1 // 1
    return

main_ban_route@27:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1099
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1099
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    callsub ban
    intc_1 // 1
    return

main_removeModerator_route@26:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1077
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1077
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub removeModerator
    intc_1 // 1
    return

main_addModerator_route@25:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1057
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1057
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub addModerator
    intc_1 // 1
    return

main_unblock_route@24:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub unblock
    intc_1 // 1
    return

main_block_route@23:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    callsub block
    intc_1 // 1
    return

main_unfollow_route@22:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:976
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:976
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    callsub unfollow
    intc_1 // 1
    return

main_follow_route@21:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    callsub follow
    intc_1 // 1
    return

main_deleteReaction_route@20:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:911
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:911
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64): void {
    callsub deleteReaction
    intc_1 // 1
    return

main_reactApp_route@19:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:903
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:903
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    callsub reactApp
    intc_1 // 1
    return

main_reactAddress_route@18:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:887
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:887
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    callsub reactAddress
    intc_1 // 1
    return

main_reactAsset_route@17:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    callsub reactAsset
    intc_1 // 1
    return

main_reactPost_route@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:875
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:875
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64, args: GateArgs): void {
    callsub reactPost
    intc_1 // 1
    return

main_editVote_route@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:856
    // editVote(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, flip: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:856
    // editVote(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, flip: boolean): void {
    callsub editVote
    intc_1 // 1
    return

main_voteApp_route@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:848
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:848
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    callsub voteApp
    intc_1 // 1
    return

main_voteAddress_route@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:842
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:842
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    callsub voteAddress
    intc_1 // 1
    return

main_voteAsset_route@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:834
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:834
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    callsub voteAsset
    intc_1 // 1
    return

main_votePost_route@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:830
    // votePost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, isUp: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:830
    // votePost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, isUp: boolean): void {
    callsub votePost
    intc_1 // 1
    return

main_editReply_route@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796-803
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: StaticBytes<32>
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796-803
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: StaticBytes<32>
    // ): void {
    callsub editReply
    intc_1 // 1
    return

main_replyApp_route@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    callsub replyApp
    intc_1 // 1
    return

main_replyAddress_route@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:773
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:773
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    callsub replyAddress
    intc_1 // 1
    return

main_replyAsset_route@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:765
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:765
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    callsub replyAsset
    intc_1 // 1
    return

main_replyPost_route@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:761
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: StaticBytes<32>, gateID: uint64, args: GateArgs): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:761
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: StaticBytes<32>, gateID: uint64, args: GateArgs): void {
    callsub replyPost
    intc_1 // 1
    return

main_editPost_route@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:735
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: StaticBytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:735
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: StaticBytes<32>): void {
    callsub editPost
    intc_1 // 1
    return

main_post_route@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:731
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:731
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    callsub post
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:722
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/arc58/plugins/social/contract.algo.ts:25
    // export class AkitaSocialPlugin extends AkitaBaseEscrow {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:722
    // @abimethod({ onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/utils/types/base.ts::bytes16(value: bytes) -> bytes:
bytes16:
    // smart_contracts/utils/types/base.ts:16
    // export function bytes16(value: bytes) {
    proto 1 1
    // smart_contracts/utils/types/base.ts:17
    // return new arc4.StaticBytes<16>(value.slice(0, 16))
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 16
    dig 2
    >=
    intc_2 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    intc_2 // 16
    ==
    assert // invalid size
    retsub


// smart_contracts/utils/types/base.ts::paddedBytes32(value: bytes) -> bytes:
paddedBytes32:
    // smart_contracts/utils/types/base.ts:28
    // export function paddedBytes32(value: bytes) {
    proto 1 1
    // smart_contracts/utils/types/base.ts:29
    // return new arc4.StaticBytes<32>(value.concat(op.bzero(32 - value.length)))
    frame_dig -1
    len
    intc_3 // 32
    swap
    -
    bzero
    frame_dig -1
    swap
    concat
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    retsub


// smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
impactRange:
    // smart_contracts/utils/functions.ts:83
    // export function impactRange(impact: uint64, min: uint64, max: uint64): uint64 {
    proto 3 1
    // smart_contracts/utils/functions.ts:84
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    frame_dig -3
    intc_1 // 1
    >
    bz impactRange_ternary_false@2
    frame_dig -3
    intc_1 // 1
    -

impactRange_ternary_merge@3:
    // smart_contracts/utils/functions.ts:85
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    frame_dig -1
    frame_dig -2
    -
    *
    // smart_contracts/utils/constants.ts:15
    // export const IMPACT_DIVISOR: uint64 = 1_000
    pushint 1000 // 1000
    // smart_contracts/utils/functions.ts:85
    // return max - (((max - min) * minImpact) / IMPACT_DIVISOR)
    /
    frame_dig -1
    swap
    -
    retsub

impactRange_ternary_false@2:
    // smart_contracts/utils/functions.ts:84
    // const minImpact: uint64 = (impact > 1) ? impact - 1 : 1
    intc_1 // 1
    b impactRange_ternary_merge@3


// smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes, id: uint64, args: bytes) -> uint64, bytes:
gateCheck:
    // smart_contracts/utils/functions.ts:128
    // export function gateCheck(akitaDAO: Application, caller: Address, id: uint64, args: GateArgs): boolean {
    proto 4 2
    // smart_contracts/utils/functions.ts:129
    // if (id === 0) {
    frame_dig -2
    bnz gateCheck_after_if_else@2
    // smart_contracts/utils/functions.ts:130
    // return true
    intc_1 // 1
    frame_dig -1
    retsub

gateCheck_after_if_else@2:
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -4
    // smart_contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    pushbytes "akita_al"
    // smart_contracts/utils/functions.ts:23
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:24
    // return decodeArc4<AkitaAppList>(appListBytes)
    pushint 40 // 40
    extract_uint64
    // smart_contracts/utils/functions.ts:135
    // args: [caller, id, args],
    frame_dig -2
    itob
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/functions.ts:136
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:133-137
    // return abiCall(Gate.prototype.check, {
    //   appId: getAkitaAppList(akitaDAO).gate,
    //   args: [caller, id, args],
    //   fee: 0,
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    frame_dig -1
    retsub


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:164
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    intc_0 // 0
    dup
    // smart_contracts/utils/functions.ts:165
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:166
    // return Global.zeroAddress
    global ZeroAddress
    frame_bury 0
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -1
    app_params_get AppAddress
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/utils/functions.ts:170
    // if (sender !== origin) {
    !=
    bz rekeyAddress_after_if_else@4
    // smart_contracts/utils/functions.ts:171
    // return sender
    retsub

rekeyAddress_after_if_else@4:
    // smart_contracts/utils/functions.ts:174
    // return walletAddress
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(address: bytes) -> uint64:
controls:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:70
    // private controls(address: Account): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:71
    // return address.authAddress === Global.currentApplicationAddress
    frame_dig -1
    acct_params_get AcctAuthAddr
    assert // account funded
    global CurrentApplicationAddress
    ==
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(wallet: uint64) -> void:
rekeyBack:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:74
    // private rekeyBack(wallet: Application) {
    proto 1 0
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:77-85
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:82
    // rekeyTo: rekeyAddress(true, wallet),
    intc_1 // 1
    frame_dig -1
    callsub rekeyAddress
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:80
    // amount: 0,
    intc_0 // 0
    itxn_field Amount
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:77-84
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:77-85
    // itxn
    //   .payment({
    //     sender,
    //     amount: 0,
    //     receiver: sender,
    //     rekeyTo: rekeyAddress(true, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isReply(ref: bytes) -> uint64:
isReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:93
    // private isReply(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:94
    // return ref.length === 68 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 68 // 68
    ==
    bnz isReply_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isReply_bool_false@3

isReply_bool_true@2:
    intc_1 // 1

isReply_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:94
    // return ref.length === 68 || ref.length === 101
    swap
    retsub

isReply_bool_false@3:
    intc_0 // 0
    b isReply_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isAmended(ref: bytes) -> uint64:
isAmended:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:97
    // private isAmended(ref: bytes): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:98
    // return ref.length === 69 || ref.length === 101
    frame_dig -1
    len
    dup
    pushint 69 // 69
    ==
    bnz isAmended_bool_true@2
    frame_dig 0
    pushint 101 // 101
    ==
    bz isAmended_bool_false@3

isAmended_bool_true@2:
    intc_1 // 1

isAmended_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:98
    // return ref.length === 69 || ref.length === 101
    swap
    retsub

isAmended_bool_false@3:
    intc_0 // 0
    b isAmended_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(account: bytes) -> uint64:
isBanned:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:101
    // private isBanned(account: Account): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 15 // "n"
    frame_dig -1
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:102
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    box_len
    bury 1
    bz isBanned_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    global LatestTimestamp
    >
    bz isBanned_bool_false@3
    intc_1 // 1

isBanned_bool_merge@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:102
    // return this.banned(account).exists && this.banned(account).value > Global.latestTimestamp
    swap
    retsub

isBanned_bool_false@3:
    intc_0 // 0
    b isBanned_bool_merge@4


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(user: bytes, blocked: bytes) -> uint64:
isBlocked:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:105
    // private isBlocked(user: Account, blocked: Account): boolean {
    proto 2 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:107
    // user: bytes16(user.bytes),
    frame_dig -2
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:108
    // blocked: bytes16(blocked.bytes)
    frame_dig -1
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:106-109
    // const blocksKey = new arc4BlockListKey({
    //   user: bytes16(user.bytes),
    //   blocked: bytes16(blocked.bytes)
    // })
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:110
    // return this.blocks(blocksKey).exists
    dup
    extract 0 16 // on error: Index access is out of bounds
    swap
    extract 16 16 // on error: Index access is out of bounds
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 16 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:110
    // return this.blocks(blocksKey).exists
    box_len
    bury 1
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(account: bytes) -> uint64:
getSocialImpactScore:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:113
    // private getSocialImpactScore(account: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    dupn 4
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:115
    // const meta = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    pushint 8 // 8
    extract_uint64
    dup
    uncover 2
    intc_2 // 16
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:118
    // if (meta.streak >= 60) {
    pushint 60 // 60
    >=
    bz getSocialImpactScore_else_body@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:119
    // socialImpact += 100
    pushint 100 // 100
    frame_bury 4

getSocialImpactScore_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:127
    // const accountAge: uint64 = Global.latestTimestamp - meta.startDate
    global LatestTimestamp
    frame_dig 7
    -
    dup
    frame_bury 1
    // smart_contracts/arc58/plugins/social/constants.ts:30
    // export const TWO_YEARS: uint64 = 63_072_000
    intc 9 // 63072000
    // smart_contracts/arc58/plugins/social/contract.algo.ts:129
    // if (accountAge >= TWO_YEARS) {
    >=
    bz getSocialImpactScore_else_body@5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:130
    // socialImpact += 75
    frame_dig 4
    pushint 75 // 75
    +
    frame_bury 4

getSocialImpactScore_after_if_else@6:
    // smart_contracts/arc58/plugins/social/constants.ts:6
    // export const AkitaSocialBoxPrefixVotes = 'v'
    pushbytes "v"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:137
    // if (this.votes(bytes32(account.bytes)).exists) {
    box_len
    bury 1
    frame_dig 4
    frame_bury 5
    bz getSocialImpactScore_after_if_else@16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:138
    // const score = this.votes(bytes32(account.bytes)).value
    frame_dig 0
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:140
    // let impact: uint64 = (score.voteCount * 75) / 100_000
    pushint 75 // 75
    *
    pushint 100000 // 100000
    /
    dup
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:141
    // if (impact > 75) {
    pushint 75 // 75
    >
    bz getSocialImpactScore_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:142
    // impact = 75
    pushint 75 // 75
    frame_bury 2

getSocialImpactScore_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:145
    // if (score.isNegative) {
    frame_dig 3
    bz getSocialImpactScore_else_body@14
    // smart_contracts/arc58/plugins/social/contract.algo.ts:147
    // if (socialImpact > impact) {
    frame_dig 4
    frame_dig 2
    >
    bz getSocialImpactScore_else_body@12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:148
    // socialImpact -= impact
    frame_dig 4
    frame_dig 2
    -
    frame_bury 4

getSocialImpactScore_after_if_else@15:
    frame_dig 4
    frame_bury 5

getSocialImpactScore_after_if_else@16:
    frame_dig 5
    // smart_contracts/arc58/plugins/social/contract.algo.ts:158
    // return socialImpact
    frame_bury 0
    retsub

getSocialImpactScore_else_body@12:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:150
    // socialImpact = 0
    intc_0 // 0
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@14:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:154
    // socialImpact += impact
    frame_dig 4
    frame_dig 2
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@15

getSocialImpactScore_else_body@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:133
    // socialImpact += (accountAge * 75) / TWO_YEARS
    frame_dig 1
    pushint 75 // 75
    *
    // smart_contracts/arc58/plugins/social/constants.ts:30
    // export const TWO_YEARS: uint64 = 63_072_000
    intc 9 // 63072000
    // smart_contracts/arc58/plugins/social/contract.algo.ts:133
    // socialImpact += (accountAge * 75) / TWO_YEARS
    /
    frame_dig 4
    +
    frame_bury 4
    b getSocialImpactScore_after_if_else@6

getSocialImpactScore_else_body@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:122
    // socialImpact += (meta.streak * 100) / 60
    frame_dig 6
    pushint 100 // 100
    *
    pushint 60 // 60
    /
    frame_bury 4
    b getSocialImpactScore_after_if_else@3


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(account: bytes) -> uint64:
getUserImpact:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:161
    // private getUserImpact(account: Account): uint64 {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:162-169
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:162-169
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0xf81c7b62 // method "getUserImpactWithoutSocial(address)uint64"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:162-169
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.getUserImpactWithoutSocial,
    //   {
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [new Address(account)],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/plugins/social/contract.algo.ts:171
    // return impact + this.getSocialImpactScore(account)
    frame_dig -1
    callsub getSocialImpactScore
    +
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(sender: bytes, appId: uint64) -> uint64:
canCallArc58OptIn:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:174
    // private canCallArc58OptIn(sender: Account, appId: Application): boolean {
    proto 2 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:175-188
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       bytes4(methodSelector(OptInPlugin.prototype.optInToAsset))
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:181
    // getPluginAppList(this.akitaDAO.value).optin,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:175-188
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       bytes4(methodSelector(OptInPlugin.prototype.optInToAsset))
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0x682fdbf8 // method "arc58_canCall(uint64,bool,address,byte[4])bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:182
    // true,
    bytec 17 // 0x80
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:184
    // bytes4(methodSelector(OptInPlugin.prototype.optInToAsset))
    bytec 20 // method "optInToAsset(uint64,bool,uint64,pay)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    frame_dig -2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:175-188
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       bytes4(methodSelector(OptInPlugin.prototype.optInToAsset))
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:175-188
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     sender,
    //     appId,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(sender),
    //       bytes4(methodSelector(OptInPlugin.prototype.optInToAsset))
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
arc58OptInAndSendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:191-197
    // private arc58OptInAndSendReactionPayments(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   recipientWallet: Application,
    //   mbrAmount: uint64,
    //   tax: uint64
    // ): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:205
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:214
    // getPluginAppList(this.akitaDAO.value).optin,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:222
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:232
    // recipientWallet,
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:233
    // true,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:234
    // akta
    dig 6
    itob
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 8 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:250
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:261
    // assetAmount: reactFee - tax,
    frame_dig -1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:263
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_begin
    uncover 9
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dig 10
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:202-207
    // const mbrTxn = itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:213
    // methodSelector(AbstractedAccount.prototype.arc58_rekeyToPlugin),
    pushbytes 0xde300fe9 // method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    uncover 8
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/social/contract.algo.ts:215
    // new DynamicArray<UintN64>()
    bytec 10 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    dig 9
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:209-218
    // const rekeyTxn = itxn.applicationCall({
    //   sender,
    //   appId: recipientWallet,
    //   appArgs: [
    //     methodSelector(AbstractedAccount.prototype.arc58_rekeyToPlugin),
    //     getPluginAppList(this.akitaDAO.value).optin,
    //     new DynamicArray<UintN64>()
    //   ],
    //   fee,
    // })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    dig 10
    itxn_field Receiver
    uncover 7
    itxn_field Amount
    dig 8
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:220-225
    // const optinMBRTxn = itxn.payment({
    //   sender,
    //   amount: Global.assetOptInMinBalance,
    //   receiver: recipientOrigin,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:231
    // methodSelector(OptInPlugin.prototype.optInToAsset),
    bytec 20 // method "optInToAsset(uint64,bool,uint64,pay)void"
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationID
    dig 4
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:227-237
    // const optinTxn = itxn.applicationCall({
    //   sender,
    //   appId: getPluginAppList(this.akitaDAO.value).optin,
    //   appArgs: [
    //     methodSelector(OptInPlugin.prototype.optInToAsset),
    //     recipientWallet,
    //     true,
    //     akta
    //   ],
    //   fee,
    // })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:243
    // methodSelector(AbstractedAccount.prototype.arc58_verifyAuthAddr)
    pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    dig 4
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:239-246
    // const verifyTxn = itxn.applicationCall({
    //   sender,
    //   appId: recipientWallet,
    //   appArgs: [
    //     methodSelector(AbstractedAccount.prototype.arc58_verifyAuthAddr)
    //   ],
    //   fee,
    // })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    dig 3
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    dig 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:248-254
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: akta,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_next
    itxn_field RekeyTo
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field Sender
    itxn_field AssetReceiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:258-265
    // const xferTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: recipientOrigin,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:267
    // submitGroup(mbrTxn, rekeyTxn, optinMBRTxn, optinTxn, verifyTxn, taxTxn, xferTxn)
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
arc59OptInAndSendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:270-276
    // private arc59OptInAndSendReactionPayments(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   recipientWallet: Application,
    //   mbrAmount: uint64,
    //   tax: uint64
    // ): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    pushbytes "other_al"
    // smart_contracts/utils/functions.ts:33
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:34
    // return decodeArc4<OtherAppList>(otherAppListBytes)
    intc_2 // 16
    extract_uint64
    dupn 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:278
    // const inboxAddress = Application(assetInbox).address
    app_params_get AppAddress
    swap
    cover 2
    assert // application exists
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:283-290
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:287
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:283-289
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:283-290
    // itxn
    //   .payment({
    //     sender,
    //     amount: mbrAmount,
    //     receiver: Global.currentApplicationAddress,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:292-303
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:299
    // akta,
    uncover 2
    itob
    dup
    cover 4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:292-303
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:292-303
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       new Address(recipientOrigin),
    //       akta,
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dig 1
    pushint 12 // 12
    extract_uint64
    dup
    cover 3
    cover 3
    pushint 128 // 128
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    cover 2
    pushint 21 // 21
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:309
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz arc59OptInAndSendReactionPayments_if_body@4
    frame_dig 8
    bz arc59OptInAndSendReactionPayments_after_if_else@6

arc59OptInAndSendReactionPayments_if_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:310-317
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:314
    // amount: mbr + receiverAlgoNeededForClaim,
    frame_dig 6
    frame_dig 8
    +
    itxn_field Amount
    frame_dig 1
    itxn_field Receiver
    frame_dig 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:310-316
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:310-317
    // itxn
    //   .payment({
    //     sender,
    //     receiver: inboxAddress,
    //     amount: mbr + receiverAlgoNeededForClaim,
    //     fee,
    //   })
    //   .submit()
    itxn_submit

arc59OptInAndSendReactionPayments_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:320
    // if (!routerOptedIn) {
    frame_dig 7
    bnz arc59OptInAndSendReactionPayments_after_if_else@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:321-326
    // abiCall(AssetInbox.prototype.arc59_optRouterIn, {
    //   sender,
    //   appId: assetInbox,
    //   args: [akta],
    //   fee,
    // })
    itxn_begin
    pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
    itxn_field ApplicationArgs
    frame_dig 5
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationID
    frame_dig 3
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:321-326
    // abiCall(AssetInbox.prototype.arc59_optRouterIn, {
    //   sender,
    //   appId: assetInbox,
    //   args: [akta],
    //   fee,
    // })
    itxn_submit

arc59OptInAndSendReactionPayments_after_if_else@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:329-337
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 8 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:332
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    frame_dig 2
    dup
    cover 2
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:329-336
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:329-337
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: this.akitaDAOEscrow.value.address,
    //     assetAmount: tax,
    //     xferAsset: akta,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:341-360
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:350
    // assetAmount: reactFee - tax,
    frame_dig -1
    -
    itxn_field AssetAmount
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetReceiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:347-353
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: inboxAddress,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   fee,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:341-360
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/social/contract.algo.ts:357
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:355
    // receiverAlgoNeededForClaim
    frame_dig 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:341-360
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    frame_dig 0
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:341-360
    // abiCall(
    //   AssetInbox.prototype.arc59_sendAsset,
    //   {
    //     sender,
    //     appId: assetInbox,
    //     args: [
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: inboxAddress,
    //         assetAmount: reactFee - tax,
    //         xferAsset: akta,
    //         fee,
    //       }),
    //       new Address(recipientOrigin),
    //       receiverAlgoNeededForClaim
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    gitxn 1 LastLog
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet: uint64, rekeyBack: uint64, recipientAccount: bytes, mbrAmount: uint64, tax: uint64) -> void:
sendReactionPayments:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:363
    // private sendReactionPayments(wallet: Application, rekeyBack: boolean, recipientAccount: Account, mbrAmount: uint64, tax: uint64): void {
    proto 5 0
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    pushint 8 // 8
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:371
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 8 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:377
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:386
    // assetAmount: reactFee - tax,
    uncover 2
    frame_dig -1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:388
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:392
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_begin
    uncover 3
    itxn_field Receiver
    frame_dig -2
    itxn_field Amount
    dig 3
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:368-373
    // const mbrPayment = itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:392
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_next
    dig 4
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    dig 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:375-381
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: tax,
    //   xferAsset: akta,
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:392
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_next
    itxn_field RekeyTo
    uncover 2
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:383-390
    // const xferTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: recipientAccount,
    //   assetAmount: reactFee - tax,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:392
    // submitGroup(mbrPayment, taxTxn, xferTxn)
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref: bytes, creator: bytes) -> void:
createEmptyPostIfNecessary:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:402
    // private createEmptyPostIfNecessary(ref: StaticBytes<32>, creator: Account): void {
    proto 2 0
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:403
    // if (!this.posts(ref).exists) {
    box_len
    bury 1
    bnz createEmptyPostIfNecessary_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:414
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:404-418
    // this.posts(ref).value = {
    //   ref: ref.native,
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    frame_dig 0
    dup
    cover 2
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:414
    // timestamp: Global.latestTimestamp,
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:415
    // gateID: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:405
    // ref: ref.native,
    pushbytes 0x0020
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:404
    // this.posts(ref).value = {
    frame_dig -1
    uncover 3
    concat
    uncover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:416
    // againstContentPolicy: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:404
    // this.posts(ref).value = {
    concat
    intc 4 // 385
    intc_0 // 0
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:404-418
    // this.posts(ref).value = {
    //   ref: ref.native,
    //   /**
    //    * when a user reacts to content other than posts
    //    * we set the creator to the following:
    //    * - AssetID: Asset Creator
    //    * - Address: Address
    //    * -   AppID: Application Creator
    //    */
    //   creator: creator,
    //   timestamp: Global.latestTimestamp,
    //   gateID: 0,
    //   againstContentPolicy: false,
    //   isAmendment: false,
    // }
    box_put

createEmptyPostIfNecessary_after_if_else@2:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(account: bytes) -> void:
updateStreak:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:422
    // private updateStreak(account: Account): void {
    proto 1 0
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    dupn 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:423
    // assert(this.meta(account).exists, ERR_META_DOESNT_EXIST)
    box_len
    bury 1
    assert // Meta box values dont exist yet
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    pushint 8 // 8
    extract_uint64
    swap
    dup
    intc_2 // 16
    extract_uint64
    dup
    uncover 2
    dup
    pushint 24 // 24
    extract_uint64
    dup
    cover 3
    cover 3
    dup
    intc_3 // 32
    extract_uint64
    cover 3
    dup
    pushint 40 // 40
    extract_uint64
    cover 3
    dup
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    cover 3
    dup
    pushint 49 // 49
    extract_uint64
    cover 3
    pushint 57 // 57
    extract_uint64
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - meta.startDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 10 // 86400
    // smart_contracts/arc58/plugins/social/contract.algo.ts:427
    // const thisWindowStart: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - meta.startDate) % ONE_DAY)
    %
    -
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/constants.ts:29
    // export const ONE_DAY: uint64 = 86_400
    intc 10 // 86400
    // smart_contracts/arc58/plugins/social/contract.algo.ts:428
    // const lastWindowStart: uint64 = thisWindowStart - ONE_DAY
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:432
    // if (lastWindowStart > meta.lastActive) {
    <
    bz updateStreak_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:436
    // lastActive: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:435
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:436
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 5
    itob
    frame_dig 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    frame_dig 8
    itob
    frame_dig 9
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:433
    // this.meta(account).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:433-437
    // this.meta(account).value = {
    //   ...meta,
    //   streak: 1,
    //   lastActive: Global.latestTimestamp,
    // }
    frame_dig 0
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:438
    // return
    retsub

updateStreak_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:443
    // if (meta.lastActive < thisWindowStart) {
    frame_dig 4
    frame_dig 10
    <
    bz updateStreak_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:446
    // streak: (meta.streak + 1),
    frame_dig 2
    intc_1 // 1
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:447
    // lastActive: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:446
    // streak: (meta.streak + 1),
    uncover 2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:447
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:425
    // const meta = this.meta(account).value
    frame_dig 5
    itob
    frame_dig 6
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    frame_dig 8
    itob
    frame_dig 9
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:444
    // this.meta(account).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:444-448
    // this.meta(account).value = {
    //   ...meta,
    //   streak: (meta.streak + 1),
    //   lastActive: Global.latestTimestamp,
    // }
    frame_dig 0
    swap
    box_put

updateStreak_after_if_else@4:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(ref: bytes, isUp: uint64, impact: uint64) -> void:
updateVotes:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:475
    // private updateVotes(ref: StaticBytes<32>, isUp: boolean, impact: uint64): void {
    proto 3 0
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/social/constants.ts:6
    // export const AkitaSocialBoxPrefixVotes = 'v'
    pushbytes "v"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:455
    // if (!this.votes(ref).exists) {
    box_len
    bury 1
    bnz updateVotes_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:456
    // return { newCount: impact, isNegative: false }
    intc_0 // 0
    frame_bury 1
    frame_dig -1
    frame_bury 2

updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:477
    // this.votes(ref).value = { voteCount, isNegative }
    frame_dig 2
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 1
    setbit
    concat
    frame_dig 3
    swap
    box_put
    retsub

updateVotes_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:459
    // const { isNegative, voteCount } = this.votes(ref).value
    frame_dig 3
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    frame_bury 2
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:462
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bz updateVotes_or_contd@5
    frame_dig 1
    bnz updateVotes_bool_true@7

updateVotes_or_contd@5:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:462
    // const differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
    frame_dig -2
    bnz updateVotes_bool_false@8
    frame_dig 1
    bnz updateVotes_bool_false@8

updateVotes_bool_true@7:
    intc_1 // 1
    frame_bury 0

updateVotes_bool_merge@9:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:465
    // const flip = impact > voteCount && differingDirections
    frame_dig -1
    frame_dig 2
    >
    frame_dig 0
    &&
    // smart_contracts/arc58/plugins/social/contract.algo.ts:466
    // if (flip) {
    bz updateVotes_after_if_else@11
    // smart_contracts/arc58/plugins/social/contract.algo.ts:467
    // const newCount: uint64 = impact - voteCount
    frame_dig -1
    frame_dig 2
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:468
    // return { newCount, isNegative: !isNegative }
    frame_dig 1
    !
    frame_bury 1
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:476
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15

updateVotes_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:471
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 0
    bz updateVotes_ternary_false@13
    frame_dig 2
    frame_dig -1
    -

updateVotes_ternary_merge@14:
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:476
    // const { newCount: voteCount, isNegative } = this.calcVotes(ref, isUp, impact)
    b updateVotes_after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes@15

updateVotes_ternary_false@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:471
    // const newCount: uint64 = differingDirections ? voteCount - impact : voteCount + impact
    frame_dig 2
    frame_dig -1
    +
    b updateVotes_ternary_merge@14

updateVotes_bool_false@8:
    intc_0 // 0
    frame_bury 0
    b updateVotes_bool_merge@9


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(ref: bytes, isUp: uint64, account: bytes, impact: uint64) -> void:
createVoteList:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:480
    // private createVoteList(ref: StaticBytes<32>, isUp: boolean, account: Account, impact: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:397
    // user: bytes16(account.bytes),
    frame_dig -2
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:398
    // ref: bytes16(ref.bytes),
    frame_dig -4
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:396-399
    // return new arc4VoteListKey({
    //   user: bytes16(account.bytes),
    //   ref: bytes16(ref.bytes),
    // })
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482
    // this.votelist(voteListKey).value = { impact, isUp }
    dup
    extract 0 16 // on error: Index access is out of bounds
    swap
    extract 16 16 // on error: Index access is out of bounds
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:482
    // this.votelist(voteListKey).value = { impact, isUp }
    frame_dig -1
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    concat
    box_put
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createPost(wallet: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, isAmendment: uint64) -> void:
createPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:485
    // private createPost(wallet: Application, rekeyBack: boolean, cid: CID, gateID: uint64, isAmendment: boolean): void {
    proto 5 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:488
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:492
    // this.updateStreak(origin)
    dup
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/contract.algo.ts:494
    // const impact = this.getUserImpact(origin)
    dup
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:502
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 8 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:508
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:511
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -4
    frame_dig -5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:515
    // submitGroup(mbrTxn, taxTxn)
    itxn_begin
    uncover 2
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:501
    // amount: (posts + votes + votelist),
    pushint 88700 // 88700
    itxn_field Amount
    dig 6
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:499-504
    // const mbrTxn = itxn.payment({
    //   sender,
    //   amount: (posts + votes + votelist),
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:515
    // submitGroup(mbrTxn, taxTxn)
    itxn_next
    itxn_field RekeyTo
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    uncover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:506-513
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: postFee,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:515
    // submitGroup(mbrTxn, taxTxn)
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:517
    // const postID = bytes32(Txn.txId)
    txn TxID
    // smart_contracts/utils/types/base.ts:25
    // return new arc4.StaticBytes<32>(value)
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:521
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    dig 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:518-525
    // this.posts(postID).value = {
    //   ref: cid.bytes,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    dup
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:521
    // timestamp: Global.latestTimestamp,
    swap
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:522
    // gateID: gateID,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:524
    // isAmendment: isAmendment,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:519
    // ref: cid.bytes,
    pushbytes 0x0024
    frame_dig -3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:518
    // this.posts(postID).value = {
    dig 7
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:523
    // againstContentPolicy: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:518
    // this.posts(postID).value = {
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:518-525
    // this.posts(postID).value = {
    //   ref: cid.bytes,
    //   creator: origin,
    //   timestamp: Global.latestTimestamp,
    //   gateID: gateID,
    //   againstContentPolicy: false,
    //   isAmendment: isAmendment,
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:526
    // this.updateVotes(postID, true, impact)
    dup
    intc_1 // 1
    dig 3
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:527
    // this.createVoteList(postID, true, origin, impact)
    intc_1 // 1
    uncover 3
    uncover 3
    callsub createVoteList
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(wallet: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes, isAmendment: uint64) -> bytes:
createReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:530-538
    // private createReply(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   ref: StaticBytes<32>,
    //   gateID: uint64,
    //   args: GateArgs,
    //   isAmendment: boolean
    // ): void {
    proto 7 1
    intc_0 // 0
    pushbytes ""
    dupn 3
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:542
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:543
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:544
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    cover 3
    pushint 40 // 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:545
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    uncover 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    frame_dig -2
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:547
    // if (post.gateID !== 0) {
    bz createReply_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:548
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), post.gateID, args), ERR_FAILED_GATE)
    frame_dig 5
    frame_dig 8
    frame_dig -2
    callsub gateCheck
    frame_bury -2
    assert // Gate check failed
    frame_dig -2
    frame_bury 9

createReply_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:553
    // this.updateStreak(origin)
    frame_dig 5
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/contract.algo.ts:555
    // const replyRef = cid.bytes.concat(ref.bytes)
    frame_dig -5
    frame_dig -4
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 7
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:556
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:557
    // const postCreatorImpact = this.getUserImpact(post.creator)
    dup
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    intc_2 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/utils/functions.ts:79
    // return impactRange(impact, impactTaxMin, impactTaxMax)
    callsub impactRange
    frame_bury 3
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:58
    // posts: 35_700 + (400 * ref.length),
    uncover 2
    len
    dup
    frame_bury 4
    pushint 400 // 400
    *
    pushint 35700 // 35700
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:59
    // votes: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:561
    // const mbrAmount: uint64 = posts + votes + votelist
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:561
    // const mbrAmount: uint64 = posts + votes + votelist
    +
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:563
    // if (!post.creator.isOptedIn(Asset(akta))) {
    asset_holding_get AssetBalance
    bury 1
    bnz createReply_else_body@9
    // smart_contracts/arc58/plugins/social/contract.algo.ts:565
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 6
    frame_dig 1
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:566
    // if (canCallArc58OptIn) {
    bz createReply_else_body@7
    // smart_contracts/arc58/plugins/social/contract.algo.ts:568
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    frame_dig 1
    frame_dig 2
    frame_dig 3
    callsub arc58OptInAndSendReactionPayments

createReply_after_if_else@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:579
    // const replyPostID = bytes32(Txn.txId)
    txn TxID
    // smart_contracts/utils/types/base.ts:25
    // return new arc4.StaticBytes<32>(value)
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:583
    // timestamp: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    dig 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:589
    // this.posts(replyPostID).value = replyPost
    dup
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:580
    // const replyPost: PostValue = {
    swap
    itob
    frame_dig -3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig -1
    setbit
    frame_dig 4
    itob
    extract 6 2
    frame_dig 0
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:589
    // this.posts(replyPostID).value = replyPost
    frame_dig 5
    dup
    cover 5
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:580
    // const replyPost: PostValue = {
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:589
    // this.posts(replyPostID).value = replyPost
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:591
    // const senderImpact = this.getUserImpact(origin)
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:592
    // this.updateVotes(replyPostID, true, senderImpact)
    dig 2
    intc_1 // 1
    dig 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:593
    // this.createVoteList(replyPostID, true, origin, senderImpact)
    uncover 2
    intc_1 // 1
    uncover 3
    uncover 3
    callsub createVoteList
    frame_dig 9
    frame_bury 0
    retsub

createReply_else_body@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:571
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    frame_dig 1
    frame_dig 2
    frame_dig 3
    callsub arc59OptInAndSendReactionPayments
    b createReply_after_if_else@10

createReply_else_body@9:
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 1
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:576
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -7
    frame_dig -6
    uncover 2
    frame_dig 2
    frame_dig 3
    callsub sendReactionPayments
    b createReply_after_if_else@10


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(wallet: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
createVote:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:596
    // private createVote(wallet: Application, rekeyBack: boolean, ref: StaticBytes<32>, isUp: boolean): void {
    proto 4 0
    pushbytes ""
    dup
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:599
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:600
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:602
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:603
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dup
    dig 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:397
    // user: bytes16(account.bytes),
    dig 1
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:398
    // ref: bytes16(ref.bytes),
    frame_dig -2
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:396-399
    // return new arc4VoteListKey({
    //   user: bytes16(account.bytes),
    //   ref: bytes16(ref.bytes),
    // })
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:606
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    dup
    extract 0 16 // on error: Index access is out of bounds
    swap
    extract 16 16 // on error: Index access is out of bounds
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:606
    // assert(!this.votelist(voteListKey).exists, ERR_ALREADY_VOTED)
    box_len
    bury 1
    !
    assert // You've already voted on this post
    // smart_contracts/arc58/plugins/social/contract.algo.ts:607
    // assert(origin !== post.creator, ERR_NO_SELF_VOTE)
    dig 1
    !=
    assert // Cannot vote on your own content
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:609
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:610
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:616
    // this.updateStreak(origin)
    callsub updateStreak
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    pushint 8 // 8
    extract_uint64
    cover 2
    dup
    intc_2 // 16
    extract_uint64
    cover 2
    pushint 24 // 24
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:620
    // if (isUp) {
    frame_dig -1
    bz createVote_else_body@8
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 4
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:621
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:623
    // const recipientImpact = this.getUserImpact(post.creator)
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:624
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    frame_dig 6
    frame_dig 7
    callsub impactRange
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:626
    // if (!post.creator.isOptedIn(Asset(akta))) {
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz createVote_else_body@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:628
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 3
    frame_dig 0
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:629
    // if (canCallArc58OptIn) {
    bz createVote_else_body@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:631
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    frame_dig 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:631
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig 1
    callsub arc58OptInAndSendReactionPayments

createVote_after_if_else@11:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:662
    // const senderImpact = this.getUserImpact(origin)
    frame_dig 2
    dup
    callsub getUserImpact
    // smart_contracts/arc58/plugins/social/contract.algo.ts:663
    // this.updateVotes(ref, isUp, senderImpact)
    frame_dig -2
    frame_dig -1
    dig 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:664
    // this.createVoteList(ref, isUp, origin, senderImpact)
    frame_dig -2
    frame_dig -1
    uncover 3
    uncover 3
    callsub createVoteList
    retsub

createVote_else_body@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:634
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    frame_dig 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:634
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig 1
    callsub arc59OptInAndSendReactionPayments
    b createVote_after_if_else@11

createVote_else_body@6:
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:639
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -4
    frame_dig -3
    uncover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votelist: 19_300,
    intc 6 // 19300
    // smart_contracts/arc58/plugins/social/contract.algo.ts:639
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig 1
    callsub sendReactionPayments
    b createVote_after_if_else@11

createVote_else_body@8:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:645
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    intc_0 // 0
    bytec 8 // "akita_escrow"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:651
    // assetReceiver: this.akitaDAOEscrow.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:654
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:658
    // submitGroup(mbrTxn, taxTxn)
    itxn_begin
    uncover 2
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:60
    // votelist: 19_300,
    intc 6 // 19300
    itxn_field Amount
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:642-647
    // const mbrTxn = itxn.payment({
    //   sender,
    //   amount: mbrAmount,
    //   receiver: Global.currentApplicationAddress,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:658
    // submitGroup(mbrTxn, taxTxn)
    itxn_next
    itxn_field RekeyTo
    uncover 2
    itxn_field XferAsset
    frame_dig 5
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:649-656
    // const taxTxn = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.akitaDAOEscrow.value.address,
    //   assetAmount: reactFee,
    //   xferAsset: akta,
    //   rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:658
    // submitGroup(mbrTxn, taxTxn)
    itxn_submit
    b createVote_after_if_else@11


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(wallet: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> bytes:
createReaction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:667
    // private createReaction(wallet: Application, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64, args: GateArgs): void {
    proto 5 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 5
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -5
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:669
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:670
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:671
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 2
    cover 3
    pushint 40 // 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:672
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dig 2
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:673
    // const senderHasNFT = AssetHolding.assetBalance(origin, NFT)[0] > 0
    swap
    frame_dig -2
    asset_holding_get AssetBalance
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:674
    // assert(senderHasNFT, ERR_USER_DOES_NOT_OWN_NFT)
    assert // User does not own this NFT
    frame_dig -1
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:676
    // if (post.gateID !== 0) {
    bz createReaction_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:677
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), post.gateID, args), ERR_FAILED_GATE)
    frame_dig 8
    frame_dig 11
    frame_dig -1
    callsub gateCheck
    frame_bury -1
    assert // Gate check failed
    frame_dig -1
    frame_bury 12

createReaction_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:680
    // const reactionListKey: ReactionListKey = { user: bytes16(origin.bytes), ref: bytes16(ref.bytes), NFT }
    frame_dig 8
    dup
    callsub bytes16
    frame_dig -3
    callsub bytes16
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:681
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    cover 2
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:9
    // export const AkitaSocialBoxPrefixReactionList = 'e'
    pushbytes "e"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:681
    // assert(!this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    box_len
    bury 1
    !
    assert // This account already reacted to this post with this NFT
    // smart_contracts/arc58/plugins/social/contract.algo.ts:685
    // this.updateStreak(origin)
    swap
    callsub updateStreak
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig 10
    dup
    cover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:687
    // const creatorMeta = this.meta(post.creator).value
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_bury 3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:688
    // const recipientImpact = this.getUserImpact(post.creator)
    callsub getUserImpact
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysSocialFees = 'social_fees'
    bytec 9 // "social_fees"
    // smart_contracts/utils/functions.ts:38
    // const [socialFeesBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysSocialFees))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:39
    // return decodeArc4<SocialFees>(socialFeesBytes)
    dup
    intc_2 // 16
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:690
    // const tax = impactRange(recipientImpact, impactTaxMin, impactTaxMax)
    callsub impactRange
    frame_bury 7
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:16
    // export const AkitaDAOGlobalStateKeysAkitaAssets = 'akita_assets'
    bytec 7 // "akita_assets"
    // smart_contracts/utils/functions.ts:63
    // const akitaAssetsBytes = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAssets))[0]
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:64
    // return decodeArc4<AkitaAssets>(akitaAssetsBytes)
    intc_0 // 0
    extract_uint64
    frame_bury 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:62
    // reactionlist: 18_900,
    intc 7 // 18900
    frame_bury 6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:695
    // const reactionExists = this.reactions(reactionKey).exists
    frame_dig -3
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:8
    // export const AkitaSocialBoxPrefixReactions = 'r'
    pushbytes "r"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:695
    // const reactionExists = this.reactions(reactionKey).exists
    box_len
    dup
    cover 2
    frame_bury 5
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:697
    // const mbrAmount: uint64 = reactionExists ? reactionlist : reactions + reactionlist
    bz createReaction_ternary_false@6
    frame_dig 6
    frame_bury 4

createReaction_ternary_merge@7:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:699
    // if (!post.creator.isOptedIn(Asset(akta))) {
    frame_dig 10
    frame_dig 2
    asset_holding_get AssetBalance
    bury 1
    bnz createReaction_else_body@12
    // smart_contracts/arc58/plugins/social/contract.algo.ts:700
    // const canCallArc58OptIn = this.canCallArc58OptIn(sender, Application(creatorMeta.walletID))
    frame_dig 9
    frame_dig 3
    callsub canCallArc58OptIn
    // smart_contracts/arc58/plugins/social/contract.algo.ts:701
    // if (canCallArc58OptIn) {
    bz createReaction_else_body@10
    // smart_contracts/arc58/plugins/social/contract.algo.ts:702
    // this.arc58OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    frame_dig 3
    frame_dig 4
    frame_dig 7
    callsub arc58OptInAndSendReactionPayments

createReaction_after_if_else@13:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:711
    // if (reactionExists) {
    frame_dig 5
    bz createReaction_else_body@15
    // smart_contracts/arc58/plugins/social/contract.algo.ts:712
    // this.reactions(reactionKey).value += 1
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    +
    itob
    box_put

createReaction_after_if_else@16:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:717
    // this.reactionlist(reactionListKey).create()
    frame_dig 0
    intc_0 // 0
    box_create
    pop
    frame_dig 12
    frame_bury 0
    retsub

createReaction_else_body@15:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:714
    // this.reactions(reactionKey).value = 1
    intc_1 // 1
    itob
    frame_dig 1
    swap
    box_put
    b createReaction_after_if_else@16

createReaction_else_body@10:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:704
    // this.arc59OptInAndSendReactionPayments(wallet, rekeyBack, Application(creatorMeta.walletID), mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    frame_dig 3
    frame_dig 4
    frame_dig 7
    callsub arc59OptInAndSendReactionPayments
    b createReaction_after_if_else@13

createReaction_else_body@12:
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:708
    // this.sendReactionPayments(wallet, rekeyBack, creatorOrigin, mbrAmount, tax)
    frame_dig -5
    frame_dig -4
    uncover 2
    frame_dig 4
    frame_dig 7
    callsub sendReactionPayments
    b createReaction_after_if_else@13

createReaction_ternary_false@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:697
    // const mbrAmount: uint64 = reactionExists ? reactionlist : reactions + reactionlist
    pushint 41000 // 41000
    frame_bury 4
    b createReaction_ternary_merge@7


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createApplication(version: bytes, akitaDAO: uint64, escrow: uint64) -> void:
createApplication:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:722-723
    // @abimethod({ onCreate: 'require' })
    // createApplication(version: string, akitaDAO: uint64, escrow: uint64): void {
    proto 3 0
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 21 // "version"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:724
    // this.version.value = version
    frame_dig -3
    app_global_put
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_1 // "akita_dao"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:725
    // this.akitaDAO.value = Application(akitaDAO)
    frame_dig -2
    app_global_put
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    bytec 8 // "akita_escrow"
    // smart_contracts/arc58/plugins/social/contract.algo.ts:726
    // this.akitaDAOEscrow.value = Application(escrow)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.post(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64) -> void:
post:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:731
    // post(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:732
    // this.createPost(Application(walletID), rekeyBack, cid, gateID, false)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createPost
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editPost(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, amendment: bytes) -> void:
editPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:735
    // editPost(walletID: uint64, rekeyBack: boolean, cid: CID, gateID: uint64, amendment: StaticBytes<32>): void {
    proto 5 0
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:738
    // assert(this.posts(amendment).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:739
    // const post = this.posts(amendment).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 49 // 49
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:90
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:740
    // assert(this.isCreator(post.creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:741
    // assert(!this.isReply(post.ref), ERR_IS_A_REPLY)
    dup
    callsub isReply
    !
    assert // Is a reply
    // smart_contracts/arc58/plugins/social/contract.algo.ts:742
    // assert(!this.isAmended(post.ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/arc58/plugins/social/contract.algo.ts:746
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    bytec 14 // "a"
    txn TxID
    concat
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:745
    // ...this.posts(amendment).value,
    dig 1
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    dig 2
    box_get
    assert // Box must have value
    intc_3 // 32
    extract_uint64
    dig 3
    box_get
    assert // Box must have value
    pushint 40 // 40
    extract_uint64
    dig 4
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 5
    box_get
    assert // Box must have value
    intc 4 // 385
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:744-747
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    dig 6
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:745
    // ...this.posts(amendment).value,
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:746
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:744
    // this.posts(amendment).value = {
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:744-747
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749-756
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:752
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:753
    // amount: 13_200, // (400 * 33) 'a' + txid
    pushint 13200 // 13200
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749-755
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:749-756
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:758
    // this.createPost(Application(walletID), rekeyBack, cid, gateID, true)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    intc_1 // 1
    callsub createPost
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyPost(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes) -> void:
replyPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:761
    // replyPost(walletID: uint64, rekeyBack: boolean, cid: CID, ref: StaticBytes<32>, gateID: uint64, args: GateArgs): void {
    proto 6 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:762
    // this.createReply(Application(walletID), rekeyBack, cid, ref, gateID, args, false)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    intc_0 // 0
    callsub createReply
    frame_bury -1
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAsset(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:765
    // replyAsset(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:766
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:767
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:768
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:769
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:770
    // this.createReply(Application(walletID), rekeyBack, cid, paddedRef, gateID, new DynamicArray<DynamicBytes>(), false)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    uncover 3
    frame_dig -1
    bytec 10 // 0x0000
    intc_0 // 0
    callsub createReply
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAddress(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: bytes, gateID: uint64, args: bytes) -> void:
replyAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:773
    // replyAddress(walletID: uint64, rekeyBack: boolean, cid: CID, ref: Address, gateID: uint64, args: GateArgs): void {
    proto 6 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:775
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz replyAddress_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:776
    // const meta = this.meta(ref.native).value
    frame_dig 2
    box_get
    assert // Box must have value
    pushint 57 // 57
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:778
    // if (meta.addressGateID !== 0) {
    bz replyAddress_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:779
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), meta.addressGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 1
    frame_dig -1
    callsub gateCheck
    frame_bury -1
    assert // Gate check failed

replyAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:784
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -3
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:785
    // this.createReply(wallet, rekeyBack, cid, r, gateID, new DynamicArray<DynamicBytes>(), false)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    bytec 10 // 0x0000
    intc_0 // 0
    callsub createReply
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyApp(walletID: uint64, rekeyBack: uint64, cid: bytes, ref: uint64, gateID: uint64) -> void:
replyApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:788
    // replyApp(walletID: uint64, rekeyBack: boolean, cid: CID, ref: uint64, gateID: uint64): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:789
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:790
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:791
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:792
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:793
    // this.createReply(Application(walletID), rekeyBack, cid, paddedRef, gateID, new DynamicArray<DynamicBytes>(), false)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    uncover 3
    frame_dig -1
    bytec 10 // 0x0000
    intc_0 // 0
    callsub createReply
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editReply(walletID: uint64, rekeyBack: uint64, cid: bytes, gateID: uint64, args: bytes, amendment: bytes) -> void:
editReply:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:796-803
    // editReply(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   cid: CID,
    //   gateID: uint64,
    //   args: GateArgs,
    //   amendment: StaticBytes<32>
    // ): void {
    proto 6 0
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:806
    // assert(this.posts(amendment).exists, ERR_REPLY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Reply not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:807
    // const post = this.posts(amendment).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    pushint 49 // 49
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:90
    // return creator === origin
    uncover 2
    ==
    // smart_contracts/arc58/plugins/social/contract.algo.ts:808
    // assert(this.isCreator(post.creator, wallet), ERR_NOT_YOUR_POST_TO_EDIT)
    assert // Not your post to edit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:809
    // assert(this.isReply(post.ref), ERR_NOT_A_REPLY)
    dup
    callsub isReply
    assert // Not a reply
    // smart_contracts/arc58/plugins/social/contract.algo.ts:810
    // assert(!this.isAmended(post.ref), ERR_IS_ALREADY_AMENDED)
    dup
    callsub isAmended
    !
    assert // Is already amended
    // smart_contracts/arc58/plugins/social/contract.algo.ts:814
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    bytec 14 // "a"
    txn TxID
    concat
    dig 1
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:813
    // ...this.posts(amendment).value,
    dig 2
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    dig 3
    box_get
    assert // Box must have value
    intc_3 // 32
    extract_uint64
    dig 4
    box_get
    assert // Box must have value
    pushint 40 // 40
    extract_uint64
    dig 5
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 6
    box_get
    assert // Box must have value
    intc 4 // 385
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:812-815
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    dig 7
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:813
    // ...this.posts(amendment).value,
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:814
    // ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:812
    // this.posts(amendment).value = {
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:812-815
    // this.posts(amendment).value = {
    //   ...this.posts(amendment).value,
    //   ref: post.ref.concat(Bytes('a').concat(Txn.txId))
    // }
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817-824
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:820
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:821
    // amount: 13_200, // (400 * 33) 'a' + txid
    pushint 13200 // 13200
    itxn_field Amount
    itxn_field Receiver
    swap
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817-823
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:817-824
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: 13_200, // (400 * 33) 'a' + txid
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:826
    // const originalPostRef = bytes32(post.ref.slice(0, 32))
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_3 // 32
    dig 2
    >=
    intc_3 // 32
    uncover 3
    uncover 2
    select
    substring3
    // smart_contracts/utils/types/base.ts:25
    // return new arc4.StaticBytes<32>(value)
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/social/contract.algo.ts:827
    // this.createReply(wallet, rekeyBack, cid, originalPostRef, gateID, args, true)
    frame_dig -6
    frame_dig -5
    frame_dig -4
    uncover 3
    frame_dig -3
    frame_dig -2
    intc_1 // 1
    callsub createReply
    frame_bury -2
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.votePost(walletID: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
votePost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:830
    // votePost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:831
    // this.createVote(Application(walletID), rekeyBack, ref, isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAsset(walletID: uint64, rekeyBack: uint64, ref: uint64, isUp: uint64) -> void:
voteAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:834
    // voteAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:835
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:836
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:837
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:838
    // this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:839
    // this.createVote(Application(walletID), rekeyBack, paddedRef, isUp)
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAddress(walletID: uint64, rekeyBack: uint64, ref: bytes, isUp: uint64) -> void:
voteAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:842
    // voteAddress(walletID: uint64, rekeyBack: boolean, ref: Address, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:844
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -2
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:845
    // this.createVote(Application(walletID), rekeyBack, r, isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteApp(walletID: uint64, rekeyBack: uint64, ref: uint64, isUp: uint64) -> void:
voteApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:848
    // voteApp(walletID: uint64, rekeyBack: boolean, ref: uint64, isUp: boolean): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:849
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:850
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:851
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:852
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:853
    // this.createVote(Application(walletID), rekeyBack, paddedRef, isUp)
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editVote(walletID: uint64, rekeyBack: uint64, ref: bytes, flip: uint64) -> void:
editVote:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:856
    // editVote(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, flip: boolean): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:397
    // user: bytes16(account.bytes),
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:398
    // ref: bytes16(ref.bytes),
    frame_dig -2
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:396-399
    // return new arc4VoteListKey({
    //   user: bytes16(account.bytes),
    //   ref: bytes16(ref.bytes),
    // })
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:859
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    dup
    extract 0 16 // on error: Index access is out of bounds
    swap
    extract 16 16 // on error: Index access is out of bounds
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:7
    // export const AkitaSocialBoxPrefixVoteList = 'o'
    bytec 18 // "o"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:859
    // assert(this.votelist(voteListKey).exists, ERR_HAVENT_VOTED)
    box_len
    bury 1
    assert // You haven't voted on this
    // smart_contracts/arc58/plugins/social/contract.algo.ts:861
    // const { impact, isUp } = this.votelist(voteListKey).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 64 // 64
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:864
    // this.updateVotes(ref, !isUp, impact)
    !
    dup
    cover 2
    frame_dig -2
    swap
    uncover 2
    callsub updateVotes
    // smart_contracts/arc58/plugins/social/contract.algo.ts:865
    // if (!flip) {
    frame_dig -1
    bnz editVote_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:867
    // this.votelist(voteListKey).delete()
    frame_dig 0
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:868
    // return
    retsub

editVote_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:872
    // this.createVote(Application(walletID), rekeyBack, ref, !isUp)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig 1
    callsub createVote
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactPost(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> void:
reactPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:875
    // reactPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64, args: GateArgs): void {
    proto 5 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:876
    // this.createReaction(Application(walletID), rekeyBack, ref, NFT, args)
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub createReaction
    frame_bury -1
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAsset(walletID: uint64, rekeyBack: uint64, ref: uint64, NFT: uint64) -> void:
reactAsset:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:879
    // reactAsset(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:880
    // assert(ref !== 0, ERR_INVALID_ASSET)
    frame_dig -2
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:881
    // assert(Asset(ref).total > 0, ERR_INVALID_ASSET)
    frame_dig -2
    asset_params_get AssetTotal
    assert // asset exists
    assert // Invalid asset
    // smart_contracts/arc58/plugins/social/contract.algo.ts:882
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:883
    // this.createEmptyPostIfNecessary(paddedRef, Asset(ref).creator)
    frame_dig -2
    asset_params_get AssetCreator
    assert // asset exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:884
    // this.createReaction(Application(walletID), rekeyBack, paddedRef, NFT, new DynamicArray<DynamicBytes>())
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    bytec 10 // 0x0000
    callsub createReaction
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAddress(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64, args: bytes) -> void:
reactAddress:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:887
    // reactAddress(walletID: uint64, rekeyBack: boolean, ref: Address, NFT: uint64, args: GateArgs): void {
    proto 5 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -3
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:889
    // if (this.meta(ref.native).exists) {
    box_len
    bury 1
    bz reactAddress_after_if_else@4
    // smart_contracts/arc58/plugins/social/contract.algo.ts:890
    // const meta = this.meta(ref.native).value
    frame_dig 2
    box_get
    assert // Box must have value
    pushint 57 // 57
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -5
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:893
    // if (meta.addressGateID !== 0) {
    bz reactAddress_after_if_else@4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:894
    // assert(gateCheck(this.akitaDAO.value, new Address(senderAccount), meta.addressGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 1
    frame_dig -1
    callsub gateCheck
    frame_bury -1
    assert // Gate check failed

reactAddress_after_if_else@4:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:899
    // this.createEmptyPostIfNecessary(r, ref.native)
    frame_dig -3
    dup
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:900
    // this.createReaction(wallet, rekeyBack, r, NFT, new DynamicArray<DynamicBytes>())
    frame_dig -5
    frame_dig -4
    frame_dig -3
    frame_dig -2
    bytec 10 // 0x0000
    callsub createReaction
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactApp(walletID: uint64, rekeyBack: uint64, ref: uint64, NFT: uint64) -> void:
reactApp:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:903
    // reactApp(walletID: uint64, rekeyBack: boolean, ref: uint64, NFT: uint64): void {
    proto 4 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:904
    // assert(ref !== 0, ERR_INVALID_APP)
    frame_dig -2
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:905
    // assert(Application(ref).approvalProgram.length > 0, ERR_INVALID_APP)
    frame_dig -2
    app_params_get AppApprovalProgram
    assert // application exists
    len
    assert // Invalid App
    // smart_contracts/arc58/plugins/social/contract.algo.ts:906
    // const paddedRef = paddedBytes32(itob(ref))
    frame_dig -2
    itob
    callsub paddedBytes32
    // smart_contracts/arc58/plugins/social/contract.algo.ts:907
    // this.createEmptyPostIfNecessary(paddedRef, Application(ref).creator)
    frame_dig -2
    app_params_get AppCreator
    assert // application exists
    dig 1
    swap
    callsub createEmptyPostIfNecessary
    // smart_contracts/arc58/plugins/social/contract.algo.ts:908
    // this.createReaction(Application(walletID), rekeyBack, paddedRef, NFT, new DynamicArray<DynamicBytes>())
    frame_dig -4
    frame_dig -3
    uncover 2
    frame_dig -1
    bytec 10 // 0x0000
    callsub createReaction
    pop
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.deleteReaction(walletID: uint64, rekeyBack: uint64, ref: bytes, NFT: uint64) -> void:
deleteReaction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:911
    // deleteReaction(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>, NFT: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:914
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:915
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:916
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:917
    // const post = this.posts(ref).value
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/arc58/plugins/social/contract.algo.ts:918
    // assert(!this.isBlocked(post.creator, origin), ERR_BLOCKED)
    dig 1
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/contract.algo.ts:920
    // const reactionListKey: ReactionListKey = { user: bytes16(origin.bytes), ref: bytes16(ref.bytes), NFT }
    dup
    callsub bytes16
    frame_dig -2
    callsub bytes16
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:921
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    cover 2
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:9
    // export const AkitaSocialBoxPrefixReactionList = 'e'
    pushbytes "e"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:921
    // assert(this.reactionlist(reactionListKey).exists, ERR_ALREADY_REACTED)
    dup
    box_len
    bury 1
    assert // This account already reacted to this post with this NFT
    // smart_contracts/arc58/plugins/social/contract.algo.ts:923
    // this.reactions({ ref, NFT }).value -= 1
    frame_dig -2
    uncover 2
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:8
    // export const AkitaSocialBoxPrefixReactions = 'r'
    pushbytes "r"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:923
    // this.reactions({ ref, NFT }).value -= 1
    dup
    box_get
    assert // Box must have value
    btoi
    intc_1 // 1
    -
    itob
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:924
    // this.reactionlist(reactionListKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926-932
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:62
    // reactionlist: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926-931
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:926-932
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).reactionlist,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:934
    // if (rekeyBack) {
    frame_dig -3
    bz deleteReaction_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:935
    // this.rekeyBack(wallet)
    frame_dig -4
    callsub rekeyBack

deleteReaction_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.follow(walletID: uint64, rekeyBack: uint64, address: bytes, args: bytes) -> void:
follow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:939
    // follow(walletID: uint64, rekeyBack: boolean, address: Address, args: GateArgs): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:942
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:943
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:944
    // assert(!this.isBlocked(address.native, origin), ERR_BLOCKED)
    frame_dig -2
    dig 1
    callsub isBlocked
    !
    assert // This account is blocked by the user
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:946
    // const senderIsAutomated = this.meta(origin).value.automated
    box_get
    assert // Box must have value
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:947
    // assert(!senderIsAutomated, ERR_AUTOMATED_ACCOUNT)
    !
    assert // This is an automated account
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -2
    concat
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949
    // const meta = this.meta(address.native).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    swap
    dup
    pushint 8 // 8
    extract_uint64
    swap
    dup
    intc_2 // 16
    extract_uint64
    swap
    dup
    pushint 24 // 24
    extract_uint64
    swap
    dup
    intc_3 // 32
    extract_uint64
    swap
    dup
    pushint 40 // 40
    extract_uint64
    swap
    dup
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    dup
    pushint 49 // 49
    extract_uint64
    dup
    uncover 2
    pushint 57 // 57
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/social/contract.algo.ts:951
    // if (meta.followGateID !== 0) {
    bz follow_after_if_else@2
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:952
    // assert(gateCheck(this.akitaDAO.value, new Address(origin), meta.followGateID, args), ERR_FAILED_GATE)
    frame_dig 0
    frame_dig 10
    frame_dig -1
    callsub gateCheck
    frame_bury -1
    assert // Gate check failed

follow_after_if_else@2:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:956
    // const followsKey: FollowsKey = { user: address.native, index: (followerIndex + 1) }
    frame_dig 7
    intc_1 // 1
    +
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:957
    // this.follows(followsKey).value = origin
    frame_dig -2
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:957
    // this.follows(followsKey).value = origin
    frame_dig 0
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:962
    // followerCount: (meta.followerCount + 1),
    frame_dig 8
    intc_1 // 1
    +
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949
    // const meta = this.meta(address.native).value
    frame_dig 3
    itob
    frame_dig 4
    itob
    frame_dig 5
    itob
    frame_dig 6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:962
    // followerCount: (meta.followerCount + 1),
    uncover 4
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:949
    // const meta = this.meta(address.native).value
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 9
    setbit
    frame_dig 10
    itob
    frame_dig 11
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:959
    // this.meta(address.native).value = {
    uncover 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:959-963
    // this.meta(address.native).value = {
    //   ...meta,
    //   followerIndex: (followerIndex + 1),
    //   followerCount: (meta.followerCount + 1),
    // }
    frame_dig 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:965-973
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:968
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:970
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:56
    // follows: 31_700,
    intc 11 // 31700
    itxn_field Amount
    itxn_field Receiver
    frame_dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:965-972
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:965-973
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).follows,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unfollow(walletID: uint64, rekeyBack: uint64, address: bytes, index: uint64) -> void:
unfollow:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:976
    // unfollow(walletID: uint64, rekeyBack: boolean, address: Address, index: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:980
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:981
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:983
    // const followsKey = { user: address.native, index }
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:984
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    frame_dig -2
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:984
    // assert(this.follows(followsKey).value === origin, ERR_WRONG_FOLLOWER_KEY)
    dup
    box_get
    assert // Box must have value
    dig 2
    ==
    assert // Wrong follower key
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:986
    // const meta = this.meta(address.native).value
    dup
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    dig 2
    intc_2 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    intc_3 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 7
    pushint 49 // 49
    extract_uint64
    uncover 8
    pushint 57 // 57
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:989
    // followerCount: (meta.followerCount - 1)
    uncover 3
    intc_1 // 1
    -
    // smart_contracts/arc58/plugins/social/contract.algo.ts:986
    // const meta = this.meta(address.native).value
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    uncover 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:989
    // followerCount: (meta.followerCount - 1)
    uncover 5
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:986
    // const meta = this.meta(address.native).value
    bytec_0 // 0x00
    intc_0 // 0
    uncover 10
    setbit
    uncover 8
    itob
    uncover 8
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:987
    // this.meta(address.native).value = {
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:987-990
    // this.meta(address.native).value = {
    //   ...meta,
    //   followerCount: (meta.followerCount - 1)
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:992
    // this.follows(followsKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:994-1000
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:56
    // follows: 31_700,
    intc 11 // 31700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:994-999
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:994-1000
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).follows,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1002
    // if (rekeyBack) {
    frame_dig -3
    bz unfollow_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1003
    // this.rekeyBack(wallet)
    frame_dig -4
    callsub rekeyBack

unfollow_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.block(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
block:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1009
    // block(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1012
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1013
    // assert(!this.isBanned(origin), ERR_BANNED)
    dig 1
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1016
    // user: bytes16(origin.bytes),
    swap
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1017
    // blocked: bytes16(address.bytes),
    frame_dig -1
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1015-1018
    // const blocksKey = new arc4BlockListKey({
    //   user: bytes16(origin.bytes),
    //   blocked: bytes16(address.bytes),
    // })
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1019
    // this.blocks(blocksKey).create()
    dup
    extract 0 16 // on error: Index access is out of bounds
    swap
    extract 16 16 // on error: Index access is out of bounds
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 16 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1019
    // this.blocks(blocksKey).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1021-1029
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1024
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1026
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -2
    frame_dig -3
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:57
    // blocks: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1021-1028
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1021-1029
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).blocks,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unblock(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
unblock:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1032
    // unblock(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1035
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1036
    // assert(!this.isBanned(origin), ERR_BANNED)
    dup
    callsub isBanned
    !
    assert // This account is banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1039
    // user: bytes16(origin.bytes),
    dup
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1040
    // blocked: bytes16(address.bytes),
    frame_dig -1
    callsub bytes16
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1042
    // this.blocks(blocksKey).delete()
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:4
    // export const AkitaSocialBoxPrefixBlocks = 'b'
    bytec 16 // "b"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1042
    // this.blocks(blocksKey).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044-1050
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:57
    // blocks: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044-1049
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1044-1050
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).blocks,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1052
    // if (rekeyBack) {
    frame_dig -2
    bz unblock_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1053
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

unblock_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addModerator(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
addModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1057
    // addModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1060
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1061
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 13 // "d"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1062
    // assert(!this.moderators(address.native).exists, ERR_ALREADY_A_MODERATOR)
    dup
    box_len
    bury 1
    !
    assert // Already a moderator
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1064
    // this.moderators(address.native).create()
    intc_0 // 0
    box_create
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1066-1074
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1069
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1071
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -2
    frame_dig -3
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:64
    // moderators: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1066-1073
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1066-1074
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).moderators,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeModerator(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
removeModerator:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1077
    // removeModerator(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1080
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1081
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 13 // "d"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1082
    // assert(this.moderators(address.native).exists, ERR_NOT_A_MODERATOR)
    dup
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1084
    // this.moderators(address.native).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1086-1092
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:64
    // moderators: 15_700,
    intc 8 // 15700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1086-1091
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1086-1092
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).moderators,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1094
    // if (rekeyBack) {
    frame_dig -2
    bz removeModerator_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1095
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

removeModerator_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.ban(walletID: uint64, rekeyBack: uint64, address: bytes, expiration: uint64) -> void:
ban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1099
    // ban(walletID: uint64, rekeyBack: boolean, address: Address, expiration: uint64): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -4
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1102
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 13 // "d"
    uncover 2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1103
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 15 // "n"
    frame_dig -2
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1104
    // assert(!this.banned(address.native).exists, ERR_ALREADY_BANNED)
    dup
    box_len
    bury 1
    !
    assert // This account is already banned
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1105
    // this.banned(address.native).value = expiration
    frame_dig -1
    itob
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1107-1115
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1110
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1112
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:65
    // banned: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1107-1114
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1107-1115
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).banned,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.flagPost(walletID: uint64, rekeyBack: uint64, ref: bytes) -> void:
flagPost:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1118
    // flagPost(walletID: uint64, rekeyBack: boolean, ref: StaticBytes<32>): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1121
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 13 // "d"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1122
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:5
    // export const AkitaSocialBoxPrefixPosts = 'p'
    bytec 6 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1123
    // assert(this.posts(ref).exists, ERR_POST_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Post not found
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1124
    // const post = this.posts(ref).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    intc_3 // 32
    extract_uint64
    dig 2
    pushint 40 // 40
    extract_uint64
    dig 3
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 4
    intc 4 // 385
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 5
    pushint 49 // 49
    extract_uint16
    dig 6
    len
    uncover 7
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1125
    // assert(!post.againstContentPolicy, ERR_ALREADY_FLAGGED)
    uncover 2
    !
    assert // Already flagged
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127-1130
    // this.posts(ref).value = {
    //   ...post,
    //   againstContentPolicy: true
    // }
    dig 5
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1124
    // const post = this.posts(ref).value
    uncover 3
    itob
    uncover 3
    itob
    bytec_0 // 0x00
    intc_0 // 0
    uncover 5
    setbit
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127
    // this.posts(ref).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1129
    // againstContentPolicy: true
    bytec 17 // 0x80
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127
    // this.posts(ref).value = {
    concat
    uncover 2
    intc_0 // 0
    getbit
    intc 4 // 385
    swap
    setbit
    bytec 12 // 0x0033
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1127-1130
    // this.posts(ref).value = {
    //   ...post,
    //   againstContentPolicy: true
    // }
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1132
    // if (rekeyBack) {
    frame_dig -2
    bz flagPost_after_if_else@2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1133
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

flagPost_after_if_else@2:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unban(walletID: uint64, rekeyBack: uint64, address: bytes) -> void:
unban:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1137
    // unban(walletID: uint64, rekeyBack: boolean, address: Address): void {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1140
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:11
    // export const AkitaSocialBoxPrefixModerators = 'd'
    bytec 13 // "d"
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1141
    // assert(this.moderators(origin).exists, ERR_NOT_A_MODERATOR)
    box_len
    bury 1
    assert // Sender is not a moderator
    // smart_contracts/arc58/plugins/social/constants.ts:12
    // export const AkitaSocialBoxPrefixBanned = 'n'
    bytec 15 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1142
    // this.banned(address.native).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144-1150
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:65
    // banned: 18_900,
    intc 7 // 18900
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144-1149
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1144-1150
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).banned,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1152
    // if (rekeyBack) {
    frame_dig -2
    bz unban_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1153
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

unban_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addAction(walletID: uint64, rekeyBack: uint64, actionAppID: uint64, content: bytes) -> void:
addAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1157
    // addAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64, content: CID) {
    proto 4 0
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1160
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    dup
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1161
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -4
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1162
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/social/constants.ts:13
    // export const AkitaSocialBoxPrefixActions = 'a'
    bytec 14 // "a"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1162
    // assert(!this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    !
    assert // Already an action
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1164
    // this.actions(actionAppID).value = { content }
    frame_dig -1
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1166-1174
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1169
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1171
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/arc58/plugins/social/contract.algo.ts:66
    // actions: 29_700
    intc 12 // 29700
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1166-1173
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1166-1174
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.mbr(Bytes('')).actions,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeAction(walletID: uint64, rekeyBack: uint64, actionAppID: uint64) -> void:
removeAction:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1177
    // removeAction(walletID: uint64, rekeyBack: boolean, actionAppID: uint64) {
    proto 3 0
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -3
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1180
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1181
    // assert(wallet === this.akitaDAO.value, ERR_NOT_DAO)
    frame_dig -3
    ==
    assert // Not the DAO
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1182
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/constants.ts:13
    // export const AkitaSocialBoxPrefixActions = 'a'
    bytec 14 // "a"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1182
    // assert(this.actions(actionAppID).exists, ERR_ALREADY_AN_ACTION)
    dup
    box_len
    bury 1
    assert // Already an action
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1184
    // this.actions(actionAppID).delete()
    box_del
    pop
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1186-1192
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/social/contract.algo.ts:66
    // actions: 29_700
    intc 12 // 29700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1186-1191
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1186-1192
    // itxn
    //   .payment({
    //     receiver: origin,
    //     amount: this.mbr(Bytes('')).actions,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1194
    // if (rekeyBack) {
    frame_dig -2
    bz removeAction_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1195
    // this.rekeyBack(wallet)
    frame_dig -3
    callsub rekeyBack

removeAction_after_if_else@3:
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.initMeta(walletID: uint64, rekeyBack: uint64, automated: uint64, subscriptionIndex: uint64, NFD: uint64, akitaNFT: uint64) -> uint64:
initMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1199-1206
    // initMeta(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   automated: boolean,
    //   subscriptionIndex: uint64,
    //   NFD: uint64,
    //   akitaNFT: uint64
    // ): uint64 {
    proto 6 1
    pushbytes ""
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/utils/functions.ts:100-103
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_3 // "spending_address"
    // smart_contracts/utils/functions.ts:157-160
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    // smart_contracts/utils/functions.ts:150
    // walletAddress: wallet.address,
    frame_dig -6
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1210
    // assert(this.controls(sender), ERR_PLUGIN_NOT_AUTH_ADDR)
    callsub controls
    assert // This plugin does not have control of the account
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    swap
    concat
    dup
    cover 2
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1211
    // assert(!this.meta(origin).exists, ERR_META_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // Meta box values already exist
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1214
    // if (automated) {
    frame_dig -4
    bz initMeta_after_if_else@3
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1218
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1219
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1216
    // walletID: walletID,
    frame_dig -6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1217
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1218
    // startDate: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1219
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1220
    // followerIndex: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1215
    // this.meta(origin).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1222
    // automated: true,
    bytec 17 // 0x80
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1215
    // this.meta(origin).value = {
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1215-1225
    // this.meta(origin).value = {
    //   walletID: walletID,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: true,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    uncover 3
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227-1235
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227-1235
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    bytec 22 // method "cacheMeta(uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1227-1235
    // abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [0, 0, 0],
    //     fee,
    //   }
    // )
    itxn_submit
    itxn LastLog
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1237
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

initMeta_after_if_else@3:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1243
    // startDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1244
    // lastActive: Global.latestTimestamp,
    dup
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1241
    // walletID: walletID,
    frame_dig -6
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1242
    // streak: 1,
    intc_1 // 1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1243
    // startDate: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1244
    // lastActive: Global.latestTimestamp,
    uncover 3
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1245
    // followerIndex: 0,
    intc_0 // 0
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1240
    // this.meta(origin).value = {
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    concat
    dig 1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1247
    // automated: false,
    bytec_0 // 0x00
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1240
    // this.meta(origin).value = {
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1240-1250
    // this.meta(origin).value = {
    //   walletID: walletID,
    //   streak: 1,
    //   startDate: Global.latestTimestamp,
    //   lastActive: Global.latestTimestamp,
    //   followerIndex: 0,
    //   followerCount: 0,
    //   automated: false,
    //   followGateID: 0,
    //   addressGateID: 0,
    // }
    uncover 2
    swap
    box_put
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1252-1260
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 11 // "plugn_al"
    // smart_contracts/utils/functions.ts:28
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:29
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_2 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1257
    // args: [subscriptionIndex, NFD, akitaNFT],
    frame_dig -3
    itob
    frame_dig -2
    itob
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1252-1260
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    bytec 22 // method "cacheMeta(uint64,uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1252-1260
    // const impact = abiCall(
    //   AkitaSocialImpact.prototype.cacheMeta,
    //   {
    //     sender,
    //     appId: getPluginAppList(this.akitaDAO.value).impact,
    //     args: [subscriptionIndex, NFD, akitaNFT],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    frame_bury 0
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1262
    // if (rekeyBack) {
    frame_dig -5
    bz initMeta_after_if_else@6
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1263
    // this.rekeyBack(wallet)
    frame_dig -6
    callsub rekeyBack

initMeta_after_if_else@6:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1266
    // return impact + this.getSocialImpactScore(origin)
    frame_dig 1
    callsub getSocialImpactScore
    frame_dig 0
    +
    frame_bury 0
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserSocialImpact(user: bytes) -> uint64:
getUserSocialImpact:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1271-1272
    // @abimethod({ readonly: true })
    // getUserSocialImpact(user: Address): uint64 {
    proto 1 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1273
    // return this.getSocialImpactScore(user.native)
    frame_dig -1
    callsub getSocialImpactScore
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isFollower(user: bytes, index: uint64, follower: bytes) -> uint64:
isFollower:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1276-1277
    // @abimethod({ readonly: true })
    // isFollower(user: Address, index: uint64, follower: Address): boolean {
    proto 3 1
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1278
    // return this.follows({ user: user.native, index }).value === follower.native
    frame_dig -2
    itob
    frame_dig -3
    swap
    concat
    // smart_contracts/arc58/plugins/social/constants.ts:3
    // export const AkitaSocialBoxPrefixFollows = 'f'
    bytec 19 // "f"
    swap
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1278
    // return this.follows({ user: user.native, index }).value === follower.native
    box_get
    assert // Box must have value
    frame_dig -1
    ==
    retsub


// smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getMeta(user: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64:
getMeta:
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1281-1282
    // @abimethod({ readonly: true })
    // getMeta(user: Address): MetaValue {
    proto 1 9
    // smart_contracts/arc58/plugins/social/constants.ts:10
    // export const AkitaSocialBoxPrefixMeta = 'm'
    bytec 4 // "m"
    frame_dig -1
    concat
    // smart_contracts/arc58/plugins/social/contract.algo.ts:1283
    // return this.meta(user.native).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 8 // 8
    extract_uint64
    dig 2
    intc_2 // 16
    extract_uint64
    dig 3
    pushint 24 // 24
    extract_uint64
    dig 4
    intc_3 // 32
    extract_uint64
    dig 5
    pushint 40 // 40
    extract_uint64
    dig 6
    intc 5 // 384
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 7
    pushint 49 // 49
    extract_uint64
    uncover 8
    pushint 57 // 57
    extract_uint64
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateApplication(newVersion: bytes) -> void:
updateApplication:
    // smart_contracts/utils/base-contracts/base.ts:78-79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:80
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:80
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    bytec 21 // "version"
    // smart_contracts/utils/base-contracts/base.ts:81
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:86
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:87
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:87
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_1 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:88
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/base.ts:91
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:92
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_1 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/base.ts:92
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    bytec 8 // "akita_escrow"
    // smart_contracts/utils/base-contracts/base.ts:93
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
