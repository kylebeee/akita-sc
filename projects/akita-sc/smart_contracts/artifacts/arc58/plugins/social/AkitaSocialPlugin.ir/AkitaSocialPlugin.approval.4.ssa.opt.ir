main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        let tmp%0#1: uint64 = (txn NumAppArgs)
        goto tmp%0#1 ? block@2 : block@43
    block@2: // abi_routing_L27
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "create(string,uint64,uint64)void" => block@3, method "post(uint64,bool,byte[36],uint64)void" => block@4, method "editPost(uint64,bool,byte[36],uint64,byte[32])void" => block@5, method "replyPost(uint64,bool,byte[36],byte[32],uint64,byte[][])void" => block@6, method "replyAsset(uint64,bool,byte[36],uint64,uint64)void" => block@7, method "replyAddress(uint64,bool,byte[36],address,uint64,byte[][])void" => block@8, method "replyApp(uint64,bool,byte[36],uint64,uint64)void" => block@9, method "editReply(uint64,bool,byte[36],uint64,byte[][],byte[32])void" => block@10, method "votePost(uint64,bool,byte[32],bool)void" => block@11, method "voteAsset(uint64,bool,uint64,bool)void" => block@12, method "voteAddress(uint64,bool,address,bool)void" => block@13, method "voteApp(uint64,bool,uint64,bool)void" => block@14, method "editVote(uint64,bool,byte[32],bool)void" => block@15, method "reactPost(uint64,bool,byte[32],uint64,byte[][])void" => block@16, method "reactAsset(uint64,bool,uint64,uint64)void" => block@17, method "reactAddress(uint64,bool,address,uint64,byte[][])void" => block@18, method "reactApp(uint64,bool,uint64,uint64)void" => block@19, method "deleteReaction(uint64,bool,byte[32],uint64)void" => block@20, method "follow(uint64,bool,address,byte[][])void" => block@21, method "unfollow(uint64,bool,address,uint64)void" => block@22, method "block(uint64,bool,address)void" => block@23, method "unblock(uint64,bool,address)void" => block@24, method "addModerator(uint64,bool,address)void" => block@25, method "removeModerator(uint64,bool,address)void" => block@26, method "ban(uint64,bool,address,uint64)void" => block@27, method "flagPost(uint64,bool,byte[32])void" => block@28, method "unban(uint64,bool,address)void" => block@29, method "addAction(uint64,bool,uint64,byte[36])void" => block@30, method "removeAction(uint64,bool,uint64)void" => block@31, method "initMeta(uint64,bool,bool,uint64,uint64,uint64)uint64" => block@32, method "getUserSocialImpact(address)uint64" => block@33, method "isFollower(address,uint64,address)bool" => block@34, method "getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)" => block@35, method "gas()void" => block@36, method "update(string)void" => block@37, method "updateAkitaDAO(uint64)void" => block@38, method "updateAkitaDAOEscrow(uint64)void" => block@39, * => block@43}
    block@3: // create_route_L746
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (! tmp%5#0)
        (assert tmp%6#0) // can only call when creating
        let tmp%7#0: bytes = (txna ApplicationArgs 1)
        let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%9#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%10#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.create(tmp%8#0, tmp%9#0, tmp%10#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#0: bool = 1u
        goto block@44
    block@4: // post_route_L755
        let tmp%11#0: uint64 = (txn OnCompletion)
        let tmp%12#0: bool = (! tmp%11#0)
        (assert tmp%12#0) // OnCompletion is not NoOp
        let tmp%13#0: uint64 = (txn ApplicationID)
        (assert tmp%13#0) // can only call when not creating
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%15#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%16#0: bool = (getbit reinterpret_bytes[1]%0#0 0u)
        let reinterpret_bytes[36]%0#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%17#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.post(tmp%15#0, tmp%16#0, reinterpret_bytes[36]%0#0, tmp%17#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#1: bool = 1u
        goto block@44
    block@5: // editPost_route_L759
        let tmp%18#0: uint64 = (txn OnCompletion)
        let tmp%19#0: bool = (! tmp%18#0)
        (assert tmp%19#0) // OnCompletion is not NoOp
        let tmp%20#0: uint64 = (txn ApplicationID)
        (assert tmp%20#0) // can only call when not creating
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%22#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%23#0: bool = (getbit reinterpret_bytes[1]%1#0 0u)
        let reinterpret_bytes[36]%1#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%24#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 5)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editPost(tmp%22#0, tmp%23#0, reinterpret_bytes[36]%1#0, tmp%24#0, reinterpret_bytes[32]%0#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#2: bool = 1u
        goto block@44
    block@6: // replyPost_route_L785
        let tmp%25#0: uint64 = (txn OnCompletion)
        let tmp%26#0: bool = (! tmp%25#0)
        (assert tmp%26#0) // OnCompletion is not NoOp
        let tmp%27#0: uint64 = (txn ApplicationID)
        (assert tmp%27#0) // can only call when not creating
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%29#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%30#0: bool = (getbit reinterpret_bytes[1]%2#0 0u)
        let reinterpret_bytes[36]%2#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%31#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        let reinterpret_bytes[]%0#0: bytes[] = (txna ApplicationArgs 6)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyPost(tmp%29#0, tmp%30#0, reinterpret_bytes[36]%2#0, reinterpret_bytes[32]%1#0, tmp%31#0, reinterpret_bytes[]%0#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#3: bool = 1u
        goto block@44
    block@7: // replyAsset_route_L789
        let tmp%32#0: uint64 = (txn OnCompletion)
        let tmp%33#0: bool = (! tmp%32#0)
        (assert tmp%33#0) // OnCompletion is not NoOp
        let tmp%34#0: uint64 = (txn ApplicationID)
        (assert tmp%34#0) // can only call when not creating
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%36#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let reinterpret_bytes[1]%3#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%37#0: bool = (getbit reinterpret_bytes[1]%3#0 0u)
        let reinterpret_bytes[36]%3#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%38#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%39#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAsset(tmp%36#0, tmp%37#0, reinterpret_bytes[36]%3#0, tmp%38#0, tmp%39#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#4: bool = 1u
        goto block@44
    block@8: // replyAddress_route_L797
        let tmp%40#0: uint64 = (txn OnCompletion)
        let tmp%41#0: bool = (! tmp%40#0)
        (assert tmp%41#0) // OnCompletion is not NoOp
        let tmp%42#0: uint64 = (txn ApplicationID)
        (assert tmp%42#0) // can only call when not creating
        let reinterpret_bytes[8]%11#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%44#0: uint64 = (btoi reinterpret_bytes[8]%11#0)
        let reinterpret_bytes[1]%4#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%45#0: bool = (getbit reinterpret_bytes[1]%4#0 0u)
        let reinterpret_bytes[36]%4#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%12#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%46#0: uint64 = (btoi reinterpret_bytes[8]%12#0)
        let reinterpret_bytes[]%1#0: bytes[] = (txna ApplicationArgs 6)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAddress(tmp%44#0, tmp%45#0, reinterpret_bytes[36]%4#0, reinterpret_bytes[32]%2#0, tmp%46#0, reinterpret_bytes[]%1#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#5: bool = 1u
        goto block@44
    block@9: // replyApp_route_L812
        let tmp%47#0: uint64 = (txn OnCompletion)
        let tmp%48#0: bool = (! tmp%47#0)
        (assert tmp%48#0) // OnCompletion is not NoOp
        let tmp%49#0: uint64 = (txn ApplicationID)
        (assert tmp%49#0) // can only call when not creating
        let reinterpret_bytes[8]%13#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%51#0: uint64 = (btoi reinterpret_bytes[8]%13#0)
        let reinterpret_bytes[1]%5#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%52#0: bool = (getbit reinterpret_bytes[1]%5#0 0u)
        let reinterpret_bytes[36]%5#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%14#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%53#0: uint64 = (btoi reinterpret_bytes[8]%14#0)
        let reinterpret_bytes[8]%15#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%54#0: uint64 = (btoi reinterpret_bytes[8]%15#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyApp(tmp%51#0, tmp%52#0, reinterpret_bytes[36]%5#0, tmp%53#0, tmp%54#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#6: bool = 1u
        goto block@44
    block@10: // editReply_route_L820
        let tmp%55#0: uint64 = (txn OnCompletion)
        let tmp%56#0: bool = (! tmp%55#0)
        (assert tmp%56#0) // OnCompletion is not NoOp
        let tmp%57#0: uint64 = (txn ApplicationID)
        (assert tmp%57#0) // can only call when not creating
        let reinterpret_bytes[8]%16#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%59#0: uint64 = (btoi reinterpret_bytes[8]%16#0)
        let reinterpret_bytes[1]%6#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%60#0: bool = (getbit reinterpret_bytes[1]%6#0 0u)
        let reinterpret_bytes[36]%6#0: bytes[36] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%17#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%61#0: uint64 = (btoi reinterpret_bytes[8]%17#0)
        let reinterpret_bytes[]%2#0: bytes[] = (txna ApplicationArgs 5)
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 6)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editReply(tmp%59#0, tmp%60#0, reinterpret_bytes[36]%6#0, tmp%61#0, reinterpret_bytes[]%2#0, reinterpret_bytes[32]%3#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#7: bool = 1u
        goto block@44
    block@11: // votePost_route_L854
        let tmp%62#0: uint64 = (txn OnCompletion)
        let tmp%63#0: bool = (! tmp%62#0)
        (assert tmp%63#0) // OnCompletion is not NoOp
        let tmp%64#0: uint64 = (txn ApplicationID)
        (assert tmp%64#0) // can only call when not creating
        let reinterpret_bytes[8]%18#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%66#0: uint64 = (btoi reinterpret_bytes[8]%18#0)
        let reinterpret_bytes[1]%7#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%67#0: bool = (getbit reinterpret_bytes[1]%7#0 0u)
        let reinterpret_bytes[32]%4#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%8#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%68#0: bool = (getbit reinterpret_bytes[1]%8#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.votePost(tmp%66#0, tmp%67#0, reinterpret_bytes[32]%4#0, tmp%68#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#8: bool = 1u
        goto block@44
    block@12: // voteAsset_route_L858
        let tmp%69#0: uint64 = (txn OnCompletion)
        let tmp%70#0: bool = (! tmp%69#0)
        (assert tmp%70#0) // OnCompletion is not NoOp
        let tmp%71#0: uint64 = (txn ApplicationID)
        (assert tmp%71#0) // can only call when not creating
        let reinterpret_bytes[8]%19#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%73#0: uint64 = (btoi reinterpret_bytes[8]%19#0)
        let reinterpret_bytes[1]%9#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%74#0: bool = (getbit reinterpret_bytes[1]%9#0 0u)
        let reinterpret_bytes[8]%20#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%75#0: uint64 = (btoi reinterpret_bytes[8]%20#0)
        let reinterpret_bytes[1]%10#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%76#0: bool = (getbit reinterpret_bytes[1]%10#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAsset(tmp%73#0, tmp%74#0, tmp%75#0, tmp%76#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#9: bool = 1u
        goto block@44
    block@13: // voteAddress_route_L866
        let tmp%77#0: uint64 = (txn OnCompletion)
        let tmp%78#0: bool = (! tmp%77#0)
        (assert tmp%78#0) // OnCompletion is not NoOp
        let tmp%79#0: uint64 = (txn ApplicationID)
        (assert tmp%79#0) // can only call when not creating
        let reinterpret_bytes[8]%21#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%81#0: uint64 = (btoi reinterpret_bytes[8]%21#0)
        let reinterpret_bytes[1]%11#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%82#0: bool = (getbit reinterpret_bytes[1]%11#0 0u)
        let reinterpret_bytes[32]%5#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%12#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%83#0: bool = (getbit reinterpret_bytes[1]%12#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAddress(tmp%81#0, tmp%82#0, reinterpret_bytes[32]%5#0, tmp%83#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#10: bool = 1u
        goto block@44
    block@14: // voteApp_route_L872
        let tmp%84#0: uint64 = (txn OnCompletion)
        let tmp%85#0: bool = (! tmp%84#0)
        (assert tmp%85#0) // OnCompletion is not NoOp
        let tmp%86#0: uint64 = (txn ApplicationID)
        (assert tmp%86#0) // can only call when not creating
        let reinterpret_bytes[8]%22#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%88#0: uint64 = (btoi reinterpret_bytes[8]%22#0)
        let reinterpret_bytes[1]%13#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%89#0: bool = (getbit reinterpret_bytes[1]%13#0 0u)
        let reinterpret_bytes[8]%23#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%90#0: uint64 = (btoi reinterpret_bytes[8]%23#0)
        let reinterpret_bytes[1]%14#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%91#0: bool = (getbit reinterpret_bytes[1]%14#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteApp(tmp%88#0, tmp%89#0, tmp%90#0, tmp%91#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#11: bool = 1u
        goto block@44
    block@15: // editVote_route_L880
        let tmp%92#0: uint64 = (txn OnCompletion)
        let tmp%93#0: bool = (! tmp%92#0)
        (assert tmp%93#0) // OnCompletion is not NoOp
        let tmp%94#0: uint64 = (txn ApplicationID)
        (assert tmp%94#0) // can only call when not creating
        let reinterpret_bytes[8]%24#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%96#0: uint64 = (btoi reinterpret_bytes[8]%24#0)
        let reinterpret_bytes[1]%15#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%97#0: bool = (getbit reinterpret_bytes[1]%15#0 0u)
        let reinterpret_bytes[32]%6#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%16#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%98#0: bool = (getbit reinterpret_bytes[1]%16#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editVote(tmp%96#0, tmp%97#0, reinterpret_bytes[32]%6#0, tmp%98#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#12: bool = 1u
        goto block@44
    block@16: // reactPost_route_L899
        let tmp%99#0: uint64 = (txn OnCompletion)
        let tmp%100#0: bool = (! tmp%99#0)
        (assert tmp%100#0) // OnCompletion is not NoOp
        let tmp%101#0: uint64 = (txn ApplicationID)
        (assert tmp%101#0) // can only call when not creating
        let reinterpret_bytes[8]%25#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%103#0: uint64 = (btoi reinterpret_bytes[8]%25#0)
        let reinterpret_bytes[1]%17#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%104#0: bool = (getbit reinterpret_bytes[1]%17#0 0u)
        let reinterpret_bytes[32]%7#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%26#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%105#0: uint64 = (btoi reinterpret_bytes[8]%26#0)
        let reinterpret_bytes[]%3#0: bytes[] = (txna ApplicationArgs 5)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactPost(tmp%103#0, tmp%104#0, reinterpret_bytes[32]%7#0, tmp%105#0, reinterpret_bytes[]%3#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#13: bool = 1u
        goto block@44
    block@17: // reactAsset_route_L903
        let tmp%106#0: uint64 = (txn OnCompletion)
        let tmp%107#0: bool = (! tmp%106#0)
        (assert tmp%107#0) // OnCompletion is not NoOp
        let tmp%108#0: uint64 = (txn ApplicationID)
        (assert tmp%108#0) // can only call when not creating
        let reinterpret_bytes[8]%27#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%110#0: uint64 = (btoi reinterpret_bytes[8]%27#0)
        let reinterpret_bytes[1]%18#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%111#0: bool = (getbit reinterpret_bytes[1]%18#0 0u)
        let reinterpret_bytes[8]%28#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%112#0: uint64 = (btoi reinterpret_bytes[8]%28#0)
        let reinterpret_bytes[8]%29#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%113#0: uint64 = (btoi reinterpret_bytes[8]%29#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAsset(tmp%110#0, tmp%111#0, tmp%112#0, tmp%113#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#14: bool = 1u
        goto block@44
    block@18: // reactAddress_route_L911
        let tmp%114#0: uint64 = (txn OnCompletion)
        let tmp%115#0: bool = (! tmp%114#0)
        (assert tmp%115#0) // OnCompletion is not NoOp
        let tmp%116#0: uint64 = (txn ApplicationID)
        (assert tmp%116#0) // can only call when not creating
        let reinterpret_bytes[8]%30#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%118#0: uint64 = (btoi reinterpret_bytes[8]%30#0)
        let reinterpret_bytes[1]%19#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%119#0: bool = (getbit reinterpret_bytes[1]%19#0 0u)
        let reinterpret_bytes[32]%8#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%31#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%120#0: uint64 = (btoi reinterpret_bytes[8]%31#0)
        let reinterpret_bytes[]%4#0: bytes[] = (txna ApplicationArgs 5)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAddress(tmp%118#0, tmp%119#0, reinterpret_bytes[32]%8#0, tmp%120#0, reinterpret_bytes[]%4#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#15: bool = 1u
        goto block@44
    block@19: // reactApp_route_L927
        let tmp%121#0: uint64 = (txn OnCompletion)
        let tmp%122#0: bool = (! tmp%121#0)
        (assert tmp%122#0) // OnCompletion is not NoOp
        let tmp%123#0: uint64 = (txn ApplicationID)
        (assert tmp%123#0) // can only call when not creating
        let reinterpret_bytes[8]%32#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%125#0: uint64 = (btoi reinterpret_bytes[8]%32#0)
        let reinterpret_bytes[1]%20#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%126#0: bool = (getbit reinterpret_bytes[1]%20#0 0u)
        let reinterpret_bytes[8]%33#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%127#0: uint64 = (btoi reinterpret_bytes[8]%33#0)
        let reinterpret_bytes[8]%34#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%128#0: uint64 = (btoi reinterpret_bytes[8]%34#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactApp(tmp%125#0, tmp%126#0, tmp%127#0, tmp%128#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#16: bool = 1u
        goto block@44
    block@20: // deleteReaction_route_L935
        let tmp%129#0: uint64 = (txn OnCompletion)
        let tmp%130#0: bool = (! tmp%129#0)
        (assert tmp%130#0) // OnCompletion is not NoOp
        let tmp%131#0: uint64 = (txn ApplicationID)
        (assert tmp%131#0) // can only call when not creating
        let reinterpret_bytes[8]%35#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%133#0: uint64 = (btoi reinterpret_bytes[8]%35#0)
        let reinterpret_bytes[1]%21#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%134#0: bool = (getbit reinterpret_bytes[1]%21#0 0u)
        let reinterpret_bytes[32]%9#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%36#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%135#0: uint64 = (btoi reinterpret_bytes[8]%36#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.deleteReaction(tmp%133#0, tmp%134#0, reinterpret_bytes[32]%9#0, tmp%135#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#17: bool = 1u
        goto block@44
    block@21: // follow_route_L963
        let tmp%136#0: uint64 = (txn OnCompletion)
        let tmp%137#0: bool = (! tmp%136#0)
        (assert tmp%137#0) // OnCompletion is not NoOp
        let tmp%138#0: uint64 = (txn ApplicationID)
        (assert tmp%138#0) // can only call when not creating
        let reinterpret_bytes[8]%37#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%140#0: uint64 = (btoi reinterpret_bytes[8]%37#0)
        let reinterpret_bytes[1]%22#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%141#0: bool = (getbit reinterpret_bytes[1]%22#0 0u)
        let reinterpret_bytes[32]%10#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[]%5#0: bytes[] = (txna ApplicationArgs 4)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.follow(tmp%140#0, tmp%141#0, reinterpret_bytes[32]%10#0, reinterpret_bytes[]%5#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#18: bool = 1u
        goto block@44
    block@22: // unfollow_route_L1000
        let tmp%142#0: uint64 = (txn OnCompletion)
        let tmp%143#0: bool = (! tmp%142#0)
        (assert tmp%143#0) // OnCompletion is not NoOp
        let tmp%144#0: uint64 = (txn ApplicationID)
        (assert tmp%144#0) // can only call when not creating
        let reinterpret_bytes[8]%38#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%146#0: uint64 = (btoi reinterpret_bytes[8]%38#0)
        let reinterpret_bytes[1]%23#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%147#0: bool = (getbit reinterpret_bytes[1]%23#0 0u)
        let reinterpret_bytes[32]%11#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%39#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%148#0: uint64 = (btoi reinterpret_bytes[8]%39#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unfollow(tmp%146#0, tmp%147#0, reinterpret_bytes[32]%11#0, tmp%148#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#19: bool = 1u
        goto block@44
    block@23: // block_route_L1033
        let tmp%149#0: uint64 = (txn OnCompletion)
        let tmp%150#0: bool = (! tmp%149#0)
        (assert tmp%150#0) // OnCompletion is not NoOp
        let tmp%151#0: uint64 = (txn ApplicationID)
        (assert tmp%151#0) // can only call when not creating
        let reinterpret_bytes[8]%40#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%153#0: uint64 = (btoi reinterpret_bytes[8]%40#0)
        let reinterpret_bytes[1]%24#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%154#0: bool = (getbit reinterpret_bytes[1]%24#0 0u)
        let reinterpret_bytes[32]%12#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.block(tmp%153#0, tmp%154#0, reinterpret_bytes[32]%12#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#20: bool = 1u
        goto block@44
    block@24: // unblock_route_L1053
        let tmp%155#0: uint64 = (txn OnCompletion)
        let tmp%156#0: bool = (! tmp%155#0)
        (assert tmp%156#0) // OnCompletion is not NoOp
        let tmp%157#0: uint64 = (txn ApplicationID)
        (assert tmp%157#0) // can only call when not creating
        let reinterpret_bytes[8]%41#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%159#0: uint64 = (btoi reinterpret_bytes[8]%41#0)
        let reinterpret_bytes[1]%25#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%160#0: bool = (getbit reinterpret_bytes[1]%25#0 0u)
        let reinterpret_bytes[32]%13#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unblock(tmp%159#0, tmp%160#0, reinterpret_bytes[32]%13#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#21: bool = 1u
        goto block@44
    block@25: // addModerator_route_L1075
        let tmp%161#0: uint64 = (txn OnCompletion)
        let tmp%162#0: bool = (! tmp%161#0)
        (assert tmp%162#0) // OnCompletion is not NoOp
        let tmp%163#0: uint64 = (txn ApplicationID)
        (assert tmp%163#0) // can only call when not creating
        let reinterpret_bytes[8]%42#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%165#0: uint64 = (btoi reinterpret_bytes[8]%42#0)
        let reinterpret_bytes[1]%26#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%166#0: bool = (getbit reinterpret_bytes[1]%26#0 0u)
        let reinterpret_bytes[32]%14#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addModerator(tmp%165#0, tmp%166#0, reinterpret_bytes[32]%14#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#22: bool = 1u
        goto block@44
    block@26: // removeModerator_route_L1095
        let tmp%167#0: uint64 = (txn OnCompletion)
        let tmp%168#0: bool = (! tmp%167#0)
        (assert tmp%168#0) // OnCompletion is not NoOp
        let tmp%169#0: uint64 = (txn ApplicationID)
        (assert tmp%169#0) // can only call when not creating
        let reinterpret_bytes[8]%43#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%171#0: uint64 = (btoi reinterpret_bytes[8]%43#0)
        let reinterpret_bytes[1]%27#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%172#0: bool = (getbit reinterpret_bytes[1]%27#0 0u)
        let reinterpret_bytes[32]%15#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeModerator(tmp%171#0, tmp%172#0, reinterpret_bytes[32]%15#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#23: bool = 1u
        goto block@44
    block@27: // ban_route_L1117
        let tmp%173#0: uint64 = (txn OnCompletion)
        let tmp%174#0: bool = (! tmp%173#0)
        (assert tmp%174#0) // OnCompletion is not NoOp
        let tmp%175#0: uint64 = (txn ApplicationID)
        (assert tmp%175#0) // can only call when not creating
        let reinterpret_bytes[8]%44#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%177#0: uint64 = (btoi reinterpret_bytes[8]%44#0)
        let reinterpret_bytes[1]%28#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%178#0: bool = (getbit reinterpret_bytes[1]%28#0 0u)
        let reinterpret_bytes[32]%16#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%45#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%179#0: uint64 = (btoi reinterpret_bytes[8]%45#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.ban(tmp%177#0, tmp%178#0, reinterpret_bytes[32]%16#0, tmp%179#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#24: bool = 1u
        goto block@44
    block@28: // flagPost_route_L1136
        let tmp%180#0: uint64 = (txn OnCompletion)
        let tmp%181#0: bool = (! tmp%180#0)
        (assert tmp%181#0) // OnCompletion is not NoOp
        let tmp%182#0: uint64 = (txn ApplicationID)
        (assert tmp%182#0) // can only call when not creating
        let reinterpret_bytes[8]%46#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%184#0: uint64 = (btoi reinterpret_bytes[8]%46#0)
        let reinterpret_bytes[1]%29#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%185#0: bool = (getbit reinterpret_bytes[1]%29#0 0u)
        let reinterpret_bytes[32]%17#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.flagPost(tmp%184#0, tmp%185#0, reinterpret_bytes[32]%17#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#25: bool = 1u
        goto block@44
    block@29: // unban_route_L1155
        let tmp%186#0: uint64 = (txn OnCompletion)
        let tmp%187#0: bool = (! tmp%186#0)
        (assert tmp%187#0) // OnCompletion is not NoOp
        let tmp%188#0: uint64 = (txn ApplicationID)
        (assert tmp%188#0) // can only call when not creating
        let reinterpret_bytes[8]%47#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%190#0: uint64 = (btoi reinterpret_bytes[8]%47#0)
        let reinterpret_bytes[1]%30#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%191#0: bool = (getbit reinterpret_bytes[1]%30#0 0u)
        let reinterpret_bytes[32]%18#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unban(tmp%190#0, tmp%191#0, reinterpret_bytes[32]%18#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#26: bool = 1u
        goto block@44
    block@30: // addAction_route_L1175
        let tmp%192#0: uint64 = (txn OnCompletion)
        let tmp%193#0: bool = (! tmp%192#0)
        (assert tmp%193#0) // OnCompletion is not NoOp
        let tmp%194#0: uint64 = (txn ApplicationID)
        (assert tmp%194#0) // can only call when not creating
        let reinterpret_bytes[8]%48#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%196#0: uint64 = (btoi reinterpret_bytes[8]%48#0)
        let reinterpret_bytes[1]%31#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%197#0: bool = (getbit reinterpret_bytes[1]%31#0 0u)
        let reinterpret_bytes[8]%49#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%198#0: uint64 = (btoi reinterpret_bytes[8]%49#0)
        let reinterpret_bytes[36]%7#0: bytes[36] = (txna ApplicationArgs 4)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addAction(tmp%196#0, tmp%197#0, tmp%198#0, reinterpret_bytes[36]%7#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#27: bool = 1u
        goto block@44
    block@31: // removeAction_route_L1195
        let tmp%199#0: uint64 = (txn OnCompletion)
        let tmp%200#0: bool = (! tmp%199#0)
        (assert tmp%200#0) // OnCompletion is not NoOp
        let tmp%201#0: uint64 = (txn ApplicationID)
        (assert tmp%201#0) // can only call when not creating
        let reinterpret_bytes[8]%50#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%203#0: uint64 = (btoi reinterpret_bytes[8]%50#0)
        let reinterpret_bytes[1]%32#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%204#0: bool = (getbit reinterpret_bytes[1]%32#0 0u)
        let reinterpret_bytes[8]%51#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%205#0: uint64 = (btoi reinterpret_bytes[8]%51#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeAction(tmp%203#0, tmp%204#0, tmp%205#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#28: bool = 1u
        goto block@44
    block@32: // initMeta_route_L1217
        let tmp%206#0: uint64 = (txn OnCompletion)
        let tmp%207#0: bool = (! tmp%206#0)
        (assert tmp%207#0) // OnCompletion is not NoOp
        let tmp%208#0: uint64 = (txn ApplicationID)
        (assert tmp%208#0) // can only call when not creating
        let reinterpret_bytes[8]%52#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%210#0: uint64 = (btoi reinterpret_bytes[8]%52#0)
        let reinterpret_bytes[1]%33#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%211#0: bool = (getbit reinterpret_bytes[1]%33#0 0u)
        let reinterpret_bytes[1]%34#0: bytes[1] = (txna ApplicationArgs 3)
        let tmp%212#0: bool = (getbit reinterpret_bytes[1]%34#0 0u)
        let reinterpret_bytes[8]%53#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%213#0: uint64 = (btoi reinterpret_bytes[8]%53#0)
        let reinterpret_bytes[8]%54#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%214#0: uint64 = (btoi reinterpret_bytes[8]%54#0)
        let reinterpret_bytes[8]%55#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%215#0: uint64 = (btoi reinterpret_bytes[8]%55#0)
        let to_encode%0#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.initMeta(tmp%210#0, tmp%211#0, tmp%212#0, tmp%213#0, tmp%214#0, tmp%215#0)
        let val_as_bytes%0#0: bytes[8] = (itob to_encode%0#0)
        let tmp%216#0: bytes = (concat 0x151f7c75 val_as_bytes%0#0)
        (log tmp%216#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#29: bool = 1u
        goto block@44
    block@33: // getUserSocialImpact_route_L1289
        let tmp%217#0: uint64 = (txn OnCompletion)
        let tmp%218#0: bool = (! tmp%217#0)
        (assert tmp%218#0) // OnCompletion is not NoOp
        let tmp%219#0: uint64 = (txn ApplicationID)
        (assert tmp%219#0) // can only call when not creating
        let reinterpret_bytes[32]%19#0: bytes[32] = (txna ApplicationArgs 1)
        let to_encode%1#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserSocialImpact(reinterpret_bytes[32]%19#0)
        let val_as_bytes%1#0: bytes[8] = (itob to_encode%1#0)
        let tmp%221#0: bytes = (concat 0x151f7c75 val_as_bytes%1#0)
        (log tmp%221#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#30: bool = 1u
        goto block@44
    block@34: // isFollower_route_L1294
        let tmp%222#0: uint64 = (txn OnCompletion)
        let tmp%223#0: bool = (! tmp%222#0)
        (assert tmp%223#0) // OnCompletion is not NoOp
        let tmp%224#0: uint64 = (txn ApplicationID)
        (assert tmp%224#0) // can only call when not creating
        let reinterpret_bytes[32]%20#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[8]%56#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%226#0: uint64 = (btoi reinterpret_bytes[8]%56#0)
        let reinterpret_bytes[32]%21#0: bytes[32] = (txna ApplicationArgs 3)
        let to_encode%2#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isFollower(reinterpret_bytes[32]%20#0, tmp%226#0, reinterpret_bytes[32]%21#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u to_encode%2#0)
        let tmp%227#0: bytes = (concat 0x151f7c75 encoded_bool%0#0)
        (log tmp%227#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#31: bool = 1u
        goto block@44
    block@35: // getMeta_route_L1299
        let tmp%228#0: uint64 = (txn OnCompletion)
        let tmp%229#0: bool = (! tmp%228#0)
        (assert tmp%229#0) // OnCompletion is not NoOp
        let tmp%230#0: uint64 = (txn ApplicationID)
        (assert tmp%230#0) // can only call when not creating
        let reinterpret_bytes[32]%22#0: bytes[32] = (txna ApplicationArgs 1)
        let (elements_to_encode%0#0: uint64, elements_to_encode%1#0: uint64, elements_to_encode%2#0: uint64, elements_to_encode%3#0: uint64, elements_to_encode%4#0: uint64, elements_to_encode%5#0: uint64, elements_to_encode%6#0: bool, elements_to_encode%7#0: uint64, elements_to_encode%8#0: uint64) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getMeta(reinterpret_bytes[32]%22#0)
        let val_as_bytes%2#0: bytes[8] = (itob elements_to_encode%0#0)
        let val_as_bytes%3#0: bytes[8] = (itob elements_to_encode%1#0)
        let val_as_bytes%4#0: bytes[8] = (itob elements_to_encode%2#0)
        let val_as_bytes%5#0: bytes[8] = (itob elements_to_encode%3#0)
        let val_as_bytes%6#0: bytes[8] = (itob elements_to_encode%4#0)
        let val_as_bytes%7#0: bytes[8] = (itob elements_to_encode%5#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u elements_to_encode%6#0)
        let val_as_bytes%8#0: bytes[8] = (itob elements_to_encode%7#0)
        let val_as_bytes%9#0: bytes[8] = (itob elements_to_encode%8#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%2#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_bool%1#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%9#0)
        let tmp%232#0: bytes = (concat 0x151f7c75 encoded_tuple_buffer%9#0)
        (log tmp%232#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#32: bool = 1u
        goto block@44
    block@36: // gas_route_L1305
        let tmp%233#0: uint64 = (txn OnCompletion)
        let tmp%234#0: bool = (! tmp%233#0)
        (assert tmp%234#0) // OnCompletion is not NoOp
        let tmp%235#0: uint64 = (txn ApplicationID)
        (assert tmp%235#0) // can only call when not creating
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#33: bool = 1u
        goto block@44
    block@37: // update_route_L78
        let tmp%237#0: uint64 = (txn OnCompletion)
        let tmp%238#0: bool = (== tmp%237#0 UpdateApplication)
        (assert tmp%238#0) // OnCompletion is not UpdateApplication
        let tmp%239#0: uint64 = (txn ApplicationID)
        (assert tmp%239#0) // can only call when not creating
        let tmp%241#0: bytes = (txna ApplicationArgs 1)
        let tmp%242#0: bytes = ((extract 2 0) tmp%241#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.update(tmp%242#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#34: bool = 1u
        goto block@44
    block@38: // updateAkitaDAO_route_L86
        let tmp%243#0: uint64 = (txn OnCompletion)
        let tmp%244#0: bool = (! tmp%243#0)
        (assert tmp%244#0) // OnCompletion is not NoOp
        let tmp%245#0: uint64 = (txn ApplicationID)
        (assert tmp%245#0) // can only call when not creating
        let reinterpret_bytes[8]%57#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%247#0: uint64 = (btoi reinterpret_bytes[8]%57#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAO(tmp%247#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#35: bool = 1u
        goto block@44
    block@39: // updateAkitaDAOEscrow_route_L91
        let tmp%248#0: uint64 = (txn OnCompletion)
        let tmp%249#0: bool = (! tmp%248#0)
        (assert tmp%249#0) // OnCompletion is not NoOp
        let tmp%250#0: uint64 = (txn ApplicationID)
        (assert tmp%250#0) // can only call when not creating
        let reinterpret_bytes[8]%58#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%252#0: uint64 = (btoi reinterpret_bytes[8]%58#0)
        smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAOEscrow(tmp%252#0)
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#36: bool = 1u
        goto block@44
    block@43: // after_if_else_L27
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#37: bool = 0u
        goto block@44
    block@44: // after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router___L1
        let tmp%0#0: bool = φ(smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#0 <- block@3, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#1 <- block@4, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#2 <- block@5, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#3 <- block@6, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#4 <- block@7, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#5 <- block@8, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#6 <- block@9, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#7 <- block@10, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#8 <- block@11, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#9 <- block@12, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#10 <- block@13, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#11 <- block@14, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#12 <- block@15, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#13 <- block@16, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#14 <- block@17, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#15 <- block@18, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#16 <- block@19, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#17 <- block@20, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#18 <- block@21, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#19 <- block@22, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#20 <- block@23, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#21 <- block@24, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#22 <- block@25, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#23 <- block@26, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#24 <- block@27, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#25 <- block@28, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#26 <- block@29, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#27 <- block@30, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#28 <- block@31, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#29 <- block@32, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#30 <- block@33, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#31 <- block@34, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#32 <- block@35, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#33 <- block@36, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#34 <- block@37, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#35 <- block@38, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#36 <- block@39, smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.__puya_arc4_router__%0#37 <- block@43)
        return tmp%0#0

subroutine smart_contracts/utils/functions.ts::impactRange(impact: uint64, min: uint64, max: uint64) -> uint64:
    block@0: // L85
        let tmp%0#0: bool = (> impact#0 1u)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // ternary_true_L86
        let ternary_result%0#0: uint64 = (- impact#0 1u)
        goto block@3
    block@2: // ternary_false_L86
        let ternary_result%0#1: uint64 = 1u
        goto block@3
    block@3: // ternary_merge_L86
        let minImpact#0: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let tmp%1#0: uint64 = (- max#0 min#0)
        let tmp%2#0: uint64 = (* tmp%1#0 minImpact#0)
        let tmp%3#0: uint64 = (/ tmp%2#0 1000u)
        let tmp%4#0: uint64 = (- max#0 tmp%3#0)
        return tmp%4#0

subroutine smart_contracts/utils/functions.ts::gateCheck(akitaDAO: uint64, caller: bytes[32], id: uint64, args: bytes[]) -> bool:
    block@0: // L130
        goto id#0 ? block@2 : block@1
    block@1: // if_body_L131
        return 1u
    block@2: // after_if_else_L131
        itxn_begin
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item5%1#0: uint64 = (extract_uint64 appListBytes#0 40u)
        let val_as_bytes%0#0: bytes[8] = (itob id#0)
        ((itxn_field ApplicationArgs) method "check(address,uint64,byte[][])bool")
        ((itxn_field ApplicationArgs) caller#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) args#0)
        ((itxn_field ApplicationID) item5%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%13#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%14#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%15#0: bool = (== tmp%14#0 0x151f7c75)
        (assert tmp%15#0) // Bytes has valid prefix
        let tmp%16#0: bool = (getbit tmp%13#0 0u)
        return tmp%16#0

subroutine smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: bool, wallet: uint64) -> bytes[32]:
    block@0: // L166
        goto rekeyBack#0 ? block@2 : block@1
    block@1: // if_body_L167
        let tmp%0#0: bytes[32] = (global ZeroAddress)
        return tmp%0#0
    block@2: // after_if_else_L167
        let (controlledAccountBytes#0: bytes, _#0: bool) = (app_global_get_ex wallet#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#1: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (walletAddress#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) wallet#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (!= spendingAddressBytes#0 controlledAccountBytes#0)
        goto tmp%1#0 ? block@3 : block@4
    block@3: // if_body_L172
        return spendingAddressBytes#0
    block@4: // after_if_else_L172
        return walletAddress#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(address: bytes[32]) -> bool:
    block@0: // L72
        let (value%0#0: bytes[32], check%0#0: bool) = ((acct_params_get AcctAuthAddr) address#0)
        (assert check%0#0) // account funded
        let tmp%0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%1#0: bool = (== value%0#0 tmp%0#0)
        return tmp%1#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(wallet: uint64) -> void:
    block@0: // L76
        let (spendingAddressBytes#0: bytes, _#0: bool) = (app_global_get_ex wallet#0 "spending_address")
        itxn_begin
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(1u, wallet#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) spendingAddressBytes#0)
        ((itxn_field Amount) 0u)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isReply(ref: bytes) -> bool:
    block@0: // L95
        let tmp%0#0: uint64 = (len ref#0)
        let tmp%1#0: bool = (== tmp%0#0 68u)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L96
        let tmp%3#0: bool = (== tmp%0#0 101u)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L96
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L96
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L96
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        return or_result%0#2

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isAmended(ref: bytes) -> bool:
    block@0: // L99
        let tmp%0#0: uint64 = (len ref#0)
        let tmp%1#0: bool = (== tmp%0#0 69u)
        goto tmp%1#0 ? block@2 : block@1
    block@1: // or_contd_L100
        let tmp%3#0: bool = (== tmp%0#0 101u)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L100
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L100
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L100
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        return or_result%0#2

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(account: bytes[32]) -> bool:
    block@0: // L103
        let box_prefixed_key%0#0: bytes = (concat "n" account#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@1 : block@3
    block@1: // and_contd_L104
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let maybe_value_converted%0#0: uint64 = (btoi maybe_value%0#0)
        let tmp%0#0: uint64 = (global LatestTimestamp)
        let tmp%1#0: bool = (> maybe_value_converted%0#0 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L104
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L104
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L104
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        return and_result%0#2

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.blk(userAddress: bytes[32], blockedAddress: bytes[32]) -> <bytes[16], bytes[16]>:
    block@0: // L108
        let length%0#0: uint64 = (len userAddress#0)
        let is_out_of_bounds%0#0: bool = (>= 0u length%0#0)
        let bounded_index%0#0: uint64 = (select 0u length%0#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 16u length%0#0)
        let bounded_index%1#0: uint64 = (select 16u length%0#0 is_out_of_bounds%1#0)
        let user#0: bytes[16] = (substring3 userAddress#0 bounded_index%0#0 bounded_index%1#0)
        let tmp%0#0: uint64 = (len user#0)
        let tmp%1#0: bool = (== tmp%0#0 16u)
        (assert tmp%1#0) // Length must be 16
        let length%1#0: uint64 = (len blockedAddress#0)
        let is_out_of_bounds%2#0: bool = (>= 0u length%1#0)
        let bounded_index%2#0: uint64 = (select 0u length%1#0 is_out_of_bounds%2#0)
        let is_out_of_bounds%3#0: bool = (>= 16u length%1#0)
        let bounded_index%3#0: uint64 = (select 16u length%1#0 is_out_of_bounds%3#0)
        let blocked#0: bytes[16] = (substring3 blockedAddress#0 bounded_index%2#0 bounded_index%3#0)
        let tmp%2#0: uint64 = (len blocked#0)
        let tmp%3#0: bool = (== tmp%2#0 16u)
        (assert tmp%3#0) // Length must be 16
        return user#0 blocked#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rlk(user: bytes[32], ref: bytes[32], NFT: uint64) -> <bytes[16], bytes[16], uint64>:
    block@0: // L115
        let length%0#0: uint64 = (len user#0)
        let is_out_of_bounds%0#0: bool = (>= 0u length%0#0)
        let bounded_index%0#0: uint64 = (select 0u length%0#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 16u length%0#0)
        let bounded_index%1#0: uint64 = (select 16u length%0#0 is_out_of_bounds%1#0)
        let userKey#0: bytes[16] = (substring3 user#0 bounded_index%0#0 bounded_index%1#0)
        let tmp%0#0: uint64 = (len userKey#0)
        let tmp%1#0: bool = (== tmp%0#0 16u)
        (assert tmp%1#0) // Length must be 16
        let length%1#0: uint64 = (len ref#0)
        let is_out_of_bounds%2#0: bool = (>= 0u length%1#0)
        let bounded_index%2#0: uint64 = (select 0u length%1#0 is_out_of_bounds%2#0)
        let is_out_of_bounds%3#0: bool = (>= 16u length%1#0)
        let bounded_index%3#0: uint64 = (select 16u length%1#0 is_out_of_bounds%3#0)
        let refKey#0: bytes[16] = (substring3 ref#0 bounded_index%2#0 bounded_index%3#0)
        let tmp%2#0: uint64 = (len refKey#0)
        let tmp%3#0: bool = (== tmp%2#0 16u)
        (assert tmp%3#0) // Length must be 16
        return userKey#0 refKey#0 NFT#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.vlk(account: bytes[32], r: bytes[32]) -> <bytes[16], bytes[16]>:
    block@0: // L122
        let length%0#0: uint64 = (len account#0)
        let is_out_of_bounds%0#0: bool = (>= 0u length%0#0)
        let bounded_index%0#0: uint64 = (select 0u length%0#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 16u length%0#0)
        let bounded_index%1#0: uint64 = (select 16u length%0#0 is_out_of_bounds%1#0)
        let user#0: bytes[16] = (substring3 account#0 bounded_index%0#0 bounded_index%1#0)
        let tmp%0#0: uint64 = (len user#0)
        let tmp%1#0: bool = (== tmp%0#0 16u)
        (assert tmp%1#0) // Length must be 16
        let length%1#0: uint64 = (len r#0)
        let is_out_of_bounds%2#0: bool = (>= 0u length%1#0)
        let bounded_index%2#0: uint64 = (select 0u length%1#0 is_out_of_bounds%2#0)
        let is_out_of_bounds%3#0: bool = (>= 16u length%1#0)
        let bounded_index%3#0: uint64 = (select 16u length%1#0 is_out_of_bounds%3#0)
        let ref#0: bytes[16] = (substring3 r#0 bounded_index%2#0 bounded_index%3#0)
        let tmp%2#0: uint64 = (len ref#0)
        let tmp%3#0: bool = (== tmp%2#0 16u)
        (assert tmp%3#0) // Length must be 16
        return user#0 ref#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(user: bytes[32], blocked: bytes[32]) -> bool:
    block@0: // L128
        let (blocksKey.user#0: bytes[16], blocksKey.blocked#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.blk(user#0, blocked#0)
        let length%0#0: uint64 = (len blocksKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len blocksKey.blocked#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat blocksKey.user#0 blocksKey.blocked#0)
        let box_prefixed_key%0#0: bytes = (concat "b" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        return maybe_exists%0#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(account: bytes[32]) -> uint64:
    block@0: // L133
        let box_prefixed_key%0#0: bytes = (concat "m" account#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let meta.streak#0: uint64 = (extract_uint64 maybe_value%0#0 8u)
        let meta.startDate#0: uint64 = (extract_uint64 maybe_value%0#0 16u)
        let tmp%0#0: bool = (>= meta.streak#0 60u)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // if_body_L138
        let socialImpact#1: uint64 = 100u
        goto block@3
    block@2: // else_body_L140
        let tmp%1#0: uint64 = (* meta.streak#0 100u)
        let socialImpact#2: uint64 = (/ tmp%1#0 60u)
        goto block@3
    block@3: // after_if_else_L138
        let socialImpact#3: uint64 = φ(socialImpact#1 <- block@1, socialImpact#2 <- block@2)
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let accountAge#0: uint64 = (- tmp%3#0 meta.startDate#0)
        let tmp%4#0: bool = (>= accountAge#0 63072000u)
        goto tmp%4#0 ? block@4 : block@5
    block@4: // if_body_L149
        let socialImpact#4: uint64 = (+ socialImpact#3 75u)
        goto block@6
    block@5: // else_body_L151
        let tmp%5#0: uint64 = (* accountAge#0 75u)
        let tmp%6#0: uint64 = (/ tmp%5#0 63072000u)
        let socialImpact#5: uint64 = (+ socialImpact#3 tmp%6#0)
        goto block@6
    block@6: // after_if_else_L149
        let socialImpact#7: uint64 = φ(socialImpact#4 <- block@4, socialImpact#5 <- block@5)
        let box_prefixed_key%1#0: bytes = (concat "v" account#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%1#0)
        goto maybe_exists%1#0 ? block@7 : block@16
    block@7: // if_body_L157
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%2#0) // Box must have value
        let score.voteCount#0: uint64 = (extract_uint64 maybe_value%1#0 0u)
        let is_true%1#0: uint64 = (getbit maybe_value%1#0 64u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let score.isNegative#0: bool = (getbit encoded_bool%1#0 0u)
        let tmp%7#0: uint64 = (* score.voteCount#0 75u)
        let impact#0: uint64 = (/ tmp%7#0 100000u)
        let tmp%8#0: bool = (> impact#0 75u)
        goto tmp%8#0 ? block@8 : block@9
    block@8: // if_body_L161
        let impact#1: uint64 = 75u
        goto block@9
    block@9: // after_if_else_L161
        let impact#2: uint64 = φ(impact#0 <- block@7, impact#1 <- block@8)
        goto score.isNegative#0 ? block@10 : block@14
    block@10: // if_body_L165
        let tmp%9#0: bool = (> socialImpact#7 impact#2)
        goto tmp%9#0 ? block@11 : block@12
    block@11: // if_body_L167
        let socialImpact#8: uint64 = (- socialImpact#7 impact#2)
        goto block@13
    block@12: // else_body_L169
        let socialImpact#9: uint64 = 0u
        goto block@13
    block@13: // after_if_else_L167
        let socialImpact#13: uint64 = φ(socialImpact#8 <- block@11, socialImpact#9 <- block@12)
        goto block@15
    block@14: // else_body_L172
        let socialImpact#10: uint64 = (+ socialImpact#7 impact#2)
        goto block@15
    block@15: // after_if_else_L165
        let socialImpact#12: uint64 = φ(socialImpact#13 <- block@13, socialImpact#10 <- block@14)
        goto block@16
    block@16: // after_if_else_L157
        let socialImpact#11: uint64 = φ(socialImpact#7 <- block@6, socialImpact#12 <- block@15)
        return socialImpact#11

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(account: bytes[32]) -> uint64:
    block@0: // L181
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (pluginAppListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "plugn_al")
        let item2%1#0: uint64 = (extract_uint64 pluginAppListBytes#0 16u)
        ((itxn_field ApplicationArgs) method "getUserImpactWithoutSocial(address)uint64")
        ((itxn_field ApplicationArgs) account#0)
        ((itxn_field ApplicationID) item2%1#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%3#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%4#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%5#0: bool = (== tmp%4#0 0x151f7c75)
        (assert tmp%5#0) // Bytes has valid prefix
        let impact#0: uint64 = (btoi tmp%3#0)
        let tmp%7#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(account#0)
        let tmp%8#0: uint64 = (+ impact#0 tmp%7#0)
        return tmp%8#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(sender: bytes[32], appId: uint64) -> bool:
    block@0: // L194
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (pluginAppListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "plugn_al")
        let item0%1#0: uint64 = (extract_uint64 pluginAppListBytes#0 0u)
        let val_as_bytes%0#0: bytes[8] = (itob item0%1#0)
        ((itxn_field ApplicationArgs) method "arc58_canCall(uint64,bool,address,byte[4])bool")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) 0x80)
        ((itxn_field ApplicationArgs) sender#0)
        ((itxn_field ApplicationArgs) method "optInToAsset(uint64,bool,uint64[],pay)void")
        ((itxn_field ApplicationID) appId#0)
        ((itxn_field Sender) sender#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%3#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%4#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%5#0: bool = (== tmp%4#0 0x151f7c75)
        (assert tmp%5#0) // Bytes has valid prefix
        let tmp%6#0: bool = (getbit tmp%3#0 0u)
        return tmp%6#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet: uint64, rekeyBack: bool, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
    block@0: // L211
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#0 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let (spendingAddressBytes#0: bytes, _#1: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (controlledAccountBytes#0: bytes, _#2: bool) = (app_global_get_ex recipientWallet#0 "controlled_address")
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Amount) mbrAmount#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let (pluginAppListBytes#0: bytes, _#3: bool) = (app_global_get_ex akitaDAO#0 "plugn_al")
        let item0%1#1: uint64 = (extract_uint64 pluginAppListBytes#0 0u)
        let val_as_bytes%0#0: bytes[8] = (itob item0%1#1)
        ((itxn_field ApplicationArgs) method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationArgs) 0x80)
        ((itxn_field ApplicationArgs) 0x0000)
        ((itxn_field ApplicationArgs) 0x0000)
        ((itxn_field ApplicationID) recipientWallet#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_next
        let inner_txn_params%2%%param_Amount_idx_0#0: uint64 = (global AssetOptInMinBalance)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field Amount) inner_txn_params%2%%param_Amount_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let (pluginAppListBytes#1: bytes, _#4: bool) = (app_global_get_ex akitaDAO#0 "plugn_al")
        let item0%1#2: uint64 = (extract_uint64 pluginAppListBytes#1 0u)
        let val_as_bytes%1#0: bytes[8] = (itob recipientWallet#0)
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(akta#0)
        let byte_len%0#0: uint64 = (len encoded%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 encoded%0#0)
        ((itxn_field ApplicationArgs) method "optInToAsset(uint64,bool,uint64[],pay)void")
        ((itxn_field ApplicationArgs) val_as_bytes%1#0)
        ((itxn_field ApplicationArgs) 0x80)
        ((itxn_field ApplicationArgs) concat_result%0#0)
        ((itxn_field ApplicationID) item0%1#2)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_next
        ((itxn_field ApplicationArgs) method "arc58_verifyAuthAddr()void")
        ((itxn_field ApplicationID) recipientWallet#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_next
        let (maybe_value%3#0: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "akita_escrow")
        (assert maybe_exists%3#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%3#0)
        (assert check%0#0) // application exists
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) tax#0)
        ((itxn_field AssetReceiver) value%0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        let (socialFeesBytes#0: bytes, _#5: bool) = (app_global_get_ex akitaDAO#0 "social_fees")
        let reactFee#0: uint64 = (extract_uint64 socialFeesBytes#0 8u)
        itxn_next
        let inner_txn_params%6%%param_AssetAmount_idx_0#0: uint64 = (- reactFee#0 tax#0)
        let inner_txn_params%6%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, wallet#0)
        ((itxn_field RekeyTo) inner_txn_params%6%%param_RekeyTo_idx_0#0)
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) inner_txn_params%6%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) controlledAccountBytes#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet: uint64, rekeyBack: bool, recipientWallet: uint64, mbrAmount: uint64, tax: uint64) -> void:
    block@0: // L301
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (otherAppListBytes#0: bytes, _#1: bool) = (app_global_get_ex akitaDAO#0 "other_al")
        let assetInbox#0: uint64 = (extract_uint64 otherAppListBytes#0 16u)
        let (inboxAddress#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) assetInbox#0)
        (assert check%0#0) // application exists
        let (akitaAssetsBytes#0: bytes, tmp%1#0: bool) = (app_global_get_ex akitaDAO#0 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let (spendingAddressBytes#0: bytes, _#3: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (controlledAccountBytes#0: bytes, _#4: bool) = (app_global_get_ex recipientWallet#0 "controlled_address")
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Amount) mbrAmount#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        itxn_begin
        let val_as_bytes%0#0: bytes[8] = (itob akta#0)
        ((itxn_field ApplicationArgs) method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)")
        ((itxn_field ApplicationArgs) controlledAccountBytes#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) assetInbox#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%5#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%6#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%7#0: bool = (== tmp%6#0 0x151f7c75)
        (assert tmp%7#0) // Bytes has valid prefix
        let canCallData.mbr#0: uint64 = (extract_uint64 awst_tmp%0#0 12u)
        let is_true%0#0: uint64 = (getbit tmp%5#0 128u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let canCallData.routerOptedIn#0: bool = (getbit encoded_bool%0#0 0u)
        let canCallData.receiverAlgoNeededForClaim#0: uint64 = (extract_uint64 awst_tmp%0#0 21u)
        goto canCallData.mbr#0 ? block@4 : block@3
    block@3: // or_contd_L340
        goto canCallData.receiverAlgoNeededForClaim#0 ? block@4 : block@6
    block@4: // if_body_L340
        itxn_begin
        let inner_txn_params%2%%param_Amount_idx_0#0: uint64 = (+ canCallData.mbr#0 canCallData.receiverAlgoNeededForClaim#0)
        ((itxn_field Amount) inner_txn_params%2%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inboxAddress#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@6
    block@6: // after_if_else_L340
        goto canCallData.routerOptedIn#0 ? block@9 : block@7
    block@7: // if_body_L351
        itxn_begin
        ((itxn_field ApplicationArgs) method "arc59_optRouterIn(uint64)void")
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) assetInbox#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@9
    block@9: // after_if_else_L351
        itxn_begin
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_escrow")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) maybe_value%2#0)
        (assert check%1#0) // application exists
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) tax#0)
        ((itxn_field AssetReceiver) value%1#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        let (akitaDAO#1: uint64, maybe_exists%3#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%3#0) // check GlobalState exists
        let (socialFeesBytes#0: bytes, _#2: bool) = (app_global_get_ex akitaDAO#1 "social_fees")
        let reactFee#0: uint64 = (extract_uint64 socialFeesBytes#0 8u)
        itxn_begin
        let inner_txn_params%5%%param_AssetAmount_idx_0#0: uint64 = (- reactFee#0 tax#0)
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) inner_txn_params%5%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) inboxAddress#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_next
        let inner_txn_params%6%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, wallet#0)
        let val_as_bytes%2#0: bytes[8] = (itob canCallData.receiverAlgoNeededForClaim#0)
        ((itxn_field ApplicationArgs) method "arc59_sendAsset(axfer,address,uint64)address")
        ((itxn_field ApplicationArgs) controlledAccountBytes#0)
        ((itxn_field ApplicationArgs) val_as_bytes%2#0)
        ((itxn_field RekeyTo) inner_txn_params%6%%param_RekeyTo_idx_0#0)
        ((itxn_field ApplicationID) assetInbox#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%5#0: bytes = (gitxn 1 LastLog)
        let tmp%9#0: bytes = ((extract 0 4) awst_tmp%5#0)
        let tmp%10#0: bool = (== tmp%9#0 0x151f7c75)
        (assert tmp%10#0) // Bytes has valid prefix
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet: uint64, rekeyBack: bool, recipientAccount: bytes[32], mbrAmount: uint64, tax: uint64) -> void:
    block@0: // L394
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#0 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let (spendingAddressBytes#0: bytes, _#1: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (socialFeesBytes#0: bytes, _#2: bool) = (app_global_get_ex akitaDAO#0 "social_fees")
        let reactFee#0: uint64 = (extract_uint64 socialFeesBytes#0 8u)
        let mbrPayment%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_escrow")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%2#0)
        (assert check%0#0) // application exists
        let xferTxn%%param_AssetAmount_idx_0#0: uint64 = (- reactFee#0 tax#0)
        let xferTxn%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, wallet#0)
        itxn_begin
        ((itxn_field Receiver) mbrPayment%%param_Receiver_idx_0#0)
        ((itxn_field Amount) mbrAmount#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) tax#0)
        ((itxn_field AssetReceiver) value%0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_next
        ((itxn_field RekeyTo) xferTxn%%param_RekeyTo_idx_0#0)
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) xferTxn%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) recipientAccount#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref: bytes[32], creator: bytes[32]) -> void:
    block@0: // L426
        let box_prefixed_key%0#0: bytes = (concat "p" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@2 : block@1
    block@1: // if_body_L427
        let tmp%1#0: uint64 = (global LatestTimestamp)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob tmp%1#0)
        let val_as_bytes%1#0: bytes[8] = (itob 0u)
        let encoded_tuple_buffer%2#0: bytes = (concat creator#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 0x00)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u 0u)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 0x0000)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%7#0)
        goto block@2
    block@2: // after_if_else_L427
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(account: bytes[32]) -> void:
    block@0: // L446
        let box_prefixed_key%0#0: bytes = (concat "m" account#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Meta box values dont exist yet
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let meta.walletID#0: uint64 = (extract_uint64 maybe_value%0#0 0u)
        let meta.streak#0: uint64 = (extract_uint64 maybe_value%0#0 8u)
        let meta.startDate#0: uint64 = (extract_uint64 maybe_value%0#0 16u)
        let meta.lastActive#0: uint64 = (extract_uint64 maybe_value%0#0 24u)
        let meta.followerIndex#0: uint64 = (extract_uint64 maybe_value%0#0 32u)
        let meta.followerCount#0: uint64 = (extract_uint64 maybe_value%0#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 384u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let meta.automated#0: bool = (getbit encoded_bool%0#0 0u)
        let meta.followGateID#0: uint64 = (extract_uint64 maybe_value%0#0 49u)
        let meta.addressGateID#0: uint64 = (extract_uint64 maybe_value%0#0 57u)
        let tmp%0#0: uint64 = (global LatestTimestamp)
        let tmp%1#0: uint64 = (global LatestTimestamp)
        let tmp%2#0: uint64 = (- tmp%1#0 meta.startDate#0)
        let tmp%3#0: uint64 = (% tmp%2#0 86400u)
        let thisWindowStart#0: uint64 = (- tmp%0#0 tmp%3#0)
        let lastWindowStart#0: uint64 = (- thisWindowStart#0 86400u)
        let tmp%4#0: bool = (> lastWindowStart#0 meta.lastActive#0)
        goto tmp%4#0 ? block@1 : block@2
    block@1: // if_body_L456
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%0#0: bytes[8] = (itob meta.walletID#0)
        let val_as_bytes%1#0: bytes[8] = (itob 1u)
        let val_as_bytes%2#0: bytes[8] = (itob meta.startDate#0)
        let val_as_bytes%3#0: bytes[8] = (itob tmp%5#0)
        let val_as_bytes%4#0: bytes[8] = (itob meta.followerIndex#0)
        let val_as_bytes%5#0: bytes[8] = (itob meta.followerCount#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u meta.automated#0)
        let val_as_bytes%6#0: bytes[8] = (itob meta.followGateID#0)
        let val_as_bytes%7#0: bytes[8] = (itob meta.addressGateID#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_bool%1#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%7#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%9#0)
        return 
    block@2: // after_if_else_L456
        let tmp%6#0: bool = (< meta.lastActive#0 thisWindowStart#0)
        goto tmp%6#0 ? block@3 : block@4
    block@3: // if_body_L467
        let tmp%7#0: uint64 = (+ meta.streak#0 1u)
        let tmp%8#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%8#0: bytes[8] = (itob meta.walletID#0)
        let val_as_bytes%9#0: bytes[8] = (itob tmp%7#0)
        let val_as_bytes%10#0: bytes[8] = (itob meta.startDate#0)
        let val_as_bytes%11#0: bytes[8] = (itob tmp%8#0)
        let val_as_bytes%12#0: bytes[8] = (itob meta.followerIndex#0)
        let val_as_bytes%13#0: bytes[8] = (itob meta.followerCount#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u meta.automated#0)
        let val_as_bytes%14#0: bytes[8] = (itob meta.followGateID#0)
        let val_as_bytes%15#0: bytes[8] = (itob meta.addressGateID#0)
        let encoded_tuple_buffer%12#0: bytes = (concat val_as_bytes%8#0 val_as_bytes%9#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%10#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%11#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%13#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 encoded_bool%2#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 val_as_bytes%14#0)
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%15#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%19#0)
        goto block@4
    block@4: // after_if_else_L467
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(ref: bytes[32], isUp: bool, impact: uint64) -> void:
    block@0: // L499
        let box_prefixed_key%0#1: bytes = (concat "v" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#1)
        goto maybe_exists%0#0 ? block@3 : block@2
    block@2: // if_body_L479
        let smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes%1#0: bool = 0u
        goto block@15
    block@3: // after_if_else_L479
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#1)
        (assert maybe_exists%1#0) // Box must have value
        let voteCount#1: uint64 = (extract_uint64 maybe_value%0#0 0u)
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 64u)
        let encoded_bool%0#1: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let isNegative#1: bool = (getbit encoded_bool%0#1 0u)
        goto isUp#0 ? block@4 : block@5
    block@4: // and_contd_L486
        goto isNegative#1 ? block@7 : block@5
    block@5: // or_contd_L486
        goto isUp#0 ? block@8 : block@6
    block@6: // and_contd_L486
        goto isNegative#1 ? block@8 : block@7
    block@7: // bool_true_L486
        let or_result%0#0: bool = 1u
        goto block@9
    block@8: // bool_false_L486
        let or_result%0#1: bool = 0u
        goto block@9
    block@9: // bool_merge_L486
        let differingDirections#0: bool = φ(or_result%0#0 <- block@7, or_result%0#1 <- block@8)
        let tmp%0#0: bool = (> impact#0 voteCount#1)
        let flip#0: bool = (&& tmp%0#0 differingDirections#0)
        goto flip#0 ? block@10 : block@11
    block@10: // if_body_L490
        let newCount#0: uint64 = (- impact#0 voteCount#1)
        let tmp%1#0: bool = (! isNegative#1)
        goto block@15
    block@11: // after_if_else_L490
        goto differingDirections#0 ? block@12 : block@13
    block@12: // ternary_true_L495
        let ternary_result%0#0: uint64 = (- voteCount#1 impact#0)
        goto block@14
    block@13: // ternary_false_L495
        let ternary_result%0#1: uint64 = (+ voteCount#1 impact#0)
        goto block@14
    block@14: // ternary_merge_L495
        let newCount₁#0: uint64 = φ(ternary_result%0#0 <- block@12, ternary_result%0#1 <- block@13)
        goto block@15
    block@15: // after_inlined_smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes_L499
        let voteCount#0: uint64 = φ(impact#0 <- block@2, newCount#0 <- block@10, newCount₁#0 <- block@14)
        let isNegative#0: bool = φ(smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.calcVotes%1#0 <- block@2, tmp%1#0 <- block@10, isNegative#1 <- block@14)
        let val_as_bytes%0#0: bytes[8] = (itob voteCount#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u isNegative#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 encoded_bool%0#0)
        (box_put box_prefixed_key%0#1 encoded_tuple_buffer%2#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(ref: bytes[32], isUp: bool, account: bytes[32], impact: uint64) -> void:
    block@0: // L504
        let (voteListKey.user#0: bytes[16], voteListKey.ref#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.vlk(account#0, ref#0)
        let length%0#0: uint64 = (len voteListKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len voteListKey.ref#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat voteListKey.user#0 voteListKey.ref#0)
        let box_prefixed_key%0#0: bytes = (concat "o" encoded_tuple_buffer%2#0)
        let val_as_bytes%0#0: bytes[8] = (itob impact#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u isUp#0)
        let encoded_tuple_buffer%5#0: bytes = (concat val_as_bytes%0#0 encoded_bool%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%5#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createPost(wallet: uint64, rekeyBack: bool, cid: bytes[36], gateID: uint64, isAmendment: bool) -> void:
    block@0: // L509
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex wallet#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex wallet#0 "spending_address")
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%1#0: bool = (! tmp%0#0)
        (assert tmp%1#0) // This account is banned
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(controlledAccountBytes#0)
        let impact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(controlledAccountBytes#0)
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#0 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let (socialFeesBytes#0: bytes, _#3: bool) = (app_global_get_ex akitaDAO#0 "social_fees")
        let postFee#0: uint64 = (extract_uint64 socialFeesBytes#0 0u)
        let tmp%0#1: uint64 = (len cid#0)
        let tmp%1#2: uint64 = (* 400u tmp%0#1)
        let posts#0: uint64 = (+ 35700u tmp%1#2)
        let tmp%4#0: uint64 = (+ posts#0 19300u)
        let mbrTxn%%param_Amount_idx_0#0: uint64 = (+ tmp%4#0 19300u)
        let mbrTxn%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_escrow")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%2#0)
        (assert check%0#0) // application exists
        let taxTxn%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, wallet#0)
        itxn_begin
        ((itxn_field Receiver) mbrTxn%%param_Receiver_idx_0#0)
        ((itxn_field Amount) mbrTxn%%param_Amount_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        ((itxn_field RekeyTo) taxTxn%%param_RekeyTo_idx_0#0)
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) postFee#0)
        ((itxn_field AssetReceiver) value%0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        let postID#0: bytes[32] = (txn TxID)
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let box_prefixed_key%0#0: bytes = (concat "p" postID#0)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob tmp%5#0)
        let val_as_bytes%1#0: bytes[8] = (itob gateID#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u isAmendment#0)
        let as_bytes%0#0: bytes[8] = (itob tmp%0#1)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 cid#0)
        let encoded_tuple_buffer%2#0: bytes = (concat controlledAccountBytes#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 0x00)
        let is_true%0#0: uint64 = (getbit encoded_bool%1#0 0u)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u is_true%0#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_value%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%7#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(postID#0, 1u, impact#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(postID#0, 1u, controlledAccountBytes#0, impact#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(wallet: uint64, rekeyBack: bool, cid: bytes[36], ref: bytes[32], gateID: uint64, args: bytes[], isAmendment: bool) -> void:
    block@0: // L554
        let (controlledAccountBytes#1: bytes, _#4: bool) = (app_global_get_ex wallet#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#5: bool) = (app_global_get_ex wallet#0 "spending_address")
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#1)
        let tmp%1#0: bool = (! tmp%0#0)
        (assert tmp%1#0) // This account is banned
        let box_prefixed_key%0#0: bytes = (concat "p" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let post.gateID#0: uint64 = (extract_uint64 maybe_value%0#0 40u)
        let tmp%2#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(post.creator#0, controlledAccountBytes#1)
        let tmp%3#0: bool = (! tmp%2#0)
        (assert tmp%3#0) // This account is blocked by the user
        goto post.gateID#0 ? block@1 : block@2
    block@1: // if_body_L571
        let (maybe_value%1#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%5#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%1#0, controlledAccountBytes#1, post.gateID#0, args#0)
        (assert tmp%5#0) // Gate check failed
        goto block@2
    block@2: // after_if_else_L571
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(controlledAccountBytes#1)
        let replyRef#0: bytes = (concat cid#0 ref#0)
        let box_prefixed_key%2#0: bytes = (concat "m" post.creator#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%3#0) // Box must have value
        let creatorMeta.walletID#0: uint64 = (extract_uint64 maybe_value%2#0 0u)
        let postCreatorImpact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(post.creator#0)
        let (akitaDAO#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (socialFeesBytes#0: bytes, _#3: bool) = (app_global_get_ex akitaDAO#0 "social_fees")
        let impactTaxMin#0: uint64 = (extract_uint64 socialFeesBytes#0 16u)
        let impactTaxMax#0: uint64 = (extract_uint64 socialFeesBytes#0 24u)
        let tax#0: uint64 = smart_contracts/utils/functions.ts::impactRange(postCreatorImpact#0, impactTaxMin#0, impactTaxMax#0)
        let (akitaDAO#2: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#2 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let tmp%0#1: uint64 = (len replyRef#0)
        let tmp%1#2: uint64 = (* 400u tmp%0#1)
        let posts#0: uint64 = (+ 35700u tmp%1#2)
        let tmp%8#0: uint64 = (+ posts#0 19300u)
        let mbrAmount#0: uint64 = (+ tmp%8#0 19300u)
        let (tmp%9#0: uint64, tmp%10#0: bool) = ((asset_holding_get AssetBalance) post.creator#0 akta#0)
        goto tmp%10#0 ? block@7 : block@3
    block@3: // if_body_L587
        let canCallArc58OptIn#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(spendingAddressBytes#0, creatorMeta.walletID#0)
        goto canCallArc58OptIn#0 ? block@4 : block@5
    block@4: // if_body_L590
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, mbrAmount#0, tax#0)
        goto block@8
    block@5: // else_body_L593
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, mbrAmount#0, tax#0)
        goto block@8
    block@7: // else_body_L597
        let (controlledAccountBytes#0: bytes, _#2: bool) = (app_global_get_ex creatorMeta.walletID#0 "controlled_address")
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet#0, rekeyBack#0, controlledAccountBytes#0, mbrAmount#0, tax#0)
        goto block@8
    block@8: // after_if_else_L587
        let replyPostID#0: bytes[32] = (txn TxID)
        let replyPost.timestamp#0: uint64 = (global LatestTimestamp)
        let box_prefixed_key%3#0: bytes = (concat "p" replyPostID#0)
        (box_del box_prefixed_key%3#0)
        let val_as_bytes%0#0: bytes[8] = (itob replyPost.timestamp#0)
        let val_as_bytes%1#0: bytes[8] = (itob gateID#0)
        let encoded_bool%4#0: bytes[1] = (setbit 0x00 0u isAmendment#0)
        let as_bytes%0#0: bytes[8] = (itob tmp%0#1)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 replyRef#0)
        let encoded_tuple_buffer%2#0: bytes = (concat controlledAccountBytes#1 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 0x00)
        let is_true%3#0: uint64 = (getbit encoded_bool%4#0 0u)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u is_true%3#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_value%0#0)
        (box_put box_prefixed_key%3#0 encoded_tuple_buffer%7#0)
        let senderImpact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(controlledAccountBytes#1)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(replyPostID#0, 1u, senderImpact#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(replyPostID#0, 1u, controlledAccountBytes#1, senderImpact#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(wallet: uint64, rekeyBack: bool, ref: bytes[32], isUp: bool) -> void:
    block@0: // L620
        let (controlledAccountBytes#1: bytes, _#2: bool) = (app_global_get_ex wallet#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#3: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (_#0: bytes[32], check%0#1: bool) = ((app_params_get AppAddress) wallet#0)
        (assert check%0#1) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#1)
        let tmp%1#0: bool = (! tmp%0#0)
        (assert tmp%1#0) // This account is banned
        let box_prefixed_key%0#0: bytes = (concat "p" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let tmp%2#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(post.creator#0, controlledAccountBytes#1)
        let tmp%3#0: bool = (! tmp%2#0)
        (assert tmp%3#0) // This account is blocked by the user
        let (voteListKey.user#0: bytes[16], voteListKey.ref#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.vlk(controlledAccountBytes#1, ref#0)
        let length%0#0: uint64 = (len voteListKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len voteListKey.ref#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat voteListKey.user#0 voteListKey.ref#0)
        let box_prefixed_key%2#0: bytes = (concat "o" encoded_tuple_buffer%2#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%2#0)
        let tmp%4#0: bool = (! maybe_exists%2#0)
        (assert tmp%4#0) // You've already voted on this post
        let tmp%5#0: bool = (!= controlledAccountBytes#1 post.creator#0)
        (assert tmp%5#0) // Cannot vote on your own content
        let box_prefixed_key%3#0: bytes = (concat "m" controlledAccountBytes#1)
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let is_true%2#0: uint64 = (getbit maybe_value%1#0 384u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let senderIsAutomated#0: bool = (getbit encoded_bool%2#0 0u)
        let tmp%6#0: bool = (! senderIsAutomated#0)
        (assert tmp%6#0) // This is an automated account
        let (akitaDAO#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#0 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(controlledAccountBytes#1)
        let (akitaDAO#1: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (socialFeesBytes#0: bytes, _#4: bool) = (app_global_get_ex akitaDAO#1 "social_fees")
        let reactFee#0: uint64 = (extract_uint64 socialFeesBytes#0 8u)
        let impactTaxMin#0: uint64 = (extract_uint64 socialFeesBytes#0 16u)
        let impactTaxMax#0: uint64 = (extract_uint64 socialFeesBytes#0 24u)
        let tmp%0#1: uint64 = (len ref#0)
        goto isUp#0 ? block@1 : block@8
    block@1: // if_body_L644
        let box_prefixed_key%4#0: bytes = (concat "m" post.creator#0)
        let (maybe_value%4#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%6#0) // Box must have value
        let creatorMeta.walletID#0: uint64 = (extract_uint64 maybe_value%4#0 0u)
        let recipientImpact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(post.creator#0)
        let tax#0: uint64 = smart_contracts/utils/functions.ts::impactRange(recipientImpact#0, impactTaxMin#0, impactTaxMax#0)
        let (tmp%9#0: uint64, tmp%10#0: bool) = ((asset_holding_get AssetBalance) post.creator#0 akta#0)
        goto tmp%10#0 ? block@6 : block@2
    block@2: // if_body_L650
        let canCallArc58OptIn#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(spendingAddressBytes#0, creatorMeta.walletID#0)
        goto canCallArc58OptIn#0 ? block@3 : block@4
    block@3: // if_body_L653
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, 19300u, tax#0)
        goto block@11
    block@4: // else_body_L656
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, 19300u, tax#0)
        goto block@11
    block@6: // else_body_L660
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex creatorMeta.walletID#0 "controlled_address")
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet#0, rekeyBack#0, controlledAccountBytes#0, 19300u, tax#0)
        goto block@11
    block@8: // else_body_L665
        let mbrTxn%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let (maybe_value%5#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "akita_escrow")
        (assert maybe_exists%7#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%5#0)
        (assert check%0#0) // application exists
        let taxTxn%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, wallet#0)
        itxn_begin
        ((itxn_field Receiver) mbrTxn%%param_Receiver_idx_0#0)
        ((itxn_field Amount) 19300u)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        ((itxn_field RekeyTo) taxTxn%%param_RekeyTo_idx_0#0)
        ((itxn_field XferAsset) akta#0)
        ((itxn_field AssetAmount) reactFee#0)
        ((itxn_field AssetReceiver) value%0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@11
    block@11: // after_if_else_L644
        let senderImpact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(controlledAccountBytes#1)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(ref#0, isUp#0, senderImpact#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVoteList(ref#0, isUp#0, controlledAccountBytes#1, senderImpact#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(wallet: uint64, rekeyBack: bool, ref: bytes[32], NFT: uint64, args: bytes[]) -> void:
    block@0: // L691
        let (controlledAccountBytes#1: bytes, _#3: bool) = (app_global_get_ex wallet#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#4: bool) = (app_global_get_ex wallet#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) wallet#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#1)
        let tmp%1#0: bool = (! tmp%0#0)
        (assert tmp%1#0) // This account is banned
        let box_prefixed_key%0#0: bytes = (concat "p" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let post.gateID#0: uint64 = (extract_uint64 maybe_value%0#0 40u)
        let tmp%2#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(post.creator#0, controlledAccountBytes#1)
        let tmp%3#0: bool = (! tmp%2#0)
        (assert tmp%3#0) // This account is blocked by the user
        let (tmp%4#0: uint64, tmp%5#0: bool) = ((asset_holding_get AssetBalance) controlledAccountBytes#1 NFT#0)
        (assert tmp%4#0) // User does not own this NFT
        goto post.gateID#0 ? block@1 : block@2
    block@1: // if_body_L700
        let (maybe_value%1#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%7#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%1#0, controlledAccountBytes#1, post.gateID#0, args#0)
        (assert tmp%7#0) // Gate check failed
        goto block@2
    block@2: // after_if_else_L700
        let (reactionListKey.user#0: bytes[16], reactionListKey.ref#0: bytes[16], reactionListKey.NFT#0: uint64) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rlk(controlledAccountBytes#1, ref#0, NFT#0)
        let length%0#0: uint64 = (len reactionListKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len reactionListKey.ref#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let val_as_bytes%0#0: bytes[8] = (itob reactionListKey.NFT#0)
        let encoded_tuple_buffer%2#0: bytes = (concat reactionListKey.user#0 reactionListKey.ref#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%0#0)
        let box_prefixed_key%2#0: bytes = (concat "e" encoded_tuple_buffer%3#0)
        let (_%1#0: uint64, maybe_exists%3#0: bool) = (box_len box_prefixed_key%2#0)
        let tmp%8#0: bool = (! maybe_exists%3#0)
        (assert tmp%8#0) // This account already reacted to this post with this NFT
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateStreak(controlledAccountBytes#1)
        let box_prefixed_key%3#0: bytes = (concat "m" post.creator#0)
        let (maybe_value%2#0: bytes, maybe_exists%4#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%4#0) // Box must have value
        let creatorMeta.walletID#0: uint64 = (extract_uint64 maybe_value%2#0 0u)
        let recipientImpact#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserImpact(post.creator#0)
        let (akitaDAO#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (socialFeesBytes#0: bytes, _#2: bool) = (app_global_get_ex akitaDAO#0 "social_fees")
        let impactTaxMin#0: uint64 = (extract_uint64 socialFeesBytes#0 16u)
        let impactTaxMax#0: uint64 = (extract_uint64 socialFeesBytes#0 24u)
        let tax#0: uint64 = smart_contracts/utils/functions.ts::impactRange(recipientImpact#0, impactTaxMin#0, impactTaxMax#0)
        let (akitaDAO#1: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%6#0) // check GlobalState exists
        let (akitaAssetsBytes#0: bytes, tmp%1#1: bool) = (app_global_get_ex akitaDAO#1 "akita_assets")
        let akta#0: uint64 = (extract_uint64 akitaAssetsBytes#0 0u)
        let tmp%0#1: uint64 = (len ref#0)
        let reactionlist#0: uint64 = 18900u
        let lengths_equal%2#0: bool = (== tmp%0#1 32u)
        (assert lengths_equal%2#0) // invalid size
        let val_as_bytes%1#0: bytes[8] = (itob NFT#0)
        let encoded_tuple_buffer%6#0: bytes = (concat ref#0 val_as_bytes%1#0)
        let box_prefixed_key%4#0: bytes = (concat "r" encoded_tuple_buffer%6#0)
        let (_%2#0: uint64, reactionExists#0: bool) = (box_len box_prefixed_key%4#0)
        goto reactionExists#0 ? block@3 : block@4
    block@3: // ternary_true_L721
        goto block@5
    block@4: // ternary_false_L721
        let ternary_result%0#1: uint64 = 41000u
        goto block@5
    block@5: // ternary_merge_L721
        let mbrAmount#0: uint64 = φ(reactionlist#0 <- block@3, ternary_result%0#1 <- block@4)
        let (tmp%11#0: uint64, tmp%12#0: bool) = ((asset_holding_get AssetBalance) post.creator#0 akta#0)
        goto tmp%12#0 ? block@10 : block@6
    block@6: // if_body_L723
        let canCallArc58OptIn#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.canCallArc58OptIn(spendingAddressBytes#0, creatorMeta.walletID#0)
        goto canCallArc58OptIn#0 ? block@7 : block@8
    block@7: // if_body_L725
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc58OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, mbrAmount#0, tax#0)
        goto block@11
    block@8: // else_body_L727
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.arc59OptInAndSendReactionPayments(wallet#0, rekeyBack#0, creatorMeta.walletID#0, mbrAmount#0, tax#0)
        goto block@11
    block@10: // else_body_L730
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex creatorMeta.walletID#0 "controlled_address")
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.sendReactionPayments(wallet#0, rekeyBack#0, controlledAccountBytes#0, mbrAmount#0, tax#0)
        goto block@11
    block@11: // after_if_else_L723
        goto reactionExists#0 ? block@12 : block@13
    block@12: // if_body_L735
        let (maybe_value%5#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%8#0) // Box must have value
        let maybe_value_converted%0#0: uint64 = (btoi maybe_value%5#0)
        let materialized_values%0#0: uint64 = (+ maybe_value_converted%0#0 1u)
        let encoded_value%0#0: bytes[8] = (itob materialized_values%0#0)
        (box_put box_prefixed_key%4#0 encoded_value%0#0)
        goto block@14
    block@13: // else_body_L737
        let encoded_value%1#0: bytes[8] = (itob 1u)
        (box_put box_prefixed_key%4#0 encoded_value%1#0)
        goto block@14
    block@14: // after_if_else_L735
        (box_create box_prefixed_key%2#0 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.create(version: bytes, akitaDAO: uint64, escrow: uint64) -> void:
    block@0: // L746
        (app_global_put "version" version#0)
        (app_global_put "akita_dao" akitaDAO#0)
        (app_global_put "akita_escrow" escrow#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.post(walletID: uint64, rekeyBack: bool, cid: bytes[36], gateID: uint64) -> void:
    block@0: // L755
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createPost(walletID#0, rekeyBack#0, cid#0, gateID#0, 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editPost(walletID: uint64, rekeyBack: bool, cid: bytes[36], gateID: uint64, amendment: bytes[32]) -> void:
    block@0: // L759
        let (spendingAddressBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "spending_address")
        let box_prefixed_key%0#0: bytes = (concat "p" amendment#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 49u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let item5%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let post.ref#0: bytes = ((extract 2 0) item5%0#0)
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let tmp%0#1: bool = (== post.creator#0 controlledAccountBytes#0)
        (assert tmp%0#1) // Not your post to edit
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isReply(post.ref#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // Is a reply
        let tmp%3#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isAmended(post.ref#0)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // Is already amended
        let tmp%5#0: bytes[32] = (txn TxID)
        let tmp%6#0: bytes = (concat "a" tmp%5#0)
        let tmp%7#0: bytes = (concat post.ref#0 tmp%6#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let item0%1#0: bytes = ((extract 0 32) maybe_value%1#0) // on error: Index access is out of bounds
        let is_true%2#0: uint64 = (getbit maybe_value%1#0 384u)
        let is_true%3#0: uint64 = (getbit maybe_value%1#0 385u)
        let item1%5#0: uint64 = (extract_uint64 maybe_value%1#0 32u)
        let item2%7#0: uint64 = (extract_uint64 maybe_value%1#0 40u)
        let encoded_bool%8#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item3%4#0: bool = (getbit encoded_bool%8#0 0u)
        let encoded_bool%11#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let item4%5#0: bool = (getbit encoded_bool%11#0 0u)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob item1%5#0)
        let val_as_bytes%1#0: bytes[8] = (itob item2%7#0)
        let encoded_bool%12#0: bytes[1] = (setbit 0x00 0u item3%4#0)
        let encoded_bool%13#0: bytes[1] = (setbit 0x00 0u item4%5#0)
        let length%0#0: uint64 = (len tmp%7#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 tmp%7#0)
        let encoded_tuple_buffer%2#0: bytes = (concat item0%1#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 encoded_bool%12#0)
        let is_true%12#0: uint64 = (getbit encoded_bool%13#0 0u)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u is_true%12#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_value%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%7#0)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Amount) 13200u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createPost(walletID#0, rekeyBack#0, cid#0, gateID#0, 1u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyPost(walletID: uint64, rekeyBack: bool, cid: bytes[36], ref: bytes[32], gateID: uint64, args: bytes[]) -> void:
    block@0: // L785
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(walletID#0, rekeyBack#0, cid#0, ref#0, gateID#0, args#0, 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAsset(walletID: uint64, rekeyBack: bool, cid: bytes[36], ref: uint64, gateID: uint64) -> void:
    block@0: // L789
        (assert ref#0) // Invalid asset
        let (value%0#0: uint64, check%0#0: bool) = ((asset_params_get AssetTotal) ref#0)
        (assert check%0#0) // asset exists
        (assert value%0#0) // Invalid asset
        let tmp%2#0: bytes[8] = (itob ref#0)
        let tmp%3#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%2#0 tmp%3#0)
        let tmp%4#0: uint64 = (len paddedRef#0)
        let tmp%5#0: bool = (== tmp%4#0 32u)
        (assert tmp%5#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppCreator) ref#0)
        (assert check%1#0) // application exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(walletID#0, rekeyBack#0, cid#0, paddedRef#0, gateID#0, 0x0000, 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyAddress(walletID: uint64, rekeyBack: bool, cid: bytes[36], ref: bytes[32], gateID: uint64, args: bytes[]) -> void:
    block@0: // L797
        let box_prefixed_key%0#0: bytes = (concat "m" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@1 : block@4
    block@1: // if_body_L799
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let meta.addressGateID#0: uint64 = (extract_uint64 maybe_value%0#0 57u)
        let (controlledAccountBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "controlled_address")
        goto meta.addressGateID#0 ? block@2 : block@4
    block@2: // if_body_L802
        let (maybe_value%1#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%1#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%1#0, controlledAccountBytes#0, meta.addressGateID#0, args#0)
        (assert tmp%1#0) // Gate check failed
        goto block@4
    block@4: // after_if_else_L799
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref#0, ref#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(walletID#0, rekeyBack#0, cid#0, ref#0, gateID#0, 0x0000, 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.replyApp(walletID: uint64, rekeyBack: bool, cid: bytes[36], ref: uint64, gateID: uint64) -> void:
    block@0: // L812
        (assert ref#0) // Invalid App
        let (value%0#0: bytes, check%0#0: bool) = ((app_params_get AppApprovalProgram) ref#0)
        (assert check%0#0) // application exists
        let tmp%1#0: uint64 = (len value%0#0)
        (assert tmp%1#0) // Invalid App
        let tmp%3#0: bytes[8] = (itob ref#0)
        let tmp%4#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%3#0 tmp%4#0)
        let tmp%5#0: uint64 = (len paddedRef#0)
        let tmp%6#0: bool = (== tmp%5#0 32u)
        (assert tmp%6#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppCreator) ref#0)
        (assert check%1#0) // application exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(walletID#0, rekeyBack#0, cid#0, paddedRef#0, gateID#0, 0x0000, 0u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editReply(walletID: uint64, rekeyBack: bool, cid: bytes[36], gateID: uint64, args: bytes[], amendment: bytes[32]) -> void:
    block@0: // L820
        let (spendingAddressBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "spending_address")
        let box_prefixed_key%0#0: bytes = (concat "p" amendment#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Reply not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 49u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let item5%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let post.ref#0: bytes = ((extract 2 0) item5%0#0)
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let tmp%0#1: bool = (== post.creator#0 controlledAccountBytes#0)
        (assert tmp%0#1) // Not your post to edit
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isReply(post.ref#0)
        (assert tmp%1#0) // Not a reply
        let tmp%2#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isAmended(post.ref#0)
        let tmp%3#0: bool = (! tmp%2#0)
        (assert tmp%3#0) // Is already amended
        let tmp%4#0: bytes[32] = (txn TxID)
        let tmp%5#0: bytes = (concat "a" tmp%4#0)
        let tmp%6#0: bytes = (concat post.ref#0 tmp%5#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let item0%1#0: bytes = ((extract 0 32) maybe_value%1#0) // on error: Index access is out of bounds
        let is_true%2#0: uint64 = (getbit maybe_value%1#0 384u)
        let is_true%3#0: uint64 = (getbit maybe_value%1#0 385u)
        let item1%5#0: uint64 = (extract_uint64 maybe_value%1#0 32u)
        let item2%7#0: uint64 = (extract_uint64 maybe_value%1#0 40u)
        let encoded_bool%8#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item3%4#0: bool = (getbit encoded_bool%8#0 0u)
        let encoded_bool%11#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let item4%5#0: bool = (getbit encoded_bool%11#0 0u)
        (box_del box_prefixed_key%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob item1%5#0)
        let val_as_bytes%1#0: bytes[8] = (itob item2%7#0)
        let encoded_bool%12#0: bytes[1] = (setbit 0x00 0u item3%4#0)
        let encoded_bool%13#0: bytes[1] = (setbit 0x00 0u item4%5#0)
        let length%0#0: uint64 = (len tmp%6#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 tmp%6#0)
        let encoded_tuple_buffer%2#0: bytes = (concat item0%1#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 encoded_bool%12#0)
        let is_true%12#0: uint64 = (getbit encoded_bool%13#0 0u)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u is_true%12#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_value%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%7#0)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Amount) 13200u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        let length%1#0: uint64 = (len post.ref#0)
        let is_out_of_bounds%0#0: bool = (>= 0u length%1#0)
        let bounded_index%0#0: uint64 = (select 0u length%1#0 is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 32u length%1#0)
        let bounded_index%1#0: uint64 = (select 32u length%1#0 is_out_of_bounds%1#0)
        let originalPostRef#0: bytes[32] = (substring3 post.ref#0 bounded_index%0#0 bounded_index%1#0)
        let tmp%7#0: uint64 = (len originalPostRef#0)
        let tmp%8#0: bool = (== tmp%7#0 32u)
        (assert tmp%8#0) // Length must be 32
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReply(walletID#0, rekeyBack#0, cid#0, originalPostRef#0, gateID#0, args#0, 1u)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.votePost(walletID: uint64, rekeyBack: bool, ref: bytes[32], isUp: bool) -> void:
    block@0: // L854
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(walletID#0, rekeyBack#0, ref#0, isUp#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAsset(walletID: uint64, rekeyBack: bool, ref: uint64, isUp: bool) -> void:
    block@0: // L858
        (assert ref#0) // Invalid asset
        let (value%0#0: uint64, check%0#0: bool) = ((asset_params_get AssetTotal) ref#0)
        (assert check%0#0) // asset exists
        (assert value%0#0) // Invalid asset
        let tmp%2#0: bytes[8] = (itob ref#0)
        let tmp%3#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%2#0 tmp%3#0)
        let tmp%4#0: uint64 = (len paddedRef#0)
        let tmp%5#0: bool = (== tmp%4#0 32u)
        (assert tmp%5#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((asset_params_get AssetCreator) ref#0)
        (assert check%1#0) // asset exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(walletID#0, rekeyBack#0, paddedRef#0, isUp#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteAddress(walletID: uint64, rekeyBack: bool, ref: bytes[32], isUp: bool) -> void:
    block@0: // L866
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref#0, ref#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(walletID#0, rekeyBack#0, ref#0, isUp#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.voteApp(walletID: uint64, rekeyBack: bool, ref: uint64, isUp: bool) -> void:
    block@0: // L872
        (assert ref#0) // Invalid App
        let (value%0#0: bytes, check%0#0: bool) = ((app_params_get AppApprovalProgram) ref#0)
        (assert check%0#0) // application exists
        let tmp%1#0: uint64 = (len value%0#0)
        (assert tmp%1#0) // Invalid App
        let tmp%3#0: bytes[8] = (itob ref#0)
        let tmp%4#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%3#0 tmp%4#0)
        let tmp%5#0: uint64 = (len paddedRef#0)
        let tmp%6#0: bool = (== tmp%5#0 32u)
        (assert tmp%6#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppCreator) ref#0)
        (assert check%1#0) // application exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(walletID#0, rekeyBack#0, paddedRef#0, isUp#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.editVote(walletID: uint64, rekeyBack: bool, ref: bytes[32], flip: bool) -> void:
    block@0: // L880
        let (controlledAccountBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (voteListKey.user#0: bytes[16], voteListKey.ref#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.vlk(controlledAccountBytes#0, ref#0)
        let length%0#0: uint64 = (len voteListKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len voteListKey.ref#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat voteListKey.user#0 voteListKey.ref#0)
        let box_prefixed_key%0#0: bytes = (concat "o" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // You haven't voted on this
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let impact#0: uint64 = (extract_uint64 maybe_value%0#0 0u)
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 64u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let isUp#0: bool = (getbit encoded_bool%0#0 0u)
        let tmp%0#0: bool = (! isUp#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.updateVotes(ref#0, tmp%0#0, impact#0)
        goto flip#0 ? block@2 : block@1
    block@1: // if_body_L889
        (box_del box_prefixed_key%0#0)
        return 
    block@2: // after_if_else_L889
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createVote(walletID#0, rekeyBack#0, ref#0, tmp%0#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactPost(walletID: uint64, rekeyBack: bool, ref: bytes[32], NFT: uint64, args: bytes[]) -> void:
    block@0: // L899
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(walletID#0, rekeyBack#0, ref#0, NFT#0, args#0)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAsset(walletID: uint64, rekeyBack: bool, ref: uint64, NFT: uint64) -> void:
    block@0: // L903
        (assert ref#0) // Invalid asset
        let (value%0#0: uint64, check%0#0: bool) = ((asset_params_get AssetTotal) ref#0)
        (assert check%0#0) // asset exists
        (assert value%0#0) // Invalid asset
        let tmp%2#0: bytes[8] = (itob ref#0)
        let tmp%3#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%2#0 tmp%3#0)
        let tmp%4#0: uint64 = (len paddedRef#0)
        let tmp%5#0: bool = (== tmp%4#0 32u)
        (assert tmp%5#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((asset_params_get AssetCreator) ref#0)
        (assert check%1#0) // asset exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(walletID#0, rekeyBack#0, paddedRef#0, NFT#0, 0x0000)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactAddress(walletID: uint64, rekeyBack: bool, ref: bytes[32], NFT: uint64, args: bytes[]) -> void:
    block@0: // L911
        let box_prefixed_key%0#0: bytes = (concat "m" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@1 : block@4
    block@1: // if_body_L913
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let meta.addressGateID#0: uint64 = (extract_uint64 maybe_value%0#0 57u)
        let (controlledAccountBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "controlled_address")
        goto meta.addressGateID#0 ? block@2 : block@4
    block@2: // if_body_L917
        let (maybe_value%1#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%1#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%1#0, controlledAccountBytes#0, meta.addressGateID#0, args#0)
        (assert tmp%1#0) // Gate check failed
        goto block@4
    block@4: // after_if_else_L913
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(ref#0, ref#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(walletID#0, rekeyBack#0, ref#0, NFT#0, 0x0000)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.reactApp(walletID: uint64, rekeyBack: bool, ref: uint64, NFT: uint64) -> void:
    block@0: // L927
        (assert ref#0) // Invalid App
        let (value%0#0: bytes, check%0#0: bool) = ((app_params_get AppApprovalProgram) ref#0)
        (assert check%0#0) // application exists
        let tmp%1#0: uint64 = (len value%0#0)
        (assert tmp%1#0) // Invalid App
        let tmp%3#0: bytes[8] = (itob ref#0)
        let tmp%4#0: bytes = (bzero 24u)
        let paddedRef#0: bytes[32] = (concat tmp%3#0 tmp%4#0)
        let tmp%5#0: uint64 = (len paddedRef#0)
        let tmp%6#0: bool = (== tmp%5#0 32u)
        (assert tmp%6#0) // Length must be 32
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppCreator) ref#0)
        (assert check%1#0) // application exists
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createEmptyPostIfNecessary(paddedRef#0, value%1#0)
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.createReaction(walletID#0, rekeyBack#0, paddedRef#0, NFT#0, 0x0000)
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.deleteReaction(walletID: uint64, rekeyBack: bool, ref: bytes[32], NFT: uint64) -> void:
    block@0: // L935
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // This account is banned
        let box_prefixed_key%0#0: bytes = (concat "p" ref#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let tmp%3#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(post.creator#0, controlledAccountBytes#0)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // This account is blocked by the user
        let (reactionListKey.user#0: bytes[16], reactionListKey.ref#0: bytes[16], reactionListKey.NFT#0: uint64) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rlk(controlledAccountBytes#0, ref#0, NFT#0)
        let length%0#0: uint64 = (len reactionListKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len reactionListKey.ref#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let val_as_bytes%0#0: bytes[8] = (itob reactionListKey.NFT#0)
        let encoded_tuple_buffer%2#0: bytes = (concat reactionListKey.user#0 reactionListKey.ref#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%0#0)
        let box_prefixed_key%2#0: bytes = (concat "e" encoded_tuple_buffer%3#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // This account already reacted to this post with this NFT
        let length%2#0: uint64 = (len ref#0)
        let lengths_equal%2#0: bool = (== length%2#0 32u)
        (assert lengths_equal%2#0) // invalid size
        let val_as_bytes%1#0: bytes[8] = (itob NFT#0)
        let encoded_tuple_buffer%6#0: bytes = (concat ref#0 val_as_bytes%1#0)
        let box_prefixed_key%3#0: bytes = (concat "r" encoded_tuple_buffer%6#0)
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let maybe_value_converted%0#0: uint64 = (btoi maybe_value%1#0)
        let materialized_values%0#0: uint64 = (- maybe_value_converted%0#0 1u)
        let encoded_value%0#0: bytes[8] = (itob materialized_values%0#0)
        (box_put box_prefixed_key%3#0 encoded_value%0#0)
        (box_del box_prefixed_key%2#0)
        itxn_begin
        ((itxn_field Amount) 18900u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L958
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L958
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.follow(walletID: uint64, rekeyBack: bool, address: bytes[32], args: bytes[]) -> void:
    block@0: // L963
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // This account is banned
        let tmp%3#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBlocked(address#0, controlledAccountBytes#0)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // This account is blocked by the user
        let box_prefixed_key%0#0: bytes = (concat "m" controlledAccountBytes#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 384u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let senderIsAutomated#0: bool = (getbit encoded_bool%0#0 0u)
        let tmp%5#0: bool = (! senderIsAutomated#0)
        (assert tmp%5#0) // This is an automated account
        let box_prefixed_key%1#0: bytes = (concat "m" address#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let meta.walletID#0: uint64 = (extract_uint64 maybe_value%1#0 0u)
        let meta.streak#0: uint64 = (extract_uint64 maybe_value%1#0 8u)
        let meta.startDate#0: uint64 = (extract_uint64 maybe_value%1#0 16u)
        let meta.lastActive#0: uint64 = (extract_uint64 maybe_value%1#0 24u)
        let meta.followerIndex#0: uint64 = (extract_uint64 maybe_value%1#0 32u)
        let meta.followerCount#0: uint64 = (extract_uint64 maybe_value%1#0 40u)
        let is_true%1#0: uint64 = (getbit maybe_value%1#0 384u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let meta.automated#0: bool = (getbit encoded_bool%1#0 0u)
        let meta.followGateID#0: uint64 = (extract_uint64 maybe_value%1#0 49u)
        let meta.addressGateID#0: uint64 = (extract_uint64 maybe_value%1#0 57u)
        goto meta.followGateID#0 ? block@1 : block@2
    block@1: // if_body_L975
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%7#0: bool = smart_contracts/utils/functions.ts::gateCheck(maybe_value%2#0, controlledAccountBytes#0, meta.followGateID#0, args#0)
        (assert tmp%7#0) // Gate check failed
        goto block@2
    block@2: // after_if_else_L975
        let followsKey.index#0: uint64 = (+ meta.followerIndex#0 1u)
        let val_as_bytes%0#0: bytes[8] = (itob followsKey.index#0)
        let encoded_tuple_buffer%2#0: bytes = (concat address#0 val_as_bytes%0#0)
        let box_prefixed_key%2#0: bytes = (concat "f" encoded_tuple_buffer%2#0)
        (box_put box_prefixed_key%2#0 controlledAccountBytes#0)
        let tmp%10#0: uint64 = (+ meta.followerCount#0 1u)
        let val_as_bytes%1#0: bytes[8] = (itob meta.walletID#0)
        let val_as_bytes%2#0: bytes[8] = (itob meta.streak#0)
        let val_as_bytes%3#0: bytes[8] = (itob meta.startDate#0)
        let val_as_bytes%4#0: bytes[8] = (itob meta.lastActive#0)
        let val_as_bytes%6#0: bytes[8] = (itob tmp%10#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u meta.automated#0)
        let val_as_bytes%7#0: bytes[8] = (itob meta.followGateID#0)
        let val_as_bytes%8#0: bytes[8] = (itob meta.addressGateID#0)
        let encoded_tuple_buffer%5#0: bytes = (concat val_as_bytes%1#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 encoded_bool%2#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%8#0)
        (box_put box_prefixed_key%1#0 encoded_tuple_buffer%12#0)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, walletID#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Amount) 31700u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unfollow(walletID: uint64, rekeyBack: bool, address: bytes[32], index: uint64) -> void:
    block@0: // L1000
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // This account is banned
        let val_as_bytes%0#0: bytes[8] = (itob index#0)
        let encoded_tuple_buffer%2#0: bytes = (concat address#0 val_as_bytes%0#0)
        let box_prefixed_key%0#0: bytes = (concat "f" encoded_tuple_buffer%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let tmp%3#0: bool = (== maybe_value%0#0 controlledAccountBytes#0)
        (assert tmp%3#0) // Wrong follower key
        let box_prefixed_key%1#0: bytes = (concat "m" address#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let meta.walletID#0: uint64 = (extract_uint64 maybe_value%1#0 0u)
        let meta.streak#0: uint64 = (extract_uint64 maybe_value%1#0 8u)
        let meta.startDate#0: uint64 = (extract_uint64 maybe_value%1#0 16u)
        let meta.lastActive#0: uint64 = (extract_uint64 maybe_value%1#0 24u)
        let meta.followerIndex#0: uint64 = (extract_uint64 maybe_value%1#0 32u)
        let meta.followerCount#0: uint64 = (extract_uint64 maybe_value%1#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 384u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let meta.automated#0: bool = (getbit encoded_bool%0#0 0u)
        let meta.followGateID#0: uint64 = (extract_uint64 maybe_value%1#0 49u)
        let meta.addressGateID#0: uint64 = (extract_uint64 maybe_value%1#0 57u)
        let tmp%4#0: uint64 = (- meta.followerCount#0 1u)
        let val_as_bytes%1#0: bytes[8] = (itob meta.walletID#0)
        let val_as_bytes%2#0: bytes[8] = (itob meta.streak#0)
        let val_as_bytes%3#0: bytes[8] = (itob meta.startDate#0)
        let val_as_bytes%4#0: bytes[8] = (itob meta.lastActive#0)
        let val_as_bytes%5#0: bytes[8] = (itob meta.followerIndex#0)
        let val_as_bytes%6#0: bytes[8] = (itob tmp%4#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u meta.automated#0)
        let val_as_bytes%7#0: bytes[8] = (itob meta.followGateID#0)
        let val_as_bytes%8#0: bytes[8] = (itob meta.addressGateID#0)
        let encoded_tuple_buffer%5#0: bytes = (concat val_as_bytes%1#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 encoded_bool%1#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%8#0)
        (box_put box_prefixed_key%1#0 encoded_tuple_buffer%12#0)
        (box_del box_prefixed_key%0#0)
        itxn_begin
        ((itxn_field Amount) 31700u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L1026
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L1026
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.block(walletID: uint64, rekeyBack: bool, address: bytes[32]) -> void:
    block@0: // L1033
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // This account is banned
        let (blocksKey.user#0: bytes[16], blocksKey.blocked#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.blk(controlledAccountBytes#0, address#0)
        let length%0#0: uint64 = (len blocksKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len blocksKey.blocked#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat blocksKey.user#0 blocksKey.blocked#0)
        let box_prefixed_key%0#0: bytes = (concat "b" encoded_tuple_buffer%2#0)
        (box_create box_prefixed_key%0#0 0u)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, walletID#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Amount) 15700u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unblock(walletID: uint64, rekeyBack: bool, address: bytes[32]) -> void:
    block@0: // L1053
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let tmp%1#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isBanned(controlledAccountBytes#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0) // This account is banned
        let (blocksKey.user#0: bytes[16], blocksKey.blocked#0: bytes[16]) = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.blk(controlledAccountBytes#0, address#0)
        let length%0#0: uint64 = (len blocksKey.user#0)
        let lengths_equal%0#0: bool = (== length%0#0 16u)
        (assert lengths_equal%0#0) // invalid size
        let length%1#0: uint64 = (len blocksKey.blocked#0)
        let lengths_equal%1#0: bool = (== length%1#0 16u)
        (assert lengths_equal%1#0) // invalid size
        let encoded_tuple_buffer%2#0: bytes = (concat blocksKey.user#0 blocksKey.blocked#0)
        let box_prefixed_key%0#0: bytes = (concat "b" encoded_tuple_buffer%2#0)
        (box_del box_prefixed_key%0#0)
        itxn_begin
        ((itxn_field Amount) 15700u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L1070
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L1070
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addModerator(walletID: uint64, rekeyBack: bool, address: bytes[32]) -> void:
    block@0: // L1075
        let (spendingAddressBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "spending_address")
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== walletID#0 maybe_value%0#0)
        (assert tmp%1#0) // Not the DAO
        let box_prefixed_key%0#0: bytes = (concat "d" address#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        let tmp%2#0: bool = (! maybe_exists%1#0)
        (assert tmp%2#0) // Already a moderator
        (box_create box_prefixed_key%0#0 0u)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, walletID#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Amount) 15700u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeModerator(walletID: uint64, rekeyBack: bool, address: bytes[32]) -> void:
    block@0: // L1095
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== walletID#0 maybe_value%0#0)
        (assert tmp%1#0) // Not the DAO
        let box_prefixed_key%0#0: bytes = (concat "d" address#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Sender is not a moderator
        (box_del box_prefixed_key%0#0)
        itxn_begin
        ((itxn_field Amount) 15700u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L1112
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L1112
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.ban(walletID: uint64, rekeyBack: bool, address: bytes[32], expiration: uint64) -> void:
    block@0: // L1117
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let box_prefixed_key%0#0: bytes = (concat "d" controlledAccountBytes#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Sender is not a moderator
        let box_prefixed_key%1#0: bytes = (concat "n" address#0)
        let (_%1#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%1#0)
        let tmp%1#0: bool = (! maybe_exists%1#0)
        (assert tmp%1#0) // This account is already banned
        let encoded_value%0#0: bytes[8] = (itob expiration#0)
        (box_put box_prefixed_key%1#0 encoded_value%0#0)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, walletID#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Amount) 18900u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.flagPost(walletID: uint64, rekeyBack: bool, ref: bytes[32]) -> void:
    block@0: // L1136
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let box_prefixed_key%0#0: bytes = (concat "d" controlledAccountBytes#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Sender is not a moderator
        let box_prefixed_key%1#0: bytes = (concat "p" ref#0)
        let (_%1#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Post not found
        let (maybe_value%0#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%2#0) // Box must have value
        let post.creator#0: bytes[32] = ((extract 0 32) maybe_value%0#0) // on error: Index access is out of bounds
        let post.timestamp#0: uint64 = (extract_uint64 maybe_value%0#0 32u)
        let post.gateID#0: uint64 = (extract_uint64 maybe_value%0#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 384u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let post.againstContentPolicy#0: bool = (getbit encoded_bool%0#0 0u)
        let is_true%1#0: uint64 = (getbit maybe_value%0#0 385u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let post.isAmendment#0: bool = (getbit encoded_bool%1#0 0u)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 49u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let item5%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let post.ref#0: bytes = ((extract 2 0) item5%0#0)
        let tmp%1#0: bool = (! post.againstContentPolicy#0)
        (assert tmp%1#0) // Already flagged
        (box_del box_prefixed_key%1#0)
        let val_as_bytes%0#0: bytes[8] = (itob post.timestamp#0)
        let val_as_bytes%1#0: bytes[8] = (itob post.gateID#0)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u post.isAmendment#0)
        let length%0#0: uint64 = (len post.ref#0)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 post.ref#0)
        let encoded_tuple_buffer%2#0: bytes = (concat post.creator#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 0x80)
        let is_true%2#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%5#0: bytes = (setbit encoded_tuple_buffer%4#0 385u is_true%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0033)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 encoded_value%0#0)
        (box_put box_prefixed_key%1#0 encoded_tuple_buffer%7#0)
        goto rekeyBack#0 ? block@1 : block@2
    block@1: // if_body_L1150
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@2
    block@2: // after_if_else_L1150
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.unban(walletID: uint64, rekeyBack: bool, address: bytes[32]) -> void:
    block@0: // L1155
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let box_prefixed_key%0#0: bytes = (concat "d" controlledAccountBytes#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Sender is not a moderator
        let box_prefixed_key%1#0: bytes = (concat "n" address#0)
        (box_del box_prefixed_key%1#0)
        itxn_begin
        ((itxn_field Amount) 18900u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L1170
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L1170
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.addAction(walletID: uint64, rekeyBack: bool, actionAppID: uint64, content: bytes[36]) -> void:
    block@0: // L1175
        let (spendingAddressBytes#0: bytes, _#0: bool) = (app_global_get_ex walletID#0 "spending_address")
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== walletID#0 maybe_value%0#0)
        (assert tmp%1#0) // Not the DAO
        let encoded_value%0#0: bytes[8] = (itob actionAppID#0)
        let box_prefixed_key%0#0: bytes = (concat "a" encoded_value%0#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        let tmp%2#0: bool = (! maybe_exists%1#0)
        (assert tmp%2#0) // Already an action
        let length%0#0: uint64 = (len content#0)
        let lengths_equal%0#0: bool = (== length%0#0 36u)
        (assert lengths_equal%0#0) // invalid size
        (box_put box_prefixed_key%0#0 content#0)
        itxn_begin
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack#0, walletID#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Amount) 29700u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.removeAction(walletID: uint64, rekeyBack: bool, actionAppID: uint64) -> void:
    block@0: // L1195
        let (controlledAccountBytes#0: bytes, _#1: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#2: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== walletID#0 maybe_value%0#0)
        (assert tmp%1#0) // Not the DAO
        let encoded_value%0#0: bytes[8] = (itob actionAppID#0)
        let box_prefixed_key%0#0: bytes = (concat "a" encoded_value%0#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Already an action
        (box_del box_prefixed_key%0#0)
        itxn_begin
        ((itxn_field Amount) 29700u)
        ((itxn_field Receiver) controlledAccountBytes#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto rekeyBack#0 ? block@2 : block@3
    block@2: // if_body_L1212
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@3
    block@3: // after_if_else_L1212
        return 

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.initMeta(walletID: uint64, rekeyBack: bool, automated: bool, subscriptionIndex: uint64, NFD: uint64, akitaNFT: uint64) -> uint64:
    block@0: // L1217
        let (controlledAccountBytes#0: bytes, _#3: bool) = (app_global_get_ex walletID#0 "controlled_address")
        let (spendingAddressBytes#0: bytes, _#4: bool) = (app_global_get_ex walletID#0 "spending_address")
        let (_#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) walletID#0)
        (assert check%0#0) // application exists
        let tmp%0#0: bool = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.controls(spendingAddressBytes#0)
        (assert tmp%0#0) // This plugin does not have control of the account
        let box_prefixed_key%0#0: bytes = (concat "m" controlledAccountBytes#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        let tmp%1#0: bool = (! maybe_exists%0#0)
        (assert tmp%1#0) // Meta box values already exist
        goto automated#0 ? block@1 : block@3
    block@1: // if_body_L1232
        let tmp%2#0: uint64 = (global LatestTimestamp)
        let tmp%3#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%0#0: bytes[8] = (itob walletID#0)
        let val_as_bytes%1#0: bytes[8] = (itob 1u)
        let val_as_bytes%2#0: bytes[8] = (itob tmp%2#0)
        let val_as_bytes%3#0: bytes[8] = (itob tmp%3#0)
        let val_as_bytes%4#0: bytes[8] = (itob 0u)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 0x80)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%4#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%9#0)
        itxn_begin
        let (akitaDAO#1: uint64, maybe_exists%1#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%1#0) // check GlobalState exists
        let (pluginAppListBytes#1: bytes, _#2: bool) = (app_global_get_ex akitaDAO#1 "plugn_al")
        let item2%1#1: uint64 = (extract_uint64 pluginAppListBytes#1 16u)
        ((itxn_field ApplicationArgs) method "cacheMeta(uint64,uint64,uint64)uint64")
        ((itxn_field ApplicationArgs) val_as_bytes%4#0)
        ((itxn_field ApplicationArgs) val_as_bytes%4#0)
        ((itxn_field ApplicationArgs) val_as_bytes%4#0)
        ((itxn_field ApplicationID) item2%1#1)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%3#0: bytes = (itxn LastLog)
        let tmp%8#0: bytes = ((extract 0 4) awst_tmp%3#0)
        let tmp%9#0: bool = (== tmp%8#0 0x151f7c75)
        (assert tmp%9#0) // Bytes has valid prefix
        return 0u
    block@3: // after_if_else_L1232
        let tmp%11#0: uint64 = (global LatestTimestamp)
        let tmp%12#0: uint64 = (global LatestTimestamp)
        let val_as_bytes%11#0: bytes[8] = (itob walletID#0)
        let val_as_bytes%12#0: bytes[8] = (itob 1u)
        let val_as_bytes%13#0: bytes[8] = (itob tmp%11#0)
        let val_as_bytes%14#0: bytes[8] = (itob tmp%12#0)
        let val_as_bytes%15#0: bytes[8] = (itob 0u)
        let encoded_tuple_buffer%12#0: bytes = (concat val_as_bytes%11#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%13#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%14#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%15#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%15#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 0x00)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 val_as_bytes%15#0)
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%15#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%19#0)
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (pluginAppListBytes#0: bytes, _#1: bool) = (app_global_get_ex akitaDAO#0 "plugn_al")
        let item2%1#0: uint64 = (extract_uint64 pluginAppListBytes#0 16u)
        let val_as_bytes%19#0: bytes[8] = (itob subscriptionIndex#0)
        let val_as_bytes%20#0: bytes[8] = (itob NFD#0)
        let val_as_bytes%21#0: bytes[8] = (itob akitaNFT#0)
        ((itxn_field ApplicationArgs) method "cacheMeta(uint64,uint64,uint64)uint64")
        ((itxn_field ApplicationArgs) val_as_bytes%19#0)
        ((itxn_field ApplicationArgs) val_as_bytes%20#0)
        ((itxn_field ApplicationArgs) val_as_bytes%21#0)
        ((itxn_field ApplicationID) item2%1#0)
        ((itxn_field Sender) spendingAddressBytes#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%4#0: bytes = (itxn LastLog)
        let tmp%16#0: bytes = ((extract 4 0) awst_tmp%4#0)
        let tmp%17#0: bytes = ((extract 0 4) awst_tmp%4#0)
        let tmp%18#0: bool = (== tmp%17#0 0x151f7c75)
        (assert tmp%18#0) // Bytes has valid prefix
        let impact#0: uint64 = (btoi tmp%16#0)
        goto rekeyBack#0 ? block@5 : block@6
    block@5: // if_body_L1280
        smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.rekeyBack(walletID#0)
        goto block@6
    block@6: // after_if_else_L1280
        let tmp%20#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(controlledAccountBytes#0)
        let tmp%21#0: uint64 = (+ impact#0 tmp%20#0)
        return tmp%21#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getUserSocialImpact(user: bytes[32]) -> uint64:
    block@0: // L1289
        let tmp%0#0: uint64 = smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getSocialImpactScore(user#0)
        return tmp%0#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.isFollower(user: bytes[32], index: uint64, follower: bytes[32]) -> bool:
    block@0: // L1294
        let val_as_bytes%0#0: bytes[8] = (itob index#0)
        let encoded_tuple_buffer%2#0: bytes = (concat user#0 val_as_bytes%0#0)
        let box_prefixed_key%0#0: bytes = (concat "f" encoded_tuple_buffer%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let tmp%0#0: bool = (== maybe_value%0#0 follower#0)
        return tmp%0#0

subroutine smart_contracts/arc58/plugins/social/contract.algo.ts::AkitaSocialPlugin.getMeta(user: bytes[32]) -> <uint64, uint64, uint64, uint64, uint64, uint64, bool, uint64, uint64>:
    block@0: // L1299
        let box_prefixed_key%0#0: bytes = (concat "m" user#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let item0%1#0: uint64 = (extract_uint64 maybe_value%0#0 0u)
        let item1%1#0: uint64 = (extract_uint64 maybe_value%0#0 8u)
        let item2%1#0: uint64 = (extract_uint64 maybe_value%0#0 16u)
        let item3%1#0: uint64 = (extract_uint64 maybe_value%0#0 24u)
        let item4%1#0: uint64 = (extract_uint64 maybe_value%0#0 32u)
        let item5%1#0: uint64 = (extract_uint64 maybe_value%0#0 40u)
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 384u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item6%0#0: bool = (getbit encoded_bool%0#0 0u)
        let item7%1#0: uint64 = (extract_uint64 maybe_value%0#0 49u)
        let item8%1#0: uint64 = (extract_uint64 maybe_value%0#0 57u)
        return item0%1#0 item1%1#0 item2%1#0 item3%1#0 item4%1#0 item5%1#0 item6%0#0 item7%1#0 item8%1#0

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.update(newVersion: bytes) -> void:
    block@0: // L78
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "version" newVersion#0)
        return 

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAO(app: uint64) -> void:
    block@0: // L86
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "akita_dao" app#0)
        return 

subroutine smart_contracts/utils/base-contracts/base.ts::AkitaBaseEscrow.updateAkitaDAOEscrow(app: uint64) -> void:
    block@0: // L91
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // Only the Akita DAO can call this function
        (app_global_put "akita_escrow" app#0)
        return 