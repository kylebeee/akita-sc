#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 17 4 100000
    bytecblock "spending_address" "e" 0x1e 0x00 0x14 "akita_dao"
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0x2d2f922b 0x3500c8ee 0x84f34c04 0xfe410f44 0xea9180dd 0x33e92c94 // method "optin(uint64,bool,uint64[],pay)void", method "newReceiveEscrow(uint64,bool,uint64,address,bool,bool,(uint64,uint8,uint64)[])void", method "startEscrowDisbursement(uint64,bool)void", method "processEscrowAllocation(uint64,bool,uint64[])void", method "update(string)void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_optin_route@3 main_newReceiveEscrow_route@4 main_startEscrowDisbursement_route@5 main_processEscrowAllocation_route@6 main_update_route@7 main_updateAkitaDAO_route@8

main_after_if_else@15:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    intc_0 // 0
    return

main_updateAkitaDAO_route@8:
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@7:
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:18
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_processEscrowAllocation_route@6:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:175
    // processEscrowAllocation(walletID: uint64, rekeyBack: boolean, ids: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:175
    // processEscrowAllocation(walletID: uint64, rekeyBack: boolean, ids: uint64[]): void {
    callsub processEscrowAllocation
    intc_1 // 1
    return

main_startEscrowDisbursement_route@5:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:154
    // startEscrowDisbursement(walletID: uint64, rekeyBack: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:154
    // startEscrowDisbursement(walletID: uint64, rekeyBack: boolean): void {
    callsub startEscrowDisbursement
    intc_1 // 1
    return

main_newReceiveEscrow_route@4:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:116-124
    // newReceiveEscrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   escrowID: uint64,
    //   source: Address,
    //   allocatable: boolean,
    //   optinAllowed: boolean,
    //   splits: Split[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    intc_0 // 0
    getbit
    txna ApplicationArgs 7
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:116-124
    // newReceiveEscrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   escrowID: uint64,
    //   source: Address,
    //   allocatable: boolean,
    //   optinAllowed: boolean,
    //   splits: Split[]
    // ): void {
    callsub newReceiveEscrow
    intc_1 // 1
    return

main_optin_route@3:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:79
    // optin(walletID: uint64, rekeyBack: boolean, assets: uint64[], mbrPayment: gtxn.PaymentTxn): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:79
    // optin(walletID: uint64, rekeyBack: boolean, assets: uint64[], mbrPayment: gtxn.PaymentTxn): void {
    callsub optin
    intc_1 // 1
    return

main_bare_routing@11:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:67
    // export class RevenueStreamer extends AkitaBaseContract {
    txn OnCompletion
    bnz main_after_if_else@15
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::mustGetEscrowInfo(wallet: uint64) -> bytes:
mustGetEscrowInfo:
    // smart_contracts/utils/functions.ts:261
    // export function mustGetEscrowInfo(wallet: Application): EscrowInfo {
    proto 1 1
    // smart_contracts/utils/functions.ts:243-246
    // const [escrowBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysCurrentEscrow)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:245
    // Bytes(AbstractAccountGlobalStateKeysCurrentEscrow)
    pushbytes "current_escrow"
    // smart_contracts/utils/functions.ts:243-246
    // const [escrowBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysCurrentEscrow)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:252-258
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_getEscrows,
    //   {
    //     appId: wallet.id,
    //     args: [[escrow]]
    //   }
    // ).returnValue[0]
    itxn_begin
    // smart_contracts/utils/functions.ts:256
    // args: [[escrow]]
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x00010002
    swap
    concat
    // smart_contracts/utils/functions.ts:252-258
    // return abiCall(
    //   AbstractedAccountInterface.prototype.arc58_getEscrows,
    //   {
    //     appId: wallet.id,
    //     args: [[escrow]]
    //   }
    // ).returnValue[0]
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    pushbytes 0x151f7c75
    ==
    assert // Bytes has valid prefix
    extract 6 9
    // smart_contracts/utils/functions.ts:263
    // assert(info.id > 0, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    intc_0 // 0
    extract_uint64
    assert // Escrow does not exist
    // smart_contracts/utils/functions.ts:264
    // return info
    retsub


// smart_contracts/utils/functions.ts::rekeyBackIfNecessary(rekeyBack: uint64, wallet: uint64) -> void:
rekeyBackIfNecessary:
    // smart_contracts/utils/functions.ts:275
    // export function rekeyBackIfNecessary(rekeyBack: boolean, wallet: Application): void {
    proto 2 0
    // smart_contracts/utils/functions.ts:276
    // if (rekeyBack) {
    frame_dig -2
    bz rekeyBackIfNecessary_after_if_else@3
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:278-285
    // itxn
    //   .payment({
    //     sender,
    //     receiver: sender,
    //     amount: 0,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/utils/functions.ts:283
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -2
    frame_dig -1
    callsub rekeyAddress
    itxn_field RekeyTo
    // smart_contracts/utils/functions.ts:282
    // amount: 0,
    intc_0 // 0
    itxn_field Amount
    dup
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/utils/functions.ts:278-284
    // itxn
    //   .payment({
    //     sender,
    //     receiver: sender,
    //     amount: 0,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:278-285
    // itxn
    //   .payment({
    //     sender,
    //     receiver: sender,
    //     amount: 0,
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //   })
    //   .submit()
    itxn_submit

rekeyBackIfNecessary_after_if_else@3:
    retsub


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:289
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:290
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:291
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:294
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts::RevenueStreamer.controls(sender: bytes) -> uint64:
controls:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:75
    // private controls(sender: Account): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:76
    // return sender.authAddress === Global.currentApplicationAddress
    frame_dig -1
    acct_params_get AcctAuthAddr
    assert // account funded
    global CurrentApplicationAddress
    ==
    retsub


// smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts::RevenueStreamer.optin(walletID: uint64, rekeyBack: uint64, assets: bytes, mbrPayment: uint64) -> void:
optin:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:79
    // optin(walletID: uint64, rekeyBack: boolean, assets: uint64[], mbrPayment: gtxn.PaymentTxn): void {
    proto 4 0
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:83-90
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: sender,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -1
    gtxns Receiver
    ==
    frame_dig -1
    gtxns Amount
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:87
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    cover 4
    *
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:83-90
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: sender,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:92
    // assert(this.escrows(walletID).exists, ERR_RECEIVE_ESCROW_DOES_NOT_EXIST)
    frame_dig -4
    itob
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:69
    // escrows = BoxMap<uint64, ReceiveEscrow>({ keyPrefix: RevenueStreamerBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:92
    // assert(this.escrows(walletID).exists, ERR_RECEIVE_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Receive escrow does not exist
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:94
    // const { source, optinAllowed } = this.escrows(walletID).value
    box_get
    pop
    dup
    extract 0 32
    swap
    pushint 257 // 257
    getbit
    // smart_contracts/utils/functions.ts:268-271
    // const [rekeyIndexBytes] = op.AppGlobal.getExUint64(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysRekeyIndex)
    // )
    frame_dig -4
    // smart_contracts/utils/functions.ts:270
    // Bytes(AbstractAccountGlobalStateKeysRekeyIndex)
    pushbytes "rekey_index"
    // smart_contracts/utils/functions.ts:268-271
    // const [rekeyIndexBytes] = op.AppGlobal.getExUint64(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysRekeyIndex)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:95
    // const initiator = gtxn.Transaction(getRekeyIndex(wallet)).sender
    gtxns Sender
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:96
    // assert(source.native === initiator, ERR_FORBIDDEN)
    uncover 2
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:97
    // assert(optinAllowed, ERR_ESCROW_NOT_ALLOWED_TO_OPTIN)
    assert // Escrow is not allowed to opt-in
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:99
    // for (let i: uint64 = 0; i < assets.length; i++) {
    intc_0 // 0

optin_while_top@1:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:99
    // for (let i: uint64 = 0; i < assets.length; i++) {
    frame_dig 3
    frame_dig 1
    <
    bz optin_after_while@4
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:100
    // assert(!sender.isOptedIn(Asset(assets[i])), ERR_ALREADY_OPTED_IN)
    frame_dig -2
    extract 2 0
    frame_dig 3
    dup
    cover 2
    pushint 8 // 8
    *
    extract_uint64
    frame_dig 0
    dup
    cover 2
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // already opted in
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:102-110
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: sender,
    //     assetAmount: 0,
    //     xferAsset: Asset(assets[i]),
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:108
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    itxn_field RekeyTo
    itxn_field XferAsset
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:106
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:102-109
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: sender,
    //     assetAmount: 0,
    //     xferAsset: Asset(assets[i]),
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:102-110
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: sender,
    //     assetAmount: 0,
    //     xferAsset: Asset(assets[i]),
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:99
    // for (let i: uint64 = 0; i < assets.length; i++) {
    intc_1 // 1
    +
    frame_bury 3
    b optin_while_top@1

optin_after_while@4:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:113
    // this.escrows(walletID).value.optinCount += assets.length
    frame_dig 2
    dup
    box_get
    assert // Box must have value
    pushint 33 // 33
    extract_uint64
    frame_dig 1
    +
    itob
    pushint 33 // 33
    swap
    box_replace
    retsub


// smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts::RevenueStreamer.newReceiveEscrow(walletID: uint64, rekeyBack: uint64, escrowID: uint64, source: bytes, allocatable: uint64, optinAllowed: uint64, splits: bytes) -> void:
newReceiveEscrow:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:116-124
    // newReceiveEscrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   escrowID: uint64,
    //   source: Address,
    //   allocatable: boolean,
    //   optinAllowed: boolean,
    //   splits: Split[]
    // ): void {
    proto 7 0
    intc_0 // 0
    pushbytes ""
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:127
    // assert(this.controls(sender), ERR_FORBIDDEN)
    callsub controls
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:128
    // assert(splits.length > 0, ERR_SPLITS_CANNOT_BE_EMPTY)
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dupn 2
    assert // Splits cannot be empty
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:129
    // assert(splits.length <= 10, ERR_SPLITS_CANNOT_BE_MORE_THAN_10)
    pushint 10 // 10
    <=
    assert // Splits cannot be more than 10
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:139
    // creationDate: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:131-140
    // this.escrows(escrowID).value = {
    //   source,
    //   allocatable,
    //   optinAllowed,
    //   optinCount: 0,
    //   phase: EscrowDisbursementPhaseIdle,
    //   allocationCounter: 0,
    //   lastDisbursement: 0,
    //   creationDate: Global.latestTimestamp,
    // }
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    intc_1 // 1
    frame_dig -2
    setbit
    frame_dig -4
    swap
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:135
    // optinCount: 0,
    intc_0 // 0
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:131-140
    // this.escrows(escrowID).value = {
    //   source,
    //   allocatable,
    //   optinAllowed,
    //   optinCount: 0,
    //   phase: EscrowDisbursementPhaseIdle,
    //   allocationCounter: 0,
    //   lastDisbursement: 0,
    //   creationDate: Global.latestTimestamp,
    // }
    itob
    swap
    dig 1
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:136
    // phase: EscrowDisbursementPhaseIdle,
    bytec_3 // 0x00
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:131-140
    // this.escrows(escrowID).value = {
    //   source,
    //   allocatable,
    //   optinAllowed,
    //   optinCount: 0,
    //   phase: EscrowDisbursementPhaseIdle,
    //   allocationCounter: 0,
    //   lastDisbursement: 0,
    //   creationDate: Global.latestTimestamp,
    // }
    concat
    dig 1
    concat
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:131
    // this.escrows(escrowID).value = {
    frame_dig -5
    itob
    dup
    cover 2
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:69
    // escrows = BoxMap<uint64, ReceiveEscrow>({ keyPrefix: RevenueStreamerBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:131-140
    // this.escrows(escrowID).value = {
    //   source,
    //   allocatable,
    //   optinAllowed,
    //   optinCount: 0,
    //   phase: EscrowDisbursementPhaseIdle,
    //   allocationCounter: 0,
    //   lastDisbursement: 0,
    //   creationDate: Global.latestTimestamp,
    // }
    swap
    box_put
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:142
    // for (let i: uint64 = 0; i < splits.length; i++) {
    intc_0 // 0

newReceiveEscrow_while_top@1:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:142
    // for (let i: uint64 = 0; i < splits.length; i++) {
    frame_dig 4
    frame_dig 2
    <
    bz newReceiveEscrow_after_while@11
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:144
    // const isLast = i === splits.length - 1
    frame_dig 2
    intc_1 // 1
    -
    frame_dig 4
    dup
    uncover 2
    ==
    frame_bury 1
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:145
    // assert(split.value > 0 || split.type === SplitDistributionTypeRemainder, ERR_SPLIT_VALUE_MUST_BE_POSITIVE_OR_REMAINDER)
    frame_dig -1
    extract 2 0
    swap
    intc_2 // 17
    *
    intc_2 // 17
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    pushint 9 // 9
    extract_uint64
    bnz newReceiveEscrow_bool_true@4
    frame_dig 0
    extract 8 1
    bytec_2 // 0x1e
    ==
    bz newReceiveEscrow_bool_false@5

newReceiveEscrow_bool_true@4:
    intc_1 // 1

newReceiveEscrow_bool_merge@6:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:145
    // assert(split.value > 0 || split.type === SplitDistributionTypeRemainder, ERR_SPLIT_VALUE_MUST_BE_POSITIVE_OR_REMAINDER)
    assert // Split value must be positive or remainder
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:146
    // assert(!isLast || split.type !== SplitDistributionTypeRemainder, ERR_REMAINDER_MUST_BE_LAST)
    frame_dig 1
    bz newReceiveEscrow_bool_true@8
    frame_dig 0
    extract 8 1
    bytec_2 // 0x1e
    !=
    bz newReceiveEscrow_bool_false@9

newReceiveEscrow_bool_true@8:
    intc_1 // 1

newReceiveEscrow_bool_merge@10:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:146
    // assert(!isLast || split.type !== SplitDistributionTypeRemainder, ERR_REMAINDER_MUST_BE_LAST)
    assert // Remainder split must be the last split
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:142
    // for (let i: uint64 = 0; i < splits.length; i++) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b newReceiveEscrow_while_top@1

newReceiveEscrow_bool_false@9:
    intc_0 // 0
    b newReceiveEscrow_bool_merge@10

newReceiveEscrow_bool_false@5:
    intc_0 // 0
    b newReceiveEscrow_bool_merge@6

newReceiveEscrow_after_while@11:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:73
    // splits = BoxMap<uint64, Split[]>({ keyPrefix: RevenueStreamerBoxPrefixSplits })
    pushbytes "s"
    frame_dig 3
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:149
    // this.splits(escrowID).value = clone(splits)
    dup
    box_del
    pop
    frame_dig -1
    box_put
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:151
    // rekeyBackIfNecessary(rekeyBack, wallet)
    frame_dig -6
    frame_dig -7
    callsub rekeyBackIfNecessary
    retsub


// smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts::RevenueStreamer.startEscrowDisbursement(walletID: uint64, rekeyBack: uint64) -> void:
startEscrowDisbursement:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:154
    // startEscrowDisbursement(walletID: uint64, rekeyBack: boolean): void {
    proto 2 0
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:156
    // const escrow = mustGetEscrowInfo(wallet)
    frame_dig -2
    callsub mustGetEscrowInfo
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:158
    // assert(this.controls(sender), ERR_FORBIDDEN)
    callsub controls
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:160
    // assert(this.escrows(escrow.id).exists, ERR_ESCROW_DOES_NOT_EXIST)
    extract 0 8
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:69
    // escrows = BoxMap<uint64, ReceiveEscrow>({ keyPrefix: RevenueStreamerBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:160
    // assert(this.escrows(escrow.id).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:162
    // const { phase, allocatable, lastDisbursement, creationDate } = this.escrows(escrow.id).value
    dup
    box_get
    pop
    dup
    extract 41 1
    dig 1
    pushint 256 // 256
    getbit
    dig 2
    pushint 50 // 50
    extract_uint64
    uncover 3
    pushint 58 // 58
    extract_uint64
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:163
    // assert(phase === EscrowDisbursementPhaseIdle, ERR_ESCROW_NOT_IDLE)
    uncover 3
    bytec_3 // 0x00
    ==
    assert // Escrow is not in idle phase
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:164
    // assert(allocatable, ERR_ESCROW_NOT_ALLOCATABLE)
    uncover 2
    assert // Escrow is not allocatable
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:166
    // const latestWindow: uint64 = Global.latestTimestamp - ((Global.latestTimestamp - creationDate) % ONE_DAY)
    global LatestTimestamp
    dup
    uncover 2
    -
    pushint 86400 // 86400
    %
    -
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:167
    // assert(latestWindow >= lastDisbursement, ERR_ESCROW_NOT_READY_FOR_DISBURSEMENT)
    dup
    uncover 2
    >=
    assert // Escrow is not ready for disbursement
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:169
    // this.escrows(escrow.id).value.phase = EscrowDisbursementPhaseAllocation
    dig 1
    pushint 41 // 41
    bytec 4 // 0x14
    box_replace
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:170
    // this.escrows(escrow.id).value.lastDisbursement = latestWindow
    itob
    pushint 50 // 50
    swap
    box_replace
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:172
    // rekeyBackIfNecessary(rekeyBack, wallet)
    frame_dig -1
    frame_dig -2
    callsub rekeyBackIfNecessary
    retsub


// smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts::RevenueStreamer.processEscrowAllocation(walletID: uint64, rekeyBack: uint64, ids: bytes) -> void:
processEscrowAllocation:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:175
    // processEscrowAllocation(walletID: uint64, rekeyBack: boolean, ids: uint64[]): void {
    proto 3 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 6
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:177
    // const escrow = mustGetEscrowInfo(wallet)
    frame_dig -3
    callsub mustGetEscrowInfo
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:180
    // const { phase, optinCount, allocationCounter } = this.escrows(escrow.id).value
    extract 0 8
    dup
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:69
    // escrows = BoxMap<uint64, ReceiveEscrow>({ keyPrefix: RevenueStreamerBoxPrefixEscrows })
    bytec_1 // "e"
    dig 1
    concat
    dup
    cover 2
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:180
    // const { phase, optinCount, allocationCounter } = this.escrows(escrow.id).value
    box_get
    assert // Box must have value
    dup
    extract 41 1
    dig 1
    pushint 33 // 33
    extract_uint64
    uncover 2
    pushint 42 // 42
    extract_uint64
    cover 3
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:181
    // assert(phase === EscrowDisbursementPhaseAllocation, ERR_ESCROW_NOT_IN_ALLOCATION_PHASE)
    swap
    bytec 4 // 0x14
    ==
    assert // Escrow is not in allocation phase
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:183
    // const totalAssetsToProcess: uint64 = optinCount + 1 // + 1 to include algo
    intc_1 // 1
    +
    swap
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:73
    // splits = BoxMap<uint64, Split[]>({ keyPrefix: RevenueStreamerBoxPrefixSplits })
    pushbytes "s"
    swap
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:187
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    intc_0 // 0

processEscrowAllocation_while_top@1:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:187
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    frame_dig 15
    >
    bz processEscrowAllocation_after_while@23
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:188
    // const asset = ids[i]
    frame_dig -1
    extract 2 0
    frame_dig 15
    pushint 8 // 8
    *
    extract_uint64
    dup
    frame_bury 5
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:189
    // assert(!this.receiveAssets({ escrow: escrow.id, asset }).exists, ERR_ASSET_ALREADY_ALLOCATED)
    dup
    itob
    frame_dig 10
    swap
    concat
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:71
    // receiveAssets = BoxMap<EscrowAssetKey, bytes<0>>({ keyPrefix: RevenueStreamerBoxPrefixReceiveAssets })
    pushbytes "a"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:189
    // assert(!this.receiveAssets({ escrow: escrow.id, asset }).exists, ERR_ASSET_ALREADY_ALLOCATED)
    box_len
    bury 1
    !
    assert // Asset is already allocated
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:190
    // assert(sender.isOptedIn(Asset(asset)), ERR_ESCROW_NOT_OPTED_IN)
    frame_dig 9
    dig 1
    asset_holding_get AssetBalance
    bury 1
    assert // Escrow is not opted in to the asset
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:192-194
    // const balance: uint64 = asset === 0
    //   ? op.balance(Global.currentApplicationAddress) - Global.minBalance
    //   : AssetHolding.assetBalance(sender, asset)[0]
    bnz processEscrowAllocation_ternary_false@4
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:193
    // ? op.balance(Global.currentApplicationAddress) - Global.minBalance
    global CurrentApplicationAddress
    balance
    global MinBalance
    -
    frame_bury 6

processEscrowAllocation_ternary_merge@5:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:196
    // let allocated: uint64 = 0
    intc_0 // 0
    frame_bury 3
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:197
    // for (let i: uint64 = 0; i < splits.length; i++) {
    intc_0 // 0
    frame_bury 8

processEscrowAllocation_while_top@6:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 14
    intc_0 // 0
    pushint 2 // 2
    box_extract
    btoi
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:197
    // for (let i: uint64 = 0; i < splits.length; i++) {
    frame_dig 8
    >
    bz processEscrowAllocation_after_while@22
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 8
    intc_2 // 17
    *
    pushint 2 // 2
    +
    dup
    frame_bury 7
    frame_dig 14
    swap
    intc_2 // 17
    box_extract
    extract 8 1
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:201
    // if (split.type === SplitDistributionTypeFlat) {
    pushbytes 0x0a
    ==
    bz processEscrowAllocation_else_body@9
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 14
    frame_dig 7
    intc_2 // 17
    box_extract
    pushint 9 // 9
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:202
    // amount = split.value
    extract_uint64
    frame_bury 4

processEscrowAllocation_after_if_else@16:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:211
    // allocated += amount
    frame_dig 3
    frame_dig 4
    +
    dup
    frame_bury 3
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:212
    // assert(allocated <= balance, ERR_OVER_ALLOCATION)
    frame_dig 6
    <=
    assert // Over allocation of assets in the escrow
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:214
    // if (asset === 0) {
    frame_dig 5
    bnz processEscrowAllocation_else_body@19
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:215-221
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Application(split.escrow).address,
    //     amount: amount
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 14
    frame_dig 7
    intc_2 // 17
    box_extract
    intc_0 // 0
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:218
    // receiver: Application(split.escrow).address,
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    frame_dig 4
    itxn_field Amount
    itxn_field Receiver
    frame_dig 9
    itxn_field Sender
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:215-220
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Application(split.escrow).address,
    //     amount: amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:215-221
    // itxn
    //   .payment({
    //     sender,
    //     receiver: Application(split.escrow).address,
    //     amount: amount
    //   })
    //   .submit()
    itxn_submit

processEscrowAllocation_after_if_else@21:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:197
    // for (let i: uint64 = 0; i < splits.length; i++) {
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 8
    b processEscrowAllocation_while_top@6

processEscrowAllocation_else_body@19:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:223-230
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Application(split.escrow).address,
    //     assetAmount: amount,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 14
    frame_dig 7
    intc_2 // 17
    box_extract
    intc_0 // 0
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:226
    // assetReceiver: Application(split.escrow).address,
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    frame_dig 5
    itxn_field XferAsset
    frame_dig 4
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 9
    itxn_field Sender
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:223-229
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Application(split.escrow).address,
    //     assetAmount: amount,
    //     xferAsset: asset
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:223-230
    // itxn
    //   .assetTransfer({
    //     sender,
    //     assetReceiver: Application(split.escrow).address,
    //     assetAmount: amount,
    //     xferAsset: asset
    //   })
    //   .submit()
    itxn_submit
    b processEscrowAllocation_after_if_else@21

processEscrowAllocation_else_body@9:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:203
    // } else if (split.type === SplitDistributionTypePercentage) {
    frame_dig 0
    bytec 4 // 0x14
    ==
    bz processEscrowAllocation_else_body@11
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:185
    // const splits = clone(this.splits(escrow.id).value)
    frame_dig 14
    frame_dig 7
    intc_2 // 17
    box_extract
    pushint 9 // 9
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:204
    // amount = calcPercent(balance, split.value)
    extract_uint64
    // smart_contracts/utils/functions.ts:83
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:84
    // return op.divw(...op.mulw(a, p), DIVISOR)
    frame_dig 6
    mulw
    intc 4 // 100000
    divw
    frame_bury 4
    b processEscrowAllocation_after_if_else@16

processEscrowAllocation_else_body@11:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:205
    // } else if (split.type === SplitDistributionTypeRemainder) {
    frame_dig 0
    bytec_2 // 0x1e
    ==
    assert // Invalid split type
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:206
    // amount = balance - allocated
    frame_dig 6
    frame_dig 3
    -
    frame_bury 4
    b processEscrowAllocation_after_if_else@16

processEscrowAllocation_after_while@22:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:234
    // this.receiveAssets({ escrow: escrow.id, asset }).create()
    frame_dig 1
    intc_0 // 0
    box_create
    pop
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:187
    // for (let i: uint64 = 0; i < ids.length; i += 1) {
    frame_dig 15
    intc_1 // 1
    +
    frame_bury 15
    b processEscrowAllocation_while_top@1

processEscrowAllocation_ternary_false@4:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:194
    // : AssetHolding.assetBalance(sender, asset)[0]
    frame_dig 9
    frame_dig 5
    asset_holding_get AssetBalance
    pop
    frame_bury 6
    b processEscrowAllocation_ternary_merge@5

processEscrowAllocation_after_while@23:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:237
    // this.escrows(escrow.id).value.allocationCounter += ids.length
    frame_dig 11
    dup
    box_get
    assert // Box must have value
    pushint 42 // 42
    extract_uint64
    frame_dig 2
    dup
    cover 2
    +
    itob
    uncover 2
    pushint 42 // 42
    uncover 2
    box_replace
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:238
    // if ((allocationCounter + ids.length) === totalAssetsToProcess) {
    frame_dig 12
    +
    frame_dig 13
    ==
    bz processEscrowAllocation_after_if_else@25
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:239
    // this.escrows(escrow.id).value.phase = EscrowDisbursementPhaseFinalization
    frame_dig 11
    pushint 41 // 41
    bytec_2 // 0x1e
    box_replace

processEscrowAllocation_after_if_else@25:
    // smart_contracts/arc58/plugins/revenue-streamer/contract.algo.ts:242
    // rekeyBackIfNecessary(rekeyBack, wallet)
    frame_dig -2
    frame_dig -3
    callsub rekeyBackIfNecessary
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update(newVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:18-19
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 5 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:20
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:12
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:21
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:26
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 5 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:27
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:14
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 5 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:28
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
