#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 6
    bytecblock "spending_address" "nfd_registry" 0x151f7c75
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:13
    // export class NFDPlugin extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@18
    pushbytess 0x0d84e7a4 0x820cd4a6 0x7b7032a0 0xfacae035 0x1f856ed2 0x23dcee6c 0xa38f8ca8 0x3f1b7ae9 0xd1b98243 0x44fcae5f 0x7886dc2a 0x5375f243 0xa3710a89 0x44613f58 // method "deleteFields(uint64,bool,uint64,byte[][])void", method "updateFields(uint64,bool,uint64,byte[][])void", method "offerForSale(uint64,bool,uint64,uint64,address)void", method "cancelSale(uint64,bool,uint64)void", method "postOffer(uint64,bool,uint64,uint64,string)void", method "purchase(uint64,bool,uint64)void", method "updateHash(uint64,bool,uint64,byte[])void", method "contractLock(uint64,bool,uint64,bool)void", method "segmentLock(uint64,bool,uint64,bool,uint64)void", method "vaultOptInLock(uint64,bool,uint64,bool)void", method "vaultOptIn(uint64,bool,uint64,uint64[])void", method "vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void", method "renew(uint64,bool,uint64,uint64)void", method "setPrimaryAddress(uint64,bool,uint64,string,address)void"
    txna ApplicationArgs 0
    match deleteFields updateFields offerForSale cancelSale postOffer purchase updateHash contractLock segmentLock vaultOptInLock vaultOptIn vaultSend renew setPrimaryAddress
    err

main_create_NoOp@18:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:13
    // export class NFDPlugin extends Contract {
    pushbytes 0x240d2f67 // method "create(uint64)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:321
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:322
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:323
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:326
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.create[routing]() -> void:
create:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:32
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:17
    // registry = GlobalState<Application>({ key: NFDPluginGlobalStateKeyRegistry })
    bytec_1 // "nfd_registry"
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:34
    // this.registry.value = Application(registry)
    swap
    app_global_put
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:32
    // @abimethod({ onCreate: 'require' })
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.deleteFields[routing]() -> void:
deleteFields:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:39-44
    // deleteFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldNames: bytes[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 3
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:47
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:49-54
    // abiCall<typeof NFD.prototype.deleteFields>({
    //   sender,
    //   appId,
    //   args: [fieldNames],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:53
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:49-54
    // abiCall<typeof NFD.prototype.deleteFields>({
    //   sender,
    //   appId,
    //   args: [fieldNames],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x5132df75 // method "deleteFields(byte[][])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:39-44
    // deleteFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldNames: bytes[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.updateFields[routing]() -> void:
updateFields:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:57-62
    // updateFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldAndVals: bytes[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 3
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:66
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:68-73
    // abiCall<typeof NFD.prototype.updateFields>({
    //   sender,
    //   appId,
    //   args: [fieldAndVals],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:72
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:68-73
    // abiCall<typeof NFD.prototype.updateFields>({
    //   sender,
    //   appId,
    //   args: [fieldAndVals],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x78f42711 // method "updateFields(byte[][])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:57-62
    // updateFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldAndVals: bytes[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.offerForSale[routing]() -> void:
offerForSale:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:76-82
    // offerForSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   sellAmount: uint64,
    //   reservedFor: Account
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:86
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:88-93
    // abiCall<typeof NFD.prototype.offerForSale>({
    //   sender,
    //   appId,
    //   args: [sellAmount, reservedFor],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:92
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:88-93
    // abiCall<typeof NFD.prototype.offerForSale>({
    //   sender,
    //   appId,
    //   args: [sellAmount, reservedFor],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x5076d9ca // method "offerForSale(uint64,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:76-82
    // offerForSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   sellAmount: uint64,
    //   reservedFor: Account
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.cancelSale[routing]() -> void:
cancelSale:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:96-100
    // cancelSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:104
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dup
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:106-111
    // abiCall<typeof NFD.prototype.cancelSale>({
    //   sender,
    //   appId,
    //   args: [],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:110
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    swap
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:106-111
    // abiCall<typeof NFD.prototype.cancelSale>({
    //   sender,
    //   appId,
    //   args: [],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x99f5d50d // method "cancelSale()void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:96-100
    // cancelSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.postOffer[routing]() -> void:
postOffer:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:114-120
    // postOffer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   offer: uint64,
    //   note: string
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:124
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:126-131
    // abiCall<typeof NFD.prototype.postOffer>({
    //   sender,
    //   appId,
    //   args: [offer, note],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:130
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:126-131
    // abiCall<typeof NFD.prototype.postOffer>({
    //   sender,
    //   appId,
    //   args: [offer, note],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x913112ef // method "postOffer(uint64,string)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:114-120
    // postOffer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   offer: uint64,
    //   note: string
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.purchase[routing]() -> void:
purchase:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:134-138
    // purchase(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:142
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dup
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:144
    // const [saleAmountBytes, saleAmountBytesExists] = op.AppGlobal.getExBytes(appId.id, Bytes(NFDGlobalStateKeySaleAmountKey))
    dup
    pushbytes "i.saleamt"
    app_global_get_ex
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:145
    // assert(saleAmountBytesExists, 'No sale amount set')
    assert // No sale amount set
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:147-158
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:153
    // receiver: appId.address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:154
    // amount: btoi(saleAmountBytes)
    swap
    btoi
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:151-155
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: btoi(saleAmountBytes)
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:147-158
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:157
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:147-158
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xa392ae82 // method "purchase(pay)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:134-138
    // purchase(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.updateHash[routing]() -> void:
updateHash:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:161-166
    // updateHash(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   hash: bytes
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:170
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:172-177
    // abiCall<typeof NFD.prototype.updateHash>({
    //   sender,
    //   appId,
    //   args: [hash],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:176
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:172-177
    // abiCall<typeof NFD.prototype.updateHash>({
    //   sender,
    //   appId,
    //   args: [hash],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x762e82da // method "updateHash(byte[])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:161-166
    // updateHash(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   hash: bytes
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.contractLock[routing]() -> void:
contractLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:180-185
    // contractLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:189
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:191-196
    // abiCall<typeof NFD.prototype.contractLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:195
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:191-196
    // abiCall<typeof NFD.prototype.contractLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x8ebc2c83 // method "contractLock(bool)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:180-185
    // contractLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.segmentLock[routing]() -> void:
segmentLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:199-205
    // segmentLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean,
    //   usdPrice: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:209
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:211-216
    // abiCall<typeof NFD.prototype.segmentLock>({
    //   sender,
    //   appId,
    //   args: [lock, usdPrice],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:215
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:211-216
    // abiCall<typeof NFD.prototype.segmentLock>({
    //   sender,
    //   appId,
    //   args: [lock, usdPrice],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xcd5358a6 // method "segmentLock(bool,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:199-205
    // segmentLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean,
    //   usdPrice: uint64
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultOptInLock[routing]() -> void:
vaultOptInLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:219-224
    // vaultOptInLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:228
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:230-235
    // abiCall<typeof NFD.prototype.vaultOptInLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:234
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:230-235
    // abiCall<typeof NFD.prototype.vaultOptInLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x3a657d77 // method "vaultOptInLock(bool)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:219-224
    // vaultOptInLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultOptIn[routing]() -> void:
vaultOptIn:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:238-243
    // vaultOptIn(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   assets: uint64[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 8
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:247
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:249-254
    // abiCall<typeof NFD.prototype.vaultOptIn>({
    //   sender,
    //   appId,
    //   args: [assets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:253
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:249-254
    // abiCall<typeof NFD.prototype.vaultOptIn>({
    //   sender,
    //   appId,
    //   args: [assets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x413d1523 // method "vaultOptIn(uint64[])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:238-243
    // vaultOptIn(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   assets: uint64[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultSend[routing]() -> void:
vaultSend:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:257-266
    // vaultSend(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   amount: uint64,
    //   receiver: Account,
    //   note: string,
    //   asset: uint64,
    //   otherAssets: uint64[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 8
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 8
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 7
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:270
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 6
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:272-277
    // abiCall<typeof NFD.prototype.vaultSend>({
    //   sender,
    //   appId,
    //   args: [amount, receiver, note, asset, otherAssets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:276
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:272-277
    // abiCall<typeof NFD.prototype.vaultSend>({
    //   sender,
    //   appId,
    //   args: [amount, receiver, note, asset, otherAssets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x66821c1a // method "vaultSend(uint64,address,string,uint64,uint64[])void"
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:257-266
    // vaultSend(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   amount: uint64,
    //   receiver: Account,
    //   note: string,
    //   asset: uint64,
    //   otherAssets: uint64[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.renew[routing]() -> void:
renew:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:280-285
    // renew(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   years: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:289
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:291-295
    // const price = abiCall<typeof NFD.prototype.getRenewPrice>({
    //   sender,
    //   appId,
    //   args: []
    // }).returnValue
    itxn_begin
    pushbytes 0x50f490c2 // method "getRenewPrice()uint64"
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationID
    dup
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:297-308
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:303
    // receiver: appId.address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:304
    // amount: (price * years)
    swap
    uncover 3
    *
    itxn_field Amount
    itxn_field Receiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:301-305
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: (price * years)
    // })
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:297-308
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:307
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:297-308
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x77fd5b74 // method "renew(pay)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:280-285
    // renew(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   years: uint64
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.setPrimaryAddress[routing]() -> void:
setPrimaryAddress:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:311-317
    // setPrimaryAddress(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldName: string,
    //   address: Account
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:320
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:322-327
    // abiCall<typeof NFD.prototype.setPrimaryAddress>({
    //   sender,
    //   appId,
    //   args: [fieldName, address],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:326
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:322-327
    // abiCall<typeof NFD.prototype.setPrimaryAddress>({
    //   sender,
    //   appId,
    //   args: [fieldName, address],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x97b6d86c // method "setPrimaryAddress(string,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:311-317
    // setPrimaryAddress(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldName: string,
    //   address: Account
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.isNFD(NFDApp: uint64) -> uint64:
isNFD:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:21
    // private isNFD(NFDApp: Application): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:22
    // const nfdNameBytes = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysName))[0]
    frame_dig -1
    pushbytes "i.name"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:24-27
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: this.registry.value,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:25
    // appId: this.registry.value,
    intc_0 // 0
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:17
    // registry = GlobalState<Application>({ key: NFDPluginGlobalStateKeyRegistry })
    bytec_1 // "nfd_registry"
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:25
    // appId: this.registry.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:26
    // args: [String(nfdNameBytes), NFDApp.id]
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:24-27
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: this.registry.value,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub
