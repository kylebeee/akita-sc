#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 6
    bytecblock "spending_address" "nfd_registry" 0x151f7c75
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:11
    // export class NFDPlugin extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@18
    pushbytess 0x0d84e7a4 0x820cd4a6 0x7b7032a0 0xfacae035 0x1f856ed2 0x23dcee6c 0xa38f8ca8 0x3f1b7ae9 0xd1b98243 0x44fcae5f 0x7886dc2a 0x5375f243 0xa3710a89 0x44613f58 // method "deleteFields(uint64,bool,uint64,byte[][])void", method "updateFields(uint64,bool,uint64,byte[][])void", method "offerForSale(uint64,bool,uint64,uint64,address)void", method "cancelSale(uint64,bool,uint64)void", method "postOffer(uint64,bool,uint64,uint64,string)void", method "purchase(uint64,bool,uint64)void", method "updateHash(uint64,bool,uint64,byte[])void", method "contractLock(uint64,bool,uint64,bool)void", method "segmentLock(uint64,bool,uint64,bool,uint64)void", method "vaultOptInLock(uint64,bool,uint64,bool)void", method "vaultOptIn(uint64,bool,uint64,uint64[])void", method "vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void", method "renew(uint64,bool,uint64,uint64)void", method "setPrimaryAddress(uint64,bool,uint64,string,address)void"
    txna ApplicationArgs 0
    match deleteFields updateFields offerForSale cancelSale postOffer purchase updateHash contractLock segmentLock vaultOptInLock vaultOptIn vaultSend renew setPrimaryAddress
    err

main_create_NoOp@18:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:11
    // export class NFDPlugin extends Contract {
    pushbytes 0x240d2f67 // method "create(uint64)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:289
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:290
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:291
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:294
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.create[routing]() -> void:
create:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:30
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:15
    // registry = GlobalState<Application>({ key: NFDPluginGlobalStateKeyRegistry })
    bytec_1 // "nfd_registry"
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:32
    // this.registry.value = Application(registry)
    swap
    app_global_put
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:30
    // @abimethod({ onCreate: 'require' })
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.deleteFields[routing]() -> void:
deleteFields:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:37-42
    // deleteFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldNames: bytes[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 3
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:45
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:47-52
    // abiCall<typeof NFD.prototype.deleteFields>({
    //   sender,
    //   appId,
    //   args: [fieldNames],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:51
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:47-52
    // abiCall<typeof NFD.prototype.deleteFields>({
    //   sender,
    //   appId,
    //   args: [fieldNames],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x5132df75 // method "deleteFields(byte[][])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:37-42
    // deleteFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldNames: bytes[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.updateFields[routing]() -> void:
updateFields:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:55-60
    // updateFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldAndVals: bytes[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 3
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:64
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:66-71
    // abiCall<typeof NFD.prototype.updateFields>({
    //   sender,
    //   appId,
    //   args: [fieldAndVals],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:70
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:66-71
    // abiCall<typeof NFD.prototype.updateFields>({
    //   sender,
    //   appId,
    //   args: [fieldAndVals],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x78f42711 // method "updateFields(byte[][])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:55-60
    // updateFields(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldAndVals: bytes[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.offerForSale[routing]() -> void:
offerForSale:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:74-80
    // offerForSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   sellAmount: uint64,
    //   reservedFor: Address
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:84
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:86-91
    // abiCall<typeof NFD.prototype.offerForSale>({
    //   sender,
    //   appId,
    //   args: [sellAmount, reservedFor],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:90
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:86-91
    // abiCall<typeof NFD.prototype.offerForSale>({
    //   sender,
    //   appId,
    //   args: [sellAmount, reservedFor],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x5076d9ca // method "offerForSale(uint64,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:74-80
    // offerForSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   sellAmount: uint64,
    //   reservedFor: Address
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.cancelSale[routing]() -> void:
cancelSale:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:94-98
    // cancelSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:102
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dup
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:104-109
    // abiCall<typeof NFD.prototype.cancelSale>({
    //   sender,
    //   appId,
    //   args: [],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:108
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    swap
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:104-109
    // abiCall<typeof NFD.prototype.cancelSale>({
    //   sender,
    //   appId,
    //   args: [],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x99f5d50d // method "cancelSale()void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:94-98
    // cancelSale(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.postOffer[routing]() -> void:
postOffer:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:112-118
    // postOffer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   offer: uint64,
    //   note: string
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:122
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:124-129
    // abiCall<typeof NFD.prototype.postOffer>({
    //   sender,
    //   appId,
    //   args: [offer, note],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:128
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:124-129
    // abiCall<typeof NFD.prototype.postOffer>({
    //   sender,
    //   appId,
    //   args: [offer, note],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x913112ef // method "postOffer(uint64,string)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:112-118
    // postOffer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   offer: uint64,
    //   note: string
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.purchase[routing]() -> void:
purchase:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:132-136
    // purchase(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 2
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:140
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dup
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:142
    // const [saleAmountBytes, saleAmountBytesExists] = op.AppGlobal.getExBytes(appId.id, Bytes(NFDGlobalStateKeySaleAmountKey))
    dup
    pushbytes "i.saleamt"
    app_global_get_ex
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:143
    // assert(saleAmountBytesExists, 'No sale amount set')
    assert // No sale amount set
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:145-156
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:151
    // receiver: appId.address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:152
    // amount: btoi(saleAmountBytes)
    swap
    btoi
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:149-153
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: btoi(saleAmountBytes)
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:145-156
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:155
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:145-156
    // abiCall<typeof NFD.prototype.purchase>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: btoi(saleAmountBytes)
    //     }),
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xa392ae82 // method "purchase(pay)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:132-136
    // purchase(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.updateHash[routing]() -> void:
updateHash:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:159-164
    // updateHash(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   hash: bytes
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:168
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:170-175
    // abiCall<typeof NFD.prototype.updateHash>({
    //   sender,
    //   appId,
    //   args: [hash],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:174
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:170-175
    // abiCall<typeof NFD.prototype.updateHash>({
    //   sender,
    //   appId,
    //   args: [hash],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x762e82da // method "updateHash(byte[])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:159-164
    // updateHash(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   hash: bytes
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.contractLock[routing]() -> void:
contractLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:178-183
    // contractLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:187
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:189-194
    // abiCall<typeof NFD.prototype.contractLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:193
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:189-194
    // abiCall<typeof NFD.prototype.contractLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x8ebc2c83 // method "contractLock(bool)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:178-183
    // contractLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.segmentLock[routing]() -> void:
segmentLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:197-203
    // segmentLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean,
    //   usdPrice: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:207
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:209-214
    // abiCall<typeof NFD.prototype.segmentLock>({
    //   sender,
    //   appId,
    //   args: [lock, usdPrice],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:213
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:209-214
    // abiCall<typeof NFD.prototype.segmentLock>({
    //   sender,
    //   appId,
    //   args: [lock, usdPrice],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xcd5358a6 // method "segmentLock(bool,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:197-203
    // segmentLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean,
    //   usdPrice: uint64
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultOptInLock[routing]() -> void:
vaultOptInLock:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:217-222
    // vaultOptInLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:226
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 1
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:228-233
    // abiCall<typeof NFD.prototype.vaultOptInLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:232
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:228-233
    // abiCall<typeof NFD.prototype.vaultOptInLock>({
    //   sender,
    //   appId,
    //   args: [lock],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x3a657d77 // method "vaultOptInLock(bool)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:217-222
    // vaultOptInLock(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   lock: boolean
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultOptIn[routing]() -> void:
vaultOptIn:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:236-241
    // vaultOptIn(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   assets: uint64[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 8
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:245
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:247-252
    // abiCall<typeof NFD.prototype.vaultOptIn>({
    //   sender,
    //   appId,
    //   args: [assets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:251
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 3
    uncover 4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:247-252
    // abiCall<typeof NFD.prototype.vaultOptIn>({
    //   sender,
    //   appId,
    //   args: [assets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x413d1523 // method "vaultOptIn(uint64[])void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:236-241
    // vaultOptIn(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   assets: uint64[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.vaultSend[routing]() -> void:
vaultSend:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:255-264
    // vaultSend(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   amount: uint64,
    //   receiver: Address,
    //   note: string,
    //   asset: uint64,
    //   otherAssets: uint64[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 8
    dup
    intc_0 // 0
    extract_uint16
    intc_1 // 8
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 7
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:268
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 6
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:270-275
    // abiCall<typeof NFD.prototype.vaultSend>({
    //   sender,
    //   appId,
    //   args: [amount, receiver, note, asset, otherAssets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:274
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:270-275
    // abiCall<typeof NFD.prototype.vaultSend>({
    //   sender,
    //   appId,
    //   args: [amount, receiver, note, asset, otherAssets],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x66821c1a // method "vaultSend(uint64,address,string,uint64,uint64[])void"
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:255-264
    // vaultSend(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   amount: uint64,
    //   receiver: Address,
    //   note: string,
    //   asset: uint64,
    //   otherAssets: uint64[]
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.renew[routing]() -> void:
renew:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:278-283
    // renew(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   years: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:287
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 2
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:289-293
    // const price = abiCall<typeof NFD.prototype.getRenewPrice>({
    //   sender,
    //   appId,
    //   args: []
    // }).returnValue
    itxn_begin
    pushbytes 0x50f490c2 // method "getRenewPrice()uint64"
    itxn_field ApplicationArgs
    dig 2
    itxn_field ApplicationID
    dup
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:295-306
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:301
    // receiver: appId.address,
    dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:302
    // amount: (price * years)
    swap
    uncover 3
    *
    itxn_field Amount
    itxn_field Receiver
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:299-303
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: (price * years)
    // })
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:295-306
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:305
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 2
    uncover 3
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:295-306
    // abiCall<typeof NFD.prototype.renew>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: (price * years)
    //     })
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x77fd5b74 // method "renew(pay)void"
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:278-283
    // renew(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   years: uint64
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.setPrimaryAddress[routing]() -> void:
setPrimaryAddress:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:309-315
    // setPrimaryAddress(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldName: string,
    //   address: Address
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 4
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_0 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:318
    // assert(this.isNFD(appId), ERR_NOT_AN_NFD)
    dig 3
    callsub isNFD
    assert // Not a valid NFD app id
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:320-325
    // abiCall<typeof NFD.prototype.setPrimaryAddress>({
    //   sender,
    //   appId,
    //   args: [fieldName, address],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:324
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:320-325
    // abiCall<typeof NFD.prototype.setPrimaryAddress>({
    //   sender,
    //   appId,
    //   args: [fieldName, address],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x97b6d86c // method "setPrimaryAddress(string,address)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationArgs
    itxn_field Sender
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:309-315
    // setPrimaryAddress(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   appId: Application,
    //   fieldName: string,
    //   address: Address
    // ): void {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/nfd/contract.algo.ts::NFDPlugin.isNFD(NFDApp: uint64) -> uint64:
isNFD:
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:19
    // private isNFD(NFDApp: Application): boolean {
    proto 1 1
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:20
    // const nfdNameBytes = op.AppGlobal.getExBytes(NFDApp, Bytes(NFDGlobalStateKeysName))[0]
    frame_dig -1
    pushbytes "i.name"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:22-25
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: this.registry.value,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:23
    // appId: this.registry.value,
    intc_0 // 0
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:15
    // registry = GlobalState<Application>({ key: NFDPluginGlobalStateKeyRegistry })
    bytec_1 // "nfd_registry"
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:23
    // appId: this.registry.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:24
    // args: [String(nfdNameBytes), NFDApp.id]
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/nfd/contract.algo.ts:22-25
    // return abiCall<typeof NFDRegistry.prototype.isValidNfdAppId>({
    //   appId: this.registry.value,
    //   args: [String(nfdNameBytes), NFDApp.id]
    // }).returnValue
    pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    retsub
