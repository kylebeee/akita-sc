#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 6 34900
    bytecblock "akita_dao" "spending_address" "akita_al" 0x0000 0x80 0x151f7c75 "plugn_al"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn NumAppArgs
    bz main___algots__.defaultCreate@19
    pushbytes 0x23cf4fef // method "update(string,string)void"
    txna ApplicationArgs 0
    match main_update_route@5

main_switch_case_next@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x6cdf8431 0xf9dbd50c 0x2ef5c87a 0xf15e644b 0xb678e5b5 0x7f0ad198 0x33e92c94 0x1ead20a9 // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void", method "accept(uint64,bool,uint64,byte[32][])void", method "escrow(uint64,bool,uint64,address,uint64,byte[32][])void", method "escrowAsa(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void", method "cancel(uint64,bool,uint64,byte[32][])void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match offer accept escrow escrowAsa disburse cancel updateAkitaDAO updateAkitaDAOEscrow
    err

main_update_route@5:
    // smart_contracts/utils/base-contracts/factory.ts:71
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update

main___algots__.defaultCreate@19:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:289
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:290
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:291
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:294
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.offer[routing]() -> void:
offer:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:34-42
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:59
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:48
    // const hyperSwapOfferMBRAmount: uint64 = costs.offers + costs.participants + (metaMerklesCost * 2)
    pushint 222200 // 222200
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:57-61
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: hyperSwapOfferMBRAmount
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:68
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0db3a44b // method "offer(pay,byte[32],uint64,byte[32],uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:34-42
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.accept[routing]() -> void:
accept:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73-78
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:92
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93
    // amount: this.mbr().participants
    intc 4 // 34900
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:90-94
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: this.mbr().participants
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:98
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73-78
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrow[routing]() -> void:
escrow:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103-110
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    dup
    btoi
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:124
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:125
    // amount: amount + this.mbr().hashes
    uncover 4
    intc 4 // 34900
    +
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:122-126
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: amount + this.mbr().hashes
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:132
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 6
    uncover 7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103-110
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrowAsa[routing]() -> void:
escrowAsa:
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-145
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    txna ApplicationArgs 6
    dup
    cover 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 3
    txna ApplicationArgs 7
    dup
    cover 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:149
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    cover 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:151
    // if (!receiver.native.isOptedIn(Asset(asset))) {
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:39
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153-159
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset]
    //   }
    // ).returnValue
    itxn_begin
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:161
    // const mbr = canCallData.mbr
    dup
    pushint 12 // 12
    extract_uint64
    dup
    cover 2
    bury 15
    pushint 21 // 21
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:162
    // const receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
    extract_uint64
    bury 13
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:164
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz escrowAsa_if_body@5
    dig 11
    bz escrowAsa_after_if_else@7

escrowAsa_if_body@5:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    dig 12
    dig 12
    +
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:149
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    +
    bury 1

escrowAsa_after_if_else@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    dup
    bury 15
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:171
    // if (!hyperSwapApp.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@9
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:172
    // mbrAmount += Global.assetOptInMinBalance
    dup
    global AssetOptInMinBalance
    +
    bury 1

escrowAsa_after_if_else@9:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183
    // receiver: hyperSwapApp.address,
    dig 13
    dup
    app_params_get AppAddress
    assert // application exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    dig 2
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:181-185
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: mbrAmount
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:188
    // assetReceiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    dig 8
    itxn_field XferAsset
    dig 6
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:198
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-145
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.disburse[routing]() -> void:
disburse:
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-211
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    txna ApplicationArgs 5
    dup
    cover 3
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    cover 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 7
    dup
    cover 3
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:216
    // if (receiverAppID !== 0) {
    bz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:218
    // assert(receiverApp.address === receiver.native, 'receiverAppID address mismatch')
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    dig 6
    ==
    assert // receiverAppID address mismatch
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:219
    // if (!receiverApp.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    dig 3
    asset_holding_get AssetBalance
    bury 1
    bnz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:34
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    extract 0 8
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:24
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:26
    // op.bzero(4).toFixed({ length: 4 }),
    pushint 4 // 4
    bzero
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:25
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationID
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:221
    // if (canCallArc58OptIn) {
    bz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:222
    // arc58OptInAndSend(this.akitaDAO.value, receiverAppID, '', [asset], [0])
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:222
    // arc58OptInAndSend(this.akitaDAO.value, receiverAppID, '', [asset], [0])
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    itob
    pushbytes 0x0001
    swap
    concat
    dup
    bury 17
    // smart_contracts/utils/functions.ts:343
    // assert(assets.length === amounts.length, ERR_ASSETS_AND_AMOUNTS_MISMATCH)
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_2 // 1
    ==
    assert // Assets and amounts mismatch
    // smart_contracts/utils/functions.ts:34
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    uncover 2
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:344
    // const optinPlugin = getPluginAppList(akitaDAO).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 9
    dup
    cover 2
    // smart_contracts/utils/functions.ts:145
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:143-146
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    bury 20
    // smart_contracts/utils/functions.ts:347-353
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    itxn_begin
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:25
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:351
    // args: [optinPlugin, true, escrow, [], []]
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/utils/functions.ts:347-353
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:355-369
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:365
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    uncover 3
    *
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:363-366
    // itxn.payment({
    //   receiver: origin,
    //   amount: Global.assetOptInMinBalance * assets.length
    // })
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:355-369
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    pushbytes 0x27ece5e6 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:355-369
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:371
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    intc_0 // 0
    bury 12

disburse_while_top@9:
    // smart_contracts/utils/functions.ts:371
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    dig 11
    intc_2 // 1
    <
    bz disburse_after_while@13
    // smart_contracts/utils/functions.ts:372
    // if (amounts[i] > 0) {
    dig 11
    intc_1 // 8
    *
    dup
    bury 14
    pushbytes 0x0000000000000000
    swap
    extract_uint64
    dup
    bury 12
    bz disburse_after_if_else@12
    // smart_contracts/utils/functions.ts:373-379
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetAmount: amounts[i],
    //     assetReceiver: origin,
    //     xferAsset: assets[i]
    //   })
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:377
    // xferAsset: assets[i]
    dig 14
    extract 2 0
    dig 13
    extract_uint64
    itxn_field XferAsset
    dig 13
    itxn_field AssetReceiver
    dig 10
    itxn_field AssetAmount
    // smart_contracts/utils/functions.ts:374-378
    // itxn.assetTransfer({
    //   assetAmount: amounts[i],
    //   assetReceiver: origin,
    //   xferAsset: assets[i]
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

disburse_after_if_else@12:
    // smart_contracts/utils/functions.ts:371
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    dig 11
    intc_2 // 1
    +
    bury 12
    b disburse_while_top@9

disburse_after_while@13:
    // smart_contracts/utils/functions.ts:383-386
    // itxnCompose.next(
    //   AbstractedAccountInterface.prototype.arc58_verifyAuthAddress,
    //   { appId: recipientWalletID }
    // )
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:388
    // itxnCompose.submit()
    itxn_submit

disburse_after_if_else@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:227-240
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:238
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 9
    dig 11
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:227-240
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x5bac4ce3 // method "disburse(uint64,address,uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    dup
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-211
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.cancel[routing]() -> void:
cancel:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:243-248
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:237
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:235-238
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:252-260
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:29
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:258
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:252-260
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:243-248
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/factory.ts:71
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:73
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:73
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:32
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/factory.ts:74
    // this.version.value = newVersion
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:38
    // childContractVersion = GlobalState<string>({ key: BaseFactoryGlobalStateKeyChildContractVersion })
    pushbytes "child_contract_version"
    // smart_contracts/utils/base-contracts/factory.ts:75
    // this.childContractVersion.value = newChildVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:71
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_2 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:82
    // this.akitaDAO.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    intc_2 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:36
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    pushbytes "akita_escrow"
    // smart_contracts/utils/base-contracts/factory.ts:87
    // this.akitaDAOEscrow.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    intc_2 // 1
    return
