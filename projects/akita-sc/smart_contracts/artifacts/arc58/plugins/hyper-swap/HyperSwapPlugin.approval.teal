#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 32 34900
    bytecblock "akita_dao" "spending_address" "aal"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, AkitaBaseContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@15
    pushbytess 0x6cdf8431 0xf9dbd50c 0x9e290396 0xb678e5b5 0x7f0ad198 0xb63ab0d3 0x33e92c94 0x854dede0 0x840733dd // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void", method "accept(uint64,bool,uint64,byte[32][])void", method "escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void", method "cancel(uint64,bool,uint64,byte[32][])void", method "withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "updateAkitaDAO(uint64)void", method "opUp()void", method "mbr()(uint64,uint64,uint64,(uint64,uint64))"
    txna ApplicationArgs 0
    match offer accept escrow disburse cancel withdraw updateAkitaDAO main_opUp_route@12 main_mbr_route@13
    err

main_mbr_route@13:
    // smart_contracts/hyper-swap/base.ts:6
    // @abimethod({ readonly: true })
    pushbytes 0x151f7c75000000000000c6d4000000000000885400000000000088540000000000009fc40000000000006aa4
    log
    intc_2 // 1
    return

main_opUp_route@12:
    // smart_contracts/utils/base-contracts/base.ts:43
    // opUp(): void { }
    intc_2 // 1
    return

main_create_NoOp@15:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, AkitaBaseContract) {
    pushbytes 0xcd9ad67e // method "create(string,uint64)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:321
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:322
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:323
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:326
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.create[routing]() -> void:
create:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:14
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:27
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:16
    // this.version.value = version
    uncover 2
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:14
    // @abimethod({ onCreate: 'require' })
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.offer[routing]() -> void:
offer:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22-30
    // offer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:36
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:36
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:36
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:38-54
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:44
    // receiver: appId.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:35
    // const hyperSwapOfferMBRAmount: uint64 = costs.offers + costs.participants + (metaMerklesCost * 2)
    pushint 222200 // 222200
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:42-46
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: hyperSwapOfferMBRAmount
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:38-54
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:53
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:38-54
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x0db3a44b // method "offer(pay,byte[32],uint64,byte[32],uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22-30
    // offer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.accept[routing]() -> void:
accept:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:57-62
    // accept(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:65
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:65
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:65
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:67-80
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73
    // receiver: appId.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:74
    // amount: this.mbr().participants
    intc 4 // 34900
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:71-75
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: this.mbr().participants
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:67-80
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:79
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:67-80
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:57-62
    // accept(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrow[routing]() -> void:
escrow:
    pushbytes ""
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:83-91
    // escrow(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    txna ApplicationArgs 6
    dup
    cover 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 7
    dup
    cover 3
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:95
    // if (asset === 0) {
    bnz escrow_else_body@5
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:97-112
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103
    // receiver: hyperSwapApp.address,
    dupn 2
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:104
    // amount: amount + this.mbr().hashes
    dig 5
    intc 4 // 34900
    +
    itxn_field Amount
    itxn_field Receiver
    dig 2
    dup
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:101-105
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: amount + this.mbr().hashes
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:97-112
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:111
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:97-112
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field Sender
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

escrow_after_if_else@13:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:83-91
    // escrow(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return

escrow_else_body@5:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:115
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    bury 12
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:118
    // if (!receiver.isOptedIn(Asset(asset))) {
    dig 7
    dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz escrow_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:115
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:119
    // mbrAmount += Global.assetOptInMinBalance
    global AssetOptInMinBalance
    +
    bury 12

escrow_after_if_else@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:123
    // if (!hyperSwapApp.address.isOptedIn(Asset(asset))) {
    dup
    app_params_get AppAddress
    assert // application exists
    dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz escrow_after_if_else@9
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:124
    // mbrAmount += Global.assetOptInMinBalance
    dig 11
    global AssetOptInMinBalance
    +
    bury 12

escrow_after_if_else@9:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:127-149
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:133
    // receiver: hyperSwapApp.address,
    dupn 2
    app_params_get AppAddress
    assert // application exists
    dig 13
    itxn_field Amount
    itxn_field Receiver
    dig 2
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:131-135
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: mbrAmount
    // }),
    intc_2 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:136-141
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:138
    // assetReceiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    dig 8
    itxn_field XferAsset
    dig 6
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:136-141
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:127-149
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:148
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:127-149
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b escrow_after_if_else@13


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.disburse[routing]() -> void:
disburse:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153-161
    // disburse(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverWallet: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:164-175
    // abiCall<typeof HyperSwap.prototype.disburse>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [
    //     id,
    //     receiverWallet,
    //     receiver,
    //     asset,
    //     amount,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:166
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:166
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:166
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:174
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:164-175
    // abiCall<typeof HyperSwap.prototype.disburse>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [
    //     id,
    //     receiverWallet,
    //     receiver,
    //     asset,
    //     amount,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x566a62b2 // method "disburse(uint64,uint64,address,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153-161
    // disburse(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverWallet: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.cancel[routing]() -> void:
cancel:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:178-183
    // cancel(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // abiCall<typeof HyperSwap.prototype.cancel>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:188
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:188
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:188
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:190
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // abiCall<typeof HyperSwap.prototype.cancel>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:178-183
    // cancel(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.withdraw[routing]() -> void:
withdraw:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:194-202
    // withdraw(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 6
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:268
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:266-269
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205-210
    // abiCall<typeof HyperSwap.prototype.withdraw>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, receiver, asset, amount, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:207
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:207
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:207
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:209
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205-210
    // abiCall<typeof HyperSwap.prototype.withdraw>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, receiver, asset, amount, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x0631868b // method "withdraw(uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:194-202
    // withdraw(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_2 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // const [walletID] = op.AppGlobal.getExUint64(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysWallet))
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes "wallet"
    app_global_get_ex
    pop
    // smart_contracts/utils/base-contracts/base.ts:39
    // assert(Txn.sender === this.getAkitaDAOWallet().address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:29
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:40
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:38
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_2 // 1
    return
