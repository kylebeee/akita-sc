#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 6 56 34900
    bytecblock "akita_dao" "spending_address" "akita_al" 0x0000 0x80 0x151f7c75 "plugn_al"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn NumAppArgs
    bz main_bare_routing@16
    pushbytess 0x6cdf8431 0xf9dbd50c 0x2ef5c87a 0xf15e644b 0xb678e5b5 0x7f0ad198 0x23cf4fef 0x33e92c94 0x1ead20a9 // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void", method "accept(uint64,bool,uint64,byte[32][])void", method "escrow(uint64,bool,uint64,address,uint64,byte[32][])void", method "escrowAsa(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void", method "cancel(uint64,bool,uint64,byte[32][])void", method "update(string,string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_offer_route@5 main_accept_route@6 main_escrow_route@7 main_escrowAsa_route@8 main_disburse_route@9 main_cancel_route@10 main_update_route@11 main_updateAkitaDAO_route@12 main_updateAkitaDAOEscrow_route@13

main_after_if_else@20:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    intc_0 // 0
    return

main_updateAkitaDAOEscrow_route@13:
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_1 // 1
    return

main_updateAkitaDAO_route@12:
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_update_route@11:
    // smart_contracts/utils/base-contracts/factory.ts:71
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:71
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_cancel_route@10:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:243-248
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:243-248
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    callsub cancel
    intc_1 // 1
    return

main_disburse_route@9:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-211
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-211
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    callsub disburse
    intc_1 // 1
    return

main_escrowAsa_route@8:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-145
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-145
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    callsub escrowAsa
    intc_1 // 1
    return

main_escrow_route@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103-110
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103-110
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    callsub escrow
    intc_1 // 1
    return

main_accept_route@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73-78
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73-78
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    callsub accept
    intc_1 // 1
    return

main_offer_route@5:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:34-42
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:34-42
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    callsub offer
    intc_1 // 1
    return

main_bare_routing@16:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn OnCompletion
    bnz main_after_if_else@20
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:288
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:289
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:290
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:293
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.offer(walletID: uint64, rekeyBack: uint64, root: bytes, leaves: uint64, participantsRoot: bytes, participantLeaves: uint64, expiration: uint64) -> void:
offer:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:34-42
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    proto 7 0
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:59
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:48
    // const hyperSwapOfferMBRAmount: uint64 = costs.offers + costs.participants + (metaMerklesCost * 2)
    pushint 222200 // 222200
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:57-61
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: hyperSwapOfferMBRAmount
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:68
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:62
    // root,
    frame_dig -5
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:63
    // leaves,
    frame_dig -4
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:64
    // participantsRoot,
    frame_dig -3
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:65
    // participantLeaves,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:66
    // expiration,
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-70
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0db3a44b // method "offer(pay,byte[32],uint64,byte[32],uint64,uint64)void"
    itxn_field ApplicationArgs
    frame_dig -5
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.accept(walletID: uint64, rekeyBack: uint64, id: uint64, proof: bytes) -> void:
accept:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:73-78
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    proto 4 0
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:92
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93
    // amount: this.mbr().participants
    intc 4 // 34900
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:90-94
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: this.mbr().participants
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:98
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:95
    // id,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:84-100
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrow(walletID: uint64, rekeyBack: uint64, id: uint64, receiver: bytes, amount: uint64, proof: bytes) -> void:
escrow:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:103-110
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    proto 6 0
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:114
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:124
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:125
    // amount: amount + this.mbr().hashes
    frame_dig -2
    intc 4 // 34900
    +
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:122-126
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: amount + this.mbr().hashes
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:132
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -5
    frame_dig -6
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:127
    // id,
    frame_dig -4
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:129
    // amount,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:116-134
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrowAsa(walletID: uint64, rekeyBack: uint64, id: uint64, receiver: bytes, asset: uint64, amount: uint64, proof: bytes) -> void:
escrowAsa:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-145
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    proto 7 0
    pushbytes ""
    dupn 2
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:149
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    dup
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:151
    // if (!receiver.native.isOptedIn(Asset(asset))) {
    frame_dig -4
    frame_dig -3
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:38
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153-159
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:157
    // args: [receiver, asset]
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153-159
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset]
    //   }
    // ).returnValue
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:161
    // const mbr = canCallData.mbr
    dup
    pushint 12 // 12
    extract_uint64
    dup
    cover 2
    frame_bury 1
    pushint 21 // 21
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:162
    // const receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
    extract_uint64
    frame_bury 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:164
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz escrowAsa_if_body@4
    frame_dig 2
    bz escrowAsa_after_if_else@5

escrowAsa_if_body@4:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    frame_dig 1
    frame_dig 2
    +
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:149
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    +
    frame_bury 4

escrowAsa_after_if_else@5:
    frame_dig 4
    frame_bury 5

escrowAsa_after_if_else@6:
    frame_dig 5
    dup
    frame_bury 4
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:169
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_3 // 56
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:171
    // if (!hyperSwapApp.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    asset_holding_get AssetBalance
    bury 1
    swap
    frame_bury 5
    bnz escrowAsa_after_if_else@8
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:172
    // mbrAmount += Global.assetOptInMinBalance
    frame_dig 4
    global AssetOptInMinBalance
    +
    frame_bury 5

escrowAsa_after_if_else@8:
    frame_dig 5
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183
    // receiver: hyperSwapApp.address,
    frame_dig 0
    dup
    cover 2
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:181-185
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: mbrAmount
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:188
    // assetReceiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    itxn_field XferAsset
    frame_dig -2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:186-191
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:198
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:192
    // id,
    frame_dig -5
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:194
    // asset,
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:195
    // amount,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:175-200
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.disburse(walletID: uint64, rekeyBack: uint64, id: uint64, receiverAppID: uint64, receiver: bytes, asset: uint64, amount: uint64) -> void:
disburse:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-211
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    proto 7 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:216
    // if (receiverAppID !== 0) {
    frame_dig -4
    bz disburse_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:218
    // assert(receiverApp.address === receiver.native, 'receiverAppID address mismatch')
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    ==
    assert // receiverAppID address mismatch
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:219
    // if (!receiverApp.address.isOptedIn(Asset(asset))) {
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bnz disburse_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:33
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // getPluginAppList(this.akitaDAO.value).optin,
    extract 0 8
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:24
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:26
    // op.bzero(4).toFixed({ length: 4 }),
    pushint 4 // 4
    bzero
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:25
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-29
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       '',
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ]
    //   }
    // ).returnValue
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:221
    // if (canCallArc58OptIn) {
    bz disburse_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:222
    // arc58OptInAndSend(this.akitaDAO.value, receiverAppID, '', [asset], [0])
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:222
    // arc58OptInAndSend(this.akitaDAO.value, receiverAppID, '', [asset], [0])
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -2
    itob
    pushbytes 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:342
    // assert(assets.length === amounts.length, ERR_ASSETS_AND_AMOUNTS_MISMATCH)
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_1 // 1
    ==
    assert // Assets and amounts mismatch
    // smart_contracts/utils/functions.ts:33
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    uncover 2
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:343
    // const optinPlugin = getPluginAppList(akitaDAO).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/utils/functions.ts:144
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:142-145
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    frame_bury 1
    // smart_contracts/utils/functions.ts:346-352
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    itxn_begin
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:25
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:350
    // args: [optinPlugin, true, escrow, [], []]
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    // smart_contracts/utils/functions.ts:346-352
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:354-368
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:364
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    uncover 3
    *
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:362-365
    // itxn.payment({
    //   receiver: origin,
    //   amount: Global.assetOptInMinBalance * assets.length
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:354-368
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:359
    // recipientWalletID,
    frame_dig -4
    itob
    // smart_contracts/utils/functions.ts:354-368
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    pushbytes 0x27ece5e6 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:354-368
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:370
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    intc_0 // 0
    frame_bury 3

disburse_while_top@9:
    // smart_contracts/utils/functions.ts:370
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    frame_dig 3
    intc_1 // 1
    <
    bz disburse_after_while@13
    // smart_contracts/utils/functions.ts:371
    // if (amounts[i] > 0) {
    frame_dig 3
    pushint 8 // 8
    *
    dup
    frame_bury 2
    pushbytes 0x0000000000000000
    swap
    extract_uint64
    dup
    frame_bury 4
    bz disburse_after_if_else@12
    // smart_contracts/utils/functions.ts:372-378
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetAmount: amounts[i],
    //     assetReceiver: origin,
    //     xferAsset: assets[i]
    //   })
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:376
    // xferAsset: assets[i]
    frame_dig 0
    extract 2 0
    frame_dig 2
    extract_uint64
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetReceiver
    frame_dig 4
    itxn_field AssetAmount
    // smart_contracts/utils/functions.ts:373-377
    // itxn.assetTransfer({
    //   assetAmount: amounts[i],
    //   assetReceiver: origin,
    //   xferAsset: assets[i]
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

disburse_after_if_else@12:
    // smart_contracts/utils/functions.ts:370
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b disburse_while_top@9

disburse_after_while@13:
    // smart_contracts/utils/functions.ts:382-385
    // itxnCompose.next(
    //   AbstractedAccountInterface.prototype.arc58_verifyAuthAddress,
    //   { appId: recipientWalletID }
    // )
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:387
    // itxnCompose.submit()
    itxn_submit

disburse_after_if_else@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:227-240
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:231
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:238
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:233
    // id,
    frame_dig -5
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:235
    // asset,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:236
    // amount,
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:227-240
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x5bac4ce3 // method "disburse(uint64,address,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    frame_dig 5
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.cancel(walletID: uint64, rekeyBack: uint64, id: uint64, proof: bytes) -> void:
cancel:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:243-248
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    proto 4 0
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/utils/functions.ts:236
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:234-237
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:252-260
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:28
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:256
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:258
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:257
    // args: [id, proof],
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:252-260
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet)
    //   }
    // )
    pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.update(newVersion: bytes, newChildVersion: bytes) -> void:
update:
    // smart_contracts/utils/base-contracts/factory.ts:71-72
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(newVersion: string, newChildVersion: string): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/factory.ts:73
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:73
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:32
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/factory.ts:74
    // this.version.value = newVersion
    frame_dig -2
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:38
    // childContractVersion = GlobalState<string>({ key: BaseFactoryGlobalStateKeyChildContractVersion })
    pushbytes "child_contract_version"
    // smart_contracts/utils/base-contracts/factory.ts:75
    // this.childContractVersion.value = newChildVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:82
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:36
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    pushbytes "akita_escrow"
    // smart_contracts/utils/base-contracts/factory.ts:87
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
