#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 6 34900
    bytecblock "akita_dao" "spending_address" "akita_al" 0x0000 0x80 0x151f7c75 "plugn_al"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, AkitaBaseContract) {
    txn NumAppArgs
    bz main___algots__.defaultCreate@19
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@5

main_switch_case_next@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, AkitaBaseContract) {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x6cdf8431 0xf9dbd50c 0x2ef5c87a 0xf15e644b 0xb678e5b5 0x7f0ad198 0x33e92c94 0x854dede0 // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void", method "accept(uint64,bool,uint64,byte[32][])void", method "escrow(uint64,bool,uint64,address,uint64,byte[32][])void", method "escrowAsa(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void", method "cancel(uint64,bool,uint64,byte[32][])void", method "updateAkitaDAO(uint64)void", method "opUp()void"
    txna ApplicationArgs 0
    match offer accept escrow escrowAsa disburse cancel updateAkitaDAO main_opUp_route@15
    err

main_opUp_route@15:
    // smart_contracts/utils/base-contracts/base.ts:36
    // opUp(): void { }
    intc_1 // 1
    return

main_update_route@5:
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update

main___algots__.defaultCreate@19:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:12
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, AkitaBaseContract) {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:289
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    // smart_contracts/utils/functions.ts:290
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:291
    // return Global.zeroAddress
    global ZeroAddress
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:294
    // return wallet.address
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.offer[routing]() -> void:
offer:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:31-39
    // offer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:45
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:45
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:45
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:47-63
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:53
    // receiver: appId.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:44
    // const hyperSwapOfferMBRAmount: uint64 = costs.offers + costs.participants + (metaMerklesCost * 2)
    pushint 222200 // 222200
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:51-55
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: hyperSwapOfferMBRAmount
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:47-63
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:62
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 7
    uncover 8
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:47-63
    // abiCall<typeof HyperSwap.prototype.offer>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: hyperSwapOfferMBRAmount
    //     }),
    //     root,
    //     leaves,
    //     participantsRoot,
    //     participantLeaves,
    //     expiration,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x0db3a44b // method "offer(pay,byte[32],uint64,byte[32],uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 7
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:31-39
    // offer(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.accept[routing]() -> void:
accept:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:66-71
    // accept(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:74
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:74
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:74
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-89
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:82
    // receiver: appId.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:83
    // amount: this.mbr().participants
    intc 4 // 34900
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:80-84
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: this.mbr().participants
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-89
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:88
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-89
    // abiCall<typeof HyperSwap.prototype.accept>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: this.mbr().participants
    //     }),
    //     id,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:66-71
    // accept(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrow[routing]() -> void:
escrow:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:92-99
    // escrow(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    dup
    btoi
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 6
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:102
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:102
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:102
    // const appId = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:104-119
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:110
    // receiver: appId.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:111
    // amount: amount + this.mbr().hashes
    uncover 4
    intc 4 // 34900
    +
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:108-112
    // itxn.payment({
    //   sender,
    //   receiver: appId.address,
    //   amount: amount + this.mbr().hashes
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:104-119
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:118
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 6
    uncover 7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:104-119
    // abiCall<typeof HyperSwap.prototype.escrow>({
    //   sender,
    //   appId,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: appId.address,
    //       amount: amount + this.mbr().hashes
    //     }),
    //     id,
    //     receiver,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 6
    itxn_field ApplicationArgs
    uncover 5
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:92-99
    // escrow(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrowAsa[routing]() -> void:
escrowAsa:
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:122-130
    // escrowAsa(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 3
    txna ApplicationArgs 6
    dup
    cover 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 3
    txna ApplicationArgs 7
    dup
    cover 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    uncover 2
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    cover 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:133
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    cover 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:135
    // if (!receiver.native.isOptedIn(Asset(asset))) {
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:136
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:136
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:50
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    pushbytes "other_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:136
    // const assetInbox = getOtherAppList(this.akitaDAO.value).assetInbox
    pushint 16 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:137-140
    // const canCallData = abiCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo>({
    //   appId: assetInbox,
    //   args: [receiver, asset]
    // }).returnValue
    itxn_begin
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 25 // 25
    ==
    assert // invalid number of bytes for (uint64,uint64,bool1,bool1,uint64)
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:142
    // const mbr = canCallData.mbr
    dup
    pushint 12 // 12
    extract_uint64
    dup
    cover 2
    bury 15
    pushint 21 // 21
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:143
    // const receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
    extract_uint64
    bury 13
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:145
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz escrowAsa_if_body@5
    dig 11
    bz escrowAsa_after_if_else@7

escrowAsa_if_body@5:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:146
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    dig 12
    dig 12
    +
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:133
    // let mbrAmount = this.mbr().hashes
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:146
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    +
    bury 1

escrowAsa_after_if_else@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:150
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:150
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:150
    // const hyperSwapApp = Application(getAkitaAppList(this.akitaDAO.value).hyperSwap)
    pushint 56 // 56
    extract_uint64
    dup
    bury 15
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:152
    // if (!hyperSwapApp.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    dig 6
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@9
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:153
    // mbrAmount += Global.assetOptInMinBalance
    dup
    global AssetOptInMinBalance
    +
    bury 1

escrowAsa_after_if_else@9:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:156-178
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:162
    // receiver: hyperSwapApp.address,
    dig 13
    dup
    app_params_get AppAddress
    assert // application exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    dig 2
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:160-164
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: mbrAmount
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165-170
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:167
    // assetReceiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    dig 8
    itxn_field XferAsset
    dig 6
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:165-170
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:156-178
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:177
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 11
    dig 13
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:156-178
    // abiCall<typeof HyperSwap.prototype.escrowAsa>({
    //   sender,
    //   appId: hyperSwapApp,
    //   args: [
    //     itxn.payment({
    //       sender,
    //       receiver: hyperSwapApp.address,
    //       amount: mbrAmount
    //     }),
    //     itxn.assetTransfer({
    //       sender,
    //       assetReceiver: hyperSwapApp.address,
    //       assetAmount: amount,
    //       xferAsset: asset
    //     }),
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //     proof,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    dig 11
    itxn_field ApplicationArgs
    dig 10
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 7
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:122-130
    // escrowAsa(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.disburse[routing]() -> void:
disburse:
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:181-189
    // disburse(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverWallet: Application,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    dup
    cover 2
    txna ApplicationArgs 5
    dup
    cover 3
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 6
    dup
    cover 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 7
    dup
    cover 3
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    swap
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:193
    // if (receiverWallet.id !== 0) {
    bz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:194
    // assert(receiverWallet.address === receiver, 'receiverAppID address mismatch')
    dig 5
    dup
    app_params_get AppAddress
    assert // application exists
    dig 6
    ==
    assert // receiverAppID address mismatch
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:195
    // if (!receiverWallet.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    dig 3
    asset_holding_get AssetBalance
    bury 1
    bnz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-26
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(this.akitaDAO.value).optin,
    //     true,
    //     new Address(Global.currentApplicationAddress),
    //     '',
    //     op.bzero(4).toFixed({ length: 4 }),
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:20
    // getPluginAppList(this.akitaDAO.value).optin,
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:20
    // getPluginAppList(this.akitaDAO.value).optin,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:45
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:20
    // getPluginAppList(this.akitaDAO.value).optin,
    extract 0 8
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:22
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:24
    // op.bzero(4).toFixed({ length: 4 }),
    pushint 4 // 4
    bzero
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-26
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(this.akitaDAO.value).optin,
    //     true,
    //     new Address(Global.currentApplicationAddress),
    //     '',
    //     op.bzero(4).toFixed({ length: 4 }),
    //   ]
    // }).returnValue
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:21
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationID
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:17-26
    // return abiCall<typeof AbstractedAccount.prototype.arc58_canCall>({
    //   appId,
    //   args: [
    //     getPluginAppList(this.akitaDAO.value).optin,
    //     true,
    //     new Address(Global.currentApplicationAddress),
    //     '',
    //     op.bzero(4).toFixed({ length: 4 }),
    //   ]
    // }).returnValue
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:197
    // if (canCallArc58OptIn) {
    bz disburse_after_if_else@7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:198
    // arc58OptInAndSend(this.akitaDAO.value, receiverWallet, '', [asset], [0])
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:198
    // arc58OptInAndSend(this.akitaDAO.value, receiverWallet, '', [asset], [0])
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    itob
    pushbytes 0x0001
    swap
    concat
    dup
    bury 17
    // smart_contracts/utils/functions.ts:340
    // assert(assets.length === amounts.length, ERR_ASSETS_AND_AMOUNTS_MISMATCH)
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_1 // 1
    ==
    assert // Assets and amounts mismatch
    // smart_contracts/utils/functions.ts:45
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    uncover 2
    bytec 6 // "plugn_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:341
    // const optinPlugin = getPluginAppList(akitaDAO).optin
    dup
    extract 0 8
    swap
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:151-154
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    dig 9
    dup
    cover 2
    // smart_contracts/utils/functions.ts:153
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:151-154
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 3
    bury 20
    // smart_contracts/utils/functions.ts:344-350
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWallet.id,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    itxn_begin
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:21
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // '',
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:348
    // args: [optinPlugin, true, escrow, [], []]
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    bytec_3 // 0x0000
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/utils/functions.ts:344-350
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWallet.id,
    //     args: [optinPlugin, true, escrow, [], []]
    //   }
    // )
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:352-366
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optIn,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWallet,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:362
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    uncover 3
    *
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:360-363
    // itxn.payment({
    //   receiver: origin,
    //   amount: Global.assetOptInMinBalance * assets.length
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:352-366
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optIn,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWallet,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    itxn_next
    pushbytes 0x6835e3bc // method "optIn(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:21
    // true,
    bytec 4 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:352-366
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optIn,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWallet,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length
    //       })
    //     ]
    //   }
    // )
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:368
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    intc_0 // 0
    bury 12

disburse_while_top@9:
    // smart_contracts/utils/functions.ts:368
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    dig 11
    intc_1 // 1
    <
    bz disburse_after_while@13
    // smart_contracts/utils/functions.ts:369
    // if (amounts[i] > 0) {
    dig 11
    intc_2 // 8
    *
    dup
    bury 14
    pushbytes 0x0000000000000000
    swap
    extract_uint64
    dup
    bury 12
    bz disburse_after_if_else@12
    // smart_contracts/utils/functions.ts:370-376
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetAmount: amounts[i],
    //     assetReceiver: origin,
    //     xferAsset: assets[i]
    //   })
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:374
    // xferAsset: assets[i]
    dig 14
    extract 2 0
    dig 13
    extract_uint64
    itxn_field XferAsset
    dig 13
    itxn_field AssetReceiver
    dig 10
    itxn_field AssetAmount
    // smart_contracts/utils/functions.ts:371-375
    // itxn.assetTransfer({
    //   assetAmount: amounts[i],
    //   assetReceiver: origin,
    //   xferAsset: assets[i]
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

disburse_after_if_else@12:
    // smart_contracts/utils/functions.ts:368
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    dig 11
    intc_1 // 1
    +
    bury 12
    b disburse_while_top@9

disburse_after_while@13:
    // smart_contracts/utils/functions.ts:380-383
    // itxnCompose.next(
    //   AbstractedAccountInterface.prototype.arc58_verifyAuthAddress,
    //   { appId: recipientWallet }
    // )
    itxn_next
    pushbytes 0x6cc3f606 // method "arc58_verifyAuthAddress()void"
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationID
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:385
    // itxnCompose.submit()
    itxn_submit

disburse_after_if_else@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-213
    // abiCall<typeof HyperSwap.prototype.disburse>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:212
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    dig 9
    dig 11
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:203-213
    // abiCall<typeof HyperSwap.prototype.disburse>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [
    //     id,
    //     receiver,
    //     asset,
    //     amount,
    //   ],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x5bac4ce3 // method "disburse(uint64,address,uint64,uint64)void"
    itxn_field ApplicationArgs
    dig 9
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    dup
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:181-189
    // disburse(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverWallet: Application,
    //   receiver: Account,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    intc_1 // 1
    return


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.cancel[routing]() -> void:
cancel:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:216-221
    // cancel(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    dig 3
    // smart_contracts/utils/functions.ts:240
    // Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:238-241
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    swap
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:224-229
    // abiCall<typeof HyperSwap.prototype.cancel>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:226
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:226
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    bytec_2 // "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:226
    // appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    pushint 56 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:228
    // rekeyTo: rekeyAddress(rekeyBack, wallet)
    uncover 4
    uncover 5
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:224-229
    // abiCall<typeof HyperSwap.prototype.cancel>({
    //   sender,
    //   appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //   args: [id, proof],
    //   rekeyTo: rekeyAddress(rekeyBack, wallet)
    // })
    pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_3 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:216-221
    // cancel(
    //   wallet: Application,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.update[routing]() -> void:
update:
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/base.ts:25
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:25
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:17
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    pushbytes "version"
    // smart_contracts/utils/base-contracts/base.ts:26
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:23
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/utils/base-contracts/base.ts::AkitaBaseContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/base.ts:31
    // updateAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/base.ts:32
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:32
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/base.ts:19
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/base.ts:33
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/base.ts:31
    // updateAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return
