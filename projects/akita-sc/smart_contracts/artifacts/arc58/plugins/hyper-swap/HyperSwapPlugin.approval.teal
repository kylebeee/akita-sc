#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 6 56 34900
    bytecblock "akita_dao" "spending_address" "akita_al" 0x80 "controlled_address" 0x151f7c75 "plugn_al" 0x0000
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn NumAppArgs
    bz main_bare_routing@15
    pushbytess 0x6cdf8431 0xf9dbd50c 0x2ef5c87a 0xf15e644b 0xb678e5b5 0x7f0ad198 0xc385cfae 0x33e92c94 // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void", method "accept(uint64,bool,uint64,byte[32][])void", method "escrow(uint64,bool,uint64,address,uint64,byte[32][])void", method "escrowAsa(uint64,bool,uint64,address,uint64,uint64,byte[32][])void", method "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void", method "cancel(uint64,bool,uint64,byte[32][])void", method "updateApplication(string,string)void", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_offer_route@5 main_accept_route@6 main_escrow_route@7 main_escrowAsa_route@8 main_disburse_route@9 main_cancel_route@10 main_updateApplication_route@11 main_updateAkitaDAO_route@12

main_after_if_else@19:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    intc_0 // 0
    return

main_updateAkitaDAO_route@12:
    // smart_contracts/utils/base-contracts/factory.ts:59
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:59
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_updateApplication_route@11:
    // smart_contracts/utils/base-contracts/factory.ts:50
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:50
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_1 // 1
    return

main_cancel_route@10:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:255-260
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:255-260
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    callsub cancel
    intc_1 // 1
    return

main_disburse_route@9:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:214-222
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:214-222
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    callsub disburse
    intc_1 // 1
    return

main_escrowAsa_route@8:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:144-152
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:144-152
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    callsub escrowAsa
    intc_1 // 1
    return

main_escrow_route@7:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:108-115
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:108-115
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    callsub escrow
    intc_1 // 1
    return

main_accept_route@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-81
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-81
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    callsub accept
    intc_1 // 1
    return

main_offer_route@5:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:35-43
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:35-43
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    callsub offer
    intc_1 // 1
    return

main_bare_routing@15:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:13
    // export class HyperSwapPlugin extends classes(BaseHyperSwap, ServiceFactoryContract) {
    txn OnCompletion
    bnz main_after_if_else@19
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/utils/functions.ts::rekeyAddress(rekeyBack: uint64, wallet: uint64) -> bytes:
rekeyAddress:
    // smart_contracts/utils/functions.ts:166
    // export function rekeyAddress(rekeyBack: boolean, wallet: Application): Account {
    proto 2 1
    intc_0 // 0
    dup
    // smart_contracts/utils/functions.ts:167
    // if (!rekeyBack) {
    frame_dig -2
    bnz rekeyAddress_after_if_else@2
    // smart_contracts/utils/functions.ts:168
    // return Global.zeroAddress
    global ZeroAddress
    frame_bury 0
    retsub

rekeyAddress_after_if_else@2:
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -1
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -1
    app_params_get AppAddress
    swap
    frame_bury 1
    assert // application exists
    // smart_contracts/utils/functions.ts:172
    // if (sender !== origin) {
    !=
    bz rekeyAddress_after_if_else@4
    // smart_contracts/utils/functions.ts:173
    // return sender
    retsub

rekeyAddress_after_if_else@4:
    // smart_contracts/utils/functions.ts:176
    // return walletAddress
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.offer(walletID: uint64, rekeyBack: uint64, root: bytes, leaves: uint64, participantsRoot: bytes, participantLeaves: uint64, expiration: uint64) -> void:
offer:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:35-43
    // offer(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   root: bytes<32>,
    //   leaves: uint64,
    //   participantsRoot: bytes<32>,
    //   participantLeaves: uint64,
    //   expiration: uint64
    // ) {
    proto 7 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:152
    // walletAddress: wallet.address,
    frame_dig -7
    app_params_get AppAddress
    bury 1
    assert // application exists
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:52-73
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount,
    //         fee,
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:60
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:49
    // const hyperSwapOfferMBRAmount: uint64 = costs.offers + costs.participants + (metaMerklesCost * 2)
    pushint 222200 // 222200
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:58-63
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: hyperSwapOfferMBRAmount,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:52-73
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount,
    //         fee,
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:70
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:64
    // root,
    frame_dig -5
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:65
    // leaves,
    frame_dig -4
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:66
    // participantsRoot,
    frame_dig -3
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:67
    // participantLeaves,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:68
    // expiration,
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:52-73
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount,
    //         fee,
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x0db3a44b // method "offer(pay,byte[32],uint64,byte[32],uint64,uint64)void"
    itxn_field ApplicationArgs
    frame_dig -5
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:52-73
    // abiCall(
    //   HyperSwap.prototype.offer,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: hyperSwapOfferMBRAmount,
    //         fee,
    //       }),
    //       root,
    //       leaves,
    //       participantsRoot,
    //       participantLeaves,
    //       expiration,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.accept(walletID: uint64, rekeyBack: uint64, id: uint64, proof: bytes) -> void:
accept:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:76-81
    // accept(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    proto 4 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:87-105
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants,
    //         fee,
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:95
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/hyper-swap/base.ts:8
    // participants: 34_900,
    intc 4 // 34900
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:93-98
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: this.mbr().participants,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:87-105
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants,
    //         fee,
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:102
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:99
    // id,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:87-105
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants,
    //         fee,
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee
    //   }
    // )
    pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:87-105
    // abiCall(
    //   HyperSwap.prototype.accept,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: this.mbr().participants,
    //         fee,
    //       }),
    //       id,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrow(walletID: uint64, rekeyBack: uint64, id: uint64, receiver: bytes, amount: uint64, proof: bytes) -> void:
escrow:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:108-115
    // escrow(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    proto 6 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -6
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:121-141
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:129
    // receiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:130
    // amount: amount + this.mbr().hashes,
    frame_dig -2
    // smart_contracts/hyper-swap/base.ts:9
    // hashes: 34_900,
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:130
    // amount: amount + this.mbr().hashes,
    +
    itxn_field Amount
    itxn_field Receiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:127-132
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: amount + this.mbr().hashes,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:121-141
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:138
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -5
    frame_dig -6
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:133
    // id,
    frame_dig -4
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:135
    // amount,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:121-141
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:121-141
    // abiCall(
    //   HyperSwap.prototype.escrow,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: amount + this.mbr().hashes,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.escrowAsa(walletID: uint64, rekeyBack: uint64, id: uint64, receiver: bytes, asset: uint64, amount: uint64, proof: bytes) -> void:
escrowAsa:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:144-152
    // escrowAsa(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64,
    //   proof: Proof
    // ) {
    proto 7 0
    pushbytes ""
    dupn 2
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/hyper-swap/base.ts:9
    // hashes: 34_900,
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:156
    // let mbrAmount = this.mbr().hashes
    dup
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:158
    // if (!receiver.native.isOptedIn(Asset(asset))) {
    frame_dig -4
    frame_dig -3
    asset_holding_get AssetBalance
    bury 1
    bnz escrowAsa_after_if_else@6
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:9
    // export const AkitaDAOGlobalStateKeysOtherAppList = 'other_al'
    pushbytes "other_al"
    // smart_contracts/utils/functions.ts:35
    // const [otherAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysOtherAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:36
    // return decodeArc4<OtherAppList>(otherAppListBytes)
    pushint 16 // 16
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:160-167
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:164
    // args: [receiver, asset],
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:160-167
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:160-167
    // const canCallData = abiCall(
    //   AssetInbox.prototype.arc59_getSendAssetInfo,
    //   {
    //     appId: assetInbox,
    //     args: [receiver, asset],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    pushint 12 // 12
    extract_uint64
    dup
    cover 2
    frame_bury 0
    pushint 21 // 21
    extract_uint64
    frame_bury 1
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:172
    // if (mbr || receiverAlgoNeededForClaim) {
    bnz escrowAsa_if_body@4
    frame_dig 1
    bz escrowAsa_after_if_else@5

escrowAsa_if_body@4:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:173
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    frame_dig 0
    frame_dig 1
    +
    // smart_contracts/hyper-swap/base.ts:9
    // hashes: 34_900,
    intc 4 // 34900
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:173
    // mbrAmount += canCallData.mbr + canCallData.receiverAlgoNeededForClaim
    +
    frame_bury 4

escrowAsa_after_if_else@5:
    frame_dig 4
    frame_bury 5

escrowAsa_after_if_else@6:
    frame_dig 5
    dup
    frame_bury 4
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:179
    // if (!hyperSwapApp.address.isOptedIn(Asset(asset))) {
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    asset_holding_get AssetBalance
    bury 1
    swap
    frame_bury 5
    bnz escrowAsa_after_if_else@8
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:180
    // mbrAmount += Global.assetOptInMinBalance
    frame_dig 4
    global AssetOptInMinBalance
    +
    frame_bury 5

escrowAsa_after_if_else@8:
    frame_dig 5
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183-211
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount,
    //         fee,
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:191
    // receiver: hyperSwapApp.address,
    frame_dig 2
    dup
    cover 2
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    frame_dig 3
    dup
    cover 2
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:189-194
    // itxn.payment({
    //   sender,
    //   receiver: hyperSwapApp.address,
    //   amount: mbrAmount,
    //   fee,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:195-201
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset,
    //   fee,
    // }),
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:197
    // assetReceiver: hyperSwapApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    itxn_field XferAsset
    frame_dig -2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:195-201
    // itxn.assetTransfer({
    //   sender,
    //   assetReceiver: hyperSwapApp.address,
    //   assetAmount: amount,
    //   xferAsset: asset,
    //   fee,
    // }),
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183-211
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount,
    //         fee,
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:208
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:202
    // id,
    frame_dig -5
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:204
    // asset,
    frame_dig -3
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:205
    // amount,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183-211
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount,
    //         fee,
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:183-211
    // abiCall(
    //   HyperSwap.prototype.escrowAsa,
    //   {
    //     sender,
    //     appId: hyperSwapApp,
    //     args: [
    //       itxn.payment({
    //         sender,
    //         receiver: hyperSwapApp.address,
    //         amount: mbrAmount,
    //         fee,
    //       }),
    //       itxn.assetTransfer({
    //         sender,
    //         assetReceiver: hyperSwapApp.address,
    //         assetAmount: amount,
    //         xferAsset: asset,
    //         fee,
    //       }),
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //       proof,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.disburse(walletID: uint64, rekeyBack: uint64, id: uint64, receiverAppID: uint64, receiver: bytes, asset: uint64, amount: uint64) -> void:
disburse:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:214-222
    // disburse(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   receiverAppID: uint64,
    //   receiver: Address,
    //   asset: uint64,
    //   amount: uint64
    // ) {
    proto 7 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -7
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:227
    // if (receiverAppID !== 0) {
    frame_dig -4
    bz disburse_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:229
    // assert(receiverApp.address === receiver.native, 'receiverAppID address mismatch')
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    frame_dig -3
    ==
    assert // receiverAppID address mismatch
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:230
    // if (!receiverApp.address.isOptedIn(Asset(asset))) {
    frame_dig -4
    app_params_get AppAddress
    assert // application exists
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    bnz disburse_after_if_else@6
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:18-30
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 6 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:23
    // getPluginAppList(this.akitaDAO.value).optin,
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:25
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:26
    // op.bzero(4).toFixed({ length: 4 }),
    pushint 4 // 4
    bzero
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:18-30
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ],
    //     fee,
    //   }
    // ).returnValue
    pushbytes 0x682fdbf8 // method "arc58_canCall(uint64,bool,address,byte[4])bool"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:24
    // true,
    bytec_3 // 0x80
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:18-30
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ],
    //     fee,
    //   }
    // ).returnValue
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:18-30
    // return abiCall(
    //   AbstractedAccount.prototype.arc58_canCall,
    //   {
    //     appId: walletAppID,
    //     args: [
    //       getPluginAppList(this.akitaDAO.value).optin,
    //       true,
    //       new Address(Global.currentApplicationAddress),
    //       op.bzero(4).toFixed({ length: 4 }),
    //     ],
    //     fee,
    //   }
    // ).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc_0 // 0
    getbit
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:232
    // if (canCallArc58OptIn) {
    bz disburse_after_if_else@6
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:233
    // arc58OptInAndSend(this.akitaDAO.value, receiverAppID, [asset], [0])
    frame_dig -2
    itob
    pushbytes 0x0001
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:231
    // assert(assets.length === amounts.length, ERR_ASSETS_AND_AMOUNTS_MISMATCH)
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_1 // 1
    ==
    assert // Assets and amounts mismatch
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    uncover 2
    // smart_contracts/dao/constants.ts:8
    // export const AkitaDAOGlobalStateKeysPluginAppList = 'plugn_al'
    bytec 6 // "plugn_al"
    // smart_contracts/utils/functions.ts:30
    // const [pluginAppListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysPluginAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:31
    // return decodeArc4<PluginAppList>(pluginAppListBytes)
    intc_0 // 0
    extract_uint64
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec 4 // "controlled_address"
    // smart_contracts/utils/functions.ts:102-105
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    dup
    cover 2
    frame_bury 1
    // smart_contracts/utils/functions.ts:235-242
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, [], []],
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/utils/functions.ts:239
    // args: [optinPlugin, true, [], []],
    dup
    itob
    // smart_contracts/utils/functions.ts:235-242
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, [], []],
    //     fee,
    //   }
    // )
    pushbytes 0xde300fe9 // method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:239
    // args: [optinPlugin, true, [], []],
    bytec_3 // 0x80
    itxn_field ApplicationArgs
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    bytec 7 // 0x0000
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    // smart_contracts/utils/functions.ts:235-242
    // itxnCompose.begin(
    //   AbstractedAccountInterface.prototype.arc58_rekeyToPlugin,
    //   {
    //     appId: recipientWalletID,
    //     args: [optinPlugin, true, [], []],
    //     fee,
    //   }
    // )
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:244-260
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:254
    // amount: Global.assetOptInMinBalance * assets.length,
    global AssetOptInMinBalance
    uncover 3
    *
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/utils/functions.ts:252-256
    // itxn.payment({
    //   receiver: origin,
    //   amount: Global.assetOptInMinBalance * assets.length,
    //   fee,
    // })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:244-260
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:249
    // recipientWalletID,
    frame_dig -4
    itob
    // smart_contracts/utils/functions.ts:244-260
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    pushbytes 0x27ece5e6 // method "optInToAsset(uint64,bool,uint64[],pay)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:250
    // true,
    bytec_3 // 0x80
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    // smart_contracts/utils/functions.ts:244-260
    // itxnCompose.next(
    //   OptInPluginInterface.prototype.optInToAsset,
    //   {
    //     appId: optinPlugin,
    //     args: [
    //       recipientWalletID,
    //       true,
    //       assets,
    //       itxn.payment({
    //         receiver: origin,
    //         amount: Global.assetOptInMinBalance * assets.length,
    //         fee,
    //       })
    //     ],
    //     fee,
    //   }
    // )
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:262
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    intc_0 // 0
    frame_bury 2

disburse_while_top@9:
    // smart_contracts/utils/functions.ts:262
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    frame_dig 2
    // smart_contracts/utils/functions.ts:231
    // assert(assets.length === amounts.length, ERR_ASSETS_AND_AMOUNTS_MISMATCH)
    intc_1 // 1
    // smart_contracts/utils/functions.ts:262
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    <
    bz disburse_after_while@13
    // smart_contracts/utils/functions.ts:263
    // if (amounts[i] > 0) {
    frame_dig 2
    pushint 8 // 8
    *
    dup
    frame_bury 3
    pushbytes 0x0000000000000000
    swap
    extract_uint64
    dup
    frame_bury 4
    bz disburse_after_if_else@12
    // smart_contracts/utils/functions.ts:264-271
    // itxnCompose.next(
    //   itxn.assetTransfer({
    //     assetAmount: amounts[i],
    //     assetReceiver: origin,
    //     xferAsset: assets[i],
    //     fee,
    //   })
    // )
    itxn_next
    // smart_contracts/utils/functions.ts:268
    // xferAsset: assets[i],
    frame_dig 0
    extract 2 0
    frame_dig 3
    extract_uint64
    itxn_field XferAsset
    frame_dig 1
    itxn_field AssetReceiver
    frame_dig 4
    itxn_field AssetAmount
    // smart_contracts/utils/functions.ts:265-270
    // itxn.assetTransfer({
    //   assetAmount: amounts[i],
    //   assetReceiver: origin,
    //   xferAsset: assets[i],
    //   fee,
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee

disburse_after_if_else@12:
    // smart_contracts/utils/functions.ts:262
    // for (let i: uint64 = 0; i < amounts.length; i++) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b disburse_while_top@9

disburse_after_while@13:
    // smart_contracts/utils/functions.ts:275-278
    // itxnCompose.next(
    //   AbstractedAccountInterface.prototype.arc58_verifyAuthAddr,
    //   { appId: recipientWalletID, fee }
    // )
    itxn_next
    pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationID
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/utils/functions.ts:280
    // itxnCompose.submit()
    itxn_submit

disburse_after_if_else@6:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:238-252
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:249
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -6
    frame_dig -7
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:244
    // id,
    frame_dig -5
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:246
    // asset,
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:247
    // amount,
    frame_dig -1
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:238-252
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x5bac4ce3 // method "disburse(uint64,address,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    frame_dig 5
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:238-252
    // abiCall(
    //   HyperSwap.prototype.disburse,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [
    //       id,
    //       receiver,
    //       asset,
    //       amount,
    //     ],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts::HyperSwapPlugin.cancel(walletID: uint64, rekeyBack: uint64, id: uint64, proof: bytes) -> void:
cancel:
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:255-260
    // cancel(
    //   walletID: uint64,
    //   rekeyBack: boolean,
    //   id: uint64,
    //   proof: Proof
    // ) {
    proto 4 0
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    frame_dig -4
    // smart_contracts/arc58/account/constants.ts:9
    // export const AbstractAccountGlobalStateKeysSpendingAddress = 'spending_address'
    bytec_1 // "spending_address"
    // smart_contracts/utils/functions.ts:159-162
    // const [spendingAddressBytes] = op.AppGlobal.getExBytes(
    //   wallet,
    //   Bytes(AbstractAccountGlobalStateKeysSpendingAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:264-273
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_begin
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/dao/constants.ts:7
    // export const AkitaDAOGlobalStateKeysAkitaAppList = 'akita_al'
    bytec_2 // "akita_al"
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    intc_3 // 56
    extract_uint64
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:270
    // rekeyTo: rekeyAddress(rekeyBack, wallet),
    frame_dig -3
    frame_dig -4
    callsub rekeyAddress
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:269
    // args: [id, proof],
    frame_dig -2
    itob
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:264-273
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field RekeyTo
    itxn_field ApplicationID
    itxn_field Sender
    intc_2 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/plugins/hyper-swap/contract.algo.ts:264-273
    // abiCall(
    //   HyperSwap.prototype.cancel,
    //   {
    //     sender,
    //     appId: Application(getAkitaAppList(this.akitaDAO.value).hyperSwap),
    //     args: [id, proof],
    //     rekeyTo: rekeyAddress(rekeyBack, wallet),
    //     fee,
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/utils/base-contracts/factory.ts::ServiceFactoryContract.updateApplication(newVersion: bytes, newChildVersion: bytes) -> void:
updateApplication:
    // smart_contracts/utils/base-contracts/factory.ts:50-51
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(newVersion: string, newChildVersion: string): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/factory.ts:52
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:52
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    pushbytes "version"
    // smart_contracts/utils/base-contracts/factory.ts:53
    // this.version.value = newVersion
    frame_dig -2
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:15
    // export const BaseFactoryGlobalStateKeyChildContractVersion = 'child_contract_version'
    pushbytes "child_contract_version"
    // smart_contracts/utils/base-contracts/factory.ts:54
    // this.childContractVersion.value = newChildVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::ServiceFactoryContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:59
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:60
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:60
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:61
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
