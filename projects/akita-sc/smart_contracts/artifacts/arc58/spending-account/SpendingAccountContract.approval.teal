#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "wallet_id" "plugin_id"
    // smart_contracts/arc58/spending-account/contract.algo.ts:7
    // export class SpendingAccountContract extends Contract {
    txn NumAppArgs
    bz main_after_if_else@10
    pushbytess 0x917c48b6 0x2487c32c 0x65a97bcc 0x3ea11832 // method "createApplication(uint64,uint64)void", method "deleteApplication()void", method "rekey(address)void", method "optin(pay,uint64)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_deleteApplication_route@4 main_rekey_route@5 main_optin_route@6

main_after_if_else@10:
    // smart_contracts/arc58/spending-account/contract.algo.ts:7
    // export class SpendingAccountContract extends Contract {
    intc_0 // 0
    return

main_optin_route@6:
    // smart_contracts/arc58/spending-account/contract.algo.ts:58
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/spending-account/contract.algo.ts:7
    // export class SpendingAccountContract extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/spending-account/contract.algo.ts:58
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    callsub optin
    intc_1 // 1
    return

main_rekey_route@5:
    // smart_contracts/arc58/spending-account/contract.algo.ts:41
    // rekey(address: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/spending-account/contract.algo.ts:7
    // export class SpendingAccountContract extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/arc58/spending-account/contract.algo.ts:41
    // rekey(address: Address): void {
    callsub rekey
    intc_1 // 1
    return

main_deleteApplication_route@4:
    // smart_contracts/arc58/spending-account/contract.algo.ts:34
    // @abimethod({ allowActions: ['DeleteApplication'] })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/arc58/spending-account/contract.algo.ts:28
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/arc58/spending-account/contract.algo.ts:7
    // export class SpendingAccountContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/arc58/spending-account/contract.algo.ts:28
    // @abimethod({ onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/arc58/spending-account/contract.algo.ts::SpendingAccountContract.isWallet() -> uint64:
isWallet:
    // smart_contracts/arc58/spending-account/contract.algo.ts:19
    // return Txn.sender === Application(this.walletID.value).address
    txn Sender
    // smart_contracts/arc58/spending-account/constants.ts:3
    // export const SpendingAccountGlobalStateKeyWalletID = 'wallet_id'
    intc_0 // 0
    bytec_0 // "wallet_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/spending-account/contract.algo.ts:19
    // return Txn.sender === Application(this.walletID.value).address
    app_params_get AppAddress
    assert // application exists
    ==
    retsub


// smart_contracts/arc58/spending-account/contract.algo.ts::SpendingAccountContract.createApplication(walletID: uint64, plugin: uint64) -> void:
createApplication:
    // smart_contracts/arc58/spending-account/contract.algo.ts:28-29
    // @abimethod({ onCreate: 'require' })
    // createApplication(walletID: uint64, plugin: uint64): void {
    proto 2 0
    // smart_contracts/arc58/spending-account/constants.ts:3
    // export const SpendingAccountGlobalStateKeyWalletID = 'wallet_id'
    bytec_0 // "wallet_id"
    // smart_contracts/arc58/spending-account/contract.algo.ts:30
    // this.walletID.value = walletID
    frame_dig -2
    app_global_put
    // smart_contracts/arc58/spending-account/constants.ts:4
    // export const SpendingAccountGlobalStateKeyPluginID = 'plugin_id'
    bytec_1 // "plugin_id"
    // smart_contracts/arc58/spending-account/contract.algo.ts:31
    // this.pluginID.value = plugin
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/spending-account/contract.algo.ts::SpendingAccountContract.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/arc58/spending-account/contract.algo.ts:36
    // assert(Txn.sender === Global.creatorAddress, ERR_ONLY_FACTORY_CAN_DELETE)
    txn Sender
    global CreatorAddress
    ==
    assert // Only the factory can delete the application
    retsub


// smart_contracts/arc58/spending-account/contract.algo.ts::SpendingAccountContract.rekey(address: bytes) -> void:
rekey:
    // smart_contracts/arc58/spending-account/contract.algo.ts:41
    // rekey(address: Address): void {
    proto 1 0
    // smart_contracts/arc58/spending-account/contract.algo.ts:42
    // assert(this.isWallet(), ERR_ONLY_CREATOR_CAN_REKEY)
    callsub isWallet
    assert // only the creator can rekey a spend contract
    // smart_contracts/arc58/spending-account/contract.algo.ts:44-50
    // itxn
    //   .payment({
    //     amount: 0,
    //     rekeyTo: address.native,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -1
    itxn_field RekeyTo
    // smart_contracts/arc58/spending-account/contract.algo.ts:46
    // amount: 0,
    intc_0 // 0
    itxn_field Amount
    // smart_contracts/arc58/spending-account/contract.algo.ts:44-49
    // itxn
    //   .payment({
    //     amount: 0,
    //     rekeyTo: address.native,
    //     fee,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/spending-account/contract.algo.ts:44-50
    // itxn
    //   .payment({
    //     amount: 0,
    //     rekeyTo: address.native,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/arc58/spending-account/contract.algo.ts::SpendingAccountContract.optin(payment: uint64, asset: uint64) -> void:
optin:
    // smart_contracts/arc58/spending-account/contract.algo.ts:58
    // optin(payment: gtxn.PaymentTxn, asset: uint64): void {
    proto 2 0
    // smart_contracts/arc58/spending-account/contract.algo.ts:59
    // assert(this.isWallet() || this.isPlugin(), ERR_ONLY_WALLET_OR_PLUGIN)
    callsub isWallet
    bnz optin_bool_true@2
    // smart_contracts/arc58/spending-account/contract.algo.ts:23
    // return Txn.sender === Application(this.pluginID.value).address
    txn Sender
    // smart_contracts/arc58/spending-account/constants.ts:4
    // export const SpendingAccountGlobalStateKeyPluginID = 'plugin_id'
    intc_0 // 0
    bytec_1 // "plugin_id"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/spending-account/contract.algo.ts:23
    // return Txn.sender === Application(this.pluginID.value).address
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/spending-account/contract.algo.ts:59
    // assert(this.isWallet() || this.isPlugin(), ERR_ONLY_WALLET_OR_PLUGIN)
    bz optin_bool_false@3

optin_bool_true@2:
    intc_1 // 1

optin_bool_merge@4:
    // smart_contracts/arc58/spending-account/contract.algo.ts:59
    // assert(this.isWallet() || this.isPlugin(), ERR_ONLY_WALLET_OR_PLUGIN)
    assert // Only the wallet or plugin can opt in
    // smart_contracts/arc58/spending-account/contract.algo.ts:61-68
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/arc58/spending-account/contract.algo.ts:64
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/spending-account/contract.algo.ts:61-68
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@7
    frame_dig -2
    gtxns Amount
    // smart_contracts/arc58/spending-account/contract.algo.ts:65
    // amount: Global.assetOptInMinBalance,
    global AssetOptInMinBalance
    // smart_contracts/arc58/spending-account/contract.algo.ts:61-68
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz optin_bool_false@7
    intc_1 // 1

optin_bool_merge@8:
    // smart_contracts/arc58/spending-account/contract.algo.ts:61-68
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: Global.assetOptInMinBalance,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // invalid payment
    // smart_contracts/arc58/spending-account/contract.algo.ts:70-77
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/spending-account/contract.algo.ts:72
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/arc58/spending-account/contract.algo.ts:73
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/arc58/spending-account/contract.algo.ts:70-76
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/spending-account/contract.algo.ts:70-77
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    retsub

optin_bool_false@7:
    intc_0 // 0
    b optin_bool_merge@8

optin_bool_false@3:
    intc_0 // 0
    b optin_bool_merge@4
