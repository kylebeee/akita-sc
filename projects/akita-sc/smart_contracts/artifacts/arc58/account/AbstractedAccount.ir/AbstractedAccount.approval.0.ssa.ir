main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__()
        return tmp%0#0

subroutine smart_contracts/utils/functions.ts::getAkitaAppList(akitaDAO: uint64) -> <uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64>:
    block@0: // L24
        let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let appListBytes#0: bytes = tuple_assignment%0#0
        let _#0: bool = tuple_assignment%1#0
        let reinterpret_bytes[96]%0#0: bytes[96] = appListBytes#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 16u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 24u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 32u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item5%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 40u 8u) // on error: Index access is out of bounds
        let item5%1#0: uint64 = (btoi item5%0#0)
        let item6%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 48u 8u) // on error: Index access is out of bounds
        let item6%1#0: uint64 = (btoi item6%0#0)
        let item7%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 56u 8u) // on error: Index access is out of bounds
        let item7%1#0: uint64 = (btoi item7%0#0)
        let item8%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 64u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let item9%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 72u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let item10%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 80u 8u) // on error: Index access is out of bounds
        let item10%1#0: uint64 = (btoi item10%0#0)
        let item11%0#0: bytes = (extract3 reinterpret_bytes[96]%0#0 88u 8u) // on error: Index access is out of bounds
        let item11%1#0: uint64 = (btoi item11%0#0)
        return item0%1#0 item1%1#0 item2%1#0 item3%1#0 item4%1#0 item5%1#0 item6%1#0 item7%1#0 item8%1#0 item9%1#0 item10%1#0 item11%1#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__() -> bool:
    block@0: // L74
        let tmp%0#0: uint64 = (txn NumAppArgs)
        let tmp%1#0: bool = (!= tmp%0#0 0u)
        goto tmp%1#0 ? block@1 : block@27
    block@1: // abi_routing_L74
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "create(string,address,address,uint64,uint64,string)void" => block@2, method "update(string)void" => block@3, method "changeRevocationApp(uint64)void" => block@4, method "setNickname(string)void" => block@5, method "setAvatar(uint64)void" => block@6, method "setBanner(uint64)void" => block@7, method "setBio(string)void" => block@8, method "arc58_changeAdmin(address)void" => block@9, method "arc58_pluginChangeAdmin(uint64,address,address)void" => block@10, method "arc58_verifyAuthAddr()void" => block@11, method "arc58_rekeyTo(address,bool)void" => block@12, method "arc58_canCall(uint64,bool,address,byte[4])bool" => block@13, method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void" => block@14, method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void" => block@15, method "arc58_addPlugin(uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@16, method "assignDomain(address,string)void" => block@17, method "arc58_removePlugin(uint64,address)void" => block@18, method "arc58_addNamedPlugin(string,uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@19, method "arc58_removeNamedPlugin(string)void" => block@20, method "arc58_addAllowance(uint64,address,uint64,uint8,uint64,uint64,uint64)void" => block@21, method "arc58_removeAllowance(uint64,address,uint64)void" => block@22, method "arc58_getAdmin()address" => block@23, method "balance(uint64[])uint64[]" => block@24, * => block@25}
    block@2: // create_route_L527
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (== tmp%3#0 NoOp)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (== tmp%5#0 0u)
        (assert tmp%6#0) // can only call when creating
        let tmp%7#0: bytes = (txna ApplicationArgs 1)
        let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%9#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%10#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        let tmp%11#0: bytes = (txna ApplicationArgs 6)
        let tmp%12#0: bytes = ((extract 2 0) tmp%11#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(tmp%8#0, reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0, tmp%9#0, tmp%10#0, tmp%12#0)
        return 1u
    block@3: // update_route_L553
        let tmp%13#0: uint64 = (txn OnCompletion)
        let tmp%14#0: bool = (== tmp%13#0 UpdateApplication)
        (assert tmp%14#0) // OnCompletion is not UpdateApplication
        let tmp%15#0: uint64 = (txn ApplicationID)
        let tmp%16#0: bool = (!= tmp%15#0 0u)
        (assert tmp%16#0) // can only call when not creating
        let tmp%17#0: bytes = (txna ApplicationArgs 1)
        let tmp%18#0: bytes = ((extract 2 0) tmp%17#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(tmp%18#0)
        return 1u
    block@4: // changeRevocationApp_route_L566
        let tmp%19#0: uint64 = (txn OnCompletion)
        let tmp%20#0: bool = (== tmp%19#0 NoOp)
        (assert tmp%20#0) // OnCompletion is not NoOp
        let tmp%21#0: uint64 = (txn ApplicationID)
        let tmp%22#0: bool = (!= tmp%21#0 0u)
        (assert tmp%22#0) // can only call when not creating
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%23#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(tmp%23#0)
        return 1u
    block@5: // setNickname_route_L576
        let tmp%24#0: uint64 = (txn OnCompletion)
        let tmp%25#0: bool = (== tmp%24#0 NoOp)
        (assert tmp%25#0) // OnCompletion is not NoOp
        let tmp%26#0: uint64 = (txn ApplicationID)
        let tmp%27#0: bool = (!= tmp%26#0 0u)
        (assert tmp%27#0) // can only call when not creating
        let tmp%28#0: bytes = (txna ApplicationArgs 1)
        let tmp%29#0: bytes = ((extract 2 0) tmp%28#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(tmp%29#0)
        return 1u
    block@6: // setAvatar_route_L586
        let tmp%30#0: uint64 = (txn OnCompletion)
        let tmp%31#0: bool = (== tmp%30#0 NoOp)
        (assert tmp%31#0) // OnCompletion is not NoOp
        let tmp%32#0: uint64 = (txn ApplicationID)
        let tmp%33#0: bool = (!= tmp%32#0 0u)
        (assert tmp%33#0) // can only call when not creating
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%34#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(tmp%34#0)
        return 1u
    block@7: // setBanner_route_L598
        let tmp%35#0: uint64 = (txn OnCompletion)
        let tmp%36#0: bool = (== tmp%35#0 NoOp)
        (assert tmp%36#0) // OnCompletion is not NoOp
        let tmp%37#0: uint64 = (txn ApplicationID)
        let tmp%38#0: bool = (!= tmp%37#0 0u)
        (assert tmp%38#0) // can only call when not creating
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%39#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(tmp%39#0)
        return 1u
    block@8: // setBio_route_L610
        let tmp%40#0: uint64 = (txn OnCompletion)
        let tmp%41#0: bool = (== tmp%40#0 NoOp)
        (assert tmp%41#0) // OnCompletion is not NoOp
        let tmp%42#0: uint64 = (txn ApplicationID)
        let tmp%43#0: bool = (!= tmp%42#0 0u)
        (assert tmp%43#0) // can only call when not creating
        let tmp%44#0: bytes = (txna ApplicationArgs 1)
        let tmp%45#0: bytes = ((extract 2 0) tmp%44#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(tmp%45#0)
        return 1u
    block@9: // arc58_changeAdmin_route_L620
        let tmp%46#0: uint64 = (txn OnCompletion)
        let tmp%47#0: bool = (== tmp%46#0 NoOp)
        (assert tmp%47#0) // OnCompletion is not NoOp
        let tmp%48#0: uint64 = (txn ApplicationID)
        let tmp%49#0: bool = (!= tmp%48#0 0u)
        (assert tmp%49#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(reinterpret_bytes[32]%2#0)
        return 1u
    block@10: // arc58_pluginChangeAdmin_route_L635
        let tmp%50#0: uint64 = (txn OnCompletion)
        let tmp%51#0: bool = (== tmp%50#0 NoOp)
        (assert tmp%51#0) // OnCompletion is not NoOp
        let tmp%52#0: uint64 = (txn ApplicationID)
        let tmp%53#0: bool = (!= tmp%52#0 0u)
        (assert tmp%53#0) // can only call when not creating
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%54#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%4#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(tmp%54#0, reinterpret_bytes[32]%3#0, reinterpret_bytes[32]%4#0)
        return 1u
    block@11: // arc58_verifyAuthAddr_route_L659
        let tmp%55#0: uint64 = (txn OnCompletion)
        let tmp%56#0: bool = (== tmp%55#0 NoOp)
        (assert tmp%56#0) // OnCompletion is not NoOp
        let tmp%57#0: uint64 = (txn ApplicationID)
        let tmp%58#0: bool = (!= tmp%57#0 0u)
        (assert tmp%58#0) // can only call when not creating
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddr()
        return 1u
    block@12: // arc58_rekeyTo_route_L670
        let tmp%59#0: uint64 = (txn OnCompletion)
        let tmp%60#0: bool = (== tmp%59#0 NoOp)
        (assert tmp%60#0) // OnCompletion is not NoOp
        let tmp%61#0: uint64 = (txn ApplicationID)
        let tmp%62#0: bool = (!= tmp%61#0 0u)
        (assert tmp%62#0) // can only call when not creating
        let reinterpret_bytes[32]%5#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%63#0: bool = (getbit reinterpret_bytes[1]%0#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(reinterpret_bytes[32]%5#0, tmp%63#0)
        return 1u
    block@13: // arc58_canCall_route_L696
        let tmp%64#0: uint64 = (txn OnCompletion)
        let tmp%65#0: bool = (== tmp%64#0 NoOp)
        (assert tmp%65#0) // OnCompletion is not NoOp
        let tmp%66#0: uint64 = (txn ApplicationID)
        let tmp%67#0: bool = (!= tmp%66#0 0u)
        (assert tmp%67#0) // can only call when not creating
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%68#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%69#0: bool = (getbit reinterpret_bytes[1]%1#0 0u)
        let reinterpret_bytes[32]%6#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[4]%0#0: bytes[4] = (txna ApplicationArgs 4)
        let to_encode%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(tmp%68#0, tmp%69#0, reinterpret_bytes[32]%6#0, reinterpret_bytes[4]%0#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%70#0: bytes = (concat 0x151f7c75 encoded_bool%0#0)
        (log tmp%70#0)
        return 1u
    block@14: // arc58_rekeyToPlugin_route_L718
        let tmp%71#0: uint64 = (txn OnCompletion)
        let tmp%72#0: bool = (== tmp%71#0 NoOp)
        (assert tmp%72#0) // OnCompletion is not NoOp
        let tmp%73#0: uint64 = (txn ApplicationID)
        let tmp%74#0: bool = (!= tmp%73#0 0u)
        (assert tmp%74#0) // can only call when not creating
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%75#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%76#0: bool = (getbit reinterpret_bytes[1]%2#0 0u)
        let reinterpret_encoded_uint64[]%0#0: encoded_uint64[] = (txna ApplicationArgs 3)
        let reinterpret_(encoded_uint64,encoded_uint64)[]%0#0: (encoded_uint64,encoded_uint64)[] = (txna ApplicationArgs 4)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(tmp%75#0, tmp%76#0, reinterpret_encoded_uint64[]%0#0, reinterpret_(encoded_uint64,encoded_uint64)[]%0#0)
        return 1u
    block@15: // arc58_rekeyToNamedPlugin_route_L779
        let tmp%77#0: uint64 = (txn OnCompletion)
        let tmp%78#0: bool = (== tmp%77#0 NoOp)
        (assert tmp%78#0) // OnCompletion is not NoOp
        let tmp%79#0: uint64 = (txn ApplicationID)
        let tmp%80#0: bool = (!= tmp%79#0 0u)
        (assert tmp%80#0) // can only call when not creating
        let tmp%81#0: bytes = (txna ApplicationArgs 1)
        let tmp%82#0: bytes = ((extract 2 0) tmp%81#0)
        let reinterpret_bytes[1]%3#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%83#0: bool = (getbit reinterpret_bytes[1]%3#0 0u)
        let reinterpret_encoded_uint64[]%1#0: encoded_uint64[] = (txna ApplicationArgs 3)
        let reinterpret_(encoded_uint64,encoded_uint64)[]%1#0: (encoded_uint64,encoded_uint64)[] = (txna ApplicationArgs 4)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(tmp%82#0, tmp%83#0, reinterpret_encoded_uint64[]%1#0, reinterpret_(encoded_uint64,encoded_uint64)[]%1#0)
        return 1u
    block@16: // arc58_addPlugin_route_L801
        let tmp%84#0: uint64 = (txn OnCompletion)
        let tmp%85#0: bool = (== tmp%84#0 NoOp)
        (assert tmp%85#0) // OnCompletion is not NoOp
        let tmp%86#0: uint64 = (txn ApplicationID)
        let tmp%87#0: bool = (!= tmp%86#0 0u)
        (assert tmp%87#0) // can only call when not creating
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%88#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let reinterpret_bytes[32]%7#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[1]%4#0: bytes[1] = (txna ApplicationArgs 3)
        let tmp%89#0: bool = (getbit reinterpret_bytes[1]%4#0 0u)
        let reinterpret_bytes[1]%5#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%90#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%91#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        let reinterpret_(bytes[4],encoded_uint64)[]%0#0: (bytes[4],encoded_uint64)[] = (txna ApplicationArgs 7)
        let reinterpret_bytes[1]%6#0: bytes[1] = (txna ApplicationArgs 8)
        let tmp%92#0: bool = (getbit reinterpret_bytes[1]%6#0 0u)
        let reinterpret_bytes[1]%7#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%93#0: bool = (getbit reinterpret_bytes[1]%7#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(tmp%88#0, reinterpret_bytes[32]%7#0, tmp%89#0, reinterpret_bytes[1]%5#0, tmp%90#0, tmp%91#0, reinterpret_(bytes[4],encoded_uint64)[]%0#0, tmp%92#0, tmp%93#0)
        return 1u
    block@17: // assignDomain_route_L889
        let tmp%94#0: uint64 = (txn OnCompletion)
        let tmp%95#0: bool = (== tmp%94#0 NoOp)
        (assert tmp%95#0) // OnCompletion is not NoOp
        let tmp%96#0: uint64 = (txn ApplicationID)
        let tmp%97#0: bool = (!= tmp%96#0 0u)
        (assert tmp%97#0) // can only call when not creating
        let reinterpret_bytes[32]%8#0: bytes[32] = (txna ApplicationArgs 1)
        let tmp%98#0: bytes = (txna ApplicationArgs 2)
        let tmp%99#0: bytes = ((extract 2 0) tmp%98#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(reinterpret_bytes[32]%8#0, tmp%99#0)
        return 1u
    block@18: // arc58_removePlugin_route_L902
        let tmp%100#0: uint64 = (txn OnCompletion)
        let tmp%101#0: bool = (== tmp%100#0 NoOp)
        (assert tmp%101#0) // OnCompletion is not NoOp
        let tmp%102#0: uint64 = (txn ApplicationID)
        let tmp%103#0: bool = (!= tmp%102#0 0u)
        (assert tmp%103#0) // can only call when not creating
        let reinterpret_bytes[8]%11#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%104#0: uint64 = (btoi reinterpret_bytes[8]%11#0)
        let reinterpret_bytes[32]%9#0: bytes[32] = (txna ApplicationArgs 2)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(tmp%104#0, reinterpret_bytes[32]%9#0)
        return 1u
    block@19: // arc58_addNamedPlugin_route_L952
        let tmp%105#0: uint64 = (txn OnCompletion)
        let tmp%106#0: bool = (== tmp%105#0 NoOp)
        (assert tmp%106#0) // OnCompletion is not NoOp
        let tmp%107#0: uint64 = (txn ApplicationID)
        let tmp%108#0: bool = (!= tmp%107#0 0u)
        (assert tmp%108#0) // can only call when not creating
        let tmp%109#0: bytes = (txna ApplicationArgs 1)
        let tmp%110#0: bytes = ((extract 2 0) tmp%109#0)
        let reinterpret_bytes[8]%12#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%111#0: uint64 = (btoi reinterpret_bytes[8]%12#0)
        let reinterpret_bytes[32]%10#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%8#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%112#0: bool = (getbit reinterpret_bytes[1]%8#0 0u)
        let reinterpret_bytes[1]%9#0: bytes[1] = (txna ApplicationArgs 5)
        let reinterpret_bytes[8]%13#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%113#0: uint64 = (btoi reinterpret_bytes[8]%13#0)
        let reinterpret_bytes[8]%14#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%114#0: uint64 = (btoi reinterpret_bytes[8]%14#0)
        let reinterpret_(bytes[4],encoded_uint64)[]%1#0: (bytes[4],encoded_uint64)[] = (txna ApplicationArgs 8)
        let reinterpret_bytes[1]%10#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%115#0: bool = (getbit reinterpret_bytes[1]%10#0 0u)
        let reinterpret_bytes[1]%11#0: bytes[1] = (txna ApplicationArgs 10)
        let tmp%116#0: bool = (getbit reinterpret_bytes[1]%11#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(tmp%110#0, tmp%111#0, reinterpret_bytes[32]%10#0, tmp%112#0, reinterpret_bytes[1]%9#0, tmp%113#0, tmp%114#0, reinterpret_(bytes[4],encoded_uint64)[]%1#0, tmp%115#0, tmp%116#0)
        return 1u
    block@20: // arc58_removeNamedPlugin_route_L1037
        let tmp%117#0: uint64 = (txn OnCompletion)
        let tmp%118#0: bool = (== tmp%117#0 NoOp)
        (assert tmp%118#0) // OnCompletion is not NoOp
        let tmp%119#0: uint64 = (txn ApplicationID)
        let tmp%120#0: bool = (!= tmp%119#0 0u)
        (assert tmp%120#0) // can only call when not creating
        let tmp%121#0: bytes = (txna ApplicationArgs 1)
        let tmp%122#0: bytes = ((extract 2 0) tmp%121#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(tmp%122#0)
        return 1u
    block@21: // arc58_addAllowance_route_L1074
        let tmp%123#0: uint64 = (txn OnCompletion)
        let tmp%124#0: bool = (== tmp%123#0 NoOp)
        (assert tmp%124#0) // OnCompletion is not NoOp
        let tmp%125#0: uint64 = (txn ApplicationID)
        let tmp%126#0: bool = (!= tmp%125#0 0u)
        (assert tmp%126#0) // can only call when not creating
        let reinterpret_bytes[8]%15#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%127#0: uint64 = (btoi reinterpret_bytes[8]%15#0)
        let reinterpret_bytes[32]%11#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%16#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%128#0: uint64 = (btoi reinterpret_bytes[8]%16#0)
        let reinterpret_bytes[1]%12#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%17#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%129#0: uint64 = (btoi reinterpret_bytes[8]%17#0)
        let reinterpret_bytes[8]%18#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%130#0: uint64 = (btoi reinterpret_bytes[8]%18#0)
        let reinterpret_bytes[8]%19#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%131#0: uint64 = (btoi reinterpret_bytes[8]%19#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowance(tmp%127#0, reinterpret_bytes[32]%11#0, tmp%128#0, reinterpret_bytes[1]%12#0, tmp%129#0, tmp%130#0, tmp%131#0)
        return 1u
    block@22: // arc58_removeAllowance_route_L1116
        let tmp%132#0: uint64 = (txn OnCompletion)
        let tmp%133#0: bool = (== tmp%132#0 NoOp)
        (assert tmp%133#0) // OnCompletion is not NoOp
        let tmp%134#0: uint64 = (txn ApplicationID)
        let tmp%135#0: bool = (!= tmp%134#0 0u)
        (assert tmp%135#0) // can only call when not creating
        let reinterpret_bytes[8]%20#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%136#0: uint64 = (btoi reinterpret_bytes[8]%20#0)
        let reinterpret_bytes[32]%12#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%21#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%137#0: uint64 = (btoi reinterpret_bytes[8]%21#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowance(tmp%136#0, reinterpret_bytes[32]%12#0, tmp%137#0)
        return 1u
    block@23: // arc58_getAdmin_route_L1148
        let tmp%138#0: uint64 = (txn OnCompletion)
        let tmp%139#0: bool = (== tmp%138#0 NoOp)
        (assert tmp%139#0) // OnCompletion is not NoOp
        let tmp%140#0: uint64 = (txn ApplicationID)
        let tmp%141#0: bool = (!= tmp%140#0 0u)
        (assert tmp%141#0) // can only call when not creating
        let tmp%142#0: bytes[32] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin()
        let tmp%143#0: bytes = (concat 0x151f7c75 tmp%142#0)
        (log tmp%143#0)
        return 1u
    block@24: // balance_route_L1154
        let tmp%144#0: uint64 = (txn OnCompletion)
        let tmp%145#0: bool = (== tmp%144#0 NoOp)
        (assert tmp%145#0) // OnCompletion is not NoOp
        let tmp%146#0: uint64 = (txn ApplicationID)
        let tmp%147#0: bool = (!= tmp%146#0 0u)
        (assert tmp%147#0) // can only call when not creating
        let reinterpret_encoded_uint64[]%2#0: encoded_uint64[] = (txna ApplicationArgs 1)
        let tmp%148#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(reinterpret_encoded_uint64[]%2#0)
        let tmp%149#0: bytes = (concat 0x151f7c75 tmp%148#0)
        (log tmp%149#0)
        return 1u
    block@25: // switch_case_default_L74
        goto block@26
    block@26: // switch_case_next_L74
        goto block@28
    block@27: // bare_routing_L74
        goto block@28
    block@28: // after_if_else_L74
        return 0u

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
    block@0: // L136
        let materialized_values%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_user_interaction" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange() -> void:
    block@0: // L140
        let materialized_values%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_change" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin() -> bool:
    block@0: // L145
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@3 : block@1
    block@1: // or_contd_L147
        let materialized_values%0#0: bytes[32] = (txn Sender)
        let box_prefixed_key%0#0: bytes = (concat "d" materialized_values%0#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%1#0 ? block@2 : block@4
    block@2: // and_contd_L148
        let materialized_values%1#0: bytes[32] = (txn Sender)
        let box_prefixed_key%1#0: bytes = (concat "d" materialized_values%1#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%2#0) // Box must have value
        let tmp%2#0: bool = (== maybe_value%1#0 "akita.community")
        goto tmp%2#0 ? block@3 : block@4
    block@3: // bool_true_L147
        let or_result%0#0: bool = 1u
        goto block@5
    block@4: // bool_false_L147
        let or_result%0#1: bool = 0u
        goto block@5
    block@5: // bool_merge_L147
        let or_result%0#2: bool = φ(or_result%0#0 <- block@3, or_result%0#1 <- block@4)
        return or_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke() -> bool:
    block@0: // L153
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "revocation_app")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        return tmp%1#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(application: uint64, allowedCaller: bytes[32], method: bytes[4]) -> bool:
    block@0: // L157
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (application#0, allowedCaller#0)
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@2 : block@1
    block@1: // if_body_L160
        return 0u
    block@2: // after_if_else_L160
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let tmp%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%0#0
        let methods#0: bytes = copy%0#0
        let tmp%1#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%2#0: bool = (> tmp%1#0 0u)
        let select%0#0: bool = (select 1u 0u tmp%2#0)
        let methodAllowed#0: bool = select%0#0
        let i#0: uint64 = 0u
        goto block@3
    block@3: // while_top_L166
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@6)
        let tmp%3#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%4#0: bool = (< i#1 tmp%3#0)
        goto tmp%4#0 ? block@4 : block@7
    block@4: // while_body_L166
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 20u)
        let tmp%5#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let tmp%6#0: bytes = (extract3 tmp%5#0 0u 4u) // on error: Index access is out of bounds
        let tmp%7#0: bool = (== tmp%6#0 method#0)
        goto tmp%7#0 ? block@5 : block@6
    block@5: // if_body_L167
        let methodAllowed#1: bool = 1u
        goto block@8
    block@6: // after_if_else_L167
        let i#2: uint64 = (+ i#1 1u)
        goto block@3
    block@7: // after_while_L166
        goto block@8
    block@8: // L166
        let methodAllowed#4: bool = φ(methodAllowed#1 <- block@5, methodAllowed#0 <- block@7)
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item0%0#0: bool = (getbit encoded_bool%0#0 0u)
        let item1%0#0: bytes = (extract3 maybe_value%1#0 1u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 maybe_value%1#0 2u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 maybe_value%1#0 10u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 maybe_value%1#0 18u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item_start_offset%1#0: uint64 = (extract_uint16 maybe_value%1#0 26u)
        let item_end_offset%1#0: uint64 = (len maybe_value%1#0)
        let item5%0#0: bytes = (substring3 maybe_value%1#0 item_start_offset%1#0 item_end_offset%1#0)
        let is_true%1#0: uint64 = (getbit maybe_value%1#0 224u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let item6%0#0: bool = (getbit encoded_bool%1#0 0u)
        let is_true%2#0: uint64 = (getbit maybe_value%1#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item8%0#0: bytes = (extract3 maybe_value%1#0 29u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let item9%0#0: bytes = (extract3 maybe_value%1#0 37u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let (p.admin#0: bool, p.delegationType#0: bytes[1], p.spendingApp#0: uint64, p.lastValid#0: uint64, p.cooldown#0: uint64, p.methods#0: bytes, p.useAllowance#0: bool, p.useRounds#0: bool, p.lastCalled#0: uint64, p.start#0: uint64) = (item0%0#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0, item5%0#0, item6%0#0, item7%0#0, item8%1#0, item9%1#0)
        goto p.useRounds#0 ? block@9 : block@10
    block@9: // ternary_true_L174
        let ternary_result%0#0: uint64 = (global Round)
        goto block@11
    block@10: // ternary_false_L174
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@11
    block@11: // ternary_merge_L174
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@9, ternary_result%0#1 <- block@10)
        let epochRef#0: uint64 = ternary_result%0#2
        let tmp%8#0: bool = (>= p.lastCalled#0 epochRef#0)
        goto tmp%8#0 ? block@12 : block@14
    block@12: // and_contd_L177
        let tmp%9#0: uint64 = (- epochRef#0 p.lastCalled#0)
        let tmp%10#0: bool = (>= tmp%9#0 p.cooldown#0)
        goto tmp%10#0 ? block@13 : block@14
    block@13: // bool_true_L177
        let and_result%0#0: bool = 1u
        goto block@15
    block@14: // bool_false_L177
        let and_result%0#1: bool = 0u
        goto block@15
    block@15: // bool_merge_L177
        let and_result%0#2: bool = φ(and_result%0#0 <- block@13, and_result%0#1 <- block@14)
        let tmp%11#0: bool = (&& and_result%0#2 methodAllowed#4)
        return tmp%11#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> bool:
    block@0: // L183
        let tmp%0#0: bytes[32] = ((gtxns Sender) txn#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L186
        let tmp%2#0: bytes[32] = ((gtxns RekeyTo) txn#0)
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (== tmp%2#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // if_body_L188
        return 1u
    block@3: // after_if_else_L185
        let tmp%5#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%6#0: bool = (== tmp%5#0 6u)
        goto tmp%6#0 ? block@4 : block@9
    block@4: // and_contd_L193
        let tmp%7#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%8#0: uint64 = (global CurrentApplicationID)
        let tmp%9#0: bool = (== tmp%7#0 tmp%8#0)
        goto tmp%9#0 ? block@5 : block@9
    block@5: // and_contd_L193
        let tmp%10#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%11#0: bool = (== tmp%10#0 1u)
        goto tmp%11#0 ? block@6 : block@9
    block@6: // and_contd_L193
        let tmp%12#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%13#0: bool = (== tmp%12#0 0u)
        goto tmp%13#0 ? block@7 : block@9
    block@7: // and_contd_L193
        let tmp%14#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%15#0: bool = (== tmp%14#0 method "arc58_verifyAuthAddr()void")
        goto tmp%15#0 ? block@8 : block@9
    block@8: // bool_true_L193
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L193
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L193
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        return and_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertRekeysBack() -> void:
    block@0: // L201
        let rekeysBack#0: bool = 0u
        let tmp%0#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%0#0 1u)
        goto block@1
    block@1: // while_top_L203
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@4)
        let tmp%1#0: uint64 = (global GroupSize)
        let tmp%2#0: bool = (< i#1 tmp%1#0)
        goto tmp%2#0 ? block@2 : block@5
    block@2: // while_body_L203
        let txn#0: uint64 = i#1
        let tmp%3#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%3#0 ? block@3 : block@4
    block@3: // if_body_L206
        let rekeysBack#1: bool = 1u
        goto block@6
    block@4: // after_if_else_L206
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@5: // after_while_L203
        goto block@6
    block@6: // L203
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@3, rekeysBack#0 <- block@5)
        (assert rekeysBack#2) // missing rekey back
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key.application: uint64, key.allowedCaller: bytes[32]) -> <bool, bool, bool, bool, bool, bool>:
    block@0: // L215
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        let exists#0: bool = maybe_exists%0#0
        goto exists#0 ? block@2 : block@1
    block@1: // if_body_L218
        return 0u 1u 1u 1u 0u 0u
    block@2: // after_if_else_L218
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item0%0#0: bool = (getbit encoded_bool%0#0 0u)
        let item1%0#0: bytes = (extract3 maybe_value%0#0 1u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 maybe_value%0#0 2u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 maybe_value%0#0 10u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 maybe_value%0#0 18u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let item5%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%1#0: uint64 = (getbit maybe_value%0#0 224u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let item6%0#0: bool = (getbit encoded_bool%1#0 0u)
        let is_true%2#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item8%0#0: bytes = (extract3 maybe_value%0#0 29u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let item9%0#0: bytes = (extract3 maybe_value%0#0 37u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let (pluginInfo.admin#0: bool, pluginInfo.delegationType#0: bytes[1], pluginInfo.spendingApp#0: uint64, pluginInfo.lastValid#0: uint64, pluginInfo.cooldown#0: uint64, pluginInfo.methods#0: bytes, pluginInfo.useAllowance#0: bool, pluginInfo.useRounds#0: bool, pluginInfo.lastCalled#0: uint64, pluginInfo.start#0: uint64) = (item0%0#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0, item5%0#0, item6%0#0, item7%0#0, item8%1#0, item9%1#0)
        goto pluginInfo.useRounds#0 ? block@3 : block@4
    block@3: // ternary_true_L230
        let ternary_result%0#0: uint64 = (global Round)
        goto block@5
    block@4: // ternary_false_L230
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@5
    block@5: // ternary_merge_L230
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@3, ternary_result%0#1 <- block@4)
        let epochRef#0: uint64 = ternary_result%0#2
        let expired#0: bool = (> epochRef#0 pluginInfo.lastValid#0)
        let hasCooldown#0: bool = (> pluginInfo.cooldown#0 0u)
        let tmp%0#0: uint64 = (- epochRef#0 pluginInfo.lastCalled#0)
        let onCooldown#0: bool = (< tmp%0#0 pluginInfo.cooldown#0)
        let tmp%1#0: uint64 = (extract_uint16 pluginInfo.methods#0 0u)
        let hasMethodRestrictions#0: bool = (> tmp%1#0 0u)
        goto exists#0 ? block@6 : block@9
    block@6: // and_contd_L237
        goto expired#0 ? block@9 : block@7
    block@7: // and_contd_L237
        goto onCooldown#0 ? block@9 : block@8
    block@8: // bool_true_L237
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L237
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L237
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        let valid#0: bool = and_result%0#2
        return exists#0 expired#0 hasCooldown#0 onCooldown#0 hasMethodRestrictions#0 valid#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.fullPluginCheck(key.application: uint64, key.allowedCaller: bytes[32], txn: uint64, methodOffsets: encoded_uint64[], methodIndex: uint64) -> <bool, bool, bool, bool, bool, bool, bool, bool, bool>:
    block@0: // L249
        let (check.exists#0: bool, check.expired#0: bool, check.hasCooldown#0: bool, check.onCooldown#0: bool, check.hasMethodRestrictions#0: bool, check.valid#0: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key.application#0, key.allowedCaller#0)
        goto check.valid#0 ? block@2 : block@1
    block@1: // if_body_L258
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 0u 1u 1u check.valid#0
    block@2: // after_if_else_L258
        let tmp%0#0: bool = (! check.hasMethodRestrictions#0)
        let (mCheck.methodAllowed#0: bool, mCheck.methodHasCooldown#0: bool, mCheck.methodOnCooldown#0: bool) = (tmp%0#0, 0u, 0u)
        goto check.hasMethodRestrictions#0 ? block@3 : block@4
    block@3: // if_body_L273
        let tmp%1#0: uint64 = (extract_uint16 methodOffsets#0 0u)
        let tmp%2#0: bool = (< methodIndex#0 tmp%1#0)
        (assert tmp%2#0) // malformed method offsets
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methodOffsets#0)
        let item_offset%0#0: uint64 = (* methodIndex#0 8u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let tmp%3#0: uint64 = (btoi arc4_item%0#0)
        let (mCheck.methodAllowed#1: bool, mCheck.methodHasCooldown#1: bool, mCheck.methodOnCooldown#1: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck(key.application#0, key.allowedCaller#0, txn#0, tmp%3#0)
        goto block@4
    block@4: // after_if_else_L273
        let mCheck.methodAllowed#2: bool = φ(mCheck.methodAllowed#0 <- block@2, mCheck.methodAllowed#1 <- block@3)
        let mCheck.methodHasCooldown#2: bool = φ(mCheck.methodHasCooldown#0 <- block@2, mCheck.methodHasCooldown#1 <- block@3)
        let mCheck.methodOnCooldown#2: bool = φ(mCheck.methodOnCooldown#0 <- block@2, mCheck.methodOnCooldown#1 <- block@3)
        goto check.valid#0 ? block@5 : block@7
    block@5: // and_contd_L281
        goto mCheck.methodAllowed#2 ? block@6 : block@7
    block@6: // bool_true_L281
        let and_result%0#0: bool = 1u
        goto block@8
    block@7: // bool_false_L281
        let and_result%0#1: bool = 0u
        goto block@8
    block@8: // bool_merge_L281
        let and_result%0#2: bool = φ(and_result%0#0 <- block@6, and_result%0#1 <- block@7)
        return check.exists#0 check.expired#0 check.hasCooldown#0 check.onCooldown#0 check.hasMethodRestrictions#0 mCheck.methodAllowed#2 mCheck.methodHasCooldown#2 mCheck.methodOnCooldown#2 and_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertValidGroup(key.application: uint64, key.allowedCaller: bytes[32], methodOffsets: encoded_uint64[]) -> void:
    block@0: // L291
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%0#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%0#0 ? block@1 : block@2
    block@1: // ternary_true_L293
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L293
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L293
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let (initialCheck.exists#0: bool, initialCheck.expired#0: bool, initialCheck.hasCooldown#0: bool, initialCheck.onCooldown#0: bool, initialCheck.hasMethodRestrictions#0: bool, initialCheck.valid#0: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key.application#0, key.allowedCaller#0)
        (assert initialCheck.exists#0) // Plugin does not exist
        let tmp%1#0: bool = (! initialCheck.expired#0)
        (assert tmp%1#0) // plugin expired
        let tmp%2#0: bool = (! initialCheck.onCooldown#0)
        (assert tmp%2#0) // plugin on cooldown
        let rekeysBack#0: bool = 0u
        let methodIndex#0: uint64 = 0u
        let tmp%3#0: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%3#0 1u)
        goto block@4
    block@4: // while_top_L306
        let i#1: uint64 = φ(i#0 <- block@3, i#3 <- block@12)
        let methodIndex#1: uint64 = φ(methodIndex#0 <- block@3, methodIndex#4 <- block@12)
        let tmp%4#0: uint64 = (global GroupSize)
        let tmp%5#0: bool = (< i#1 tmp%4#0)
        goto tmp%5#0 ? block@5 : block@13
    block@5: // while_body_L306
        let txn#0: uint64 = i#1
        let tmp%6#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn#0)
        goto tmp%6#0 ? block@6 : block@7
    block@6: // if_body_L309
        let rekeysBack#1: bool = 1u
        goto block@14
    block@7: // after_if_else_L309
        let tmp%7#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%8#0: bool = (!= tmp%7#0 6u)
        goto tmp%8#0 ? block@8 : block@9
    block@8: // if_body_L314
        goto block@12
    block@9: // after_if_else_L314
        let tmp%9#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%10#0: bool = (== tmp%9#0 key.application#0)
        (assert tmp%10#0) // cannot call other apps during rekey
        let tmp%11#0: uint64 = ((gtxns OnCompletion) txn#0)
        let tmp%12#0: bool = (== tmp%11#0 0u)
        (assert tmp%12#0) // invalid oncomplete must be no op
        let tmp%13#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%14#0: bool = (> tmp%13#0 1u)
        (assert tmp%14#0) // invalid sender must be this app id
        let tmp%15#0: bytes = ((gtxnsas ApplicationArgs) txn#0 1u)
        let tmp%16#0: uint64 = (btoi tmp%15#0)
        let tmp%17#0: uint64 = (global CurrentApplicationID)
        let tmp%18#0: bool = (== tmp%16#0 tmp%17#0)
        (assert tmp%18#0) // invalid sender app id
        let (check.exists#0: bool, check.expired#0: bool, check.hasCooldown#0: bool, check.onCooldown#0: bool, check.hasMethodRestrictions#0: bool, check.methodAllowed#0: bool, check.methodHasCooldown#0: bool, check.methodOnCooldown#0: bool, check.valid#0: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.fullPluginCheck(key.application#0, key.allowedCaller#0, txn#0, methodOffsets#0, methodIndex#1)
        let tmp%19#0: bool = (! check.methodOnCooldown#0)
        (assert tmp%19#0) // method on cooldown
        (assert check.valid#0) // invalid plugin call
        goto initialCheck.hasCooldown#0 ? block@10 : block@11
    block@10: // if_body_L330
        let val_as_bytes%1#0: bytes[8] = (itob epochRef#0)
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let copy%0#0: bytes = maybe_value%1#0
        let is_true%1#0: uint64 = (getbit copy%0#0 0u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let copy%1#0: bytes = maybe_value%2#0
        let tmp%20#0: bytes = (extract3 copy%1#0 1u 1u) // on error: Index access is out of bounds
        let val_as_bytes%4#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 key.allowedCaller#0)
        let box_prefixed_key%3#0: bytes = (concat "p" encoded_tuple_buffer%11#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let copy%2#0: bytes = maybe_value%3#0
        let tmp%21#0: bytes = (extract3 copy%2#0 2u 8u) // on error: Index access is out of bounds
        let val_as_bytes%5#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%4#0: uint64 = 40u
        let encoded_tuple_buffer%12#0: bytes[0] = 0x
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 key.allowedCaller#0)
        let box_prefixed_key%4#0: bytes = (concat "p" encoded_tuple_buffer%14#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%4#0) // Box must have value
        let copy%3#0: bytes = maybe_value%4#0
        let tmp%22#0: bytes = (extract3 copy%3#0 10u 8u) // on error: Index access is out of bounds
        let val_as_bytes%6#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%5#0: uint64 = 40u
        let encoded_tuple_buffer%15#0: bytes[0] = 0x
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 key.allowedCaller#0)
        let box_prefixed_key%5#0: bytes = (concat "p" encoded_tuple_buffer%17#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get box_prefixed_key%5#0)
        (assert maybe_exists%5#0) // Box must have value
        let copy%4#0: bytes = maybe_value%5#0
        let tmp%23#0: bytes = (extract3 copy%4#0 18u 8u) // on error: Index access is out of bounds
        let val_as_bytes%7#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%6#0: uint64 = 40u
        let encoded_tuple_buffer%18#0: bytes[0] = 0x
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%20#0: bytes = (concat encoded_tuple_buffer%19#0 key.allowedCaller#0)
        let box_prefixed_key%6#0: bytes = (concat "p" encoded_tuple_buffer%20#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%6#0)
        (assert maybe_exists%6#0) // Box must have value
        let copy%5#0: bytes = maybe_value%6#0
        let item_start_offset%0#0: uint64 = (extract_uint16 copy%5#0 26u)
        let item_end_offset%0#0: uint64 = (len copy%5#0)
        let tmp%24#0: bytes = (substring3 copy%5#0 item_start_offset%0#0 item_end_offset%0#0)
        let val_as_bytes%8#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%7#0: uint64 = 40u
        let encoded_tuple_buffer%21#0: bytes[0] = 0x
        let encoded_tuple_buffer%22#0: bytes = (concat encoded_tuple_buffer%21#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%23#0: bytes = (concat encoded_tuple_buffer%22#0 key.allowedCaller#0)
        let box_prefixed_key%7#0: bytes = (concat "p" encoded_tuple_buffer%23#0)
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (box_get box_prefixed_key%7#0)
        (assert maybe_exists%7#0) // Box must have value
        let copy%6#0: bytes = maybe_value%7#0
        let is_true%2#0: uint64 = (getbit copy%6#0 224u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let val_as_bytes%9#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%8#0: uint64 = 40u
        let encoded_tuple_buffer%24#0: bytes[0] = 0x
        let encoded_tuple_buffer%25#0: bytes = (concat encoded_tuple_buffer%24#0 val_as_bytes%9#0)
        let encoded_tuple_buffer%26#0: bytes = (concat encoded_tuple_buffer%25#0 key.allowedCaller#0)
        let box_prefixed_key%8#0: bytes = (concat "p" encoded_tuple_buffer%26#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%8#0)
        (assert maybe_exists%8#0) // Box must have value
        let copy%7#0: bytes = maybe_value%8#0
        let is_true%3#0: uint64 = (getbit copy%7#0 225u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let val_as_bytes%10#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%9#0: uint64 = 40u
        let encoded_tuple_buffer%27#0: bytes[0] = 0x
        let encoded_tuple_buffer%28#0: bytes = (concat encoded_tuple_buffer%27#0 val_as_bytes%10#0)
        let encoded_tuple_buffer%29#0: bytes = (concat encoded_tuple_buffer%28#0 key.allowedCaller#0)
        let box_prefixed_key%9#0: bytes = (concat "p" encoded_tuple_buffer%29#0)
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (box_get box_prefixed_key%9#0)
        (assert maybe_exists%9#0) // Box must have value
        let copy%8#0: bytes = maybe_value%9#0
        let tmp%25#0: bytes = (extract3 copy%8#0 37u 8u) // on error: Index access is out of bounds
        let current_tail_offset%10#0: uint64 = 45u
        let encoded_tuple_buffer%30#0: bytes[0] = 0x
        let encoded_tuple_buffer%31#0: bytes = (concat encoded_tuple_buffer%30#0 encoded_bool%1#0)
        let encoded_tuple_buffer%32#0: bytes = (concat encoded_tuple_buffer%31#0 tmp%20#0)
        let encoded_tuple_buffer%33#0: bytes = (concat encoded_tuple_buffer%32#0 tmp%21#0)
        let encoded_tuple_buffer%34#0: bytes = (concat encoded_tuple_buffer%33#0 tmp%22#0)
        let encoded_tuple_buffer%35#0: bytes = (concat encoded_tuple_buffer%34#0 tmp%23#0)
        let as_bytes%0#0: bytes[8] = (itob current_tail_offset%10#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_tuple_buffer%36#0: bytes = (concat encoded_tuple_buffer%35#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len tmp%24#0)
        let current_tail_offset%11#0: uint64 = (+ current_tail_offset%10#0 data_length%0#0)
        let encoded_tuple_buffer%37#0: bytes = (concat encoded_tuple_buffer%36#0 encoded_bool%2#0)
        let is_true%4#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%38#0: bytes = (setbit encoded_tuple_buffer%37#0 225u is_true%4#0)
        let encoded_tuple_buffer%39#0: bytes = (concat encoded_tuple_buffer%38#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%40#0: bytes = (concat encoded_tuple_buffer%39#0 tmp%25#0)
        let encoded_tuple_buffer%41#0: bytes = (concat encoded_tuple_buffer%40#0 tmp%24#0)
        let val_as_bytes%11#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%12#0: uint64 = 40u
        let encoded_tuple_buffer%42#0: bytes[0] = 0x
        let encoded_tuple_buffer%43#0: bytes = (concat encoded_tuple_buffer%42#0 val_as_bytes%11#0)
        let encoded_tuple_buffer%44#0: bytes = (concat encoded_tuple_buffer%43#0 key.allowedCaller#0)
        let box_prefixed_key%10#0: bytes = (concat "p" encoded_tuple_buffer%44#0)
        (box_del box_prefixed_key%10#0)
        (box_put box_prefixed_key%10#0 encoded_tuple_buffer%41#0)
        goto block@11
    block@11: // after_if_else_L330
        let methodIndex#3: uint64 = (+ methodIndex#1 1u)
        goto block@12
    block@12: // L306
        let methodIndex#4: uint64 = φ(methodIndex#1 <- block@8, methodIndex#3 <- block@11)
        let i#3: uint64 = (+ i#1 1u)
        goto block@4
    block@13: // after_while_L306
        goto block@14
    block@14: // L306
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@6, rekeysBack#0 <- block@13)
        (assert rekeysBack#2) // missing rekey back
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck(key.application: uint64, key.allowedCaller: bytes[32], txn: uint64, offset: uint64) -> <bool, bool, bool>:
    block@0: // L351
        let tmp%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%1#0: uint64 = (len tmp%0#0)
        let tmp%2#0: bool = (== tmp%1#0 4u)
        (assert tmp%2#0) // invalid method signature length
        let awst_tmp%0#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let reinterpret_bytes[4]%0#0: bytes[4] = awst_tmp%0#0
        let tmp%3#0: uint64 = (len awst_tmp%0#0)
        let tmp%4#0: bool = (== tmp%3#0 4u)
        (assert tmp%4#0) // Length must be 4
        let selectorArg#0: bytes[4] = reinterpret_bytes[4]%0#0
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let tmp%5#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%5#0
        let methods#0: bytes = copy%0#0
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* offset#0 20u)
        let tmp%6#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let copy%1#0: bytes = tmp%6#0
        let allowedMethod#0: bytes[20] = copy%1#0
        let tmp%7#0: bytes = (extract3 allowedMethod#0 4u 8u) // on error: Index access is out of bounds
        let tmp%8#0: uint64 = (btoi tmp%7#0)
        let hasCooldown#0: bool = (> tmp%8#0 0u)
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 225u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let useRounds#0: bool = (getbit encoded_bool%0#0 0u)
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L363
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L363
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L363
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let epochRef#0: uint64 = ternary_result%0#2
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* offset#0 20u)
        let tmp%9#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 20u) // on error: Index access is out of bounds
        let tmp%10#0: bytes = (extract3 tmp%9#0 12u 8u) // on error: Index access is out of bounds
        let tmp%11#0: uint64 = (btoi tmp%10#0)
        let tmp%12#0: uint64 = (- epochRef#0 tmp%11#0)
        let array_head_and_tail%2#0: bytes = ((extract 2 0) methods#0)
        let item_offset%2#0: uint64 = (* offset#0 20u)
        let tmp%13#0: bytes = (extract3 array_head_and_tail%2#0 item_offset%2#0 20u) // on error: Index access is out of bounds
        let tmp%14#0: bytes = (extract3 tmp%13#0 4u 8u) // on error: Index access is out of bounds
        let tmp%15#0: uint64 = (btoi tmp%14#0)
        let onCooldown#0: bool = (< tmp%12#0 tmp%15#0)
        let array_head_and_tail%3#0: bytes = ((extract 2 0) methods#0)
        let item_offset%3#0: uint64 = (* offset#0 20u)
        let tmp%16#0: bytes = (extract3 array_head_and_tail%3#0 item_offset%3#0 20u) // on error: Index access is out of bounds
        let tmp%17#0: bytes = (extract3 tmp%16#0 0u 4u) // on error: Index access is out of bounds
        let tmp%18#0: bool = (== tmp%17#0 selectorArg#0)
        goto tmp%18#0 ? block@4 : block@12
    block@4: // and_contd_L366
        goto hasCooldown#0 ? block@5 : block@6
    block@5: // or_contd_L366
        goto onCooldown#0 ? block@12 : block@6
    block@6: // if_body_L366
        goto hasCooldown#0 ? block@7 : block@11
    block@7: // if_body_L368
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L369
        let ternary_result%1#0: uint64 = (global Round)
        goto block@10
    block@9: // ternary_false_L369
        let ternary_result%1#1: uint64 = (global LatestTimestamp)
        goto block@10
    block@10: // ternary_merge_L369
        let ternary_result%1#2: uint64 = φ(ternary_result%1#0 <- block@8, ternary_result%1#1 <- block@9)
        let lastCalled#0: uint64 = ternary_result%1#2
        let val_as_bytes%2#0: bytes[8] = (itob lastCalled#0)
        let array_head_and_tail%4#0: bytes = ((extract 2 0) methods#0)
        let item_offset%4#0: uint64 = (* offset#0 20u)
        let tmp%19#0: bytes = (extract3 array_head_and_tail%4#0 item_offset%4#0 20u) // on error: Index access is out of bounds
        let assigned_value%0#0: bytes[8] = val_as_bytes%2#0
        let updated_data%0#0: bytes = (replace3 tmp%19#0 12u assigned_value%0#0)
        let assigned_value%1#0: bytes = updated_data%0#0
        let array_length%0#0: uint64 = (extract_uint16 methods#0 0u)
        let index_is_in_bounds%0#0: bool = (< offset#0 array_length%0#0)
        (assert index_is_in_bounds%0#0) // Index access is out of bounds
        let write_offset%0#0: uint64 = (* offset#0 20u)
        let write_offset%0#1: uint64 = (+ write_offset%0#0 2u)
        let updated_target%0#0: bytes = (replace3 methods#0 write_offset%0#1 assigned_value%1#0)
        let methods#4: bytes = updated_target%0#0
        let copy%2#0: bytes = methods#4
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%1#0: uint64 = (getbit maybe_value%2#0 0u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let val_as_bytes%4#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 key.allowedCaller#0)
        let box_prefixed_key%3#0: bytes = (concat "p" encoded_tuple_buffer%11#0)
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%20#0: bytes = (extract3 maybe_value%3#0 1u 1u) // on error: Index access is out of bounds
        let val_as_bytes%5#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%4#0: uint64 = 40u
        let encoded_tuple_buffer%12#0: bytes[0] = 0x
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 key.allowedCaller#0)
        let box_prefixed_key%4#0: bytes = (concat "p" encoded_tuple_buffer%14#0)
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%4#0) // Box must have value
        let tmp%21#0: bytes = (extract3 maybe_value%4#0 2u 8u) // on error: Index access is out of bounds
        let val_as_bytes%6#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%5#0: uint64 = 40u
        let encoded_tuple_buffer%15#0: bytes[0] = 0x
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 key.allowedCaller#0)
        let box_prefixed_key%5#0: bytes = (concat "p" encoded_tuple_buffer%17#0)
        let (maybe_value%5#0: bytes, maybe_exists%5#0: bool) = (box_get box_prefixed_key%5#0)
        (assert maybe_exists%5#0) // Box must have value
        let tmp%22#0: bytes = (extract3 maybe_value%5#0 10u 8u) // on error: Index access is out of bounds
        let val_as_bytes%7#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%6#0: uint64 = 40u
        let encoded_tuple_buffer%18#0: bytes[0] = 0x
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%20#0: bytes = (concat encoded_tuple_buffer%19#0 key.allowedCaller#0)
        let box_prefixed_key%6#0: bytes = (concat "p" encoded_tuple_buffer%20#0)
        let (maybe_value%6#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%6#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%23#0: bytes = (extract3 maybe_value%6#0 18u 8u) // on error: Index access is out of bounds
        let val_as_bytes%8#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%7#0: uint64 = 40u
        let encoded_tuple_buffer%21#0: bytes[0] = 0x
        let encoded_tuple_buffer%22#0: bytes = (concat encoded_tuple_buffer%21#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%23#0: bytes = (concat encoded_tuple_buffer%22#0 key.allowedCaller#0)
        let box_prefixed_key%7#0: bytes = (concat "p" encoded_tuple_buffer%23#0)
        let (maybe_value%7#0: bytes, maybe_exists%7#0: bool) = (box_get box_prefixed_key%7#0)
        (assert maybe_exists%7#0) // Box must have value
        let is_true%2#0: uint64 = (getbit maybe_value%7#0 224u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let val_as_bytes%9#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%8#0: uint64 = 40u
        let encoded_tuple_buffer%24#0: bytes[0] = 0x
        let encoded_tuple_buffer%25#0: bytes = (concat encoded_tuple_buffer%24#0 val_as_bytes%9#0)
        let encoded_tuple_buffer%26#0: bytes = (concat encoded_tuple_buffer%25#0 key.allowedCaller#0)
        let box_prefixed_key%8#0: bytes = (concat "p" encoded_tuple_buffer%26#0)
        let (maybe_value%8#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%8#0)
        (assert maybe_exists%8#0) // Box must have value
        let is_true%3#0: uint64 = (getbit maybe_value%8#0 225u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let val_as_bytes%10#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%9#0: uint64 = 40u
        let encoded_tuple_buffer%27#0: bytes[0] = 0x
        let encoded_tuple_buffer%28#0: bytes = (concat encoded_tuple_buffer%27#0 val_as_bytes%10#0)
        let encoded_tuple_buffer%29#0: bytes = (concat encoded_tuple_buffer%28#0 key.allowedCaller#0)
        let box_prefixed_key%9#0: bytes = (concat "p" encoded_tuple_buffer%29#0)
        let (maybe_value%9#0: bytes, maybe_exists%9#0: bool) = (box_get box_prefixed_key%9#0)
        (assert maybe_exists%9#0) // Box must have value
        let tmp%24#0: bytes = (extract3 maybe_value%9#0 29u 8u) // on error: Index access is out of bounds
        let val_as_bytes%11#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%10#0: uint64 = 40u
        let encoded_tuple_buffer%30#0: bytes[0] = 0x
        let encoded_tuple_buffer%31#0: bytes = (concat encoded_tuple_buffer%30#0 val_as_bytes%11#0)
        let encoded_tuple_buffer%32#0: bytes = (concat encoded_tuple_buffer%31#0 key.allowedCaller#0)
        let box_prefixed_key%10#0: bytes = (concat "p" encoded_tuple_buffer%32#0)
        let (maybe_value%10#0: bytes, maybe_exists%10#0: bool) = (box_get box_prefixed_key%10#0)
        (assert maybe_exists%10#0) // Box must have value
        let tmp%25#0: bytes = (extract3 maybe_value%10#0 37u 8u) // on error: Index access is out of bounds
        let current_tail_offset%11#0: uint64 = 45u
        let encoded_tuple_buffer%33#0: bytes[0] = 0x
        let encoded_tuple_buffer%34#0: bytes = (concat encoded_tuple_buffer%33#0 encoded_bool%1#0)
        let encoded_tuple_buffer%35#0: bytes = (concat encoded_tuple_buffer%34#0 tmp%20#0)
        let encoded_tuple_buffer%36#0: bytes = (concat encoded_tuple_buffer%35#0 tmp%21#0)
        let encoded_tuple_buffer%37#0: bytes = (concat encoded_tuple_buffer%36#0 tmp%22#0)
        let encoded_tuple_buffer%38#0: bytes = (concat encoded_tuple_buffer%37#0 tmp%23#0)
        let as_bytes%0#0: bytes[8] = (itob current_tail_offset%11#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_tuple_buffer%39#0: bytes = (concat encoded_tuple_buffer%38#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len copy%2#0)
        let current_tail_offset%12#0: uint64 = (+ current_tail_offset%11#0 data_length%0#0)
        let encoded_tuple_buffer%40#0: bytes = (concat encoded_tuple_buffer%39#0 encoded_bool%2#0)
        let is_true%4#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%41#0: bytes = (setbit encoded_tuple_buffer%40#0 225u is_true%4#0)
        let encoded_tuple_buffer%42#0: bytes = (concat encoded_tuple_buffer%41#0 tmp%24#0)
        let encoded_tuple_buffer%43#0: bytes = (concat encoded_tuple_buffer%42#0 tmp%25#0)
        let encoded_tuple_buffer%44#0: bytes = (concat encoded_tuple_buffer%43#0 copy%2#0)
        let val_as_bytes%12#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%13#0: uint64 = 40u
        let encoded_tuple_buffer%45#0: bytes[0] = 0x
        let encoded_tuple_buffer%46#0: bytes = (concat encoded_tuple_buffer%45#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%47#0: bytes = (concat encoded_tuple_buffer%46#0 key.allowedCaller#0)
        let box_prefixed_key%11#0: bytes = (concat "p" encoded_tuple_buffer%47#0)
        (box_del box_prefixed_key%11#0)
        (box_put box_prefixed_key%11#0 encoded_tuple_buffer%44#0)
        goto block@11
    block@11: // after_if_else_L368
        return 1u hasCooldown#0 onCooldown#0
    block@12: // after_if_else_L366
        return 0u 1u 1u

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.transferFunds(key.application: uint64, key.allowedCaller: bytes[32], fundsRequests: (encoded_uint64,encoded_uint64)[]) -> void:
    block@0: // L395
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L396
        let i#1: uint64 = φ(i#0 <- block@0, i#3 <- block@7)
        let tmp%0#0: uint64 = (extract_uint16 fundsRequests#0 0u)
        let tmp%1#0: bool = (< i#1 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@8
    block@2: // while_body_L396
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let item0%0#0: bool = (getbit encoded_bool%0#0 0u)
        let item1%0#0: bytes = (extract3 maybe_value%0#0 1u 1u) // on error: Index access is out of bounds
        let item2%0#0: bytes = (extract3 maybe_value%0#0 2u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 maybe_value%0#0 10u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 maybe_value%0#0 18u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let item5%0#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%1#0: uint64 = (getbit maybe_value%0#0 224u)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u is_true%1#0)
        let item6%0#0: bool = (getbit encoded_bool%1#0 0u)
        let is_true%2#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let item7%0#0: bool = (getbit encoded_bool%2#0 0u)
        let item8%0#0: bytes = (extract3 maybe_value%0#0 29u 8u) // on error: Index access is out of bounds
        let item8%1#0: uint64 = (btoi item8%0#0)
        let item9%0#0: bytes = (extract3 maybe_value%0#0 37u 8u) // on error: Index access is out of bounds
        let item9%1#0: uint64 = (btoi item9%0#0)
        let (pluginInfo.admin#0: bool, pluginInfo.delegationType#0: bytes[1], pluginInfo.spendingApp#0: uint64, pluginInfo.lastValid#0: uint64, pluginInfo.cooldown#0: uint64, pluginInfo.methods#0: bytes, pluginInfo.useAllowance#0: bool, pluginInfo.useRounds#0: bool, pluginInfo.lastCalled#0: uint64, pluginInfo.start#0: uint64) = (item0%0#0, item1%0#0, item2%1#0, item3%1#0, item4%1#0, item5%0#0, item6%0#0, item7%0#0, item8%1#0, item9%1#0)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%0#0: uint64 = (* i#1 16u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 16u) // on error: Index access is out of bounds
        let item0%1#0: bytes = (extract3 arc4_item%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%2#0: uint64 = (btoi item0%1#0)
        let item1%1#0: bytes = (extract3 arc4_item%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%2#0: uint64 = (btoi item1%1#0)
        let (allowanceKey.application#0: uint64, allowanceKey.allowedCaller#0: bytes[32], allowanceKey.asset#0: uint64) = (key.application#0, key.allowedCaller#0, item0%2#0)
        let array_head_and_tail%1#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%1#0: uint64 = (* i#1 16u)
        let arc4_item%1#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 16u) // on error: Index access is out of bounds
        let item0%3#0: bytes = (extract3 arc4_item%1#0 0u 8u) // on error: Index access is out of bounds
        let item0%4#0: uint64 = (btoi item0%3#0)
        let item1%3#0: bytes = (extract3 arc4_item%1#0 8u 8u) // on error: Index access is out of bounds
        let item1%4#0: uint64 = (btoi item1%3#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.verifyAllowance(pluginInfo.start#0, pluginInfo.useRounds#0, allowanceKey.application#0, allowanceKey.allowedCaller#0, allowanceKey.asset#0, item0%4#0, item1%4#0)
        let array_head_and_tail%2#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%2#0: uint64 = (* i#1 16u)
        let arc4_item%2#0: bytes = (extract3 array_head_and_tail%2#0 item_offset%2#0 16u) // on error: Index access is out of bounds
        let item0%5#0: bytes = (extract3 arc4_item%2#0 0u 8u) // on error: Index access is out of bounds
        let item0%6#0: uint64 = (btoi item0%5#0)
        let item1%5#0: bytes = (extract3 arc4_item%2#0 8u 8u) // on error: Index access is out of bounds
        let item1%6#0: uint64 = (btoi item1%5#0)
        let tmp%2#0: bool = (!= item0%6#0 0u)
        goto tmp%2#0 ? block@3 : block@5
    block@3: // if_body_L413
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 4u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes = maybe_value%1#0
        let inner_txn_params%0%%Sender_length#0: uint64 = 1u
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let inner_txn_params%0%%param_AssetReceiver_idx_0#0: bytes = maybe_value%2#0
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 1u
        let array_head_and_tail%3#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%3#0: uint64 = (* i#1 16u)
        let arc4_item%3#0: bytes = (extract3 array_head_and_tail%3#0 item_offset%3#0 16u) // on error: Index access is out of bounds
        let item0%7#0: bytes = (extract3 arc4_item%3#0 0u 8u) // on error: Index access is out of bounds
        let item0%8#0: uint64 = (btoi item0%7#0)
        let item1%7#0: bytes = (extract3 arc4_item%3#0 8u 8u) // on error: Index access is out of bounds
        let item1%8#0: uint64 = (btoi item1%7#0)
        let inner_txn_params%0%%param_AssetAmount_idx_0#0: uint64 = item1%8#0
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 1u
        let array_head_and_tail%4#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%4#0: uint64 = (* i#1 16u)
        let arc4_item%4#0: bytes = (extract3 array_head_and_tail%4#0 item_offset%4#0 16u) // on error: Index access is out of bounds
        let item0%9#0: bytes = (extract3 arc4_item%4#0 0u 8u) // on error: Index access is out of bounds
        let item0%10#0: uint64 = (btoi item0%9#0)
        let item1%9#0: bytes = (extract3 arc4_item%4#0 8u 8u) // on error: Index access is out of bounds
        let item1%10#0: uint64 = (btoi item1%9#0)
        let inner_txn_params%0%%param_XferAsset_idx_0#0: uint64 = item0%10#0
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 1u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field XferAsset) inner_txn_params%0%%param_XferAsset_idx_0#0)
        ((itxn_field AssetAmount) inner_txn_params%0%%param_AssetAmount_idx_0#0)
        ((itxn_field AssetReceiver) inner_txn_params%0%%param_AssetReceiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@4
    block@4: // next_txn_L414
        itxn_submit
        goto block@7
    block@5: // else_body_L423
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes = maybe_value%3#0
        let inner_txn_params%1%%Sender_length#0: uint64 = 1u
        let (maybe_value%4#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes = maybe_value%4#0
        let inner_txn_params%1%%Receiver_length#0: uint64 = 1u
        let array_head_and_tail%5#0: bytes = ((extract 2 0) fundsRequests#0)
        let item_offset%5#0: uint64 = (* i#1 16u)
        let arc4_item%5#0: bytes = (extract3 array_head_and_tail%5#0 item_offset%5#0 16u) // on error: Index access is out of bounds
        let item0%11#0: bytes = (extract3 arc4_item%5#0 0u 8u) // on error: Index access is out of bounds
        let item0%12#0: uint64 = (btoi item0%11#0)
        let item1%11#0: bytes = (extract3 arc4_item%5#0 8u 8u) // on error: Index access is out of bounds
        let item1%12#0: uint64 = (btoi item1%11#0)
        let inner_txn_params%1%%param_Amount_idx_0#0: uint64 = item1%12#0
        let inner_txn_params%1%%Amount_length#0: uint64 = 1u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%1%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@6
    block@6: // next_txn_L424
        itxn_submit
        goto block@7
    block@7: // after_if_else_L413
        let i#3: uint64 = (+ i#1 1u)
        goto block@1
    block@8: // after_while_L396
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.verifyAllowance(start: uint64, useRounds: bool, key.application: uint64, key.allowedCaller: bytes[32], key.asset: uint64, fundRequest.asset: uint64, fundRequest.amount: uint64) -> void:
    block@0: // L436
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%1#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%0#0: uint64 = 48u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#0)
        let box_prefixed_key%0#0: bytes = (concat "a" encoded_tuple_buffer%3#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Allowance does not exist
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%3#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%1#0: uint64 = 48u
        let encoded_tuple_buffer%4#0: bytes[0] = 0x
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 key.allowedCaller#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%3#0)
        let box_prefixed_key%1#0: bytes = (concat "a" encoded_tuple_buffer%7#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%0#0 0u 1u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 maybe_value%0#0 1u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let item2%0#0: bytes = (extract3 maybe_value%0#0 9u 8u) // on error: Index access is out of bounds
        let item2%1#0: uint64 = (btoi item2%0#0)
        let item3%0#0: bytes = (extract3 maybe_value%0#0 17u 8u) // on error: Index access is out of bounds
        let item3%1#0: uint64 = (btoi item3%0#0)
        let item4%0#0: bytes = (extract3 maybe_value%0#0 25u 8u) // on error: Index access is out of bounds
        let item4%1#0: uint64 = (btoi item4%0#0)
        let item5%0#0: bytes = (extract3 maybe_value%0#0 33u 8u) // on error: Index access is out of bounds
        let item5%1#0: uint64 = (btoi item5%0#0)
        let type#0: bytes[1] = item0%0#0
        let spent#0: uint64 = item3%1#0
        let allowed#0: uint64 = item2%1#0
        let last#0: uint64 = item5%1#0
        let max#0: uint64 = item1%1#0
        let interval#0: uint64 = item4%1#0
        goto useRounds#0 ? block@1 : block@2
    block@1: // ternary_true_L444
        let ternary_result%0#0: uint64 = (global Round)
        goto block@3
    block@2: // ternary_false_L444
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@3
    block@3: // ternary_merge_L444
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let newLast#0: uint64 = ternary_result%0#2
        let tmp%0#0: bool = (== type#0 0x01)
        goto tmp%0#0 ? block@4 : block@5
    block@4: // if_body_L448
        let leftover#0: uint64 = (- allowed#0 spent#0)
        let tmp%1#0: bool = (>= leftover#0 fundRequest.amount#0)
        (assert tmp%1#0) // Allowance exceeded
        let tmp%2#0: uint64 = (+ spent#0 fundRequest.amount#0)
        let val_as_bytes%4#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%5#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%2#0: uint64 = 48u
        let encoded_tuple_buffer%8#0: bytes[0] = 0x
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 key.allowedCaller#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%5#0)
        let box_prefixed_key%2#0: bytes = (concat "a" encoded_tuple_buffer%11#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let item0%1#0: bytes = (extract3 maybe_value%1#0 0u 1u) // on error: Index access is out of bounds
        let item1%2#0: bytes = (extract3 maybe_value%1#0 1u 8u) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (btoi item1%2#0)
        let item2%2#0: bytes = (extract3 maybe_value%1#0 9u 8u) // on error: Index access is out of bounds
        let item2%3#0: uint64 = (btoi item2%2#0)
        let item3%2#0: bytes = (extract3 maybe_value%1#0 17u 8u) // on error: Index access is out of bounds
        let item3%3#0: uint64 = (btoi item3%2#0)
        let item4%2#0: bytes = (extract3 maybe_value%1#0 25u 8u) // on error: Index access is out of bounds
        let item4%3#0: uint64 = (btoi item4%2#0)
        let item5%2#0: bytes = (extract3 maybe_value%1#0 33u 8u) // on error: Index access is out of bounds
        let item5%3#0: uint64 = (btoi item5%2#0)
        let val_as_bytes%6#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%7#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%3#0: uint64 = 48u
        let encoded_tuple_buffer%12#0: bytes[0] = 0x
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 key.allowedCaller#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%7#0)
        let box_prefixed_key%3#0: bytes = (concat "a" encoded_tuple_buffer%15#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let item0%2#0: bytes = (extract3 maybe_value%2#0 0u 1u) // on error: Index access is out of bounds
        let item1%4#0: bytes = (extract3 maybe_value%2#0 1u 8u) // on error: Index access is out of bounds
        let item1%5#0: uint64 = (btoi item1%4#0)
        let item2%4#0: bytes = (extract3 maybe_value%2#0 9u 8u) // on error: Index access is out of bounds
        let item2%5#0: uint64 = (btoi item2%4#0)
        let item3%4#0: bytes = (extract3 maybe_value%2#0 17u 8u) // on error: Index access is out of bounds
        let item3%5#0: uint64 = (btoi item3%4#0)
        let item4%4#0: bytes = (extract3 maybe_value%2#0 25u 8u) // on error: Index access is out of bounds
        let item4%5#0: uint64 = (btoi item4%4#0)
        let item5%4#0: bytes = (extract3 maybe_value%2#0 33u 8u) // on error: Index access is out of bounds
        let item5%5#0: uint64 = (btoi item5%4#0)
        let val_as_bytes%8#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%9#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%4#0: uint64 = 48u
        let encoded_tuple_buffer%16#0: bytes[0] = 0x
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 key.allowedCaller#0)
        let encoded_tuple_buffer%19#0: bytes = (concat encoded_tuple_buffer%18#0 val_as_bytes%9#0)
        let box_prefixed_key%4#0: bytes = (concat "a" encoded_tuple_buffer%19#0)
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%4#0) // Box must have value
        let item0%3#0: bytes = (extract3 maybe_value%3#0 0u 1u) // on error: Index access is out of bounds
        let item1%6#0: bytes = (extract3 maybe_value%3#0 1u 8u) // on error: Index access is out of bounds
        let item1%7#0: uint64 = (btoi item1%6#0)
        let item2%6#0: bytes = (extract3 maybe_value%3#0 9u 8u) // on error: Index access is out of bounds
        let item2%7#0: uint64 = (btoi item2%6#0)
        let item3%6#0: bytes = (extract3 maybe_value%3#0 17u 8u) // on error: Index access is out of bounds
        let item3%7#0: uint64 = (btoi item3%6#0)
        let item4%6#0: bytes = (extract3 maybe_value%3#0 25u 8u) // on error: Index access is out of bounds
        let item4%7#0: uint64 = (btoi item4%6#0)
        let item5%6#0: bytes = (extract3 maybe_value%3#0 33u 8u) // on error: Index access is out of bounds
        let item5%7#0: uint64 = (btoi item5%6#0)
        let val_as_bytes%10#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%11#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%5#0: uint64 = 48u
        let encoded_tuple_buffer%20#0: bytes[0] = 0x
        let encoded_tuple_buffer%21#0: bytes = (concat encoded_tuple_buffer%20#0 val_as_bytes%10#0)
        let encoded_tuple_buffer%22#0: bytes = (concat encoded_tuple_buffer%21#0 key.allowedCaller#0)
        let encoded_tuple_buffer%23#0: bytes = (concat encoded_tuple_buffer%22#0 val_as_bytes%11#0)
        let box_prefixed_key%5#0: bytes = (concat "a" encoded_tuple_buffer%23#0)
        let (maybe_value%4#0: bytes, maybe_exists%5#0: bool) = (box_get box_prefixed_key%5#0)
        (assert maybe_exists%5#0) // Box must have value
        let item0%4#0: bytes = (extract3 maybe_value%4#0 0u 1u) // on error: Index access is out of bounds
        let item1%8#0: bytes = (extract3 maybe_value%4#0 1u 8u) // on error: Index access is out of bounds
        let item1%9#0: uint64 = (btoi item1%8#0)
        let item2%8#0: bytes = (extract3 maybe_value%4#0 9u 8u) // on error: Index access is out of bounds
        let item2%9#0: uint64 = (btoi item2%8#0)
        let item3%8#0: bytes = (extract3 maybe_value%4#0 17u 8u) // on error: Index access is out of bounds
        let item3%9#0: uint64 = (btoi item3%8#0)
        let item4%8#0: bytes = (extract3 maybe_value%4#0 25u 8u) // on error: Index access is out of bounds
        let item4%9#0: uint64 = (btoi item4%8#0)
        let item5%8#0: bytes = (extract3 maybe_value%4#0 33u 8u) // on error: Index access is out of bounds
        let item5%9#0: uint64 = (btoi item5%8#0)
        let val_as_bytes%12#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%13#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%6#0: uint64 = 48u
        let encoded_tuple_buffer%24#0: bytes[0] = 0x
        let encoded_tuple_buffer%25#0: bytes = (concat encoded_tuple_buffer%24#0 val_as_bytes%12#0)
        let encoded_tuple_buffer%26#0: bytes = (concat encoded_tuple_buffer%25#0 key.allowedCaller#0)
        let encoded_tuple_buffer%27#0: bytes = (concat encoded_tuple_buffer%26#0 val_as_bytes%13#0)
        let box_prefixed_key%6#0: bytes = (concat "a" encoded_tuple_buffer%27#0)
        let (maybe_value%5#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%6#0)
        (assert maybe_exists%6#0) // Box must have value
        let item0%5#0: bytes = (extract3 maybe_value%5#0 0u 1u) // on error: Index access is out of bounds
        let item1%10#0: bytes = (extract3 maybe_value%5#0 1u 8u) // on error: Index access is out of bounds
        let item1%11#0: uint64 = (btoi item1%10#0)
        let item2%10#0: bytes = (extract3 maybe_value%5#0 9u 8u) // on error: Index access is out of bounds
        let item2%11#0: uint64 = (btoi item2%10#0)
        let item3%10#0: bytes = (extract3 maybe_value%5#0 17u 8u) // on error: Index access is out of bounds
        let item3%11#0: uint64 = (btoi item3%10#0)
        let item4%10#0: bytes = (extract3 maybe_value%5#0 25u 8u) // on error: Index access is out of bounds
        let item4%11#0: uint64 = (btoi item4%10#0)
        let item5%10#0: bytes = (extract3 maybe_value%5#0 33u 8u) // on error: Index access is out of bounds
        let item5%11#0: uint64 = (btoi item5%10#0)
        let val_as_bytes%14#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%15#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%7#0: uint64 = 48u
        let encoded_tuple_buffer%28#0: bytes[0] = 0x
        let encoded_tuple_buffer%29#0: bytes = (concat encoded_tuple_buffer%28#0 val_as_bytes%14#0)
        let encoded_tuple_buffer%30#0: bytes = (concat encoded_tuple_buffer%29#0 key.allowedCaller#0)
        let encoded_tuple_buffer%31#0: bytes = (concat encoded_tuple_buffer%30#0 val_as_bytes%15#0)
        let box_prefixed_key%7#0: bytes = (concat "a" encoded_tuple_buffer%31#0)
        let val_as_bytes%16#0: bytes[8] = (itob item1%5#0)
        let val_as_bytes%17#0: bytes[8] = (itob item2%7#0)
        let val_as_bytes%18#0: bytes[8] = (itob tmp%2#0)
        let val_as_bytes%19#0: bytes[8] = (itob item4%9#0)
        let val_as_bytes%20#0: bytes[8] = (itob item5%11#0)
        let current_tail_offset%8#0: uint64 = 41u
        let encoded_tuple_buffer%32#0: bytes[0] = 0x
        let encoded_tuple_buffer%33#0: bytes = (concat encoded_tuple_buffer%32#0 item0%1#0)
        let encoded_tuple_buffer%34#0: bytes = (concat encoded_tuple_buffer%33#0 val_as_bytes%16#0)
        let encoded_tuple_buffer%35#0: bytes = (concat encoded_tuple_buffer%34#0 val_as_bytes%17#0)
        let encoded_tuple_buffer%36#0: bytes = (concat encoded_tuple_buffer%35#0 val_as_bytes%18#0)
        let encoded_tuple_buffer%37#0: bytes = (concat encoded_tuple_buffer%36#0 val_as_bytes%19#0)
        let encoded_tuple_buffer%38#0: bytes = (concat encoded_tuple_buffer%37#0 val_as_bytes%20#0)
        (box_put box_prefixed_key%7#0 encoded_tuple_buffer%38#0)
        goto block@17
    block@5: // else_body_L457
        let tmp%3#0: bool = (== type#0 0x02)
        goto tmp%3#0 ? block@6 : block@10
    block@6: // if_body_L457
        let currentWindowStart#0: uint64 = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds#0, start#0, interval#0)
        let tmp%4#0: bool = (> currentWindowStart#0 last#0)
        goto tmp%4#0 ? block@7 : block@8
    block@7: // if_body_L460
        let tmp%5#0: bool = (>= allowed#0 fundRequest.amount#0)
        (assert tmp%5#0) // Allowance exceeded
        goto block@9
    block@8: // else_body_L462
        let leftover₁#0: uint64 = (- allowed#0 spent#0)
        let tmp%6#0: bool = (>= leftover₁#0 fundRequest.amount#0)
        (assert tmp%6#0) // Allowance exceeded
        goto block@9
    block@9: // after_if_else_L460
        let tmp%7#0: uint64 = (+ spent#0 fundRequest.amount#0)
        let val_as_bytes%21#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%22#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%9#0: uint64 = 48u
        let encoded_tuple_buffer%39#0: bytes[0] = 0x
        let encoded_tuple_buffer%40#0: bytes = (concat encoded_tuple_buffer%39#0 val_as_bytes%21#0)
        let encoded_tuple_buffer%41#0: bytes = (concat encoded_tuple_buffer%40#0 key.allowedCaller#0)
        let encoded_tuple_buffer%42#0: bytes = (concat encoded_tuple_buffer%41#0 val_as_bytes%22#0)
        let box_prefixed_key%8#0: bytes = (concat "a" encoded_tuple_buffer%42#0)
        let (maybe_value%6#0: bytes, maybe_exists%7#0: bool) = (box_get box_prefixed_key%8#0)
        (assert maybe_exists%7#0) // Box must have value
        let item0%6#0: bytes = (extract3 maybe_value%6#0 0u 1u) // on error: Index access is out of bounds
        let item1%12#0: bytes = (extract3 maybe_value%6#0 1u 8u) // on error: Index access is out of bounds
        let item1%13#0: uint64 = (btoi item1%12#0)
        let item2%12#0: bytes = (extract3 maybe_value%6#0 9u 8u) // on error: Index access is out of bounds
        let item2%13#0: uint64 = (btoi item2%12#0)
        let item3%12#0: bytes = (extract3 maybe_value%6#0 17u 8u) // on error: Index access is out of bounds
        let item3%13#0: uint64 = (btoi item3%12#0)
        let item4%12#0: bytes = (extract3 maybe_value%6#0 25u 8u) // on error: Index access is out of bounds
        let item4%13#0: uint64 = (btoi item4%12#0)
        let item5%12#0: bytes = (extract3 maybe_value%6#0 33u 8u) // on error: Index access is out of bounds
        let item5%13#0: uint64 = (btoi item5%12#0)
        let val_as_bytes%23#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%24#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%10#0: uint64 = 48u
        let encoded_tuple_buffer%43#0: bytes[0] = 0x
        let encoded_tuple_buffer%44#0: bytes = (concat encoded_tuple_buffer%43#0 val_as_bytes%23#0)
        let encoded_tuple_buffer%45#0: bytes = (concat encoded_tuple_buffer%44#0 key.allowedCaller#0)
        let encoded_tuple_buffer%46#0: bytes = (concat encoded_tuple_buffer%45#0 val_as_bytes%24#0)
        let box_prefixed_key%9#0: bytes = (concat "a" encoded_tuple_buffer%46#0)
        let (maybe_value%7#0: bytes, maybe_exists%8#0: bool) = (box_get box_prefixed_key%9#0)
        (assert maybe_exists%8#0) // Box must have value
        let item0%7#0: bytes = (extract3 maybe_value%7#0 0u 1u) // on error: Index access is out of bounds
        let item1%14#0: bytes = (extract3 maybe_value%7#0 1u 8u) // on error: Index access is out of bounds
        let item1%15#0: uint64 = (btoi item1%14#0)
        let item2%14#0: bytes = (extract3 maybe_value%7#0 9u 8u) // on error: Index access is out of bounds
        let item2%15#0: uint64 = (btoi item2%14#0)
        let item3%14#0: bytes = (extract3 maybe_value%7#0 17u 8u) // on error: Index access is out of bounds
        let item3%15#0: uint64 = (btoi item3%14#0)
        let item4%14#0: bytes = (extract3 maybe_value%7#0 25u 8u) // on error: Index access is out of bounds
        let item4%15#0: uint64 = (btoi item4%14#0)
        let item5%14#0: bytes = (extract3 maybe_value%7#0 33u 8u) // on error: Index access is out of bounds
        let item5%15#0: uint64 = (btoi item5%14#0)
        let val_as_bytes%25#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%26#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%11#0: uint64 = 48u
        let encoded_tuple_buffer%47#0: bytes[0] = 0x
        let encoded_tuple_buffer%48#0: bytes = (concat encoded_tuple_buffer%47#0 val_as_bytes%25#0)
        let encoded_tuple_buffer%49#0: bytes = (concat encoded_tuple_buffer%48#0 key.allowedCaller#0)
        let encoded_tuple_buffer%50#0: bytes = (concat encoded_tuple_buffer%49#0 val_as_bytes%26#0)
        let box_prefixed_key%10#0: bytes = (concat "a" encoded_tuple_buffer%50#0)
        let (maybe_value%8#0: bytes, maybe_exists%9#0: bool) = (box_get box_prefixed_key%10#0)
        (assert maybe_exists%9#0) // Box must have value
        let item0%8#0: bytes = (extract3 maybe_value%8#0 0u 1u) // on error: Index access is out of bounds
        let item1%16#0: bytes = (extract3 maybe_value%8#0 1u 8u) // on error: Index access is out of bounds
        let item1%17#0: uint64 = (btoi item1%16#0)
        let item2%16#0: bytes = (extract3 maybe_value%8#0 9u 8u) // on error: Index access is out of bounds
        let item2%17#0: uint64 = (btoi item2%16#0)
        let item3%16#0: bytes = (extract3 maybe_value%8#0 17u 8u) // on error: Index access is out of bounds
        let item3%17#0: uint64 = (btoi item3%16#0)
        let item4%16#0: bytes = (extract3 maybe_value%8#0 25u 8u) // on error: Index access is out of bounds
        let item4%17#0: uint64 = (btoi item4%16#0)
        let item5%16#0: bytes = (extract3 maybe_value%8#0 33u 8u) // on error: Index access is out of bounds
        let item5%17#0: uint64 = (btoi item5%16#0)
        let val_as_bytes%27#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%28#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%12#0: uint64 = 48u
        let encoded_tuple_buffer%51#0: bytes[0] = 0x
        let encoded_tuple_buffer%52#0: bytes = (concat encoded_tuple_buffer%51#0 val_as_bytes%27#0)
        let encoded_tuple_buffer%53#0: bytes = (concat encoded_tuple_buffer%52#0 key.allowedCaller#0)
        let encoded_tuple_buffer%54#0: bytes = (concat encoded_tuple_buffer%53#0 val_as_bytes%28#0)
        let box_prefixed_key%11#0: bytes = (concat "a" encoded_tuple_buffer%54#0)
        let (maybe_value%9#0: bytes, maybe_exists%10#0: bool) = (box_get box_prefixed_key%11#0)
        (assert maybe_exists%10#0) // Box must have value
        let item0%9#0: bytes = (extract3 maybe_value%9#0 0u 1u) // on error: Index access is out of bounds
        let item1%18#0: bytes = (extract3 maybe_value%9#0 1u 8u) // on error: Index access is out of bounds
        let item1%19#0: uint64 = (btoi item1%18#0)
        let item2%18#0: bytes = (extract3 maybe_value%9#0 9u 8u) // on error: Index access is out of bounds
        let item2%19#0: uint64 = (btoi item2%18#0)
        let item3%18#0: bytes = (extract3 maybe_value%9#0 17u 8u) // on error: Index access is out of bounds
        let item3%19#0: uint64 = (btoi item3%18#0)
        let item4%18#0: bytes = (extract3 maybe_value%9#0 25u 8u) // on error: Index access is out of bounds
        let item4%19#0: uint64 = (btoi item4%18#0)
        let item5%18#0: bytes = (extract3 maybe_value%9#0 33u 8u) // on error: Index access is out of bounds
        let item5%19#0: uint64 = (btoi item5%18#0)
        let val_as_bytes%29#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%30#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%13#0: uint64 = 48u
        let encoded_tuple_buffer%55#0: bytes[0] = 0x
        let encoded_tuple_buffer%56#0: bytes = (concat encoded_tuple_buffer%55#0 val_as_bytes%29#0)
        let encoded_tuple_buffer%57#0: bytes = (concat encoded_tuple_buffer%56#0 key.allowedCaller#0)
        let encoded_tuple_buffer%58#0: bytes = (concat encoded_tuple_buffer%57#0 val_as_bytes%30#0)
        let box_prefixed_key%12#0: bytes = (concat "a" encoded_tuple_buffer%58#0)
        let val_as_bytes%31#0: bytes[8] = (itob item1%15#0)
        let val_as_bytes%32#0: bytes[8] = (itob item2%17#0)
        let val_as_bytes%33#0: bytes[8] = (itob tmp%7#0)
        let val_as_bytes%34#0: bytes[8] = (itob item4%19#0)
        let val_as_bytes%35#0: bytes[8] = (itob newLast#0)
        let current_tail_offset%14#0: uint64 = 41u
        let encoded_tuple_buffer%59#0: bytes[0] = 0x
        let encoded_tuple_buffer%60#0: bytes = (concat encoded_tuple_buffer%59#0 item0%6#0)
        let encoded_tuple_buffer%61#0: bytes = (concat encoded_tuple_buffer%60#0 val_as_bytes%31#0)
        let encoded_tuple_buffer%62#0: bytes = (concat encoded_tuple_buffer%61#0 val_as_bytes%32#0)
        let encoded_tuple_buffer%63#0: bytes = (concat encoded_tuple_buffer%62#0 val_as_bytes%33#0)
        let encoded_tuple_buffer%64#0: bytes = (concat encoded_tuple_buffer%63#0 val_as_bytes%34#0)
        let encoded_tuple_buffer%65#0: bytes = (concat encoded_tuple_buffer%64#0 val_as_bytes%35#0)
        (box_put box_prefixed_key%12#0 encoded_tuple_buffer%65#0)
        goto block@16
    block@10: // else_body_L474
        let tmp%8#0: bool = (== type#0 0x03)
        goto tmp%8#0 ? block@11 : block@15
    block@11: // if_body_L474
        goto useRounds#0 ? block@12 : block@13
    block@12: // ternary_true_L475
        let ternary_result%1#0: uint64 = (global Round)
        goto block@14
    block@13: // ternary_false_L475
        let ternary_result%1#1: uint64 = (global LatestTimestamp)
        goto block@14
    block@14: // ternary_merge_L475
        let ternary_result%1#2: uint64 = φ(ternary_result%1#0 <- block@12, ternary_result%1#1 <- block@13)
        let epochRef#0: uint64 = ternary_result%1#2
        let amount#0: uint64 = fundRequest.amount#0
        let accrualRate#0: uint64 = allowed#0
        let lastLeftover#0: uint64 = spent#0
        let passed#0: uint64 = (- epochRef#0 last#0)
        let tmp%9#0: uint64 = (/ passed#0 interval#0)
        let tmp%10#0: uint64 = (* tmp%9#0 accrualRate#0)
        let accrued#0: uint64 = (+ lastLeftover#0 tmp%10#0)
        let tmp%11#0: bool = (> accrued#0 max#0)
        let select%0#0: uint64 = (select accrued#0 max#0 tmp%11#0)
        let available#0: uint64 = select%0#0
        let tmp%12#0: bool = (>= available#0 amount#0)
        (assert tmp%12#0) // Allowance exceeded
        let tmp%13#0: uint64 = (- available#0 amount#0)
        let val_as_bytes%36#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%37#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%15#0: uint64 = 48u
        let encoded_tuple_buffer%66#0: bytes[0] = 0x
        let encoded_tuple_buffer%67#0: bytes = (concat encoded_tuple_buffer%66#0 val_as_bytes%36#0)
        let encoded_tuple_buffer%68#0: bytes = (concat encoded_tuple_buffer%67#0 key.allowedCaller#0)
        let encoded_tuple_buffer%69#0: bytes = (concat encoded_tuple_buffer%68#0 val_as_bytes%37#0)
        let box_prefixed_key%13#0: bytes = (concat "a" encoded_tuple_buffer%69#0)
        let (maybe_value%10#0: bytes, maybe_exists%11#0: bool) = (box_get box_prefixed_key%13#0)
        (assert maybe_exists%11#0) // Box must have value
        let item0%10#0: bytes = (extract3 maybe_value%10#0 0u 1u) // on error: Index access is out of bounds
        let item1%20#0: bytes = (extract3 maybe_value%10#0 1u 8u) // on error: Index access is out of bounds
        let item1%21#0: uint64 = (btoi item1%20#0)
        let item2%20#0: bytes = (extract3 maybe_value%10#0 9u 8u) // on error: Index access is out of bounds
        let item2%21#0: uint64 = (btoi item2%20#0)
        let item3%20#0: bytes = (extract3 maybe_value%10#0 17u 8u) // on error: Index access is out of bounds
        let item3%21#0: uint64 = (btoi item3%20#0)
        let item4%20#0: bytes = (extract3 maybe_value%10#0 25u 8u) // on error: Index access is out of bounds
        let item4%21#0: uint64 = (btoi item4%20#0)
        let item5%20#0: bytes = (extract3 maybe_value%10#0 33u 8u) // on error: Index access is out of bounds
        let item5%21#0: uint64 = (btoi item5%20#0)
        let val_as_bytes%38#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%39#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%16#0: uint64 = 48u
        let encoded_tuple_buffer%70#0: bytes[0] = 0x
        let encoded_tuple_buffer%71#0: bytes = (concat encoded_tuple_buffer%70#0 val_as_bytes%38#0)
        let encoded_tuple_buffer%72#0: bytes = (concat encoded_tuple_buffer%71#0 key.allowedCaller#0)
        let encoded_tuple_buffer%73#0: bytes = (concat encoded_tuple_buffer%72#0 val_as_bytes%39#0)
        let box_prefixed_key%14#0: bytes = (concat "a" encoded_tuple_buffer%73#0)
        let (maybe_value%11#0: bytes, maybe_exists%12#0: bool) = (box_get box_prefixed_key%14#0)
        (assert maybe_exists%12#0) // Box must have value
        let item0%11#0: bytes = (extract3 maybe_value%11#0 0u 1u) // on error: Index access is out of bounds
        let item1%22#0: bytes = (extract3 maybe_value%11#0 1u 8u) // on error: Index access is out of bounds
        let item1%23#0: uint64 = (btoi item1%22#0)
        let item2%22#0: bytes = (extract3 maybe_value%11#0 9u 8u) // on error: Index access is out of bounds
        let item2%23#0: uint64 = (btoi item2%22#0)
        let item3%22#0: bytes = (extract3 maybe_value%11#0 17u 8u) // on error: Index access is out of bounds
        let item3%23#0: uint64 = (btoi item3%22#0)
        let item4%22#0: bytes = (extract3 maybe_value%11#0 25u 8u) // on error: Index access is out of bounds
        let item4%23#0: uint64 = (btoi item4%22#0)
        let item5%22#0: bytes = (extract3 maybe_value%11#0 33u 8u) // on error: Index access is out of bounds
        let item5%23#0: uint64 = (btoi item5%22#0)
        let val_as_bytes%40#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%41#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%17#0: uint64 = 48u
        let encoded_tuple_buffer%74#0: bytes[0] = 0x
        let encoded_tuple_buffer%75#0: bytes = (concat encoded_tuple_buffer%74#0 val_as_bytes%40#0)
        let encoded_tuple_buffer%76#0: bytes = (concat encoded_tuple_buffer%75#0 key.allowedCaller#0)
        let encoded_tuple_buffer%77#0: bytes = (concat encoded_tuple_buffer%76#0 val_as_bytes%41#0)
        let box_prefixed_key%15#0: bytes = (concat "a" encoded_tuple_buffer%77#0)
        let (maybe_value%12#0: bytes, maybe_exists%13#0: bool) = (box_get box_prefixed_key%15#0)
        (assert maybe_exists%13#0) // Box must have value
        let item0%12#0: bytes = (extract3 maybe_value%12#0 0u 1u) // on error: Index access is out of bounds
        let item1%24#0: bytes = (extract3 maybe_value%12#0 1u 8u) // on error: Index access is out of bounds
        let item1%25#0: uint64 = (btoi item1%24#0)
        let item2%24#0: bytes = (extract3 maybe_value%12#0 9u 8u) // on error: Index access is out of bounds
        let item2%25#0: uint64 = (btoi item2%24#0)
        let item3%24#0: bytes = (extract3 maybe_value%12#0 17u 8u) // on error: Index access is out of bounds
        let item3%25#0: uint64 = (btoi item3%24#0)
        let item4%24#0: bytes = (extract3 maybe_value%12#0 25u 8u) // on error: Index access is out of bounds
        let item4%25#0: uint64 = (btoi item4%24#0)
        let item5%24#0: bytes = (extract3 maybe_value%12#0 33u 8u) // on error: Index access is out of bounds
        let item5%25#0: uint64 = (btoi item5%24#0)
        let val_as_bytes%42#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%43#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%18#0: uint64 = 48u
        let encoded_tuple_buffer%78#0: bytes[0] = 0x
        let encoded_tuple_buffer%79#0: bytes = (concat encoded_tuple_buffer%78#0 val_as_bytes%42#0)
        let encoded_tuple_buffer%80#0: bytes = (concat encoded_tuple_buffer%79#0 key.allowedCaller#0)
        let encoded_tuple_buffer%81#0: bytes = (concat encoded_tuple_buffer%80#0 val_as_bytes%43#0)
        let box_prefixed_key%16#0: bytes = (concat "a" encoded_tuple_buffer%81#0)
        let (maybe_value%13#0: bytes, maybe_exists%14#0: bool) = (box_get box_prefixed_key%16#0)
        (assert maybe_exists%14#0) // Box must have value
        let item0%13#0: bytes = (extract3 maybe_value%13#0 0u 1u) // on error: Index access is out of bounds
        let item1%26#0: bytes = (extract3 maybe_value%13#0 1u 8u) // on error: Index access is out of bounds
        let item1%27#0: uint64 = (btoi item1%26#0)
        let item2%26#0: bytes = (extract3 maybe_value%13#0 9u 8u) // on error: Index access is out of bounds
        let item2%27#0: uint64 = (btoi item2%26#0)
        let item3%26#0: bytes = (extract3 maybe_value%13#0 17u 8u) // on error: Index access is out of bounds
        let item3%27#0: uint64 = (btoi item3%26#0)
        let item4%26#0: bytes = (extract3 maybe_value%13#0 25u 8u) // on error: Index access is out of bounds
        let item4%27#0: uint64 = (btoi item4%26#0)
        let item5%26#0: bytes = (extract3 maybe_value%13#0 33u 8u) // on error: Index access is out of bounds
        let item5%27#0: uint64 = (btoi item5%26#0)
        let val_as_bytes%44#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%45#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%19#0: uint64 = 48u
        let encoded_tuple_buffer%82#0: bytes[0] = 0x
        let encoded_tuple_buffer%83#0: bytes = (concat encoded_tuple_buffer%82#0 val_as_bytes%44#0)
        let encoded_tuple_buffer%84#0: bytes = (concat encoded_tuple_buffer%83#0 key.allowedCaller#0)
        let encoded_tuple_buffer%85#0: bytes = (concat encoded_tuple_buffer%84#0 val_as_bytes%45#0)
        let box_prefixed_key%17#0: bytes = (concat "a" encoded_tuple_buffer%85#0)
        let val_as_bytes%46#0: bytes[8] = (itob item1%23#0)
        let val_as_bytes%47#0: bytes[8] = (itob item2%25#0)
        let val_as_bytes%48#0: bytes[8] = (itob tmp%13#0)
        let val_as_bytes%49#0: bytes[8] = (itob item4%27#0)
        let val_as_bytes%50#0: bytes[8] = (itob newLast#0)
        let current_tail_offset%20#0: uint64 = 41u
        let encoded_tuple_buffer%86#0: bytes[0] = 0x
        let encoded_tuple_buffer%87#0: bytes = (concat encoded_tuple_buffer%86#0 item0%10#0)
        let encoded_tuple_buffer%88#0: bytes = (concat encoded_tuple_buffer%87#0 val_as_bytes%46#0)
        let encoded_tuple_buffer%89#0: bytes = (concat encoded_tuple_buffer%88#0 val_as_bytes%47#0)
        let encoded_tuple_buffer%90#0: bytes = (concat encoded_tuple_buffer%89#0 val_as_bytes%48#0)
        let encoded_tuple_buffer%91#0: bytes = (concat encoded_tuple_buffer%90#0 val_as_bytes%49#0)
        let encoded_tuple_buffer%92#0: bytes = (concat encoded_tuple_buffer%91#0 val_as_bytes%50#0)
        (box_put box_prefixed_key%17#0 encoded_tuple_buffer%92#0)
        goto block@15
    block@15: // after_if_else_L474
        goto block@16
    block@16: // after_if_else_L457
        goto block@17
    block@17: // after_if_else_L448
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds: bool, start: uint64, interval: uint64) -> uint64:
    block@0: // L496
        goto useRounds#0 ? block@1 : block@2
    block@1: // if_body_L497
        let tmp%0#0: uint64 = (global Round)
        let tmp%1#0: uint64 = (global Round)
        let tmp%2#0: uint64 = (- tmp%1#0 start#0)
        let tmp%3#0: uint64 = (% tmp%2#0 interval#0)
        let tmp%4#0: uint64 = (- tmp%0#0 tmp%3#0)
        return tmp%4#0
    block@2: // after_if_else_L497
        let tmp%5#0: uint64 = (global LatestTimestamp)
        let tmp%6#0: uint64 = (global LatestTimestamp)
        let tmp%7#0: uint64 = (- tmp%6#0 start#0)
        let tmp%8#0: uint64 = (% tmp%7#0 interval#0)
        let tmp%9#0: uint64 = (- tmp%5#0 tmp%8#0)
        return tmp%9#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getAuthAddr() -> bytes[32]:
    block@0: // L507
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%0#0: bool = (== maybe_value%0#0 maybe_value%1#0)
        goto tmp%0#0 ? block@1 : block@5
    block@1: // ternary_true_L508
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%1#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%2#0: bool = (== maybe_value%2#0 tmp%1#0)
        goto tmp%2#0 ? block@2 : block@3
    block@2: // ternary_true_L509
        let ternary_result%1#0: bytes[32] = (global ZeroAddress)
        goto block@4
    block@3: // ternary_false_L509
        let ternary_result%1#1: bytes[32] = (global CurrentApplicationAddress)
        goto block@4
    block@4: // ternary_merge_L509
        let ternary_result%1#2: bytes[32] = φ(ternary_result%1#0 <- block@2, ternary_result%1#1 <- block@3)
        let ternary_result%0#0: bytes[32] = ternary_result%1#2
        goto block@6
    block@5: // ternary_false_L508
        let ternary_result%0#1: bytes[32] = (global ZeroAddress)
        goto block@6
    block@6: // ternary_merge_L508
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@4, ternary_result%0#1 <- block@5)
        return ternary_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(version: bytes, controlledAddress: bytes[32], admin: bytes[32], spendingAccountFactoryApp: uint64, revocationApp: uint64, nickname: bytes) -> void:
    block@0: // L527
        let tmp%0#0: uint64 = (global CallerApplicationID)
        let tmp%1#0: bool = (!= tmp%0#0 0u)
        (assert tmp%1#0) // This contract must be deployed from a factory
        let tmp%2#0: bool = (!= admin#0 controlledAddress#0)
        (assert tmp%2#0)
        (app_global_put "version" version#0)
        (app_global_put "admin" admin#0)
        let tmp%3#0: bytes[32] = (global ZeroAddress)
        let tmp%4#0: bool = (== controlledAddress#0 tmp%3#0)
        goto tmp%4#0 ? block@1 : block@2
    block@1: // ternary_true_L542
        let ternary_result%0#0: bytes[32] = (global CurrentApplicationAddress)
        goto block@3
    block@2: // ternary_false_L542
        let ternary_result%0#1: bytes[32] = controlledAddress#0
        goto block@3
    block@3: // ternary_merge_L542
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        (app_global_put "controlled_address" ternary_result%0#2)
        (app_global_put "spending_account_factory_app" spendingAccountFactoryApp#0)
        let materialized_values%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" materialized_values%0#0)
        (app_global_put "revocation_app" revocationApp#0)
        (app_global_put "nickname" nickname#0)
        let materialized_values%1#0: uint64 = (global CallerApplicationID)
        (app_global_put "factory_app" materialized_values%1#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(version: bytes) -> void:
    block@0: // L553
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can update the application
        (app_global_put "version" version#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(newRevocationApp: uint64) -> void:
    block@0: // L566
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the revocation app
        (app_global_put "revocation_app" newRevocationApp#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(nickname: bytes) -> void:
    block@0: // L576
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        (app_global_put "nickname" nickname#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(avatar: uint64) -> void:
    block@0: // L586
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) array_data%0#0)
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(avatar#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let amount#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(concat_result%0#0)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) amount#0)
        let item_offset%0#0: uint64 = (* 0u 8u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let tmp%1#0: uint64 = (btoi arc4_item%0#0)
        let tmp%2#0: bool = (> tmp%1#0 0u)
        (assert tmp%2#0) // The account does not hold the asset
        (app_global_put "avatar" avatar#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(banner: uint64) -> void:
    block@0: // L598
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) array_data%0#0)
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(banner#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let amount#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(concat_result%0#0)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) amount#0)
        let item_offset%0#0: uint64 = (* 0u 8u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let tmp%1#0: uint64 = (btoi arc4_item%0#0)
        let tmp%2#0: bool = (> tmp%1#0 0u)
        (assert tmp%2#0) // The account does not hold the asset
        (app_global_put "banner" banner#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(bio: bytes) -> void:
    block@0: // L610
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        (app_global_put "bio" bio#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes[32]) -> void:
    block@0: // L620
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the admin account
        (app_global_put "admin" newAdmin#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: bytes[32], newAdmin: bytes[32]) -> void:
    block@0: // L635
        let tmp%0#0: bytes[32] = (txn Sender)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // sender must be admin plugin
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%1#0: bytes[32], check%1#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%1#0) // account funded
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%2#0) // application exists
        let tmp%2#0: bool = (== value%1#0 value%2#0)
        (assert tmp%2#0) // This plugin is not in control of the account
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (plugin#0, allowedCaller#0)
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%1#0 ? block@1 : block@3
    block@1: // and_contd_L645
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%3#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L645
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L645
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L645
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // This plugin does not have admin privileges
        (app_global_put "admin" newAdmin#0)
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%4#0: bytes = (extract3 maybe_value%2#0 1u 1u) // on error: Index access is out of bounds
        let tmp%5#0: bool = (== tmp%4#0 0x01)
        goto tmp%5#0 ? block@5 : block@6
    block@5: // if_body_L650
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@6
    block@6: // after_if_else_L650
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
    block@0: // L659
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%0#0) // account funded
        let tmp%0#0: bytes[32] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getAuthAddr()
        let tmp%1#0: bool = (== value%0#0 tmp%0#0)
        (assert tmp%1#0)
        let materialized_values%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes[32], flash: bool) -> void:
    block@0: // L670
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // admin only
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes = maybe_value%0#0
        let inner_txn_params%0%%Sender_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = address#0
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%0%%param_RekeyTo_idx_0#0: bytes[32] = address#0
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Note_idx_0#0: bytes[27] = "rekeying abstracted account"
        let inner_txn_params%0%%Note_length#0: uint64 = 1u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Note) inner_txn_params%0%%param_Note_idx_0#0)
        ((itxn_field RekeyTo) inner_txn_params%0%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@1
    block@1: // next_txn_L673
        itxn_submit
        goto flash#0 ? block@2 : block@3
    block@2: // if_body_L683
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertRekeysBack()
        goto block@3
    block@3: // after_if_else_L683
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: bool, address: bytes[32], method: bytes[4]) -> bool:
    block@0: // L696
        goto global#0 ? block@1 : block@2
    block@1: // if_body_L703
        let tmp%0#0: bytes[32] = (global ZeroAddress)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, tmp%0#0, method#0)
        goto block@2
    block@2: // after_if_else_L703
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, address#0, method#0)
        return tmp%1#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: bool, methodOffsets: encoded_uint64[], fundsRequest: (encoded_uint64,encoded_uint64)[]) -> void:
    block@0: // L718
        let pluginApp#0: uint64 = plugin#0
        goto global#0 ? block@1 : block@2
    block@1: // ternary_true_L728
        let ternary_result%0#0: bytes[32] = (global ZeroAddress)
        goto block@3
    block@2: // ternary_false_L728
        let ternary_result%0#1: bytes[32] = (txn Sender)
        goto block@3
    block@3: // ternary_merge_L728
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (plugin#0, ternary_result%0#2)
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertValidGroup(key.application#0, key.allowedCaller#0, methodOffsets#0)
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let tmp%0#0: bytes = (extract3 maybe_value%0#0 2u 8u) // on error: Index access is out of bounds
        let tmp%1#0: uint64 = (btoi tmp%0#0)
        let tmp%2#0: bool = (!= tmp%1#0 0u)
        goto tmp%2#0 ? block@4 : block@6
    block@4: // if_body_L737
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let tmp%3#0: bytes = (extract3 maybe_value%1#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%3#0)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) spendingApp#0)
        (assert check%0#0) // application exists
        (app_global_put "spending_address" value%0#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.transferFunds(key.application#0, key.allowedCaller#0, fundsRequest#0)
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = spendingApp#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%1#0) // application exists
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "rekey(address)void"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = value%1#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@5
    block@5: // next_txn_L742
        itxn_submit
        goto block@8
    block@6: // else_body_L750
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        (app_global_put "spending_address" maybe_value%2#0)
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes = maybe_value%3#0
        let inner_txn_params%1%%Sender_length#0: uint64 = 1u
        let (maybe_value%4#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%5#0) // check GlobalState exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes = maybe_value%4#0
        let inner_txn_params%1%%Receiver_length#0: uint64 = 1u
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) pluginApp#0)
        (assert check%2#0) // application exists
        let inner_txn_params%1%%param_RekeyTo_idx_0#0: bytes[32] = value%2#0
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 1u
        let inner_txn_params%1%%param_Note_idx_0#0: bytes[22] = "rekeying to plugin app"
        let inner_txn_params%1%%Note_length#0: uint64 = 1u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Note) inner_txn_params%1%%param_Note_idx_0#0)
        ((itxn_field RekeyTo) inner_txn_params%1%%param_RekeyTo_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@7
    block@7: // next_txn_L753
        itxn_submit
        goto block@8
    block@8: // after_if_else_L737
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 key.allowedCaller#0)
        let box_prefixed_key%3#0: bytes = (concat "p" encoded_tuple_buffer%11#0)
        let (maybe_value%5#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%4#0: bytes = (extract3 maybe_value%5#0 1u 1u) // on error: Index access is out of bounds
        let tmp%5#0: bool = (== tmp%4#0 0x01)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L764
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@10
    block@10: // after_if_else_L764
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: bool, methodOffsets: encoded_uint64[], fundsRequest: (encoded_uint64,encoded_uint64)[]) -> void:
    block@0: // L779
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 maybe_value%0#0 8u 32u) // on error: Index access is out of bounds
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(item0%1#0, global#0, methodOffsets#0, fundsRequest#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: (bytes[4],encoded_uint64)[], useAllowance: bool, useRounds: bool) -> void:
    block@0: // L801
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // admin only
        let tmp%1#0: bool = (== delegationType#0 0x01)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L814
        let tmp%2#0: bytes[32] = (global ZeroAddress)
        let tmp%3#0: bool = (== allowedCaller#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L814
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L814
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L814
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        let badDelegationCombo#0: bool = and_result%0#2
        let tmp%4#0: bool = (! badDelegationCombo#0)
        (assert tmp%4#0) // delegation type must not be self for global plugins
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (app#0, allowedCaller#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L821
        let i#1: uint64 = φ(i#0 <- block@4, i#2 <- block@6)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@4, methodInfos#2 <- block@6)
        let tmp%5#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@6 : block@7
    block@6: // while_body_L821
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let item0%0#0: bytes = (extract3 arc4_item%0#0 0u 4u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 arc4_item%0#0 4u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let arc4_item%1#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let item0%1#0: bytes = (extract3 arc4_item%1#0 0u 4u) // on error: Index access is out of bounds
        let item1%2#0: bytes = (extract3 arc4_item%1#0 4u 8u) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (btoi item1%2#0)
        let val_as_bytes%0#0: bytes[8] = (itob item1%3#0)
        let current_tail_offset%0#0: uint64 = 20u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 item0%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 0x0000000000000000)
        let encoded%0#0: bytes[20][] = encode<bytes[20]>(encoded_tuple_buffer%3#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@5
    block@7: // after_while_L821
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L831
        let ternary_result%0#0: uint64 = (global Round)
        goto block@10
    block@9: // ternary_false_L831
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@10
    block@10: // ternary_merge_L831
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@8, ternary_result%0#1 <- block@9)
        let epochRef#0: uint64 = ternary_result%0#2
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (!= maybe_value%0#0 tmp%7#0)
        goto tmp%8#0 ? block@11 : block@13
    block@11: // if_body_L833
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes = maybe_value%1#0
        let inner_txn_params%0%%Sender_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let tmp%9#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%10#0: uint64 = (* 13u tmp%9#0)
        let tmp%11#0: uint64 = (* 400u tmp%10#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%11#0)
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@12
    block@12: // next_txn_L834
        itxn_submit
        goto block@13
    block@13: // after_if_else_L833
        let spendingApp#0: uint64 = 0u
        goto useAllowance#0 ? block@14 : block@17
    block@14: // if_body_L845
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let inner_txn_params%1%%param_Amount_idx_0#0: uint64 = 269500u
        let inner_txn_params%1%%Amount_length#0: uint64 = 1u
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%2#0)
        (assert check%0#0) // application exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        let inner_txn_params%1%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Amount) inner_txn_params%1%%param_Amount_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@15
    block@15: // next_txn_L853
        itxn_next
        let inner_txn_params%2#0: itxn_field_set = itxn_field_set(2)
        let inner_txn_params%2%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%2%%Fee_length#0: uint64 = 1u
        let inner_txn_params%2%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%2%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%2%%param_Sender_idx_0#0: bytes = maybe_value%3#0
        let inner_txn_params%2%%Sender_length#0: uint64 = 1u
        let (maybe_value%4#0: uint64, maybe_exists%4#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%2%%param_ApplicationID_idx_0#0: uint64 = maybe_value%4#0
        let inner_txn_params%2%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%1#0: bytes[8] = (itob app#0)
        let inner_txn_params%2%%param_ApplicationArgs_idx_0#0: bytes[4] = method "mint(pay,uint64)uint64"
        let inner_txn_params%2%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%1#0
        let inner_txn_params%2%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%2%%Note_length#0: uint64 = 0u
        let inner_txn_params%2%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%2%%Amount_length#0: uint64 = 0u
        let inner_txn_params%2%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%2%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%2%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%2%%Type_length#0: uint64 = 0u
        let inner_txn_params%2%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%2%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%2%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%2%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%2%%Assets_length#0: uint64 = 0u
        let inner_txn_params%2%%Applications_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%2%%param_ApplicationID_idx_0#0)
        ((itxn_field Sender) inner_txn_params%2%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%2%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%2%%param_Fee_idx_0#0)
        goto block@16
    block@16: // next_txn_L847
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(1)].LastLog
        let tmp%12#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%13#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%14#0: bool = (== tmp%13#0 0x151f7c75)
        (assert tmp%14#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%12#0
        let tmp%15#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let spendingApp#1: uint64 = tmp%15#0
        goto block@17
    block@17: // after_if_else_L845
        let spendingApp#2: uint64 = φ(spendingApp#0 <- block@13, spendingApp#1 <- block@16)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%2#0: bytes[8] = (itob spendingApp#2)
        let val_as_bytes%3#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%4#0: bytes[8] = (itob cooldown#0)
        let copy%0#0: bytes = methodInfos#1
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%5#0: bytes[8] = (itob epochRef#0)
        let current_tail_offset%1#0: uint64 = 45u
        let encoded_tuple_buffer%4#0: bytes[0] = 0x
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 encoded_bool%0#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 delegationType#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%4#0)
        let as_bytes%1#0: bytes[8] = (itob current_tail_offset%1#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len copy%0#0)
        let current_tail_offset%2#0: uint64 = (+ current_tail_offset%1#0 data_length%0#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%12#0: bytes = (setbit encoded_tuple_buffer%11#0 225u is_true%0#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 0x0000000000000000)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 copy%0#0)
        let val_as_bytes%6#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%16#0: bytes[0] = 0x
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%18#0)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%15#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(caller: bytes[32], domain: bytes) -> void:
    block@0: // L889
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can add a plugin
        let box_prefixed_key%0#0: bytes = (concat "d" caller#0)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 domain#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(app: uint64, allowedCaller: bytes[32]) -> void:
    block@0: // L902
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L903
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L903
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L903
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L903
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove plugins
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (app#0, allowedCaller#0)
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let tmp%2#0: bytes = (extract3 maybe_value%0#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%2#0)
        let val_as_bytes%2#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%1#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%1#0)
        let tmp%3#0: bytes = (substring3 maybe_value%1#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%3#0
        let methods#0: bytes = copy%0#0
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 key.allowedCaller#0)
        let box_prefixed_key%3#0: bytes = (concat "p" encoded_tuple_buffer%11#0)
        (box_del box_prefixed_key%3#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (!= maybe_value%2#0 tmp%4#0)
        goto tmp%5#0 ? block@5 : block@7
    block@5: // if_body_L913
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes = maybe_value%3#0
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: uint64 = (* 13u tmp%6#0)
        let tmp%8#0: uint64 = (* 400u tmp%7#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%8#0)
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@6
    block@6: // next_txn_L914
        itxn_submit
        goto block@7
    block@7: // after_if_else_L913
        let tmp%9#0: bool = (!= spendingApp#0 0u)
        goto tmp%9#0 ? block@8 : block@10
    block@8: // if_body_L923
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%4#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%5#0) // check GlobalState exists
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = maybe_value%4#0
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%4#0: bytes[8] = (itob spendingApp#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_0#0: bytes[4] = method "delete(uint64)void"
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%4#0
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@9
    block@9: // next_txn_L924
        itxn_submit
        goto block@10
    block@10: // after_if_else_L923
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: (bytes[4],encoded_uint64)[], useAllowance: bool, useRounds: bool) -> void:
    block@0: // L952
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        let tmp%2#0: bool = (! maybe_exists%1#0)
        (assert tmp%2#0)
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (app#0, allowedCaller#0)
        let box_prefixed_key%1#0: bytes = (concat "n" name#0)
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 key.allowedCaller#0)
        (box_put box_prefixed_key%1#0 encoded_tuple_buffer%2#0)
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let methodInfos#0: bytes = array_data%0#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L971
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@2)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@0, methodInfos#2 <- block@2)
        let tmp%3#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%4#0: bool = (< i#1 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // while_body_L971
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let item0%0#0: bytes = (extract3 arc4_item%0#0 0u 4u) // on error: Index access is out of bounds
        let item1%0#0: bytes = (extract3 arc4_item%0#0 4u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let array_head_and_tail%1#0: bytes = ((extract 2 0) methods#0)
        let item_offset%1#0: uint64 = (* i#1 12u)
        let arc4_item%1#0: bytes = (extract3 array_head_and_tail%1#0 item_offset%1#0 12u) // on error: Index access is out of bounds
        let item0%1#0: bytes = (extract3 arc4_item%1#0 0u 4u) // on error: Index access is out of bounds
        let item1%2#0: bytes = (extract3 arc4_item%1#0 4u 8u) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (btoi item1%2#0)
        let val_as_bytes%1#0: bytes[8] = (itob item1%3#0)
        let current_tail_offset%1#0: uint64 = 20u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 item0%0#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let encoded%0#0: bytes[20][] = encode<bytes[20]>(encoded_tuple_buffer%6#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let methodInfos#2: bytes = concat_result%0#0
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@3: // after_while_L971
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%5#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%6#0: bool = (!= maybe_value%1#0 tmp%5#0)
        goto tmp%6#0 ? block@4 : block@6
    block@4: // if_body_L981
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes = maybe_value%2#0
        let inner_txn_params%0%%Sender_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let tmp%7#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%8#0: uint64 = (* 13u tmp%7#0)
        let tmp%9#0: uint64 = (len name#0)
        let tmp%10#0: uint64 = (+ tmp%8#0 tmp%9#0)
        let tmp%11#0: uint64 = (* 400u tmp%10#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%11#0)
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@5
    block@5: // next_txn_L982
        itxn_submit
        goto block@6
    block@6: // after_if_else_L981
        let spendingApp#0: uint64 = 0u
        goto useAllowance#0 ? block@7 : block@10
    block@7: // if_body_L993
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%1%%param_Sender_idx_0#0: bytes = maybe_value%3#0
        let inner_txn_params%1%%Sender_length#0: uint64 = 1u
        let inner_txn_params%1%%param_Amount_idx_0#0: uint64 = 12500u
        let inner_txn_params%1%%Amount_length#0: uint64 = 1u
        let (maybe_value%4#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%4#0)
        (assert check%0#0) // application exists
        let inner_txn_params%1%%param_Receiver_idx_0#0: bytes[32] = value%0#0
        let inner_txn_params%1%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Receiver) inner_txn_params%1%%param_Receiver_idx_0#0)
        ((itxn_field Amount) inner_txn_params%1%%param_Amount_idx_0#0)
        ((itxn_field Sender) inner_txn_params%1%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@8
    block@8: // next_txn_L1000
        itxn_next
        let inner_txn_params%2#0: itxn_field_set = itxn_field_set(2)
        let inner_txn_params%2%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%2%%Fee_length#0: uint64 = 1u
        let inner_txn_params%2%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%2%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%5#0: uint64, maybe_exists%6#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%6#0) // check GlobalState exists
        let inner_txn_params%2%%param_ApplicationID_idx_0#0: uint64 = maybe_value%5#0
        let inner_txn_params%2%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%2#0: bytes[8] = (itob 0u)
        let inner_txn_params%2%%param_ApplicationArgs_idx_0#0: bytes[4] = method "mint(pay,uint64)uint64"
        let inner_txn_params%2%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%2#0
        let inner_txn_params%2%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%2%%Sender_length#0: uint64 = 0u
        let inner_txn_params%2%%Note_length#0: uint64 = 0u
        let inner_txn_params%2%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%2%%Amount_length#0: uint64 = 0u
        let inner_txn_params%2%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%2%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%2%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%2%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%2%%Type_length#0: uint64 = 0u
        let inner_txn_params%2%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%2%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%2%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%2%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%2%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%2%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%2%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%2%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%2%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%2%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%2%%Assets_length#0: uint64 = 0u
        let inner_txn_params%2%%Applications_length#0: uint64 = 0u
        let inner_txn_params%2%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%2%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%2%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%2%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%2%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%2%%param_Fee_idx_0#0)
        goto block@9
    block@9: // next_txn_L995
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(1)].LastLog
        let tmp%12#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%13#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%14#0: bool = (== tmp%13#0 0x151f7c75)
        (assert tmp%14#0) // Bytes has valid prefix
        let reinterpret_bytes[8]%0#0: bytes[8] = tmp%12#0
        let tmp%15#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let spendingApp#1: uint64 = tmp%15#0
        goto block@10
    block@10: // after_if_else_L993
        let spendingApp#3: uint64 = φ(spendingApp#0 <- block@6, spendingApp#1 <- block@9)
        goto useRounds#0 ? block@11 : block@12
    block@11: // ternary_true_L1013
        let ternary_result%0#0: uint64 = (global Round)
        goto block@13
    block@12: // ternary_false_L1013
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@13
    block@13: // ternary_merge_L1013
        let ternary_result%0#2: uint64 = φ(ternary_result%0#0 <- block@11, ternary_result%0#1 <- block@12)
        let epochRef#0: uint64 = ternary_result%0#2
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%3#0: bytes[8] = (itob spendingApp#3)
        let val_as_bytes%4#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%5#0: bytes[8] = (itob cooldown#0)
        let copy%0#0: bytes = methodInfos#1
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%6#0: bytes[8] = (itob epochRef#0)
        let current_tail_offset%2#0: uint64 = 45u
        let encoded_tuple_buffer%7#0: bytes[0] = 0x
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 encoded_bool%0#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%5#0)
        let as_bytes%1#0: bytes[8] = (itob current_tail_offset%2#0)
        let offset_as_uint16%0#0: bytes = ((extract 6 2) as_bytes%1#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 offset_as_uint16%0#0)
        let data_length%0#0: uint64 = (len copy%0#0)
        let current_tail_offset%3#0: uint64 = (+ current_tail_offset%2#0 data_length%0#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 copy%0#0)
        let val_as_bytes%7#0: bytes[8] = (itob key.application#0)
        let current_tail_offset%4#0: uint64 = 40u
        let encoded_tuple_buffer%19#0: bytes[0] = 0x
        let encoded_tuple_buffer%20#0: bytes = (concat encoded_tuple_buffer%19#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%21#0: bytes = (concat encoded_tuple_buffer%20#0 key.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%21#0)
        (box_del box_prefixed_key%2#0)
        (box_put box_prefixed_key%2#0 encoded_tuple_buffer%18#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
    block@0: // L1037
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L1038
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L1038
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L1038
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L1038
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove plugins
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let box_prefixed_key%1#0: bytes = (concat "n" name#0)
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // Box must have value
        let item0%0#0: bytes = (extract3 maybe_value%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 maybe_value%0#0 8u 32u) // on error: Index access is out of bounds
        let (app.application#0: uint64, app.allowedCaller#0: bytes[32]) = (item0%1#0, item1%0#0)
        let val_as_bytes%0#0: bytes[8] = (itob app.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 app.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Plugin does not exist
        let val_as_bytes%1#0: bytes[8] = (itob app.application#0)
        let current_tail_offset%1#0: uint64 = 40u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 app.allowedCaller#0)
        let box_prefixed_key%3#0: bytes = (concat "p" encoded_tuple_buffer%5#0)
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%3#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%2#0: bytes = (extract3 maybe_value%1#0 2u 8u) // on error: Index access is out of bounds
        let spendingApp#0: uint64 = (btoi tmp%2#0)
        let val_as_bytes%2#0: bytes[8] = (itob app.application#0)
        let current_tail_offset%2#0: uint64 = 40u
        let encoded_tuple_buffer%6#0: bytes[0] = 0x
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 app.allowedCaller#0)
        let box_prefixed_key%4#0: bytes = (concat "p" encoded_tuple_buffer%8#0)
        let (maybe_value%2#0: bytes, maybe_exists%4#0: bool) = (box_get box_prefixed_key%4#0)
        (assert maybe_exists%4#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%2#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%2#0)
        let tmp%3#0: bytes = (substring3 maybe_value%2#0 item_start_offset%0#0 item_end_offset%0#0)
        let copy%0#0: bytes = tmp%3#0
        let methods#0: bytes = copy%0#0
        let box_prefixed_key%5#0: bytes = (concat "n" name#0)
        (box_del box_prefixed_key%5#0)
        let val_as_bytes%3#0: bytes[8] = (itob app.application#0)
        let current_tail_offset%3#0: uint64 = 40u
        let encoded_tuple_buffer%9#0: bytes[0] = 0x
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 app.allowedCaller#0)
        let box_prefixed_key%6#0: bytes = (concat "p" encoded_tuple_buffer%11#0)
        (box_del box_prefixed_key%6#0)
        let (maybe_value%3#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (!= maybe_value%3#0 tmp%4#0)
        goto tmp%5#0 ? block@5 : block@7
    block@5: // if_body_L1049
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%4#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%6#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes = maybe_value%4#0
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: uint64 = (* 13u tmp%6#0)
        let tmp%8#0: uint64 = (len name#0)
        let tmp%9#0: uint64 = (+ tmp%7#0 tmp%8#0)
        let tmp%10#0: uint64 = (* 400u tmp%9#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%10#0)
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@6
    block@6: // next_txn_L1050
        itxn_submit
        goto block@7
    block@7: // after_if_else_L1049
        let tmp%11#0: bool = (!= spendingApp#0 0u)
        goto tmp%11#0 ? block@8 : block@10
    block@8: // if_body_L1059
        itxn_begin
        let inner_txn_params%1#0: itxn_field_set = itxn_field_set(1)
        let inner_txn_params%1%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%1%%Fee_length#0: uint64 = 1u
        let inner_txn_params%1%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%1%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%5#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%7#0) // check GlobalState exists
        let inner_txn_params%1%%param_ApplicationID_idx_0#0: uint64 = maybe_value%5#0
        let inner_txn_params%1%%ApplicationID_length#0: uint64 = 1u
        let val_as_bytes%4#0: bytes[8] = (itob spendingApp#0)
        let inner_txn_params%1%%param_ApplicationArgs_idx_0#0: bytes[4] = method "delete(uint64)void"
        let inner_txn_params%1%%param_ApplicationArgs_idx_1#0: bytes[8] = val_as_bytes%4#0
        let inner_txn_params%1%%ApplicationArgs_length#0: uint64 = 2u
        let inner_txn_params%1%%Sender_length#0: uint64 = 0u
        let inner_txn_params%1%%Note_length#0: uint64 = 0u
        let inner_txn_params%1%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%1%%Amount_length#0: uint64 = 0u
        let inner_txn_params%1%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%1%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%1%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%1%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%1%%Type_length#0: uint64 = 0u
        let inner_txn_params%1%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%1%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%1%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%1%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%1%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%1%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%1%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%1%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%1%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%1%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%1%%Assets_length#0: uint64 = 0u
        let inner_txn_params%1%%Applications_length#0: uint64 = 0u
        let inner_txn_params%1%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%1%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%1%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationID) inner_txn_params%1%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%1%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%1%%param_Fee_idx_0#0)
        goto block@9
    block@9: // next_txn_L1060
        itxn_submit
        goto block@10
    block@10: // after_if_else_L1059
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowance(plugin: uint64, caller: bytes[32], asset: uint64, type: bytes[1], allowed: uint64, max: uint64, interval: uint64) -> void:
    block@0: // L1074
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let (pkey.application#0: uint64, pkey.allowedCaller#0: bytes[32]) = (plugin#0, caller#0)
        let (key.application#0: uint64, key.allowedCaller#0: bytes[32], key.asset#0: uint64) = (pkey.application#0, pkey.allowedCaller#0, asset#0)
        let val_as_bytes%0#0: bytes[8] = (itob pkey.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 pkey.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Plugin does not exist
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%2#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%1#0: uint64 = 48u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%2#0)
        let box_prefixed_key%1#0: bytes = (concat "a" encoded_tuple_buffer%6#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%1#0)
        let tmp%2#0: bool = (! maybe_exists%2#0)
        (assert tmp%2#0) // allowance already exists
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (!= maybe_value%1#0 tmp%3#0)
        goto tmp%4#0 ? block@1 : block@3
    block@1: // if_body_L1092
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%2#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%0%%param_Sender_idx_0#0: bytes = maybe_value%2#0
        let inner_txn_params%0%%Sender_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = 38500u
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) inner_txn_params%0%%param_Sender_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@2
    block@2: // next_txn_L1093
        itxn_submit
        goto block@3
    block@3: // after_if_else_L1092
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%4#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%2#0: uint64 = 48u
        let encoded_tuple_buffer%7#0: bytes[0] = 0x
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 key.allowedCaller#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        let box_prefixed_key%2#0: bytes = (concat "a" encoded_tuple_buffer%10#0)
        let val_as_bytes%5#0: bytes[8] = (itob max#0)
        let val_as_bytes%6#0: bytes[8] = (itob allowed#0)
        let val_as_bytes%7#0: bytes[8] = (itob 0u)
        let val_as_bytes%8#0: bytes[8] = (itob interval#0)
        let val_as_bytes%9#0: bytes[8] = (itob 0u)
        let current_tail_offset%3#0: uint64 = 41u
        let encoded_tuple_buffer%11#0: bytes[0] = 0x
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 type#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%9#0)
        (box_put box_prefixed_key%2#0 encoded_tuple_buffer%17#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowance(plugin: uint64, caller: bytes[32], asset: uint64) -> void:
    block@0: // L1116
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L1117
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L1117
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L1117
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L1117
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove method restrictions
        let (pkey.application#0: uint64, pkey.allowedCaller#0: bytes[32]) = (plugin#0, caller#0)
        let (key.asset#0: uint64, key.application#0: uint64, key.allowedCaller#0: bytes[32]) = (asset#0, pkey.application#0, pkey.allowedCaller#0)
        let val_as_bytes%0#0: bytes[8] = (itob pkey.application#0)
        let current_tail_offset%0#0: uint64 = 40u
        let encoded_tuple_buffer%0#0: bytes[0] = 0x
        let encoded_tuple_buffer%1#0: bytes = (concat encoded_tuple_buffer%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%2#0: bytes = (concat encoded_tuple_buffer%1#0 pkey.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let val_as_bytes%1#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%2#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%1#0: uint64 = 48u
        let encoded_tuple_buffer%3#0: bytes[0] = 0x
        let encoded_tuple_buffer%4#0: bytes = (concat encoded_tuple_buffer%3#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%5#0: bytes = (concat encoded_tuple_buffer%4#0 key.allowedCaller#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 val_as_bytes%2#0)
        let box_prefixed_key%1#0: bytes = (concat "a" encoded_tuple_buffer%6#0)
        let (_%1#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // allowance does not exist
        let val_as_bytes%3#0: bytes[8] = (itob key.application#0)
        let val_as_bytes%4#0: bytes[8] = (itob key.asset#0)
        let current_tail_offset%2#0: uint64 = 48u
        let encoded_tuple_buffer%7#0: bytes[0] = 0x
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 key.allowedCaller#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%4#0)
        let box_prefixed_key%2#0: bytes = (concat "a" encoded_tuple_buffer%10#0)
        (box_del box_prefixed_key%2#0)
        let (maybe_value%0#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%2#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%3#0: bool = (!= maybe_value%0#0 tmp%2#0)
        goto tmp%3#0 ? block@5 : block@7
    block@5: // if_body_L1128
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = 1u
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes = maybe_value%1#0
        let inner_txn_params%0%%Receiver_length#0: uint64 = 1u
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = 38500u
        let inner_txn_params%0%%Amount_length#0: uint64 = 1u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@6
    block@6: // next_txn_L1129
        itxn_submit
        goto block@7
    block@7: // after_if_else_L1128
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes[32]:
    block@0: // L1148
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let reinterpret_bytes[32]%0#0: bytes[32] = maybe_value%0#0
        return reinterpret_bytes[32]%0#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(assets: encoded_uint64[]) -> encoded_uint64[]:
    block@0: // L1154
        let array_data%0#0: bytes = (concat 0x0000 0x)
        let amounts#0: encoded_uint64[] = array_data%0#0
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L1157
        let i#1: uint64 = φ(i#0 <- block@0, i#4 <- block@8)
        let amounts#2: encoded_uint64[] = φ(amounts#0 <- block@0, amounts#4 <- block@8)
        let tmp%0#0: uint64 = (extract_uint16 assets#0 0u)
        let tmp%1#0: bool = (< i#1 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@9
    block@2: // while_body_L1157
        let amount#0: uint64 = 0u
        let array_head_and_tail%0#0: bytes = ((extract 2 0) assets#0)
        let item_offset%0#0: uint64 = (* i#1 8u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 8u) // on error: Index access is out of bounds
        let asset#0: uint64 = (btoi arc4_item%0#0)
        let tmp%2#0: bool = (== asset#0 0u)
        goto tmp%2#0 ? block@3 : block@4
    block@3: // if_body_L1161
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let (value%0#0: uint64, check%0#0: bool) = ((acct_params_get AcctBalance) tmp%3#0)
        (assert check%0#0) // account funded
        let amount#1: uint64 = value%0#0
        goto block@7
    block@4: // else_body_L1163
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: bool) = ((asset_holding_get AssetBalance) tmp%4#0 asset#0)
        let holdingAmount#0: uint64 = tuple_assignment%0#0
        let optedIn#0: bool = tuple_assignment%1#0
        goto optedIn#0 ? block@5 : block@6
    block@5: // if_body_L1165
        let amount#2: uint64 = holdingAmount#0
        goto block@6
    block@6: // after_if_else_L1165
        let amount#4: uint64 = φ(amount#0 <- block@4, amount#2 <- block@5)
        goto block@7
    block@7: // after_if_else_L1161
        let amount#3: uint64 = φ(amount#1 <- block@3, amount#4 <- block@6)
        itxn_begin
        let inner_txn_params%0#0: itxn_field_set = itxn_field_set(0)
        let inner_txn_params%0%%param_Fee_idx_0#0: uint64 = 0u
        let inner_txn_params%0%%Fee_length#0: uint64 = 1u
        let inner_txn_params%0%%param_TypeEnum_idx_0#0: uint64 = appl
        let inner_txn_params%0%%TypeEnum_length#0: uint64 = 1u
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (tmp%5#0: uint64, tmp%6#0: uint64, tmp%7#0: uint64, tmp%8#0: uint64, tmp%9#0: uint64, tmp%10#0: uint64, tmp%11#0: uint64, tmp%12#0: uint64, tmp%13#0: uint64, tmp%14#0: uint64, tmp%15#0: uint64, tmp%16#0: uint64) = smart_contracts/utils/functions.ts::getAkitaAppList(maybe_value%0#0)
        let inner_txn_params%0%%param_ApplicationID_idx_0#0: uint64 = tmp%5#0
        let inner_txn_params%0%%ApplicationID_length#0: uint64 = 1u
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let reinterpret_bytes[32]%0#0: bytes[32] = maybe_value%1#0
        let val_as_bytes%0#0: bytes[8] = (itob asset#0)
        let inner_txn_params%0%%param_ApplicationArgs_idx_0#0: bytes[4] = method "getEscrowInfo(address,uint64)(uint64,uint64)"
        let inner_txn_params%0%%param_ApplicationArgs_idx_1#0: bytes[32] = reinterpret_bytes[32]%0#0
        let inner_txn_params%0%%param_ApplicationArgs_idx_2#0: bytes[8] = val_as_bytes%0#0
        let inner_txn_params%0%%ApplicationArgs_length#0: uint64 = 3u
        let inner_txn_params%0%%Sender_length#0: uint64 = 0u
        let inner_txn_params%0%%Note_length#0: uint64 = 0u
        let inner_txn_params%0%%Receiver_length#0: uint64 = 0u
        let inner_txn_params%0%%Amount_length#0: uint64 = 0u
        let inner_txn_params%0%%CloseRemainderTo_length#0: uint64 = 0u
        let inner_txn_params%0%%VotePK_length#0: uint64 = 0u
        let inner_txn_params%0%%SelectionPK_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteFirst_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteLast_length#0: uint64 = 0u
        let inner_txn_params%0%%VoteKeyDilution_length#0: uint64 = 0u
        let inner_txn_params%0%%Type_length#0: uint64 = 0u
        let inner_txn_params%0%%XferAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetAmount_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetSender_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetReceiver_length#0: uint64 = 0u
        let inner_txn_params%0%%AssetCloseTo_length#0: uint64 = 0u
        let inner_txn_params%0%%OnCompletion_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgram_length#0: uint64 = 0u
        let inner_txn_params%0%%RekeyTo_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetTotal_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDecimals_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetDefaultFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetUnitName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetName_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetURL_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetMetadataHash_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetManager_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetReserve_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetFreeze_length#0: uint64 = 0u
        let inner_txn_params%0%%ConfigAssetClawback_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAsset_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetAccount_length#0: uint64 = 0u
        let inner_txn_params%0%%FreezeAssetFrozen_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%GlobalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumUint_length#0: uint64 = 0u
        let inner_txn_params%0%%LocalNumByteSlice_length#0: uint64 = 0u
        let inner_txn_params%0%%ExtraProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%Nonparticipation_length#0: uint64 = 0u
        let inner_txn_params%0%%StateProofPK_length#0: uint64 = 0u
        let inner_txn_params%0%%Accounts_length#0: uint64 = 0u
        let inner_txn_params%0%%Assets_length#0: uint64 = 0u
        let inner_txn_params%0%%Applications_length#0: uint64 = 0u
        let inner_txn_params%0%%ApprovalProgramPages_length#0: uint64 = 0u
        let inner_txn_params%0%%ClearStateProgramPages_length#0: uint64 = 0u
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_0#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_1#0)
        ((itxn_field ApplicationArgs) inner_txn_params%0%%param_ApplicationArgs_idx_2#0)
        ((itxn_field ApplicationID) inner_txn_params%0%%param_ApplicationID_idx_0#0)
        ((itxn_field TypeEnum) inner_txn_params%0%%param_TypeEnum_idx_0#0)
        ((itxn_field Fee) inner_txn_params%0%%param_Fee_idx_0#0)
        goto block@8
    block@8: // next_txn_L1170
        itxn_submit
        let awst_tmp%0#0: bytes = itxn[itxn_group_idx(0)].LastLog
        let tmp%17#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%18#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%19#0: bool = (== tmp%18#0 0x151f7c75)
        (assert tmp%19#0) // Bytes has valid prefix
        let reinterpret_bytes[16]%0#0: bytes[16] = tmp%17#0
        let item0%0#0: bytes = (extract3 reinterpret_bytes[16]%0#0 0u 8u) // on error: Index access is out of bounds
        let item0%1#0: uint64 = (btoi item0%0#0)
        let item1%0#0: bytes = (extract3 reinterpret_bytes[16]%0#0 8u 8u) // on error: Index access is out of bounds
        let item1%1#0: uint64 = (btoi item1%0#0)
        let (escrowInfo.hard#0: uint64, escrowInfo.lock#0: uint64) = (item0%1#0, item1%1#0)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) amounts#2)
        let array_data%1#0: bytes = (concat 0x0000 0x)
        let expr_value_trimmed%1#0: bytes = ((extract 2 0) array_data%1#0)
        let tmp%20#0: uint64 = (+ amount#3 escrowInfo.hard#0)
        let tmp%21#0: uint64 = (+ tmp%20#0 escrowInfo.lock#0)
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(tmp%21#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%1#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let expr_value_trimmed%2#0: bytes = ((extract 2 0) concat_result%0#0)
        let concatenated%1#0: bytes = (concat expr_value_trimmed%0#0 expr_value_trimmed%2#0)
        let byte_len%1#0: uint64 = (len concatenated%1#0)
        let len_%1#0: uint64 = (/ byte_len%1#0 8u)
        let as_bytes%1#0: bytes[8] = (itob len_%1#0)
        let len_16_bit%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let concat_result%1#0: bytes = (concat len_16_bit%1#0 concatenated%1#0)
        let amounts#4: encoded_uint64[] = concat_result%1#0
        let i#4: uint64 = (+ i#1 1u)
        goto block@1
    block@9: // after_while_L1157
        return amounts#2