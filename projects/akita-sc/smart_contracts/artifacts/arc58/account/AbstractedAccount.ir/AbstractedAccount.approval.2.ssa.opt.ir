main @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram:
    block@0: // L1
        let tmp%0#1: uint64 = (txn NumAppArgs)
        goto tmp%0#1 ? block@2 : block@29
    block@2: // abi_routing_L74
        let tmp%2#0: bytes = (txna ApplicationArgs 0)
        switch tmp%2#0 {method "create(string,address,address,uint64,uint64,string)void" => block@3, method "update(string)void" => block@4, method "changeRevocationApp(uint64)void" => block@5, method "setNickname(string)void" => block@6, method "setAvatar(uint64)void" => block@7, method "setBanner(uint64)void" => block@8, method "setBio(string)void" => block@9, method "arc58_changeAdmin(address)void" => block@10, method "arc58_pluginChangeAdmin(uint64,address,address)void" => block@11, method "arc58_verifyAuthAddr()void" => block@12, method "arc58_rekeyTo(address,bool)void" => block@13, method "arc58_canCall(uint64,bool,address,byte[4])bool" => block@14, method "arc58_rekeyToPlugin(uint64,bool,uint64[],(uint64,uint64)[])void" => block@15, method "arc58_rekeyToNamedPlugin(string,bool,uint64[],(uint64,uint64)[])void" => block@16, method "arc58_addPlugin(uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@17, method "assignDomain(address,string)void" => block@18, method "arc58_removePlugin(uint64,address)void" => block@19, method "arc58_addNamedPlugin(string,uint64,address,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool)void" => block@20, method "arc58_removeNamedPlugin(string)void" => block@21, method "arc58_addAllowance(uint64,address,uint64,uint8,uint64,uint64,uint64)void" => block@22, method "arc58_removeAllowance(uint64,address,uint64)void" => block@23, method "arc58_getAdmin()address" => block@24, method "balance(uint64[])uint64[]" => block@25, * => block@29}
    block@3: // create_route_L527
        let tmp%3#0: uint64 = (txn OnCompletion)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0) // OnCompletion is not NoOp
        let tmp%5#0: uint64 = (txn ApplicationID)
        let tmp%6#0: bool = (! tmp%5#0)
        (assert tmp%6#0) // can only call when creating
        let tmp%7#0: bytes = (txna ApplicationArgs 1)
        let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
        let reinterpret_bytes[32]%0#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%1#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[8]%0#0: bytes[8] = (txna ApplicationArgs 4)
        let tmp%9#0: uint64 = (btoi reinterpret_bytes[8]%0#0)
        let reinterpret_bytes[8]%1#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%10#0: uint64 = (btoi reinterpret_bytes[8]%1#0)
        let tmp%11#0: bytes = (txna ApplicationArgs 6)
        let tmp%12#0: bytes = ((extract 2 0) tmp%11#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(tmp%8#0, reinterpret_bytes[32]%0#0, reinterpret_bytes[32]%1#0, tmp%9#0, tmp%10#0, tmp%12#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0: bool = 1u
        goto block@30
    block@4: // update_route_L553
        let tmp%13#0: uint64 = (txn OnCompletion)
        let tmp%14#0: bool = (== tmp%13#0 UpdateApplication)
        (assert tmp%14#0) // OnCompletion is not UpdateApplication
        let tmp%15#0: uint64 = (txn ApplicationID)
        (assert tmp%15#0) // can only call when not creating
        let tmp%17#0: bytes = (txna ApplicationArgs 1)
        let tmp%18#0: bytes = ((extract 2 0) tmp%17#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(tmp%18#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1: bool = 1u
        goto block@30
    block@5: // changeRevocationApp_route_L566
        let tmp%19#0: uint64 = (txn OnCompletion)
        let tmp%20#0: bool = (! tmp%19#0)
        (assert tmp%20#0) // OnCompletion is not NoOp
        let tmp%21#0: uint64 = (txn ApplicationID)
        (assert tmp%21#0) // can only call when not creating
        let reinterpret_bytes[8]%2#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%23#0: uint64 = (btoi reinterpret_bytes[8]%2#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(tmp%23#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2: bool = 1u
        goto block@30
    block@6: // setNickname_route_L576
        let tmp%24#0: uint64 = (txn OnCompletion)
        let tmp%25#0: bool = (! tmp%24#0)
        (assert tmp%25#0) // OnCompletion is not NoOp
        let tmp%26#0: uint64 = (txn ApplicationID)
        (assert tmp%26#0) // can only call when not creating
        let tmp%28#0: bytes = (txna ApplicationArgs 1)
        let tmp%29#0: bytes = ((extract 2 0) tmp%28#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(tmp%29#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3: bool = 1u
        goto block@30
    block@7: // setAvatar_route_L586
        let tmp%30#0: uint64 = (txn OnCompletion)
        let tmp%31#0: bool = (! tmp%30#0)
        (assert tmp%31#0) // OnCompletion is not NoOp
        let tmp%32#0: uint64 = (txn ApplicationID)
        (assert tmp%32#0) // can only call when not creating
        let reinterpret_bytes[8]%3#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%34#0: uint64 = (btoi reinterpret_bytes[8]%3#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(tmp%34#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4: bool = 1u
        goto block@30
    block@8: // setBanner_route_L598
        let tmp%35#0: uint64 = (txn OnCompletion)
        let tmp%36#0: bool = (! tmp%35#0)
        (assert tmp%36#0) // OnCompletion is not NoOp
        let tmp%37#0: uint64 = (txn ApplicationID)
        (assert tmp%37#0) // can only call when not creating
        let reinterpret_bytes[8]%4#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%39#0: uint64 = (btoi reinterpret_bytes[8]%4#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(tmp%39#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5: bool = 1u
        goto block@30
    block@9: // setBio_route_L610
        let tmp%40#0: uint64 = (txn OnCompletion)
        let tmp%41#0: bool = (! tmp%40#0)
        (assert tmp%41#0) // OnCompletion is not NoOp
        let tmp%42#0: uint64 = (txn ApplicationID)
        (assert tmp%42#0) // can only call when not creating
        let tmp%44#0: bytes = (txna ApplicationArgs 1)
        let tmp%45#0: bytes = ((extract 2 0) tmp%44#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(tmp%45#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6: bool = 1u
        goto block@30
    block@10: // arc58_changeAdmin_route_L620
        let tmp%46#0: uint64 = (txn OnCompletion)
        let tmp%47#0: bool = (! tmp%46#0)
        (assert tmp%47#0) // OnCompletion is not NoOp
        let tmp%48#0: uint64 = (txn ApplicationID)
        (assert tmp%48#0) // can only call when not creating
        let reinterpret_bytes[32]%2#0: bytes[32] = (txna ApplicationArgs 1)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(reinterpret_bytes[32]%2#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7: bool = 1u
        goto block@30
    block@11: // arc58_pluginChangeAdmin_route_L635
        let tmp%50#0: uint64 = (txn OnCompletion)
        let tmp%51#0: bool = (! tmp%50#0)
        (assert tmp%51#0) // OnCompletion is not NoOp
        let tmp%52#0: uint64 = (txn ApplicationID)
        (assert tmp%52#0) // can only call when not creating
        let reinterpret_bytes[8]%5#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%54#0: uint64 = (btoi reinterpret_bytes[8]%5#0)
        let reinterpret_bytes[32]%3#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[32]%4#0: bytes[32] = (txna ApplicationArgs 3)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(tmp%54#0, reinterpret_bytes[32]%3#0, reinterpret_bytes[32]%4#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8: bool = 1u
        goto block@30
    block@12: // arc58_verifyAuthAddr_route_L659
        let tmp%55#0: uint64 = (txn OnCompletion)
        let tmp%56#0: bool = (! tmp%55#0)
        (assert tmp%56#0) // OnCompletion is not NoOp
        let tmp%57#0: uint64 = (txn ApplicationID)
        (assert tmp%57#0) // can only call when not creating
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddr()
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9: bool = 1u
        goto block@30
    block@13: // arc58_rekeyTo_route_L670
        let tmp%59#0: uint64 = (txn OnCompletion)
        let tmp%60#0: bool = (! tmp%59#0)
        (assert tmp%60#0) // OnCompletion is not NoOp
        let tmp%61#0: uint64 = (txn ApplicationID)
        (assert tmp%61#0) // can only call when not creating
        let reinterpret_bytes[32]%5#0: bytes[32] = (txna ApplicationArgs 1)
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%63#0: bool = (getbit reinterpret_bytes[1]%0#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(reinterpret_bytes[32]%5#0, tmp%63#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10: bool = 1u
        goto block@30
    block@14: // arc58_canCall_route_L696
        let tmp%64#0: uint64 = (txn OnCompletion)
        let tmp%65#0: bool = (! tmp%64#0)
        (assert tmp%65#0) // OnCompletion is not NoOp
        let tmp%66#0: uint64 = (txn ApplicationID)
        (assert tmp%66#0) // can only call when not creating
        let reinterpret_bytes[8]%6#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%68#0: uint64 = (btoi reinterpret_bytes[8]%6#0)
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%69#0: bool = (getbit reinterpret_bytes[1]%1#0 0u)
        let reinterpret_bytes[32]%6#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[4]%0#0: bytes[4] = (txna ApplicationArgs 4)
        let to_encode%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(tmp%68#0, tmp%69#0, reinterpret_bytes[32]%6#0, reinterpret_bytes[4]%0#0)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u to_encode%0#0)
        let tmp%70#0: bytes = (concat 0x151f7c75 encoded_bool%0#0)
        (log tmp%70#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11: bool = 1u
        goto block@30
    block@15: // arc58_rekeyToPlugin_route_L718
        let tmp%71#0: uint64 = (txn OnCompletion)
        let tmp%72#0: bool = (! tmp%71#0)
        (assert tmp%72#0) // OnCompletion is not NoOp
        let tmp%73#0: uint64 = (txn ApplicationID)
        (assert tmp%73#0) // can only call when not creating
        let reinterpret_bytes[8]%7#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%75#0: uint64 = (btoi reinterpret_bytes[8]%7#0)
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%76#0: bool = (getbit reinterpret_bytes[1]%2#0 0u)
        let reinterpret_encoded_uint64[]%0#0: encoded_uint64[] = (txna ApplicationArgs 3)
        let reinterpret_(encoded_uint64,encoded_uint64)[]%0#0: (encoded_uint64,encoded_uint64)[] = (txna ApplicationArgs 4)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(tmp%75#0, tmp%76#0, reinterpret_encoded_uint64[]%0#0, reinterpret_(encoded_uint64,encoded_uint64)[]%0#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12: bool = 1u
        goto block@30
    block@16: // arc58_rekeyToNamedPlugin_route_L779
        let tmp%77#0: uint64 = (txn OnCompletion)
        let tmp%78#0: bool = (! tmp%77#0)
        (assert tmp%78#0) // OnCompletion is not NoOp
        let tmp%79#0: uint64 = (txn ApplicationID)
        (assert tmp%79#0) // can only call when not creating
        let tmp%81#0: bytes = (txna ApplicationArgs 1)
        let tmp%82#0: bytes = ((extract 2 0) tmp%81#0)
        let reinterpret_bytes[1]%3#0: bytes[1] = (txna ApplicationArgs 2)
        let tmp%83#0: bool = (getbit reinterpret_bytes[1]%3#0 0u)
        let reinterpret_encoded_uint64[]%1#0: encoded_uint64[] = (txna ApplicationArgs 3)
        let reinterpret_(encoded_uint64,encoded_uint64)[]%1#0: (encoded_uint64,encoded_uint64)[] = (txna ApplicationArgs 4)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(tmp%82#0, tmp%83#0, reinterpret_encoded_uint64[]%1#0, reinterpret_(encoded_uint64,encoded_uint64)[]%1#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13: bool = 1u
        goto block@30
    block@17: // arc58_addPlugin_route_L801
        let tmp%84#0: uint64 = (txn OnCompletion)
        let tmp%85#0: bool = (! tmp%84#0)
        (assert tmp%85#0) // OnCompletion is not NoOp
        let tmp%86#0: uint64 = (txn ApplicationID)
        (assert tmp%86#0) // can only call when not creating
        let reinterpret_bytes[8]%8#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%88#0: uint64 = (btoi reinterpret_bytes[8]%8#0)
        let reinterpret_bytes[32]%7#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[1]%4#0: bytes[1] = (txna ApplicationArgs 3)
        let tmp%89#0: bool = (getbit reinterpret_bytes[1]%4#0 0u)
        let reinterpret_bytes[1]%5#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%9#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%90#0: uint64 = (btoi reinterpret_bytes[8]%9#0)
        let reinterpret_bytes[8]%10#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%91#0: uint64 = (btoi reinterpret_bytes[8]%10#0)
        let reinterpret_(bytes[4],encoded_uint64)[]%0#0: (bytes[4],encoded_uint64)[] = (txna ApplicationArgs 7)
        let reinterpret_bytes[1]%6#0: bytes[1] = (txna ApplicationArgs 8)
        let tmp%92#0: bool = (getbit reinterpret_bytes[1]%6#0 0u)
        let reinterpret_bytes[1]%7#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%93#0: bool = (getbit reinterpret_bytes[1]%7#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(tmp%88#0, reinterpret_bytes[32]%7#0, tmp%89#0, reinterpret_bytes[1]%5#0, tmp%90#0, tmp%91#0, reinterpret_(bytes[4],encoded_uint64)[]%0#0, tmp%92#0, tmp%93#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#14: bool = 1u
        goto block@30
    block@18: // assignDomain_route_L889
        let tmp%94#0: uint64 = (txn OnCompletion)
        let tmp%95#0: bool = (! tmp%94#0)
        (assert tmp%95#0) // OnCompletion is not NoOp
        let tmp%96#0: uint64 = (txn ApplicationID)
        (assert tmp%96#0) // can only call when not creating
        let reinterpret_bytes[32]%8#0: bytes[32] = (txna ApplicationArgs 1)
        let tmp%98#0: bytes = (txna ApplicationArgs 2)
        let tmp%99#0: bytes = ((extract 2 0) tmp%98#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(reinterpret_bytes[32]%8#0, tmp%99#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#15: bool = 1u
        goto block@30
    block@19: // arc58_removePlugin_route_L902
        let tmp%100#0: uint64 = (txn OnCompletion)
        let tmp%101#0: bool = (! tmp%100#0)
        (assert tmp%101#0) // OnCompletion is not NoOp
        let tmp%102#0: uint64 = (txn ApplicationID)
        (assert tmp%102#0) // can only call when not creating
        let reinterpret_bytes[8]%11#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%104#0: uint64 = (btoi reinterpret_bytes[8]%11#0)
        let reinterpret_bytes[32]%9#0: bytes[32] = (txna ApplicationArgs 2)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(tmp%104#0, reinterpret_bytes[32]%9#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#16: bool = 1u
        goto block@30
    block@20: // arc58_addNamedPlugin_route_L952
        let tmp%105#0: uint64 = (txn OnCompletion)
        let tmp%106#0: bool = (! tmp%105#0)
        (assert tmp%106#0) // OnCompletion is not NoOp
        let tmp%107#0: uint64 = (txn ApplicationID)
        (assert tmp%107#0) // can only call when not creating
        let tmp%109#0: bytes = (txna ApplicationArgs 1)
        let tmp%110#0: bytes = ((extract 2 0) tmp%109#0)
        let reinterpret_bytes[8]%12#0: bytes[8] = (txna ApplicationArgs 2)
        let tmp%111#0: uint64 = (btoi reinterpret_bytes[8]%12#0)
        let reinterpret_bytes[32]%10#0: bytes[32] = (txna ApplicationArgs 3)
        let reinterpret_bytes[1]%8#0: bytes[1] = (txna ApplicationArgs 4)
        let tmp%112#0: bool = (getbit reinterpret_bytes[1]%8#0 0u)
        let reinterpret_bytes[1]%9#0: bytes[1] = (txna ApplicationArgs 5)
        let reinterpret_bytes[8]%13#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%113#0: uint64 = (btoi reinterpret_bytes[8]%13#0)
        let reinterpret_bytes[8]%14#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%114#0: uint64 = (btoi reinterpret_bytes[8]%14#0)
        let reinterpret_(bytes[4],encoded_uint64)[]%1#0: (bytes[4],encoded_uint64)[] = (txna ApplicationArgs 8)
        let reinterpret_bytes[1]%10#0: bytes[1] = (txna ApplicationArgs 9)
        let tmp%115#0: bool = (getbit reinterpret_bytes[1]%10#0 0u)
        let reinterpret_bytes[1]%11#0: bytes[1] = (txna ApplicationArgs 10)
        let tmp%116#0: bool = (getbit reinterpret_bytes[1]%11#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(tmp%110#0, tmp%111#0, reinterpret_bytes[32]%10#0, tmp%112#0, reinterpret_bytes[1]%9#0, tmp%113#0, tmp%114#0, reinterpret_(bytes[4],encoded_uint64)[]%1#0, tmp%115#0, tmp%116#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#17: bool = 1u
        goto block@30
    block@21: // arc58_removeNamedPlugin_route_L1037
        let tmp%117#0: uint64 = (txn OnCompletion)
        let tmp%118#0: bool = (! tmp%117#0)
        (assert tmp%118#0) // OnCompletion is not NoOp
        let tmp%119#0: uint64 = (txn ApplicationID)
        (assert tmp%119#0) // can only call when not creating
        let tmp%121#0: bytes = (txna ApplicationArgs 1)
        let tmp%122#0: bytes = ((extract 2 0) tmp%121#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(tmp%122#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#18: bool = 1u
        goto block@30
    block@22: // arc58_addAllowance_route_L1074
        let tmp%123#0: uint64 = (txn OnCompletion)
        let tmp%124#0: bool = (! tmp%123#0)
        (assert tmp%124#0) // OnCompletion is not NoOp
        let tmp%125#0: uint64 = (txn ApplicationID)
        (assert tmp%125#0) // can only call when not creating
        let reinterpret_bytes[8]%15#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%127#0: uint64 = (btoi reinterpret_bytes[8]%15#0)
        let reinterpret_bytes[32]%11#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%16#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%128#0: uint64 = (btoi reinterpret_bytes[8]%16#0)
        let reinterpret_bytes[1]%12#0: bytes[1] = (txna ApplicationArgs 4)
        let reinterpret_bytes[8]%17#0: bytes[8] = (txna ApplicationArgs 5)
        let tmp%129#0: uint64 = (btoi reinterpret_bytes[8]%17#0)
        let reinterpret_bytes[8]%18#0: bytes[8] = (txna ApplicationArgs 6)
        let tmp%130#0: uint64 = (btoi reinterpret_bytes[8]%18#0)
        let reinterpret_bytes[8]%19#0: bytes[8] = (txna ApplicationArgs 7)
        let tmp%131#0: uint64 = (btoi reinterpret_bytes[8]%19#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowance(tmp%127#0, reinterpret_bytes[32]%11#0, tmp%128#0, reinterpret_bytes[1]%12#0, tmp%129#0, tmp%130#0, tmp%131#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#19: bool = 1u
        goto block@30
    block@23: // arc58_removeAllowance_route_L1116
        let tmp%132#0: uint64 = (txn OnCompletion)
        let tmp%133#0: bool = (! tmp%132#0)
        (assert tmp%133#0) // OnCompletion is not NoOp
        let tmp%134#0: uint64 = (txn ApplicationID)
        (assert tmp%134#0) // can only call when not creating
        let reinterpret_bytes[8]%20#0: bytes[8] = (txna ApplicationArgs 1)
        let tmp%136#0: uint64 = (btoi reinterpret_bytes[8]%20#0)
        let reinterpret_bytes[32]%12#0: bytes[32] = (txna ApplicationArgs 2)
        let reinterpret_bytes[8]%21#0: bytes[8] = (txna ApplicationArgs 3)
        let tmp%137#0: uint64 = (btoi reinterpret_bytes[8]%21#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowance(tmp%136#0, reinterpret_bytes[32]%12#0, tmp%137#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#20: bool = 1u
        goto block@30
    block@24: // arc58_getAdmin_route_L1148
        let tmp%138#0: uint64 = (txn OnCompletion)
        let tmp%139#0: bool = (! tmp%138#0)
        (assert tmp%139#0) // OnCompletion is not NoOp
        let tmp%140#0: uint64 = (txn ApplicationID)
        (assert tmp%140#0) // can only call when not creating
        let tmp%142#0: bytes[32] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin()
        let tmp%143#0: bytes = (concat 0x151f7c75 tmp%142#0)
        (log tmp%143#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#21: bool = 1u
        goto block@30
    block@25: // balance_route_L1154
        let tmp%144#0: uint64 = (txn OnCompletion)
        let tmp%145#0: bool = (! tmp%144#0)
        (assert tmp%145#0) // OnCompletion is not NoOp
        let tmp%146#0: uint64 = (txn ApplicationID)
        (assert tmp%146#0) // can only call when not creating
        let reinterpret_encoded_uint64[]%2#0: encoded_uint64[] = (txna ApplicationArgs 1)
        let tmp%148#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(reinterpret_encoded_uint64[]%2#0)
        let tmp%149#0: bytes = (concat 0x151f7c75 tmp%148#0)
        (log tmp%149#0)
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#22: bool = 1u
        goto block@30
    block@29: // after_if_else_L74
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#23: bool = 0u
        goto block@30
    block@30: // after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router___L1
        let tmp%0#0: bool = φ(smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#0 <- block@3, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#1 <- block@4, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#2 <- block@5, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#3 <- block@6, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#4 <- block@7, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#5 <- block@8, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#6 <- block@9, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#7 <- block@10, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#8 <- block@11, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#9 <- block@12, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#10 <- block@13, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#11 <- block@14, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#12 <- block@15, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#13 <- block@16, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#14 <- block@17, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#15 <- block@18, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#16 <- block@19, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#17 <- block@20, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#18 <- block@21, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#19 <- block@22, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#20 <- block@23, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#21 <- block@24, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#22 <- block@25, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__%0#23 <- block@29)
        return tmp%0#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
    block@0: // L136
        let materialized_values%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_user_interaction" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange() -> void:
    block@0: // L140
        let materialized_values%0#0: uint64 = (global LatestTimestamp)
        (app_global_put "last_change" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin() -> bool:
    block@0: // L145
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@3 : block@1
    block@1: // or_contd_L147
        let materialized_values%0#0: bytes[32] = (txn Sender)
        let box_prefixed_key%0#0: bytes = (concat "d" materialized_values%0#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%1#0 ? block@2 : block@4
    block@2: // and_contd_L148
        let materialized_values%1#0: bytes[32] = (txn Sender)
        let box_prefixed_key%1#0: bytes = (concat "d" materialized_values%1#0)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%1#0)
        (assert maybe_exists%2#0) // Box must have value
        let tmp%2#0: bool = (== maybe_value%1#0 "akita.community")
        goto tmp%2#0 ? block@3 : block@4
    block@3: // bool_true_L147
        let or_result%0#0: bool = 1u
        goto block@5
    block@4: // bool_false_L147
        let or_result%0#1: bool = 0u
        goto block@5
    block@5: // bool_merge_L147
        let or_result%0#2: bool = φ(or_result%0#0 <- block@3, or_result%0#1 <- block@4)
        return or_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke() -> bool:
    block@0: // L153
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "revocation_app")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%0#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        return tmp%1#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(application: uint64, allowedCaller: bytes[32], method: bytes[4]) -> bool:
    block@0: // L157
        let val_as_bytes%0#0: bytes[8] = (itob application#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%0#0 ? block@2 : block@1
    block@1: // if_body_L160
        return 0u
    block@2: // after_if_else_L160
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let methods#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let tmp%1#0: uint64 = (extract_uint16 methods#0 0u)
        let methodAllowed#0: bool = (! tmp%1#0)
        let i#0: uint64 = 0u
        goto block@3
    block@3: // while_top_L166
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@6)
        let tmp%4#0: bool = (< i#1 tmp%1#0)
        goto tmp%4#0 ? block@4 : block@7
    block@4: // while_body_L166
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 20u)
        let tmp%5#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 20u) // on error: Index access is out of bounds
        let tmp%6#0: bytes = ((extract 0 4) tmp%5#0) // on error: Index access is out of bounds
        let tmp%7#0: bool = (== tmp%6#0 method#0)
        goto tmp%7#0 ? block@5 : block@6
    block@5: // if_body_L167
        let methodAllowed#1: bool = 1u
        goto block@8
    block@6: // after_if_else_L167
        let i#2: uint64 = (+ i#1 1u)
        goto block@3
    block@7: // after_while_L166
        goto block@8
    block@8: // L166
        let methodAllowed#4: bool = φ(methodAllowed#1 <- block@5, methodAllowed#0 <- block@7)
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 0u)
        let p.cooldown#0: uint64 = (extract_uint64 maybe_value%1#0 18u)
        let is_true%1#0: uint64 = (getbit maybe_value%1#0 224u)
        let is_true%2#0: uint64 = (getbit maybe_value%1#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let p.useRounds#0: bool = (getbit encoded_bool%2#0 0u)
        let p.lastCalled#0: uint64 = (extract_uint64 maybe_value%1#0 29u)
        goto p.useRounds#0 ? block@9 : block@10
    block@9: // ternary_true_L174
        let ternary_result%0#0: uint64 = (global Round)
        goto block@11
    block@10: // ternary_false_L174
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@11
    block@11: // ternary_merge_L174
        let epochRef#0: uint64 = φ(ternary_result%0#0 <- block@9, ternary_result%0#1 <- block@10)
        let tmp%8#0: bool = (>= p.lastCalled#0 epochRef#0)
        goto tmp%8#0 ? block@12 : block@14
    block@12: // and_contd_L177
        let tmp%9#0: uint64 = (- epochRef#0 p.lastCalled#0)
        let tmp%10#0: bool = (>= tmp%9#0 p.cooldown#0)
        goto tmp%10#0 ? block@13 : block@14
    block@13: // bool_true_L177
        let and_result%0#0: bool = 1u
        goto block@15
    block@14: // bool_false_L177
        let and_result%0#1: bool = 0u
        goto block@15
    block@15: // bool_merge_L177
        let and_result%0#2: bool = φ(and_result%0#0 <- block@13, and_result%0#1 <- block@14)
        let tmp%11#0: bool = (&& and_result%0#2 methodAllowed#4)
        return tmp%11#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> bool:
    block@0: // L183
        let tmp%0#0: bytes[32] = ((gtxns Sender) txn#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L186
        let tmp%2#0: bytes[32] = ((gtxns RekeyTo) txn#0)
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (== tmp%2#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // if_body_L188
        return 1u
    block@3: // after_if_else_L185
        let tmp%5#0: uint64 = ((gtxns TypeEnum) txn#0)
        let tmp%6#0: bool = (== tmp%5#0 6u)
        goto tmp%6#0 ? block@4 : block@9
    block@4: // and_contd_L193
        let tmp%7#0: uint64 = ((gtxns ApplicationID) txn#0)
        let tmp%8#0: uint64 = (global CurrentApplicationID)
        let tmp%9#0: bool = (== tmp%7#0 tmp%8#0)
        goto tmp%9#0 ? block@5 : block@9
    block@5: // and_contd_L193
        let tmp%10#0: uint64 = ((gtxns NumAppArgs) txn#0)
        let tmp%11#0: bool = (== tmp%10#0 1u)
        goto tmp%11#0 ? block@6 : block@9
    block@6: // and_contd_L193
        let tmp%12#0: uint64 = ((gtxns OnCompletion) txn#0)
        goto tmp%12#0 ? block@9 : block@7
    block@7: // and_contd_L193
        let tmp%14#0: bytes = ((gtxnsas ApplicationArgs) txn#0 0u)
        let tmp%15#0: bool = (== tmp%14#0 method "arc58_verifyAuthAddr()void")
        goto tmp%15#0 ? block@8 : block@9
    block@8: // bool_true_L193
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L193
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L193
        let and_result%0#2: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        return and_result%0#2

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key.application: uint64, key.allowedCaller: bytes[32]) -> <bool, bool, bool, bool, bool, bool>:
    block@0: // L215
        let val_as_bytes%0#0: bytes[8] = (itob key.application#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, exists#0: bool) = (box_len box_prefixed_key%0#0)
        goto exists#0 ? block@2 : block@1
    block@1: // if_body_L218
        return 0u 1u 1u 1u 0u 0u
    block@2: // after_if_else_L218
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%0#0 0u)
        let pluginInfo.lastValid#0: uint64 = (extract_uint64 maybe_value%0#0 10u)
        let pluginInfo.cooldown#0: uint64 = (extract_uint64 maybe_value%0#0 18u)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let pluginInfo.methods#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        let is_true%1#0: uint64 = (getbit maybe_value%0#0 224u)
        let is_true%2#0: uint64 = (getbit maybe_value%0#0 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let pluginInfo.useRounds#0: bool = (getbit encoded_bool%2#0 0u)
        let pluginInfo.lastCalled#0: uint64 = (extract_uint64 maybe_value%0#0 29u)
        goto pluginInfo.useRounds#0 ? block@3 : block@4
    block@3: // ternary_true_L230
        let ternary_result%0#0: uint64 = (global Round)
        goto block@5
    block@4: // ternary_false_L230
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@5
    block@5: // ternary_merge_L230
        let epochRef#0: uint64 = φ(ternary_result%0#0 <- block@3, ternary_result%0#1 <- block@4)
        let expired#0: bool = (> epochRef#0 pluginInfo.lastValid#0)
        let hasCooldown#0: bool = (> pluginInfo.cooldown#0 0u)
        let tmp%0#0: uint64 = (- epochRef#0 pluginInfo.lastCalled#0)
        let onCooldown#0: bool = (< tmp%0#0 pluginInfo.cooldown#0)
        let tmp%1#0: uint64 = (extract_uint16 pluginInfo.methods#0 0u)
        let hasMethodRestrictions#0: bool = (> tmp%1#0 0u)
        goto exists#0 ? block@6 : block@9
    block@6: // and_contd_L237
        goto expired#0 ? block@9 : block@7
    block@7: // and_contd_L237
        goto onCooldown#0 ? block@9 : block@8
    block@8: // bool_true_L237
        let and_result%0#0: bool = 1u
        goto block@10
    block@9: // bool_false_L237
        let and_result%0#1: bool = 0u
        goto block@10
    block@10: // bool_merge_L237
        let valid#0: bool = φ(and_result%0#0 <- block@8, and_result%0#1 <- block@9)
        return exists#0 expired#0 hasCooldown#0 onCooldown#0 hasMethodRestrictions#0 valid#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(version: bytes, controlledAddress: bytes[32], admin: bytes[32], spendingAccountFactoryApp: uint64, revocationApp: uint64, nickname: bytes) -> void:
    block@0: // L527
        let tmp%0#0: uint64 = (global CallerApplicationID)
        (assert tmp%0#0) // This contract must be deployed from a factory
        let tmp%2#0: bool = (!= admin#0 controlledAddress#0)
        (assert tmp%2#0)
        (app_global_put "version" version#0)
        (app_global_put "admin" admin#0)
        let tmp%3#0: bytes[32] = (global ZeroAddress)
        let tmp%4#0: bool = (== controlledAddress#0 tmp%3#0)
        goto tmp%4#0 ? block@1 : block@2
    block@1: // ternary_true_L542
        let ternary_result%0#0: bytes[32] = (global CurrentApplicationAddress)
        goto block@3
    block@2: // ternary_false_L542
        goto block@3
    block@3: // ternary_merge_L542
        let ternary_result%0#2: bytes[32] = φ(ternary_result%0#0 <- block@1, controlledAddress#0 <- block@2)
        (app_global_put "controlled_address" ternary_result%0#2)
        (app_global_put "spending_account_factory_app" spendingAccountFactoryApp#0)
        let materialized_values%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" materialized_values%0#0)
        (app_global_put "revocation_app" revocationApp#0)
        (app_global_put "nickname" nickname#0)
        let materialized_values%1#0: uint64 = (global CallerApplicationID)
        (app_global_put "factory_app" materialized_values%1#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(version: bytes) -> void:
    block@0: // L553
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can update the application
        (app_global_put "version" version#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(newRevocationApp: uint64) -> void:
    block@0: // L566
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the revocation app
        (app_global_put "revocation_app" newRevocationApp#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(nickname: bytes) -> void:
    block@0: // L576
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        (app_global_put "nickname" nickname#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(avatar: uint64) -> void:
    block@0: // L586
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(avatar#0)
        let byte_len%0#0: uint64 = (len encoded%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 encoded%0#0)
        let amount#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(concat_result%0#0)
        let tmp%1#0: uint64 = (extract_uint64 amount#0 2u)
        (assert tmp%1#0) // The account does not hold the asset
        (app_global_put "avatar" avatar#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(banner: uint64) -> void:
    block@0: // L598
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(banner#0)
        let byte_len%0#0: uint64 = (len encoded%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 encoded%0#0)
        let amount#0: encoded_uint64[] = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(concat_result%0#0)
        let tmp%1#0: uint64 = (extract_uint64 amount#0 2u)
        (assert tmp%1#0) // The account does not hold the asset
        (app_global_put "banner" banner#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(bio: bytes) -> void:
    block@0: // L610
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the nickname
        (app_global_put "bio" bio#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes[32]) -> void:
    block@0: // L620
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can change the admin account
        (app_global_put "admin" newAdmin#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: bytes[32], newAdmin: bytes[32]) -> void:
    block@0: // L635
        let tmp%0#0: bytes[32] = (txn Sender)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%0#0) // application exists
        let tmp%1#0: bool = (== tmp%0#0 value%0#0)
        (assert tmp%1#0) // sender must be admin plugin
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%1#0: bytes[32], check%1#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%1#0) // account funded
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%2#0) // application exists
        let tmp%2#0: bool = (== value%1#0 value%2#0)
        (assert tmp%2#0) // This plugin is not in control of the account
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        goto maybe_exists%1#0 ? block@1 : block@3
    block@1: // and_contd_L645
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let is_true%0#0: uint64 = (getbit maybe_value%1#0 0u)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u is_true%0#0)
        let tmp%3#0: bool = (getbit encoded_bool%0#0 0u)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L645
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L645
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L645
        let and_result%0#2: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // This plugin does not have admin privileges
        (app_global_put "admin" newAdmin#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%3#0) // Box must have value
        let tmp%4#0: bytes = ((extract 1 1) maybe_value%2#0) // on error: Index access is out of bounds
        let tmp%5#0: bool = (== tmp%4#0 0x01)
        goto tmp%5#0 ? block@5 : block@6
    block@5: // if_body_L650
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@6
    block@6: // after_if_else_L650
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
    block@0: // L659
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((acct_params_get AcctAuthAddr) maybe_value%0#0)
        (assert check%0#0) // account funded
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let tmp%0#1: bool = (== maybe_value%0#0 maybe_value%1#0)
        goto tmp%0#1 ? block@2 : block@6
    block@2: // ternary_true_L508
        let (maybe_value%2#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%1#1: bytes[32] = (global CurrentApplicationAddress)
        let tmp%2#0: bool = (== maybe_value%2#0 tmp%1#1)
        goto tmp%2#0 ? block@3 : block@4
    block@3: // ternary_true_L509
        let ternary_result%1#0: bytes[32] = (global ZeroAddress)
        goto block@5
    block@4: // ternary_false_L509
        let ternary_result%1#1: bytes[32] = (global CurrentApplicationAddress)
        goto block@5
    block@5: // ternary_merge_L509
        let ternary_result%1#2: bytes[32] = φ(ternary_result%1#0 <- block@3, ternary_result%1#1 <- block@4)
        goto block@7
    block@6: // ternary_false_L508
        let ternary_result%0#1: bytes[32] = (global ZeroAddress)
        goto block@7
    block@7: // ternary_merge_L508
        let ternary_result%0#2: bytes[32] = φ(ternary_result%1#2 <- block@5, ternary_result%0#1 <- block@6)
        let tmp%1#0: bool = (== value%0#0 ternary_result%0#2)
        (assert tmp%1#0)
        let materialized_values%0#0: bytes[32] = (global ZeroAddress)
        (app_global_put "spending_address" materialized_values%0#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes[32], flash: bool) -> void:
    block@0: // L670
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // admin only
        itxn_begin
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        ((itxn_field Note) "rekeying abstracted account")
        ((itxn_field RekeyTo) address#0)
        ((itxn_field Receiver) address#0)
        ((itxn_field Sender) maybe_value%0#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto flash#0 ? block@2 : block@3
    block@2: // if_body_L683
        let rekeysBack#0: bool = 0u
        let tmp%0#1: uint64 = (txn GroupIndex)
        let i#0: uint64 = (+ tmp%0#1 1u)
        goto block@5
    block@5: // while_top_L203
        let i#1: uint64 = φ(i#0 <- block@2, i#2 <- block@8)
        let tmp%1#0: uint64 = (global GroupSize)
        let tmp%2#0: bool = (< i#1 tmp%1#0)
        goto tmp%2#0 ? block@6 : block@9
    block@6: // while_body_L203
        let tmp%3#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(i#1)
        goto tmp%3#0 ? block@7 : block@8
    block@7: // if_body_L206
        let rekeysBack#1: bool = 1u
        goto block@10
    block@8: // after_if_else_L206
        let i#2: uint64 = (+ i#1 1u)
        goto block@5
    block@9: // after_while_L203
        goto block@10
    block@10: // L203
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@7, rekeysBack#0 <- block@9)
        (assert rekeysBack#2) // missing rekey back
        goto block@3
    block@3: // after_if_else_L683
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: bool, address: bytes[32], method: bytes[4]) -> bool:
    block@0: // L696
        goto global#0 ? block@1 : block@2
    block@1: // if_body_L703
        let tmp%0#0: bytes[32] = (global ZeroAddress)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, tmp%0#0, method#0)
        goto block@2
    block@2: // after_if_else_L703
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin#0, address#0, method#0)
        return tmp%1#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: bool, methodOffsets: encoded_uint64[], fundsRequest: (encoded_uint64,encoded_uint64)[]) -> void:
    block@0: // L718
        goto global#0 ? block@1 : block@2
    block@1: // ternary_true_L728
        let ternary_result%0#0: bytes[32] = (global ZeroAddress)
        goto block@3
    block@2: // ternary_false_L728
        let ternary_result%0#1: bytes[32] = (txn Sender)
        goto block@3
    block@3: // ternary_merge_L728
        let key.allowedCaller#0: bytes[32] = φ(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 key.allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let (maybe_value%0#3: bytes, maybe_exists%0#3: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#3) // Box must have value
        let is_true%0#1: uint64 = (getbit maybe_value%0#3 225u)
        let encoded_bool%0#1: bytes[1] = (setbit 0x00 0u is_true%0#1)
        let tmp%0#3: bool = (getbit encoded_bool%0#1 0u)
        goto tmp%0#3 ? block@35 : block@36
    block@35: // ternary_true_L293
        let ternary_result%0#5: uint64 = (global Round)
        goto block@37
    block@36: // ternary_false_L293
        let ternary_result%0#6: uint64 = (global LatestTimestamp)
        goto block@37
    block@37: // ternary_merge_L293
        let epochRef#1: uint64 = φ(ternary_result%0#5 <- block@35, ternary_result%0#6 <- block@36)
        let (initialCheck.exists#0: bool, initialCheck.expired#0: bool, initialCheck.hasCooldown#0: bool, initialCheck.onCooldown#0: bool, initialCheck.hasMethodRestrictions#0: bool, initialCheck.valid#0: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(plugin#0, key.allowedCaller#0)
        (assert initialCheck.exists#0) // Plugin does not exist
        let tmp%1#3: bool = (! initialCheck.expired#0)
        (assert tmp%1#3) // plugin expired
        let tmp%2#3: bool = (! initialCheck.onCooldown#0)
        (assert tmp%2#3) // plugin on cooldown
        let rekeysBack#0: bool = 0u
        let methodIndex#0: uint64 = 0u
        let tmp%3#2: uint64 = (txn GroupIndex)
        let i#4: uint64 = (+ tmp%3#2 1u)
        goto block@38
    block@38: // while_top_L306
        let i#5: uint64 = φ(i#4 <- block@37, i#7 <- block@68)
        let methodIndex#1: uint64 = φ(methodIndex#0 <- block@37, methodIndex#4 <- block@68)
        let tmp%4#2: uint64 = (global GroupSize)
        let tmp%5#2: bool = (< i#5 tmp%4#2)
        goto tmp%5#2 ? block@39 : block@69
    block@39: // while_body_L306
        let tmp%6#1: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(i#5)
        goto tmp%6#1 ? block@40 : block@41
    block@40: // if_body_L309
        let rekeysBack#1: bool = 1u
        goto block@70
    block@41: // after_if_else_L309
        let tmp%7#1: uint64 = ((gtxns TypeEnum) i#5)
        let tmp%8#1: bool = (!= tmp%7#1 6u)
        goto tmp%8#1 ? block@42 : block@43
    block@42: // if_body_L314
        goto block@68
    block@43: // after_if_else_L314
        let tmp%9#1: uint64 = ((gtxns ApplicationID) i#5)
        let tmp%10#1: bool = (== tmp%9#1 plugin#0)
        (assert tmp%10#1) // cannot call other apps during rekey
        let tmp%11#1: uint64 = ((gtxns OnCompletion) i#5)
        let tmp%12#1: bool = (! tmp%11#1)
        (assert tmp%12#1) // invalid oncomplete must be no op
        let tmp%13#1: uint64 = ((gtxns NumAppArgs) i#5)
        let tmp%14#0: bool = (> tmp%13#1 1u)
        (assert tmp%14#0) // invalid sender must be this app id
        let tmp%15#0: bytes = ((gtxnsas ApplicationArgs) i#5 1u)
        let tmp%16#0: uint64 = (btoi tmp%15#0)
        let tmp%17#0: uint64 = (global CurrentApplicationID)
        let tmp%18#0: bool = (== tmp%16#0 tmp%17#0)
        (assert tmp%18#0) // invalid sender app id
        let (check.exists#1: bool, check.expired#1: bool, check.hasCooldown#1: bool, check.onCooldown#1: bool, check.hasMethodRestrictions#1: bool, check.valid#1: bool) = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(plugin#0, key.allowedCaller#0)
        goto check.valid#1 ? block@45 : block@44
    block@44: // if_body_L258
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.fullPluginCheck%7#0: bool = 1u
        goto block@65
    block@45: // after_if_else_L258
        let mCheck.methodAllowed#0: bool = (! check.hasMethodRestrictions#1)
        let mCheck.methodOnCooldown#0: bool = 0u
        goto check.hasMethodRestrictions#1 ? block@46 : block@60
    block@46: // if_body_L273
        let tmp%1#4: uint64 = (extract_uint16 methodOffsets#0 0u)
        let tmp%2#4: bool = (< methodIndex#1 tmp%1#4)
        (assert tmp%2#4) // malformed method offsets
        let array_head_and_tail%0#1: bytes = ((extract 2 0) methodOffsets#0)
        let item_offset%0#1: uint64 = (* methodIndex#1 8u)
        let offset#0: uint64 = (extract_uint64 array_head_and_tail%0#1 item_offset%0#1)
        let selectorArg#0: bytes[4] = ((gtxnsas ApplicationArgs) i#5 0u)
        let tmp%1#5: uint64 = (len selectorArg#0)
        let tmp%2#5: bool = (== tmp%1#5 4u)
        (assert tmp%2#5) // invalid method signature length
        let (maybe_value%0#4: bytes, maybe_exists%0#4: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#4) // Box must have value
        let item_start_offset%0#2: uint64 = (extract_uint16 maybe_value%0#4 26u)
        let item_end_offset%0#2: uint64 = (len maybe_value%0#4)
        let methods#0: bytes = (substring3 maybe_value%0#4 item_start_offset%0#2 item_end_offset%0#2)
        let array_head_and_tail%0#2: bytes = ((extract 2 0) methods#0)
        let item_offset%0#2: uint64 = (* offset#0 20u)
        let allowedMethod#0: bytes[20] = (extract3 array_head_and_tail%0#2 item_offset%0#2 20u) // on error: Index access is out of bounds
        let tmp%8#2: uint64 = (extract_uint64 allowedMethod#0 4u)
        let hasCooldown#0: bool = (> tmp%8#2 0u)
        let is_true%0#2: uint64 = (getbit maybe_value%0#4 225u)
        let encoded_bool%0#2: bytes[1] = (setbit 0x00 0u is_true%0#2)
        let useRounds#0: bool = (getbit encoded_bool%0#2 0u)
        goto useRounds#0 ? block@47 : block@48
    block@47: // ternary_true_L363
        let ternary_result%0#8: uint64 = (global Round)
        goto block@49
    block@48: // ternary_false_L363
        let ternary_result%0#9: uint64 = (global LatestTimestamp)
        goto block@49
    block@49: // ternary_merge_L363
        let epochRef#2: uint64 = φ(ternary_result%0#8 <- block@47, ternary_result%0#9 <- block@48)
        let tmp%11#2: uint64 = (extract_uint64 allowedMethod#0 12u)
        let tmp%12#2: uint64 = (- epochRef#2 tmp%11#2)
        let onCooldown#0: bool = (< tmp%12#2 tmp%8#2)
        let tmp%17#1: bytes = ((extract 0 4) allowedMethod#0) // on error: Index access is out of bounds
        let tmp%18#1: bool = (== tmp%17#1 selectorArg#0)
        goto tmp%18#1 ? block@50 : block@58
    block@50: // and_contd_L366
        goto tmp%8#2 ? block@51 : block@52
    block@51: // or_contd_L366
        goto onCooldown#0 ? block@58 : block@52
    block@52: // if_body_L366
        goto tmp%8#2 ? block@53 : block@57
    block@53: // if_body_L368
        goto useRounds#0 ? block@54 : block@55
    block@54: // ternary_true_L369
        let ternary_result%1#2: uint64 = (global Round)
        goto block@56
    block@55: // ternary_false_L369
        let ternary_result%1#3: uint64 = (global LatestTimestamp)
        goto block@56
    block@56: // ternary_merge_L369
        let lastCalled#0: uint64 = φ(ternary_result%1#2 <- block@54, ternary_result%1#3 <- block@55)
        let val_as_bytes%2#2: bytes[8] = (itob lastCalled#0)
        let updated_data%0#0: bytes = ((replace2 12) allowedMethod#0 val_as_bytes%2#2)
        let array_length%0#0: uint64 = (extract_uint16 methods#0 0u)
        let index_is_in_bounds%0#0: bool = (< offset#0 array_length%0#0)
        (assert index_is_in_bounds%0#0) // Index access is out of bounds
        let write_offset%0#1: uint64 = (+ item_offset%0#2 2u)
        let methods#4: bytes = (replace3 methods#0 write_offset%0#1 updated_data%0#0)
        let (maybe_value%2#4: bytes, maybe_exists%2#4: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#4) // Box must have value
        let is_true%1#2: uint64 = (getbit maybe_value%2#4 0u)
        let encoded_bool%1#2: bytes[1] = (setbit 0x00 0u is_true%1#2)
        let tmp%20#1: bytes = ((extract 1 1) maybe_value%2#4) // on error: Index access is out of bounds
        let tmp%21#1: bytes = ((extract 2 8) maybe_value%2#4) // on error: Index access is out of bounds
        let tmp%22#1: bytes = ((extract 10 8) maybe_value%2#4) // on error: Index access is out of bounds
        let tmp%23#1: bytes = ((extract 18 8) maybe_value%2#4) // on error: Index access is out of bounds
        let is_true%2#2: uint64 = (getbit maybe_value%2#4 224u)
        let encoded_bool%2#2: bytes[1] = (setbit 0x00 0u is_true%2#2)
        let is_true%3#1: uint64 = (getbit maybe_value%2#4 225u)
        let encoded_bool%3#1: bytes[1] = (setbit 0x00 0u is_true%3#1)
        let tmp%24#1: bytes = ((extract 29 8) maybe_value%2#4) // on error: Index access is out of bounds
        let tmp%25#1: bytes = ((extract 37 8) maybe_value%2#4) // on error: Index access is out of bounds
        let encoded_tuple_buffer%35#2: bytes = (concat encoded_bool%1#2 tmp%20#1)
        let encoded_tuple_buffer%36#2: bytes = (concat encoded_tuple_buffer%35#2 tmp%21#1)
        let encoded_tuple_buffer%37#2: bytes = (concat encoded_tuple_buffer%36#2 tmp%22#1)
        let encoded_tuple_buffer%38#2: bytes = (concat encoded_tuple_buffer%37#2 tmp%23#1)
        let encoded_tuple_buffer%39#1: bytes = (concat encoded_tuple_buffer%38#2 0x002d)
        let encoded_tuple_buffer%40#1: bytes = (concat encoded_tuple_buffer%39#1 encoded_bool%2#2)
        let is_true%4#1: uint64 = (getbit encoded_bool%3#1 0u)
        let encoded_tuple_buffer%41#1: bytes = (setbit encoded_tuple_buffer%40#1 225u is_true%4#1)
        let encoded_tuple_buffer%42#1: bytes = (concat encoded_tuple_buffer%41#1 tmp%24#1)
        let encoded_tuple_buffer%43#1: bytes = (concat encoded_tuple_buffer%42#1 tmp%25#1)
        let encoded_tuple_buffer%44#1: bytes = (concat encoded_tuple_buffer%43#1 methods#4)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%44#1)
        goto block@57
    block@57: // after_if_else_L368
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%0#0: bool = 1u
        goto block@59
    block@58: // after_if_else_L366
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%0#1: bool = 0u
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%1#1: bool = 1u
        let smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%2#1: bool = 1u
        goto block@59
    block@59: // after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck_L273
        let mCheck.methodAllowed#1: bool = φ(smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%0#0 <- block@57, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%0#1 <- block@58)
        let mCheck.methodOnCooldown#1: bool = φ(onCooldown#0 <- block@57, smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck%2#1 <- block@58)
        goto block@60
    block@60: // after_if_else_L273
        let mCheck.methodAllowed#2: bool = φ(mCheck.methodAllowed#0 <- block@45, mCheck.methodAllowed#1 <- block@59)
        let mCheck.methodOnCooldown#2: bool = φ(mCheck.methodOnCooldown#0 <- block@45, mCheck.methodOnCooldown#1 <- block@59)
        goto check.valid#1 ? block@61 : block@63
    block@61: // and_contd_L281
        goto mCheck.methodAllowed#2 ? block@62 : block@63
    block@62: // bool_true_L281
        let and_result%0#0: bool = 1u
        goto block@64
    block@63: // bool_false_L281
        let and_result%0#1: bool = 0u
        goto block@64
    block@64: // bool_merge_L281
        let and_result%0#2: bool = φ(and_result%0#0 <- block@62, and_result%0#1 <- block@63)
        goto block@65
    block@65: // after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.fullPluginCheck_L314
        let check.methodOnCooldown#0: bool = φ(smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.fullPluginCheck%7#0 <- block@44, mCheck.methodOnCooldown#2 <- block@64)
        let check.valid#0: bool = φ(check.valid#1 <- block@44, and_result%0#2 <- block@64)
        let tmp%19#0: bool = (! check.methodOnCooldown#0)
        (assert tmp%19#0) // method on cooldown
        (assert check.valid#0) // invalid plugin call
        goto initialCheck.hasCooldown#0 ? block@66 : block@67
    block@66: // if_body_L330
        let val_as_bytes%1#2: bytes[8] = (itob epochRef#1)
        let (maybe_value%1#3: bytes, maybe_exists%1#3: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#3) // Box must have value
        let is_true%1#1: uint64 = (getbit maybe_value%1#3 0u)
        let encoded_bool%1#1: bytes[1] = (setbit 0x00 0u is_true%1#1)
        let tmp%20#0: bytes = ((extract 1 1) maybe_value%1#3) // on error: Index access is out of bounds
        let tmp%21#0: bytes = ((extract 2 8) maybe_value%1#3) // on error: Index access is out of bounds
        let tmp%22#0: bytes = ((extract 10 8) maybe_value%1#3) // on error: Index access is out of bounds
        let tmp%23#0: bytes = ((extract 18 8) maybe_value%1#3) // on error: Index access is out of bounds
        let item_start_offset%0#1: uint64 = (extract_uint16 maybe_value%1#3 26u)
        let item_end_offset%0#1: uint64 = (len maybe_value%1#3)
        let tmp%24#0: bytes = (substring3 maybe_value%1#3 item_start_offset%0#1 item_end_offset%0#1)
        let is_true%2#1: uint64 = (getbit maybe_value%1#3 224u)
        let encoded_bool%2#1: bytes[1] = (setbit 0x00 0u is_true%2#1)
        let is_true%3#0: uint64 = (getbit maybe_value%1#3 225u)
        let encoded_bool%3#0: bytes[1] = (setbit 0x00 0u is_true%3#0)
        let tmp%25#0: bytes = ((extract 37 8) maybe_value%1#3) // on error: Index access is out of bounds
        let encoded_tuple_buffer%32#0: bytes = (concat encoded_bool%1#1 tmp%20#0)
        let encoded_tuple_buffer%33#0: bytes = (concat encoded_tuple_buffer%32#0 tmp%21#0)
        let encoded_tuple_buffer%34#1: bytes = (concat encoded_tuple_buffer%33#0 tmp%22#0)
        let encoded_tuple_buffer%35#1: bytes = (concat encoded_tuple_buffer%34#1 tmp%23#0)
        let encoded_tuple_buffer%36#1: bytes = (concat encoded_tuple_buffer%35#1 0x002d)
        let encoded_tuple_buffer%37#1: bytes = (concat encoded_tuple_buffer%36#1 encoded_bool%2#1)
        let is_true%4#0: uint64 = (getbit encoded_bool%3#0 0u)
        let encoded_tuple_buffer%38#1: bytes = (setbit encoded_tuple_buffer%37#1 225u is_true%4#0)
        let encoded_tuple_buffer%39#0: bytes = (concat encoded_tuple_buffer%38#1 val_as_bytes%1#2)
        let encoded_tuple_buffer%40#0: bytes = (concat encoded_tuple_buffer%39#0 tmp%25#0)
        let encoded_tuple_buffer%41#0: bytes = (concat encoded_tuple_buffer%40#0 tmp%24#0)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%41#0)
        goto block@67
    block@67: // after_if_else_L330
        let methodIndex#3: uint64 = (+ methodIndex#1 1u)
        goto block@68
    block@68: // L306
        let methodIndex#4: uint64 = φ(methodIndex#1 <- block@42, methodIndex#3 <- block@67)
        let i#7: uint64 = (+ i#5 1u)
        goto block@38
    block@69: // after_while_L306
        goto block@70
    block@70: // L306
        let rekeysBack#2: bool = φ(rekeysBack#1 <- block@40, rekeysBack#0 <- block@69)
        (assert rekeysBack#2) // missing rekey back
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let tmp%1#0: uint64 = (extract_uint64 maybe_value%0#0 2u)
        goto tmp%1#0 ? block@4 : block@6
    block@4: // if_body_L737
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%2#0) // Box must have value
        let spendingApp#0: uint64 = (extract_uint64 maybe_value%1#0 2u)
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) spendingApp#0)
        (assert check%0#0) // application exists
        (app_global_put "spending_address" value%0#0)
        let i#0: uint64 = 0u
        goto block@12
    block@12: // while_top_L396
        let i#1: uint64 = φ(i#0 <- block@4, i#3 <- block@31)
        let tmp%0#1: uint64 = (extract_uint16 fundsRequest#0 0u)
        let tmp%1#1: bool = (< i#1 tmp%0#1)
        goto tmp%1#1 ? block@13 : block@32
    block@13: // while_body_L396
        let (maybe_value%0#1: bytes, maybe_exists%0#1: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#1) // Box must have value
        let is_true%2#0: uint64 = (getbit maybe_value%0#1 225u)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u is_true%2#0)
        let pluginInfo.useRounds#0: bool = (getbit encoded_bool%2#0 0u)
        let pluginInfo.start#0: uint64 = (extract_uint64 maybe_value%0#1 37u)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) fundsRequest#0)
        let item_offset%0#0: uint64 = (* i#1 16u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 16u) // on error: Index access is out of bounds
        let allowanceKey.asset#0: uint64 = (extract_uint64 arc4_item%0#0 0u)
        let fundRequest.amount#0: uint64 = (extract_uint64 arc4_item%0#0 8u)
        let val_as_bytes%1#1: bytes[8] = (itob allowanceKey.asset#0)
        let encoded_tuple_buffer%3#1: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%1#1)
        let box_prefixed_key%0#2: bytes = (concat "a" encoded_tuple_buffer%3#1)
        let (_%0#1: uint64, maybe_exists%0#2: bool) = (box_len box_prefixed_key%0#2)
        (assert maybe_exists%0#2) // Allowance does not exist
        let (maybe_value%0#2: bytes, maybe_exists%1#2: bool) = (box_get box_prefixed_key%0#2)
        (assert maybe_exists%1#2) // Box must have value
        let type#0: bytes[1] = ((extract 0 1) maybe_value%0#2) // on error: Index access is out of bounds
        let max#0: uint64 = (extract_uint64 maybe_value%0#2 1u)
        let allowed#0: uint64 = (extract_uint64 maybe_value%0#2 9u)
        let spent#0: uint64 = (extract_uint64 maybe_value%0#2 17u)
        let interval#0: uint64 = (extract_uint64 maybe_value%0#2 25u)
        let last#0: uint64 = (extract_uint64 maybe_value%0#2 33u)
        goto pluginInfo.useRounds#0 ? block@14 : block@15
    block@14: // ternary_true_L444
        let ternary_result%0#3: uint64 = (global Round)
        goto block@16
    block@15: // ternary_false_L444
        let ternary_result%0#4: uint64 = (global LatestTimestamp)
        goto block@16
    block@16: // ternary_merge_L444
        let newLast#0: uint64 = φ(ternary_result%0#3 <- block@14, ternary_result%0#4 <- block@15)
        let tmp%0#2: bool = (== type#0 0x01)
        goto tmp%0#2 ? block@17 : block@18
    block@17: // if_body_L448
        let leftover#0: uint64 = (- allowed#0 spent#0)
        let tmp%1#2: bool = (>= leftover#0 fundRequest.amount#0)
        (assert tmp%1#2) // Allowance exceeded
        let tmp%2#2: uint64 = (+ spent#0 fundRequest.amount#0)
        let (maybe_value%1#2: bytes, maybe_exists%2#2: bool) = (box_get box_prefixed_key%0#2)
        (assert maybe_exists%2#2) // Box must have value
        let item0%1#1: bytes = ((extract 0 1) maybe_value%1#2) // on error: Index access is out of bounds
        let item1%5#1: uint64 = (extract_uint64 maybe_value%1#2 1u)
        let item2%7#0: uint64 = (extract_uint64 maybe_value%1#2 9u)
        let item4%9#0: uint64 = (extract_uint64 maybe_value%1#2 25u)
        let item5%11#0: uint64 = (extract_uint64 maybe_value%1#2 33u)
        let val_as_bytes%16#0: bytes[8] = (itob item1%5#1)
        let val_as_bytes%17#0: bytes[8] = (itob item2%7#0)
        let val_as_bytes%18#0: bytes[8] = (itob tmp%2#2)
        let val_as_bytes%19#0: bytes[8] = (itob item4%9#0)
        let val_as_bytes%20#0: bytes[8] = (itob item5%11#0)
        let encoded_tuple_buffer%34#0: bytes = (concat item0%1#1 val_as_bytes%16#0)
        let encoded_tuple_buffer%35#0: bytes = (concat encoded_tuple_buffer%34#0 val_as_bytes%17#0)
        let encoded_tuple_buffer%36#0: bytes = (concat encoded_tuple_buffer%35#0 val_as_bytes%18#0)
        let encoded_tuple_buffer%37#0: bytes = (concat encoded_tuple_buffer%36#0 val_as_bytes%19#0)
        let encoded_tuple_buffer%38#0: bytes = (concat encoded_tuple_buffer%37#0 val_as_bytes%20#0)
        (box_put box_prefixed_key%0#2 encoded_tuple_buffer%38#0)
        goto block@28
    block@18: // else_body_L457
        let tmp%3#1: bool = (== type#0 0x02)
        goto tmp%3#1 ? block@19 : block@23
    block@19: // if_body_L457
        goto pluginInfo.useRounds#0 ? block@72 : block@73
    block@72: // if_body_L497
        let tmp%0#4: uint64 = (global Round)
        let tmp%1#6: uint64 = (global Round)
        let tmp%2#6: uint64 = (- tmp%1#6 pluginInfo.start#0)
        let tmp%3#3: uint64 = (% tmp%2#6 interval#0)
        let tmp%4#3: uint64 = (- tmp%0#4 tmp%3#3)
        goto block@74
    block@73: // after_if_else_L497
        let tmp%5#3: uint64 = (global LatestTimestamp)
        let tmp%6#2: uint64 = (global LatestTimestamp)
        let tmp%7#2: uint64 = (- tmp%6#2 pluginInfo.start#0)
        let tmp%8#3: uint64 = (% tmp%7#2 interval#0)
        let tmp%9#2: uint64 = (- tmp%5#3 tmp%8#3)
        goto block@74
    block@74: // after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart_L457
        let currentWindowStart#0: uint64 = φ(tmp%4#3 <- block@72, tmp%9#2 <- block@73)
        let tmp%4#1: bool = (> currentWindowStart#0 last#0)
        goto tmp%4#1 ? block@20 : block@21
    block@20: // if_body_L460
        let tmp%5#1: bool = (>= allowed#0 fundRequest.amount#0)
        (assert tmp%5#1) // Allowance exceeded
        goto block@22
    block@21: // else_body_L462
        let leftover₁#0: uint64 = (- allowed#0 spent#0)
        let tmp%6#0: bool = (>= leftover₁#0 fundRequest.amount#0)
        (assert tmp%6#0) // Allowance exceeded
        goto block@22
    block@22: // after_if_else_L460
        let tmp%7#0: uint64 = (+ spent#0 fundRequest.amount#0)
        let (maybe_value%6#0: bytes, maybe_exists%7#0: bool) = (box_get box_prefixed_key%0#2)
        (assert maybe_exists%7#0) // Box must have value
        let item0%6#1: bytes = ((extract 0 1) maybe_value%6#0) // on error: Index access is out of bounds
        let item1%15#0: uint64 = (extract_uint64 maybe_value%6#0 1u)
        let item2%17#0: uint64 = (extract_uint64 maybe_value%6#0 9u)
        let item4%19#0: uint64 = (extract_uint64 maybe_value%6#0 25u)
        let val_as_bytes%31#0: bytes[8] = (itob item1%15#0)
        let val_as_bytes%32#0: bytes[8] = (itob item2%17#0)
        let val_as_bytes%33#0: bytes[8] = (itob tmp%7#0)
        let val_as_bytes%34#0: bytes[8] = (itob item4%19#0)
        let val_as_bytes%35#0: bytes[8] = (itob newLast#0)
        let encoded_tuple_buffer%61#0: bytes = (concat item0%6#1 val_as_bytes%31#0)
        let encoded_tuple_buffer%62#0: bytes = (concat encoded_tuple_buffer%61#0 val_as_bytes%32#0)
        let encoded_tuple_buffer%63#0: bytes = (concat encoded_tuple_buffer%62#0 val_as_bytes%33#0)
        let encoded_tuple_buffer%64#0: bytes = (concat encoded_tuple_buffer%63#0 val_as_bytes%34#0)
        let encoded_tuple_buffer%65#0: bytes = (concat encoded_tuple_buffer%64#0 val_as_bytes%35#0)
        (box_put box_prefixed_key%0#2 encoded_tuple_buffer%65#0)
        goto block@28
    block@23: // else_body_L474
        let tmp%8#0: bool = (== type#0 0x03)
        goto tmp%8#0 ? block@24 : block@28
    block@24: // if_body_L474
        goto pluginInfo.useRounds#0 ? block@25 : block@26
    block@25: // ternary_true_L475
        let ternary_result%1#0: uint64 = (global Round)
        goto block@27
    block@26: // ternary_false_L475
        let ternary_result%1#1: uint64 = (global LatestTimestamp)
        goto block@27
    block@27: // ternary_merge_L475
        let epochRef#0: uint64 = φ(ternary_result%1#0 <- block@25, ternary_result%1#1 <- block@26)
        let passed#0: uint64 = (- epochRef#0 last#0)
        let tmp%9#0: uint64 = (/ passed#0 interval#0)
        let tmp%10#0: uint64 = (* tmp%9#0 allowed#0)
        let accrued#0: uint64 = (+ spent#0 tmp%10#0)
        let tmp%11#0: bool = (> accrued#0 max#0)
        let available#0: uint64 = (select accrued#0 max#0 tmp%11#0)
        let tmp%12#0: bool = (>= available#0 fundRequest.amount#0)
        (assert tmp%12#0) // Allowance exceeded
        let tmp%13#0: uint64 = (- available#0 fundRequest.amount#0)
        let (maybe_value%10#0: bytes, maybe_exists%11#0: bool) = (box_get box_prefixed_key%0#2)
        (assert maybe_exists%11#0) // Box must have value
        let item0%10#1: bytes = ((extract 0 1) maybe_value%10#0) // on error: Index access is out of bounds
        let item1%23#0: uint64 = (extract_uint64 maybe_value%10#0 1u)
        let item2%25#0: uint64 = (extract_uint64 maybe_value%10#0 9u)
        let item4%27#0: uint64 = (extract_uint64 maybe_value%10#0 25u)
        let val_as_bytes%46#0: bytes[8] = (itob item1%23#0)
        let val_as_bytes%47#0: bytes[8] = (itob item2%25#0)
        let val_as_bytes%48#0: bytes[8] = (itob tmp%13#0)
        let val_as_bytes%49#0: bytes[8] = (itob item4%27#0)
        let val_as_bytes%50#0: bytes[8] = (itob newLast#0)
        let encoded_tuple_buffer%88#0: bytes = (concat item0%10#1 val_as_bytes%46#0)
        let encoded_tuple_buffer%89#0: bytes = (concat encoded_tuple_buffer%88#0 val_as_bytes%47#0)
        let encoded_tuple_buffer%90#0: bytes = (concat encoded_tuple_buffer%89#0 val_as_bytes%48#0)
        let encoded_tuple_buffer%91#0: bytes = (concat encoded_tuple_buffer%90#0 val_as_bytes%49#0)
        let encoded_tuple_buffer%92#0: bytes = (concat encoded_tuple_buffer%91#0 val_as_bytes%50#0)
        (box_put box_prefixed_key%0#2 encoded_tuple_buffer%92#0)
        goto block@28
    block@28: // after_if_else_L448
        goto allowanceKey.asset#0 ? block@29 : block@30
    block@29: // if_body_L413
        itxn_begin
        let (maybe_value%1#1: bytes, maybe_exists%1#1: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#1) // check GlobalState exists
        let (maybe_value%2#1: bytes, maybe_exists%2#1: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%2#1) // check GlobalState exists
        ((itxn_field XferAsset) allowanceKey.asset#0)
        ((itxn_field AssetAmount) fundRequest.amount#0)
        ((itxn_field AssetReceiver) maybe_value%2#1)
        ((itxn_field Sender) maybe_value%1#1)
        ((itxn_field TypeEnum) 4u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@31
    block@30: // else_body_L423
        itxn_begin
        let (maybe_value%3#1: bytes, maybe_exists%3#1: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#1) // check GlobalState exists
        let (maybe_value%4#1: bytes, maybe_exists%4#1: bool) = (app_global_get_ex 0u "spending_address")
        (assert maybe_exists%4#1) // check GlobalState exists
        ((itxn_field Amount) fundRequest.amount#0)
        ((itxn_field Receiver) maybe_value%4#1)
        ((itxn_field Sender) maybe_value%3#1)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@31
    block@31: // after_if_else_L413
        let i#3: uint64 = (+ i#1 1u)
        goto block@12
    block@32: // after_while_L396
        itxn_begin
        let (value%1#0: bytes[32], check%1#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%1#0) // application exists
        ((itxn_field ApplicationArgs) method "rekey(address)void")
        ((itxn_field ApplicationArgs) value%1#0)
        ((itxn_field ApplicationID) spendingApp#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@8
    block@6: // else_body_L750
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        (app_global_put "spending_address" maybe_value%2#0)
        itxn_begin
        let (value%2#0: bytes[32], check%2#0: bool) = ((app_params_get AppAddress) plugin#0)
        (assert check%2#0) // application exists
        ((itxn_field Note) "rekeying to plugin app")
        ((itxn_field RekeyTo) value%2#0)
        ((itxn_field Receiver) maybe_value%2#0)
        ((itxn_field Sender) maybe_value%2#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@8
    block@8: // after_if_else_L737
        let (maybe_value%5#0: bytes, maybe_exists%6#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%6#0) // Box must have value
        let tmp%4#0: bytes = ((extract 1 1) maybe_value%5#0) // on error: Index access is out of bounds
        let tmp%5#0: bool = (== tmp%4#0 0x01)
        goto tmp%5#0 ? block@9 : block@10
    block@9: // if_body_L764
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        goto block@10
    block@10: // after_if_else_L764
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: bool, methodOffsets: encoded_uint64[], fundsRequest: (encoded_uint64,encoded_uint64)[]) -> void:
    block@0: // L779
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Box must have value
        let item0%1#0: uint64 = (extract_uint64 maybe_value%0#0 0u)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(item0%1#0, global#0, methodOffsets#0, fundsRequest#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: (bytes[4],encoded_uint64)[], useAllowance: bool, useRounds: bool) -> void:
    block@0: // L801
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // admin only
        let tmp%1#0: bool = (== delegationType#0 0x01)
        goto tmp%1#0 ? block@1 : block@3
    block@1: // and_contd_L814
        let tmp%2#0: bytes[32] = (global ZeroAddress)
        let tmp%3#0: bool = (== allowedCaller#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L814
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L814
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L814
        let badDelegationCombo#0: bool = φ(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        let tmp%4#0: bool = (! badDelegationCombo#0)
        (assert tmp%4#0) // delegation type must not be self for global plugins
        let methodInfos#0: bytes = 0x0000
        let i#0: uint64 = 0u
        goto block@5
    block@5: // while_top_L821
        let i#1: uint64 = φ(i#0 <- block@4, i#2 <- block@6)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@4, methodInfos#2 <- block@6)
        let tmp%5#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%6#0: bool = (< i#1 tmp%5#0)
        goto tmp%6#0 ? block@6 : block@7
    block@6: // while_body_L821
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let item0%0#0: bytes = ((extract 0 4) arc4_item%0#0) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (extract_uint64 arc4_item%0#0 4u)
        let val_as_bytes%0#0: bytes[8] = (itob item1%3#0)
        let encoded_tuple_buffer%2#0: bytes = (concat item0%0#0 val_as_bytes%0#0)
        let encoded_tuple_buffer%3#0: bytes = (concat encoded_tuple_buffer%2#0 0x0000000000000000)
        let encoded%0#0: bytes[20][] = encode<bytes[20]>(encoded_tuple_buffer%3#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let methodInfos#2: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let i#2: uint64 = (+ i#1 1u)
        goto block@5
    block@7: // after_while_L821
        goto useRounds#0 ? block@8 : block@9
    block@8: // ternary_true_L831
        let ternary_result%0#0: uint64 = (global Round)
        goto block@10
    block@9: // ternary_false_L831
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@10
    block@10: // ternary_merge_L831
        let epochRef#0: uint64 = φ(ternary_result%0#0 <- block@8, ternary_result%0#1 <- block@9)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%7#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: bool = (!= maybe_value%0#0 tmp%7#0)
        goto tmp%8#0 ? block@11 : block@13
    block@11: // if_body_L833
        itxn_begin
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%10#0: uint64 = (* 13u tmp%5#0)
        let tmp%11#0: uint64 = (* 400u tmp%10#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%11#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) maybe_value%1#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@13
    block@13: // after_if_else_L833
        let spendingApp#0: uint64 = 0u
        goto useAllowance#0 ? block@14 : block@17
    block@14: // if_body_L845
        itxn_begin
        let (maybe_value%2#0: uint64, maybe_exists%2#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%2#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%2#0)
        (assert check%0#0) // application exists
        ((itxn_field Receiver) value%0#0)
        ((itxn_field Amount) 269500u)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let (maybe_value%3#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let val_as_bytes%1#0: bytes[8] = (itob app#0)
        ((itxn_field ApplicationArgs) method "mint(pay,uint64)uint64")
        ((itxn_field ApplicationArgs) val_as_bytes%1#0)
        ((itxn_field ApplicationID) maybe_value%2#0)
        ((itxn_field Sender) maybe_value%3#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (gitxn 1 LastLog)
        let tmp%12#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%13#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%14#0: bool = (== tmp%13#0 0x151f7c75)
        (assert tmp%14#0) // Bytes has valid prefix
        let spendingApp#1: uint64 = (btoi tmp%12#0)
        goto block@17
    block@17: // after_if_else_L845
        let spendingApp#2: uint64 = φ(spendingApp#0 <- block@13, spendingApp#1 <- block@14)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%2#0: bytes[8] = (itob spendingApp#2)
        let val_as_bytes%3#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%4#0: bytes[8] = (itob cooldown#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%5#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_bool%0#0 delegationType#0)
        let encoded_tuple_buffer%7#0: bytes = (concat encoded_tuple_buffer%6#0 val_as_bytes%2#0)
        let encoded_tuple_buffer%8#0: bytes = (concat encoded_tuple_buffer%7#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_tuple_buffer%8#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 0x002d)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%12#0: bytes = (setbit encoded_tuple_buffer%11#0 225u is_true%0#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 0x0000000000000000)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 methodInfos#1)
        let val_as_bytes%6#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%18#0: bytes = (concat val_as_bytes%6#0 allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%18#0)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%15#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(caller: bytes[32], domain: bytes) -> void:
    block@0: // L889
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        (assert tmp%0#0) // Only an admin can add a plugin
        let box_prefixed_key%0#0: bytes = (concat "d" caller#0)
        (box_del box_prefixed_key%0#0)
        (box_put box_prefixed_key%0#0 domain#0)
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(app: uint64, allowedCaller: bytes[32]) -> void:
    block@0: // L902
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L903
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L903
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L903
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L903
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove plugins
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 allowedCaller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let spendingApp#0: uint64 = (extract_uint64 maybe_value%0#0 2u)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%0#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%0#0)
        let methods#0: bytes = (substring3 maybe_value%0#0 item_start_offset%0#0 item_end_offset%0#0)
        (box_del box_prefixed_key%0#0)
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (!= maybe_value%2#0 tmp%4#0)
        goto tmp%5#0 ? block@5 : block@7
    block@5: // if_body_L913
        itxn_begin
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: uint64 = (* 13u tmp%6#0)
        let tmp%8#0: uint64 = (* 400u tmp%7#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 36500u tmp%8#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) maybe_value%3#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@7
    block@7: // after_if_else_L913
        goto spendingApp#0 ? block@8 : block@10
    block@8: // if_body_L923
        itxn_begin
        let (maybe_value%4#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%5#0) // check GlobalState exists
        let val_as_bytes%4#0: bytes[8] = (itob spendingApp#0)
        ((itxn_field ApplicationArgs) method "delete(uint64)void")
        ((itxn_field ApplicationArgs) val_as_bytes%4#0)
        ((itxn_field ApplicationID) maybe_value%4#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@10
    block@10: // after_if_else_L923
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: uint64, allowedCaller: bytes[32], admin: bool, delegationType: bytes[1], lastValid: uint64, cooldown: uint64, methods: (bytes[4],encoded_uint64)[], useAllowance: bool, useRounds: bool) -> void:
    block@0: // L952
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        let tmp%2#0: bool = (! maybe_exists%1#0)
        (assert tmp%2#0)
        let val_as_bytes%0#0: bytes[8] = (itob app#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 allowedCaller#0)
        (box_put box_prefixed_key%0#0 encoded_tuple_buffer%2#0)
        let methodInfos#0: bytes = 0x0000
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L971
        let i#1: uint64 = φ(i#0 <- block@0, i#2 <- block@2)
        let methodInfos#1: bytes = φ(methodInfos#0 <- block@0, methodInfos#2 <- block@2)
        let tmp%3#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%4#0: bool = (< i#1 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // while_body_L971
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) methodInfos#1)
        let array_head_and_tail%0#0: bytes = ((extract 2 0) methods#0)
        let item_offset%0#0: uint64 = (* i#1 12u)
        let arc4_item%0#0: bytes = (extract3 array_head_and_tail%0#0 item_offset%0#0 12u) // on error: Index access is out of bounds
        let item0%0#0: bytes = ((extract 0 4) arc4_item%0#0) // on error: Index access is out of bounds
        let item1%3#0: uint64 = (extract_uint64 arc4_item%0#0 4u)
        let val_as_bytes%1#0: bytes[8] = (itob item1%3#0)
        let encoded_tuple_buffer%5#0: bytes = (concat item0%0#0 val_as_bytes%1#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%5#0 0x0000000000000000)
        let encoded%0#0: bytes[20][] = encode<bytes[20]>(encoded_tuple_buffer%6#0)
        let concatenated%0#0: bytes = (concat expr_value_trimmed%0#0 encoded%0#0)
        let byte_len%0#0: uint64 = (len concatenated%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 20u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let methodInfos#2: bytes = (concat len_16_bit%0#0 concatenated%0#0)
        let i#2: uint64 = (+ i#1 1u)
        goto block@1
    block@3: // after_while_L971
        let (maybe_value%1#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%5#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%6#0: bool = (!= maybe_value%1#0 tmp%5#0)
        goto tmp%6#0 ? block@4 : block@6
    block@4: // if_body_L981
        itxn_begin
        let (maybe_value%2#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%8#0: uint64 = (* 13u tmp%3#0)
        let tmp%9#0: uint64 = (len name#0)
        let tmp%10#0: uint64 = (+ tmp%8#0 tmp%9#0)
        let tmp%11#0: uint64 = (* 400u tmp%10#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%11#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) maybe_value%2#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@6
    block@6: // after_if_else_L981
        let spendingApp#0: uint64 = 0u
        goto useAllowance#0 ? block@7 : block@10
    block@7: // if_body_L993
        itxn_begin
        let (maybe_value%3#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let (maybe_value%4#0: uint64, maybe_exists%5#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%5#0) // check GlobalState exists
        let (value%0#0: bytes[32], check%0#0: bool) = ((app_params_get AppAddress) maybe_value%4#0)
        (assert check%0#0) // application exists
        ((itxn_field Receiver) value%0#0)
        ((itxn_field Amount) 12500u)
        ((itxn_field Sender) maybe_value%3#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_next
        let val_as_bytes%2#0: bytes[8] = (itob 0u)
        ((itxn_field ApplicationArgs) method "mint(pay,uint64)uint64")
        ((itxn_field ApplicationArgs) val_as_bytes%2#0)
        ((itxn_field ApplicationID) maybe_value%4#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (gitxn 1 LastLog)
        let tmp%12#0: bytes = ((extract 4 0) awst_tmp%0#0)
        let tmp%13#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%14#0: bool = (== tmp%13#0 0x151f7c75)
        (assert tmp%14#0) // Bytes has valid prefix
        let spendingApp#1: uint64 = (btoi tmp%12#0)
        goto block@10
    block@10: // after_if_else_L993
        let spendingApp#3: uint64 = φ(spendingApp#0 <- block@6, spendingApp#1 <- block@7)
        goto useRounds#0 ? block@11 : block@12
    block@11: // ternary_true_L1013
        let ternary_result%0#0: uint64 = (global Round)
        goto block@13
    block@12: // ternary_false_L1013
        let ternary_result%0#1: uint64 = (global LatestTimestamp)
        goto block@13
    block@13: // ternary_merge_L1013
        let epochRef#0: uint64 = φ(ternary_result%0#0 <- block@11, ternary_result%0#1 <- block@12)
        let encoded_bool%0#0: bytes[1] = (setbit 0x00 0u admin#0)
        let val_as_bytes%3#0: bytes[8] = (itob spendingApp#3)
        let val_as_bytes%4#0: bytes[8] = (itob lastValid#0)
        let val_as_bytes%5#0: bytes[8] = (itob cooldown#0)
        let encoded_bool%1#0: bytes[1] = (setbit 0x00 0u useAllowance#0)
        let encoded_bool%2#0: bytes[1] = (setbit 0x00 0u useRounds#0)
        let val_as_bytes%6#0: bytes[8] = (itob epochRef#0)
        let encoded_tuple_buffer%9#0: bytes = (concat encoded_bool%0#0 delegationType#0)
        let encoded_tuple_buffer%10#0: bytes = (concat encoded_tuple_buffer%9#0 val_as_bytes%3#0)
        let encoded_tuple_buffer%11#0: bytes = (concat encoded_tuple_buffer%10#0 val_as_bytes%4#0)
        let encoded_tuple_buffer%12#0: bytes = (concat encoded_tuple_buffer%11#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%13#0: bytes = (concat encoded_tuple_buffer%12#0 0x002d)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 encoded_bool%1#0)
        let is_true%0#0: uint64 = (getbit encoded_bool%2#0 0u)
        let encoded_tuple_buffer%15#0: bytes = (setbit encoded_tuple_buffer%14#0 225u is_true%0#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 0x0000000000000000)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%18#0: bytes = (concat encoded_tuple_buffer%17#0 methodInfos#1)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        (box_del box_prefixed_key%2#0)
        (box_put box_prefixed_key%2#0 encoded_tuple_buffer%18#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
    block@0: // L1037
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L1038
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L1038
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L1038
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L1038
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove plugins
        let box_prefixed_key%0#0: bytes = (concat "n" name#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let (maybe_value%0#0: bytes, maybe_exists%1#0: bool) = (box_get box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Box must have value
        let app.application#0: uint64 = (extract_uint64 maybe_value%0#0 0u)
        let app.allowedCaller#0: bytes[32] = ((extract 8 32) maybe_value%0#0) // on error: Index access is out of bounds
        let val_as_bytes%0#0: bytes[8] = (itob app.application#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 app.allowedCaller#0)
        let box_prefixed_key%2#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%2#0)
        (assert maybe_exists%2#0) // Plugin does not exist
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (box_get box_prefixed_key%2#0)
        (assert maybe_exists%3#0) // Box must have value
        let spendingApp#0: uint64 = (extract_uint64 maybe_value%1#0 2u)
        let item_start_offset%0#0: uint64 = (extract_uint16 maybe_value%1#0 26u)
        let item_end_offset%0#0: uint64 = (len maybe_value%1#0)
        let methods#0: bytes = (substring3 maybe_value%1#0 item_start_offset%0#0 item_end_offset%0#0)
        (box_del box_prefixed_key%0#0)
        (box_del box_prefixed_key%2#0)
        let (maybe_value%3#0: bytes, maybe_exists%5#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%5#0) // check GlobalState exists
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%5#0: bool = (!= maybe_value%3#0 tmp%4#0)
        goto tmp%5#0 ? block@5 : block@7
    block@5: // if_body_L1049
        itxn_begin
        let (maybe_value%4#0: bytes, maybe_exists%6#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%6#0) // check GlobalState exists
        let tmp%6#0: uint64 = (extract_uint16 methods#0 0u)
        let tmp%7#0: uint64 = (* 13u tmp%6#0)
        let tmp%8#0: uint64 = (len name#0)
        let tmp%9#0: uint64 = (+ tmp%7#0 tmp%8#0)
        let tmp%10#0: uint64 = (* 400u tmp%9#0)
        let inner_txn_params%0%%param_Amount_idx_0#0: uint64 = (+ 55400u tmp%10#0)
        ((itxn_field Amount) inner_txn_params%0%%param_Amount_idx_0#0)
        ((itxn_field Receiver) maybe_value%4#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@7
    block@7: // after_if_else_L1049
        goto spendingApp#0 ? block@8 : block@10
    block@8: // if_body_L1059
        itxn_begin
        let (maybe_value%5#0: uint64, maybe_exists%7#0: bool) = (app_global_get_ex 0u "spending_account_factory_app")
        (assert maybe_exists%7#0) // check GlobalState exists
        let val_as_bytes%4#0: bytes[8] = (itob spendingApp#0)
        ((itxn_field ApplicationArgs) method "delete(uint64)void")
        ((itxn_field ApplicationArgs) val_as_bytes%4#0)
        ((itxn_field ApplicationID) maybe_value%5#0)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@10
    block@10: // after_if_else_L1059
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowance(plugin: uint64, caller: bytes[32], asset: uint64, type: bytes[1], allowed: uint64, max: uint64, interval: uint64) -> void:
    block@0: // L1074
        let tmp%0#0: bytes[32] = (txn Sender)
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        let tmp%1#0: bool = (== tmp%0#0 maybe_value%0#0)
        (assert tmp%1#0) // admin only
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 caller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%1#0) // Plugin does not exist
        let val_as_bytes%2#0: bytes[8] = (itob asset#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%2#0)
        let box_prefixed_key%1#0: bytes = (concat "a" encoded_tuple_buffer%6#0)
        let (_%1#0: uint64, maybe_exists%2#0: bool) = (box_len box_prefixed_key%1#0)
        let tmp%2#0: bool = (! maybe_exists%2#0)
        (assert tmp%2#0) // allowance already exists
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%4#0: bool = (!= maybe_value%1#0 tmp%3#0)
        goto tmp%4#0 ? block@1 : block@3
    block@1: // if_body_L1092
        itxn_begin
        let (maybe_value%2#0: bytes, maybe_exists%4#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%4#0) // check GlobalState exists
        let inner_txn_params%0%%param_Receiver_idx_0#0: bytes[32] = (global CurrentApplicationAddress)
        ((itxn_field Amount) 38500u)
        ((itxn_field Receiver) inner_txn_params%0%%param_Receiver_idx_0#0)
        ((itxn_field Sender) maybe_value%2#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@3
    block@3: // after_if_else_L1092
        let val_as_bytes%5#0: bytes[8] = (itob max#0)
        let val_as_bytes%6#0: bytes[8] = (itob allowed#0)
        let val_as_bytes%7#0: bytes[8] = (itob 0u)
        let val_as_bytes%8#0: bytes[8] = (itob interval#0)
        let encoded_tuple_buffer%13#0: bytes = (concat type#0 val_as_bytes%5#0)
        let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%13#0 val_as_bytes%6#0)
        let encoded_tuple_buffer%15#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%7#0)
        let encoded_tuple_buffer%16#0: bytes = (concat encoded_tuple_buffer%15#0 val_as_bytes%8#0)
        let encoded_tuple_buffer%17#0: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%7#0)
        (box_put box_prefixed_key%1#0 encoded_tuple_buffer%17#0)
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowance(plugin: uint64, caller: bytes[32], asset: uint64) -> void:
    block@0: // L1116
        let tmp%0#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin()
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L1117
        let tmp%1#0: bool = smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke()
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L1117
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L1117
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L1117
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // Only an admin or revocation app can remove method restrictions
        let val_as_bytes%0#0: bytes[8] = (itob plugin#0)
        let encoded_tuple_buffer%2#0: bytes = (concat val_as_bytes%0#0 caller#0)
        let box_prefixed_key%0#0: bytes = (concat "p" encoded_tuple_buffer%2#0)
        let (_%0#0: uint64, maybe_exists%0#0: bool) = (box_len box_prefixed_key%0#0)
        (assert maybe_exists%0#0) // Plugin does not exist
        let val_as_bytes%2#0: bytes[8] = (itob asset#0)
        let encoded_tuple_buffer%6#0: bytes = (concat encoded_tuple_buffer%2#0 val_as_bytes%2#0)
        let box_prefixed_key%1#0: bytes = (concat "a" encoded_tuple_buffer%6#0)
        let (_%1#0: uint64, maybe_exists%1#0: bool) = (box_len box_prefixed_key%1#0)
        (assert maybe_exists%1#0) // allowance does not exist
        (box_del box_prefixed_key%1#0)
        let (maybe_value%0#0: bytes, maybe_exists%2#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%2#0) // check GlobalState exists
        let tmp%2#0: bytes[32] = (global CurrentApplicationAddress)
        let tmp%3#0: bool = (!= maybe_value%0#0 tmp%2#0)
        goto tmp%3#0 ? block@5 : block@7
    block@5: // if_body_L1128
        itxn_begin
        let (maybe_value%1#0: bytes, maybe_exists%3#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%3#0) // check GlobalState exists
        ((itxn_field Amount) 38500u)
        ((itxn_field Receiver) maybe_value%1#0)
        ((itxn_field TypeEnum) 1u)
        ((itxn_field Fee) 0u)
        itxn_submit
        goto block@7
    block@7: // after_if_else_L1128
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction()
        smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange()
        return 

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes[32]:
    block@0: // L1148
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_global_get_ex 0u "admin")
        (assert maybe_exists%0#0) // check GlobalState exists
        return maybe_value%0#0

subroutine smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(assets: encoded_uint64[]) -> encoded_uint64[]:
    block@0: // L1154
        let amounts#0: encoded_uint64[] = 0x0000
        let i#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L1157
        let i#1: uint64 = φ(i#0 <- block@0, i#4 <- block@7)
        let amounts#2: encoded_uint64[] = φ(amounts#0 <- block@0, amounts#4 <- block@7)
        let tmp%0#0: uint64 = (extract_uint16 assets#0 0u)
        let tmp%1#0: bool = (< i#1 tmp%0#0)
        goto tmp%1#0 ? block@2 : block@9
    block@2: // while_body_L1157
        let amount#0: uint64 = 0u
        let array_head_and_tail%0#0: bytes = ((extract 2 0) assets#0)
        let item_offset%0#0: uint64 = (* i#1 8u)
        let asset#0: uint64 = (extract_uint64 array_head_and_tail%0#0 item_offset%0#0)
        goto asset#0 ? block@4 : block@3
    block@3: // if_body_L1161
        let tmp%3#0: bytes[32] = (global CurrentApplicationAddress)
        let (amount#1: uint64, check%0#0: bool) = ((acct_params_get AcctBalance) tmp%3#0)
        (assert check%0#0) // account funded
        goto block@7
    block@4: // else_body_L1163
        let tmp%4#0: bytes[32] = (global CurrentApplicationAddress)
        let (holdingAmount#0: uint64, optedIn#0: bool) = ((asset_holding_get AssetBalance) tmp%4#0 asset#0)
        goto optedIn#0 ? block@5 : block@6
    block@5: // if_body_L1165
        goto block@6
    block@6: // after_if_else_L1165
        let amount#4: uint64 = φ(amount#0 <- block@4, holdingAmount#0 <- block@5)
        goto block@7
    block@7: // after_if_else_L1161
        let amount#3: uint64 = φ(amount#1 <- block@3, amount#4 <- block@6)
        itxn_begin
        let (akitaDAO#0: uint64, maybe_exists%0#0: bool) = (app_global_get_ex 0u "akita_dao")
        (assert maybe_exists%0#0) // check GlobalState exists
        let (appListBytes#0: bytes, _#0: bool) = (app_global_get_ex akitaDAO#0 "akita_al")
        let item0%1#1: uint64 = (extract_uint64 appListBytes#0 0u)
        let (maybe_value%1#0: bytes, maybe_exists%1#0: bool) = (app_global_get_ex 0u "controlled_address")
        (assert maybe_exists%1#0) // check GlobalState exists
        let val_as_bytes%0#0: bytes[8] = (itob asset#0)
        ((itxn_field ApplicationArgs) method "getEscrowInfo(address,uint64)(uint64,uint64)")
        ((itxn_field ApplicationArgs) maybe_value%1#0)
        ((itxn_field ApplicationArgs) val_as_bytes%0#0)
        ((itxn_field ApplicationID) item0%1#1)
        ((itxn_field TypeEnum) appl)
        ((itxn_field Fee) 0u)
        itxn_submit
        let awst_tmp%0#0: bytes = (itxn LastLog)
        let tmp%18#0: bytes = ((extract 0 4) awst_tmp%0#0)
        let tmp%19#0: bool = (== tmp%18#0 0x151f7c75)
        (assert tmp%19#0) // Bytes has valid prefix
        let escrowInfo.hard#0: uint64 = (extract_uint64 awst_tmp%0#0 4u)
        let escrowInfo.lock#0: uint64 = (extract_uint64 awst_tmp%0#0 12u)
        let expr_value_trimmed%0#0: bytes = ((extract 2 0) amounts#2)
        let tmp%20#0: uint64 = (+ amount#3 escrowInfo.hard#0)
        let tmp%21#0: uint64 = (+ tmp%20#0 escrowInfo.lock#0)
        let encoded%0#0: encoded_uint64[] = encode<encoded_uint64>(tmp%21#0)
        let byte_len%0#0: uint64 = (len encoded%0#0)
        let len_%0#0: uint64 = (/ byte_len%0#0 8u)
        let as_bytes%0#0: bytes[8] = (itob len_%0#0)
        let len_16_bit%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let concat_result%0#0: bytes = (concat len_16_bit%0#0 encoded%0#0)
        let expr_value_trimmed%2#0: bytes = ((extract 2 0) concat_result%0#0)
        let concatenated%1#0: bytes = (concat expr_value_trimmed%0#0 expr_value_trimmed%2#0)
        let byte_len%1#0: uint64 = (len concatenated%1#0)
        let len_%1#0: uint64 = (/ byte_len%1#0 8u)
        let as_bytes%1#0: bytes[8] = (itob len_%1#0)
        let len_16_bit%1#0: bytes = ((extract 6 2) as_bytes%1#0)
        let amounts#4: encoded_uint64[] = (concat len_16_bit%1#0 concatenated%1#0)
        let i#4: uint64 = (+ i#1 1u)
        goto block@1
    block@9: // after_while_L1157
        return amounts#2