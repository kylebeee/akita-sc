#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 4 392 400 224
    bytecblock 0x "controlled_address" "e" "p" "a" 0x00 0x151f7c75 "spending_address" "admin" "x" "n" "escrow_factory" 0x01 "d" "revocation" 0x0f885493 "version" "nickname"

main_block@0:

main_block@1:
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txn NumAppArgs
    intc_0 // 0
    !=
    bz main_bare_routing@39

main_abi_routing@2:
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 0
    pushbytes 0x70ca115d // method "create(string,address,address,uint64,uint64,string)void"
    pushbytes 0x83f14748 // method "init()void"
    pushbytes 0xea9180dd // method "update(string)void"
    pushbytes 0xe500dfb6 // method "changeRevocationApp(uint64)void"
    pushbytes 0x9f91cccd // method "setNickname(string)void"
    pushbytes 0x17d8bcb4 // method "setAvatar(uint64)void"
    pushbytes 0x385658ab // method "setBanner(uint64)void"
    pushbytes 0x5ef0b415 // method "setBio(string)void"
    pushbytes 0xd24b7556 // method "arc58_changeAdmin(address)void"
    pushbytes 0x5fa449c6 // method "arc58_pluginChangeAdmin(uint64,address,address)void"
    bytec 15 // method "arc58_verifyAuthAddr()void"
    pushbytes 0xc95a5d3d // method "arc58_rekeyTo(address,bool)void"
    pushbytes 0x4727af21 // method "arc58_canCall(uint64,bool,address,string,byte[4])bool"
    pushbytes 0x582ff382 // method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void"
    pushbytes 0xdefd5cd2 // method "arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void"
    pushbytes 0xb3c80df9 // method "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void"
    pushbytes 0x57a51d88 // method "assignDomain(address,string)void"
    pushbytes 0xeef448fd // method "arc58_removePlugin(uint64,address,string)void"
    pushbytes 0x38f591ea // method "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void"
    pushbytes 0xe350b9d4 // method "arc58_removeNamedPlugin(string)void"
    pushbytes 0x0a8cb2c2 // method "arc58_newEscrow(string)uint64"
    pushbytes 0x096bddb0 // method "arc58_toggleEscrowLock(string)bool"
    pushbytes 0xebaf14a0 // method "arc58_reclaim(string,(uint64,uint64,bool)[])void"
    pushbytes 0x1fda3b4f // method "arc58_optinEscrow(string,uint64[])void"
    pushbytes 0x9d3f8918 // method "arc58_pluginOptinEscrow(uint64,address,string,uint64[],pay)void"
    pushbytes 0xbf4d7c57 // method "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void"
    pushbytes 0xd5dd382b // method "arc58_removeAllowances(string,uint64[])void"
    pushbytes 0xb071e57b // method "arc58_addExecutionKey(byte[32],uint64)void"
    pushbytes 0xd58685af // method "arc58_removeExecutionKey(byte[32])void"
    pushbytes 0x13bc44e4 // method "arc58_getAdmin()address"
    pushbytes 0xe834e7da // method "arc58_getEscrow(string)uint64"
    pushbytes 0x27feff3a // method "arc58_mustGetEscrow(string)uint64"
    pushbytes 0x17de4252 // method "mbr(uint64,string,string)(uint64,uint64,uint64,uint64,uint64,uint64)"
    pushbytes 0x124c0a7f // method "balance(uint64[])uint64[]"
    uncover 34
    match main_create_route@3 main_init_route@4 main_update_route@5 main_changeRevocationApp_route@6 main_setNickname_route@7 main_setAvatar_route@8 main_setBanner_route@9 main_setBio_route@10 main_arc58_changeAdmin_route@11 main_arc58_pluginChangeAdmin_route@12 main_arc58_verifyAuthAddr_route@13 main_arc58_rekeyTo_route@14 main_arc58_canCall_route@15 main_arc58_rekeyToPlugin_route@16 main_arc58_rekeyToNamedPlugin_route@17 main_arc58_addPlugin_route@18 main_assignDomain_route@19 main_arc58_removePlugin_route@20 main_arc58_addNamedPlugin_route@21 main_arc58_removeNamedPlugin_route@22 main_arc58_newEscrow_route@23 main_arc58_toggleEscrowLock_route@24 main_arc58_reclaim_route@25 main_arc58_optinEscrow_route@26 main_arc58_pluginOptinEscrow_route@27 main_arc58_addAllowances_route@28 main_arc58_removeAllowances_route@29 main_arc58_addExecutionKey_route@30 main_arc58_removeExecutionKey_route@31 main_arc58_getAdmin_route@32 main_arc58_getEscrow_route@33 main_arc58_mustGetEscrow_route@34 main_mbr_route@35 main_balance_route@36

main_switch_case_default@37:

main_switch_case_next@38:

main_after_if_else@40:
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    intc_0 // 0

main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41:
    return

main_balance_route@36:
    // smart_contracts/arc58/account/contract.algo.ts:1399
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1399
    // @abimethod({ readonly: true })
    callsub balance
    pop
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_mbr_route@35:
    // smart_contracts/arc58/account/contract.algo.ts:1382
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1382
    // @abimethod({ readonly: true })
    uncover 2
    uncover 2
    uncover 2
    callsub mbr
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_mustGetEscrow_route@34:
    // smart_contracts/arc58/account/contract.algo.ts:1376
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1376
    // @abimethod({ readonly: true })
    callsub arc58_mustGetEscrow
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_getEscrow_route@33:
    // smart_contracts/arc58/account/contract.algo.ts:1368
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1368
    // @abimethod({ readonly: true })
    callsub arc58_getEscrow
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_getAdmin_route@32:
    // smart_contracts/arc58/account/contract.algo.ts:1363
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_removeExecutionKey_route@31:
    // smart_contracts/arc58/account/contract.algo.ts:1348
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1348
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    callsub arc58_removeExecutionKey
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_addExecutionKey_route@30:
    // smart_contracts/arc58/account/contract.algo.ts:1338
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1338
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    callsub arc58_addExecutionKey
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_removeAllowances_route@29:
    // smart_contracts/arc58/account/contract.algo.ts:1310
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1310
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    callsub arc58_removeAllowances
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_addAllowances_route@28:
    // smart_contracts/arc58/account/contract.algo.ts:1266
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1266
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    callsub arc58_addAllowances
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_pluginOptinEscrow_route@27:
    // smart_contracts/arc58/account/contract.algo.ts:1202-1208
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/arc58/account/contract.algo.ts:1202-1208
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub arc58_pluginOptinEscrow
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_optinEscrow_route@26:
    // smart_contracts/arc58/account/contract.algo.ts:1162
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1162
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    callsub arc58_optinEscrow
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_reclaim_route@25:
    // smart_contracts/arc58/account/contract.algo.ts:1121
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1121
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    callsub arc58_reclaim
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_toggleEscrowLock_route@24:
    // smart_contracts/arc58/account/contract.algo.ts:1102
    // arc58_toggleEscrowLock(escrow: string): boolean {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1102
    // arc58_toggleEscrowLock(escrow: string): boolean {
    callsub arc58_toggleEscrowLock
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_newEscrow_route@23:
    // smart_contracts/arc58/account/contract.algo.ts:1091
    // arc58_newEscrow(escrow: string): uint64 {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1091
    // arc58_newEscrow(escrow: string): uint64 {
    callsub arc58_newEscrow
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_removeNamedPlugin_route@22:
    // smart_contracts/arc58/account/contract.algo.ts:1062
    // arc58_removeNamedPlugin(name: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1062
    // arc58_removeNamedPlugin(name: string): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_addNamedPlugin_route@21:
    // smart_contracts/arc58/account/contract.algo.ts:995-1008
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    btoi
    txna ApplicationArgs 9
    txna ApplicationArgs 10
    intc_0 // 0
    getbit
    txna ApplicationArgs 11
    intc_0 // 0
    getbit
    txna ApplicationArgs 12
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:995-1008
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    uncover 11
    callsub arc58_addNamedPlugin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_removePlugin_route@20:
    // smart_contracts/arc58/account/contract.algo.ts:957
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:957
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    uncover 2
    uncover 2
    uncover 2
    callsub arc58_removePlugin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_assignDomain_route@19:
    // smart_contracts/arc58/account/contract.algo.ts:935
    // assignDomain(caller: Address, domain: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:935
    // assignDomain(caller: Address, domain: string): void {
    callsub assignDomain
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_addPlugin_route@18:
    // smart_contracts/arc58/account/contract.algo.ts:865-877
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    txna ApplicationArgs 9
    intc_0 // 0
    getbit
    txna ApplicationArgs 10
    intc_0 // 0
    getbit
    txna ApplicationArgs 11
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:865-877
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    uncover 10
    callsub arc58_addPlugin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_rekeyToNamedPlugin_route@17:
    // smart_contracts/arc58/account/contract.algo.ts:836-841
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:836-841
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_rekeyToPlugin_route@16:
    // smart_contracts/arc58/account/contract.algo.ts:788-794
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:788-794
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub arc58_rekeyToPlugin
    popn 2
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_canCall_route@15:
    // smart_contracts/arc58/account/contract.algo.ts:765
    // @abimethod({ readonly: true })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:765
    // @abimethod({ readonly: true })
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub arc58_canCall
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_rekeyTo_route@14:
    // smart_contracts/arc58/account/contract.algo.ts:739
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:739
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_verifyAuthAddr_route@13:
    // smart_contracts/arc58/account/contract.algo.ts:728
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_pluginChangeAdmin_route@12:
    // smart_contracts/arc58/account/contract.algo.ts:704
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/arc58/account/contract.algo.ts:704
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    uncover 2
    uncover 2
    uncover 2
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_arc58_changeAdmin_route@11:
    // smart_contracts/arc58/account/contract.algo.ts:689
    // arc58_changeAdmin(newAdmin: Address): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:689
    // arc58_changeAdmin(newAdmin: Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_setBio_route@10:
    // smart_contracts/arc58/account/contract.algo.ts:679
    // setBio(bio: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:679
    // setBio(bio: string): void {
    callsub setBio
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_setBanner_route@9:
    // smart_contracts/arc58/account/contract.algo.ts:667
    // setBanner(banner: uint64): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:667
    // setBanner(banner: uint64): void {
    callsub setBanner
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_setAvatar_route@8:
    // smart_contracts/arc58/account/contract.algo.ts:655
    // setAvatar(avatar: uint64): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:655
    // setAvatar(avatar: uint64): void {
    callsub setAvatar
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_setNickname_route@7:
    // smart_contracts/arc58/account/contract.algo.ts:645
    // setNickname(nickname: string): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:645
    // setNickname(nickname: string): void {
    callsub setNickname
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_changeRevocationApp_route@6:
    // smart_contracts/arc58/account/contract.algo.ts:635
    // changeRevocationApp(newRevocationApp: uint64): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:635
    // changeRevocationApp(newRevocationApp: uint64): void {
    callsub changeRevocationApp
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_update_route@5:
    // smart_contracts/arc58/account/contract.algo.ts:622
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:622
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_init_route@4:
    // smart_contracts/arc58/account/contract.algo.ts:606
    // init(): void {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub init
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_create_route@3:
    // smart_contracts/arc58/account/contract.algo.ts:573
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    ==
    assert // can only call when creating
    // smart_contracts/arc58/account/contract.algo.ts:95
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:573
    // @abimethod({ onCreate: 'require' })
    uncover 5
    uncover 5
    uncover 5
    uncover 5
    uncover 5
    uncover 5
    callsub create
    intc_1 // 1
    b main_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.__puya_arc4_router__@41

main_bare_routing@39:
    b main_after_if_else@40


// smart_contracts/utils/functions.ts::getAkitaAppList(akitaDAO: uint64) -> bytes:
getAkitaAppList:
    // smart_contracts/utils/functions.ts:24
    // export function getAkitaAppList(akitaDAO: Application): AkitaAppList {
    proto 1 1

getAkitaAppList_block@0:
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    frame_dig -1
    pushbytes "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:26
    // return decodeArc4<AkitaAppList>(appListBytes)
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastUserInteraction() -> void:
updateLastUserInteraction:

updateLastUserInteraction_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:157
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    // smart_contracts/arc58/account/contract.algo.ts:116
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    pushbytes "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:157
    // this.lastUserInteraction.value = Global.latestTimestamp
    swap
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.updateLastChange() -> void:
updateLastChange:

updateLastChange_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:161
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    pushbytes "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:161
    // this.lastChange.value = Global.latestTimestamp
    swap
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginsMbr(methodCount: uint64) -> uint64:
pluginsMbr:
    // smart_contracts/arc58/account/contract.algo.ts:164
    // private pluginsMbr(methodCount: uint64): uint64 {
    proto 1 1

pluginsMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:166
    // BoxCostPerByte * (MethodRestrictionByteLength * methodCount)
    pushint 20 // 20
    frame_dig -1
    *
    intc 5 // 400
    *
    // smart_contracts/arc58/account/contract.algo.ts:165
    // return MinPluginMBR + (
    pushint 38100 // 38100
    // smart_contracts/arc58/account/contract.algo.ts:165-167
    // return MinPluginMBR + (
    //   BoxCostPerByte * (MethodRestrictionByteLength * methodCount)
    // );
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.namedPluginsMbr(name: bytes) -> uint64:
namedPluginsMbr:
    // smart_contracts/arc58/account/contract.algo.ts:170
    // private namedPluginsMbr(name: string): uint64 {
    proto 1 1

namedPluginsMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:171
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -1
    len
    intc 5 // 400
    *
    pushint 18900 // 18900
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.escrowsMbr() -> uint64:
escrowsMbr:

escrowsMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:175
    // return EscrowsMBR;
    pushint 6500 // 6500
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.namedEscrowsMbr(name: bytes) -> uint64:
namedEscrowsMbr:
    // smart_contracts/arc58/account/contract.algo.ts:178
    // private namedEscrowsMbr(name: string): uint64 {
    proto 1 1

namedEscrowsMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:179
    // return MinNamedEscrowsMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -1
    len
    intc 5 // 400
    *
    pushint 6100 // 6100
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.allowancesMbr() -> uint64:
allowancesMbr:

allowancesMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:183
    // return AllowanceMBR;
    pushint 29300 // 29300
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.domainKeysMbr(domain: bytes) -> uint64:
domainKeysMbr:
    // smart_contracts/arc58/account/contract.algo.ts:186
    // private domainKeysMbr(domain: string): uint64 {
    proto 1 1

domainKeysMbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:187
    // return MinDomainKeysMBR + (BoxCostPerByte * Bytes(domain).length)
    frame_dig -1
    len
    intc 5 // 400
    *
    pushint 15700 // 15700
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.maybeNewEscrow(escrow: bytes) -> uint64:
maybeNewEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:190
    // private maybeNewEscrow(escrow: string): uint64 {
    proto 1 1

maybeNewEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:191
    // if (escrow === '') {
    frame_dig -1
    bytec_0 // ""
    ==
    bz maybeNewEscrow_after_if_else@2

maybeNewEscrow_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:192
    // return 0
    intc_0 // 0
    retsub

maybeNewEscrow_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:195
    // return this.namedEscrows(escrow).exists
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:195-197
    // return this.namedEscrows(escrow).exists
    //   ? this.namedEscrows(escrow).value
    //   : this.newEscrow(escrow)
    bz maybeNewEscrow_ternary_false@4

maybeNewEscrow_ternary_true@3:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:196
    // ? this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi

maybeNewEscrow_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:195-197
    // return this.namedEscrows(escrow).exists
    //   ? this.namedEscrows(escrow).value
    //   : this.newEscrow(escrow)
    retsub

maybeNewEscrow_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:197
    // : this.newEscrow(escrow)
    frame_dig -1
    callsub newEscrow
    b maybeNewEscrow_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.newEscrow(escrow: bytes) -> uint64:
newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:200
    // private newEscrow(escrow: string): uint64 {
    proto 1 1

newEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:201
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz newEscrow_after_if_else@3

newEscrow_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:202-208
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:205
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:206
    // amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    frame_dig -1
    callsub namedEscrowsMbr
    callsub escrowsMbr
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:202-207
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

newEscrow_next_txn@2:
    // smart_contracts/arc58/account/contract.algo.ts:202-208
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    //   .submit()
    itxn_submit

newEscrow_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:211-224
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:219
    // amount: NewCostForARC58 + Global.minBalance,
    global MinBalance
    pushint 112100 // 112100
    +
    // smart_contracts/arc58/account/contract.algo.ts:122
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 11 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:220
    // receiver: this.escrowFactory.value.address
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:217-221
    // itxn.payment({
    //   sender: this.controlledAddress.value,
    //   amount: NewCostForARC58 + Global.minBalance,
    //   receiver: this.escrowFactory.value.address
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

newEscrow_next_txn@4:
    // smart_contracts/arc58/account/contract.algo.ts:211-224
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    itxn_next
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:122
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 11 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:211-224
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    pushbytes 0xd85cf184 // method "new(pay)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

newEscrow_next_txn@5:
    // smart_contracts/arc58/account/contract.algo.ts:211-224
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:226
    // this.escrows(id).value = false
    dup
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:226
    // this.escrows(id).value = false
    intc_0 // 0
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:227
    // this.namedEscrows(escrow).value = id
    dig 1
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:229
    // return id;
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin() -> uint64:
isAdmin:

isAdmin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:235
    // Txn.sender === this.admin.value ||
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 8 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:235
    // Txn.sender === this.admin.value ||
    ==
    // smart_contracts/arc58/account/contract.algo.ts:235-236
    // Txn.sender === this.admin.value ||
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    bnz isAdmin_bool_true@3

isAdmin_or_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:236
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:152
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 13 // "d"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:236
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    box_len
    bury 1
    bz isAdmin_bool_false@4

isAdmin_and_contd@2:
    // smart_contracts/arc58/account/contract.algo.ts:236
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:152
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 13 // "d"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:236
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    box_get
    assert // Box must have value
    pushbytes "akita.community"
    ==
    bz isAdmin_bool_false@4

isAdmin_bool_true@3:
    intc_1 // 1

isAdmin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:234-237
    // return (
    //   Txn.sender === this.admin.value ||
    //   (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    // )
    retsub

isAdmin_bool_false@4:
    intc_0 // 0
    b isAdmin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke() -> uint64:
canRevoke:

canRevoke_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:242
    // return Txn.sender === this.revocation.value.address
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:126
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    intc_0 // 0
    bytec 14 // "revocation"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:242
    // return Txn.sender === this.revocation.value.address
    app_params_get AppAddress
    assert // application exists
    ==
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin: uint64, caller: bytes, escrow: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/arc58/account/contract.algo.ts:245
    // private pluginCallAllowed(plugin: uint64, caller: Account, escrow: string, method: bytes<4>): boolean {
    proto 4 1
    intc_0 // 0
    bytec_0 // ""
    dupn 5

pluginCallAllowed_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:246
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -4
    itob
    bytec_0 // 0x
    swap
    concat
    frame_dig -3
    concat
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:248
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2

pluginCallAllowed_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:249
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 7
    concat
    // smart_contracts/arc58/account/contract.algo.ts:252
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = clone(this.plugins(key).value)
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    dup
    uncover 3
    uncover 3
    substring3
    swap
    dup
    intc 6 // 224
    getbit
    swap
    dup
    pushint 29 // 29
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 18 // 18
    intc_2 // 8
    extract3
    btoi
    swap
    pushint 225 // 225
    getbit
    uncover 4
    frame_bury 0
    uncover 3
    frame_bury 6
    uncover 2
    frame_bury 4
    swap
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:254
    // if (useExecutionKey) {
    bz pluginCallAllowed_after_if_else@4

pluginCallAllowed_if_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:255
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:258
    // let methodAllowed = methods.length > 0 ? false : true;
    frame_dig 0
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    intc_1 // 1
    intc_0 // 0
    uncover 2
    select
    frame_bury 5
    // smart_contracts/arc58/account/contract.algo.ts:259
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 3

pluginCallAllowed_while_top@5:
    // smart_contracts/arc58/account/contract.algo.ts:259
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 0
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz pluginCallAllowed_after_while@9

pluginCallAllowed_while_body@6:
    // smart_contracts/arc58/account/contract.algo.ts:260
    // if (methods[i].selector === method) {
    frame_dig 0
    extract 2 0
    frame_dig 3
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_3 // 4
    extract3
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@8

pluginCallAllowed_if_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:261
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 5

pluginCallAllowed_block@10:
    // smart_contracts/arc58/account/contract.algo.ts:266
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 6
    bz pluginCallAllowed_ternary_false@12

pluginCallAllowed_ternary_true@11:
    // smart_contracts/arc58/account/contract.algo.ts:266
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

pluginCallAllowed_ternary_merge@13:
    // smart_contracts/arc58/account/contract.algo.ts:266
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:269
    // lastCalled >= epochRef &&
    frame_dig 4
    <=
    // smart_contracts/arc58/account/contract.algo.ts:269-270
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16

pluginCallAllowed_and_contd@14:
    // smart_contracts/arc58/account/contract.algo.ts:270
    // (epochRef - lastCalled) >= cooldown &&
    frame_dig 2
    frame_dig 4
    -
    frame_dig 1
    >=
    // smart_contracts/arc58/account/contract.algo.ts:269-270
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16

pluginCallAllowed_bool_true@15:
    intc_1 // 1

pluginCallAllowed_bool_merge@17:
    // smart_contracts/arc58/account/contract.algo.ts:269-271
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    // methodAllowed
    frame_dig 5
    &&
    // smart_contracts/arc58/account/contract.algo.ts:268-272
    // return (
    //   lastCalled >= epochRef &&
    //   (epochRef - lastCalled) >= cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@16:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@17

pluginCallAllowed_ternary_false@12:
    // smart_contracts/arc58/account/contract.algo.ts:266
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCallAllowed_ternary_merge@13

pluginCallAllowed_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:259
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b pluginCallAllowed_while_top@5

pluginCallAllowed_after_while@9:
    b pluginCallAllowed_block@10


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // smart_contracts/arc58/account/contract.algo.ts:275
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1

txnRekeysBack_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:278
    // txn.sender === this.controlledAddress.value &&
    frame_dig -1
    gtxns Sender
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:278
    // txn.sender === this.controlledAddress.value &&
    ==
    // smart_contracts/arc58/account/contract.algo.ts:278-279
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3

txnRekeysBack_and_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:279
    // txn.rekeyTo === Global.currentApplicationAddress
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:278-279
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3

txnRekeysBack_if_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:281
    // return true;
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:285
    // txn.type === TransactionType.ApplicationCall
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // smart_contracts/arc58/account/contract.algo.ts:285-286
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@4:
    // smart_contracts/arc58/account/contract.algo.ts:286
    // && txn.appId === Global.currentApplicationId
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/arc58/account/contract.algo.ts:285-286
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@5:
    // smart_contracts/arc58/account/contract.algo.ts:287
    // && txn.numAppArgs === 1
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // smart_contracts/arc58/account/contract.algo.ts:285-287
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@6:
    // smart_contracts/arc58/account/contract.algo.ts:288
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig -1
    gtxns OnCompletion
    intc_0 // 0
    ==
    // smart_contracts/arc58/account/contract.algo.ts:285-288
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bz txnRekeysBack_bool_false@9

txnRekeysBack_and_contd@7:
    // smart_contracts/arc58/account/contract.algo.ts:289
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 15 // method "arc58_verifyAuthAddr()void"
    ==
    // smart_contracts/arc58/account/contract.algo.ts:285-289
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    bz txnRekeysBack_bool_false@9

txnRekeysBack_bool_true@8:
    intc_1 // 1

txnRekeysBack_bool_merge@10:
    // smart_contracts/arc58/account/contract.algo.ts:284-290
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    b txnRekeysBack_bool_merge@10


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertRekeysBack() -> void:
assertRekeysBack:
    // smart_contracts/arc58/account/contract.algo.ts:293
    // private assertRekeysBack(): void {
    proto 0 0

assertRekeysBack_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:294
    // let rekeysBack = false;
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:295
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +

assertRekeysBack_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:295
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    global GroupSize
    frame_dig 1
    >
    bz assertRekeysBack_after_while@5

assertRekeysBack_while_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:296
    // const txn = gtxn.Transaction(i)
    frame_dig 1
    // smart_contracts/arc58/account/contract.algo.ts:298
    // if (this.txnRekeysBack(txn)) {
    callsub txnRekeysBack
    bz assertRekeysBack_after_if_else@4

assertRekeysBack_if_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:299
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 0

assertRekeysBack_block@6:
    // smart_contracts/arc58/account/contract.algo.ts:304
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 0
    assert // missing rekey back
    retsub

assertRekeysBack_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:295
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b assertRekeysBack_while_top@1

assertRekeysBack_after_while@5:
    b assertRekeysBack_block@6


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> bytes, bytes:
pluginCheck:
    // smart_contracts/arc58/account/contract.algo.ts:307
    // private pluginCheck(key: PluginKey): PluginValidation {
    proto 1 2
    intc_0 // 0
    bytec_0 // ""
    dupn 6

pluginCheck_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:309
    // const exists = this.plugins(key).exists;
    box_len
    bury 1
    dup
    // smart_contracts/arc58/account/contract.algo.ts:310
    // if (!exists) {
    bnz pluginCheck_after_if_else@2

pluginCheck_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    bytec 5 // 0x00
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:312
    // exists: false,
    dup
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:313
    // expired: true,
    dup
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    pushint 2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:314
    // hasCooldown: true,
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    pushint 3 // 3
    // smart_contracts/arc58/account/contract.algo.ts:315
    // onCooldown: true,
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    intc_3 // 4
    // smart_contracts/arc58/account/contract.algo.ts:316
    // hasMethodRestrictions: false,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    pushint 5 // 5
    // smart_contracts/arc58/account/contract.algo.ts:317
    // valid: false
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:311-318
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    setbit
    bytec_0 // 0x
    swap
    concat
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:321
    // const { useRounds, lastValid, cooldown, lastCalled, methods } = clone(this.plugins(key).value)
    box_get
    assert // Box must have value
    dup
    intc 6 // 224
    getbit
    swap
    dup
    pushint 10 // 10
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 18 // 18
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 29 // 29
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    uncover 4
    swap
    uncover 4
    frame_bury 6
    uncover 3
    frame_bury 1
    uncover 2
    frame_bury 5
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:322
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCheck_ternary_false@4

pluginCheck_ternary_true@3:
    // smart_contracts/arc58/account/contract.algo.ts:322
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

pluginCheck_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:324
    // const expired = epochRef > lastValid;
    dup
    frame_dig 6
    >
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:325
    // const hasCooldown = cooldown > 0;
    frame_dig 1
    dup
    intc_0 // 0
    >
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:326
    // const onCooldown = (epochRef - lastCalled) < cooldown;
    swap
    frame_dig 5
    -
    >
    frame_bury 7
    // smart_contracts/arc58/account/contract.algo.ts:327
    // const hasMethodRestrictions = methods.length > 0;
    frame_dig 0
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:329
    // const valid = exists && !expired && !onCooldown;
    frame_dig 8
    bz pluginCheck_bool_false@9

pluginCheck_and_contd@6:
    // smart_contracts/arc58/account/contract.algo.ts:329
    // const valid = exists && !expired && !onCooldown;
    frame_dig 2
    bnz pluginCheck_bool_false@9

pluginCheck_and_contd@7:
    // smart_contracts/arc58/account/contract.algo.ts:329
    // const valid = exists && !expired && !onCooldown;
    frame_dig 7
    bnz pluginCheck_bool_false@9

pluginCheck_bool_true@8:
    intc_1 // 1

pluginCheck_bool_merge@10:
    // smart_contracts/arc58/account/contract.algo.ts:331-338
    // return {
    //   exists,
    //   expired,
    //   hasCooldown,
    //   onCooldown,
    //   hasMethodRestrictions,
    //   valid
    // }
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig 8
    setbit
    intc_1 // 1
    frame_dig 2
    setbit
    pushint 2 // 2
    frame_dig 3
    setbit
    pushint 3 // 3
    frame_dig 7
    setbit
    intc_3 // 4
    frame_dig 4
    setbit
    pushint 5 // 5
    uncover 2
    setbit
    bytec_0 // 0x
    swap
    concat
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_bool_false@9:
    intc_0 // 0
    b pluginCheck_bool_merge@10

pluginCheck_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:322
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCheck_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assertValidGroup(key: bytes, methodOffsets: bytes) -> bytes, bytes:
assertValidGroup:
    // smart_contracts/arc58/account/contract.algo.ts:347
    // private assertValidGroup(key: PluginKey, methodOffsets: uint64[]): void {
    proto 2 2
    intc_0 // 0
    dupn 5
    bytec_0 // ""
    dupn 5

assertValidGroup_block@0:
    frame_dig -2
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:349
    // const { useRounds, useExecutionKey } = this.plugins(key).value
    box_get
    assert // Box must have value
    dup
    intc 6 // 224
    getbit
    swap
    pushint 225 // 225
    getbit
    swap
    // smart_contracts/arc58/account/contract.algo.ts:351-353
    // const epochRef = useRounds
    //   ? Global.round
    //   : Global.latestTimestamp;
    bz assertValidGroup_ternary_false@2

assertValidGroup_ternary_true@1:
    // smart_contracts/arc58/account/contract.algo.ts:352
    // ? Global.round
    global Round

assertValidGroup_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:351-353
    // const epochRef = useRounds
    //   ? Global.round
    //   : Global.latestTimestamp;
    frame_bury 6
    // smart_contracts/arc58/account/contract.algo.ts:355
    // if (useExecutionKey) {
    frame_dig 14
    bz assertValidGroup_after_if_else@9

assertValidGroup_if_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:357
    // this.executions(Global.groupId).exists &&
    global GroupID
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:357
    // this.executions(Global.groupId).exists &&
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:357-358
    // this.executions(Global.groupId).exists &&
    // epochRef < this.executions(Global.groupId).value,
    bz assertValidGroup_bool_false@7

assertValidGroup_and_contd@5:
    // smart_contracts/arc58/account/contract.algo.ts:358
    // epochRef < this.executions(Global.groupId).value,
    global GroupID
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:358
    // epochRef < this.executions(Global.groupId).value,
    box_get
    assert // Box must have value
    btoi
    frame_dig 6
    >
    // smart_contracts/arc58/account/contract.algo.ts:357-358
    // this.executions(Global.groupId).exists &&
    // epochRef < this.executions(Global.groupId).value,
    bz assertValidGroup_bool_false@7

assertValidGroup_bool_true@6:
    intc_1 // 1

assertValidGroup_bool_merge@8:
    // smart_contracts/arc58/account/contract.algo.ts:356-360
    // assert(
    //   this.executions(Global.groupId).exists &&
    //   epochRef < this.executions(Global.groupId).value,
    //   ERR_BAD_EXECUTION_KEY
    // )
    assert // The execution key does not match the group ID of the transaction

assertValidGroup_after_if_else@9:
    // smart_contracts/arc58/account/contract.algo.ts:363
    // const initialCheck = this.pluginCheck(key);
    frame_dig -2
    callsub pluginCheck
    swap
    frame_bury 4
    frame_bury -2
    intc_1 // 1
    bz assertValidGroup_after_if_else@11

assertValidGroup_if_body@10:
    frame_dig -2
    frame_bury 12

assertValidGroup_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:363
    // const initialCheck = this.pluginCheck(key);
    frame_dig 4
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:365
    // assert(initialCheck.exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    intc_0 // 0
    getbit
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:366
    // assert(!initialCheck.expired, ERR_PLUGIN_EXPIRED);
    dup
    intc_1 // 1
    getbit
    !
    assert // plugin expired
    // smart_contracts/arc58/account/contract.algo.ts:367
    // assert(!initialCheck.onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    pushint 3 // 3
    getbit
    !
    assert // plugin on cooldown
    // smart_contracts/arc58/account/contract.algo.ts:369
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 10
    // smart_contracts/arc58/account/contract.algo.ts:370
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 8
    // smart_contracts/arc58/account/contract.algo.ts:372
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 7

assertValidGroup_while_top@12:
    // smart_contracts/arc58/account/contract.algo.ts:372
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    global GroupSize
    frame_dig 7
    >
    bz assertValidGroup_after_while@31

assertValidGroup_while_body@13:
    // smart_contracts/arc58/account/contract.algo.ts:373
    // const txn = gtxn.Transaction(i)
    frame_dig 7
    dup
    frame_bury 11
    // smart_contracts/arc58/account/contract.algo.ts:375
    // if (this.txnRekeysBack(txn)) {
    callsub txnRekeysBack
    bz assertValidGroup_after_if_else@15

assertValidGroup_if_body@14:
    // smart_contracts/arc58/account/contract.algo.ts:376
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 10

assertValidGroup_block@32:
    // smart_contracts/arc58/account/contract.algo.ts:408
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 10
    assert // missing rekey back
    frame_dig 12
    frame_dig 13
    frame_bury 1
    frame_bury 0
    retsub

assertValidGroup_after_if_else@15:
    // smart_contracts/arc58/account/contract.algo.ts:380
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 11
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bz assertValidGroup_after_if_else@17

assertValidGroup_if_body@16:

assertValidGroup_block@30:
    // smart_contracts/arc58/account/contract.algo.ts:372
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    b assertValidGroup_while_top@12

assertValidGroup_after_if_else@17:
    // smart_contracts/arc58/account/contract.algo.ts:384
    // assert(txn.appId.id === key.plugin, ERR_CANNOT_CALL_OTHER_APPS_DURING_REKEY);
    frame_dig 11
    dup
    gtxns ApplicationID
    frame_dig -2
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    ==
    assert // cannot call other apps during rekey
    // smart_contracts/arc58/account/contract.algo.ts:385
    // assert(txn.onCompletion === OnCompleteAction.NoOp, ERR_INVALID_ONCOMPLETE);
    dup
    gtxns OnCompletion
    intc_0 // 0
    ==
    assert // invalid oncomplete must be no op
    // smart_contracts/arc58/account/contract.algo.ts:388
    // assert(txn.numAppArgs > 1, ERR_INVALID_SENDER_ARG);
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // invalid sender must be this app id
    // smart_contracts/arc58/account/contract.algo.ts:389
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, ERR_INVALID_SENDER_VALUE);
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // invalid sender app id
    // smart_contracts/arc58/account/contract.algo.ts:391
    // const { hasMethodRestrictions, valid } = this.pluginCheck(key);
    frame_dig -2
    callsub pluginCheck
    swap
    frame_bury 5
    frame_bury -2
    intc_1 // 1
    bz assertValidGroup_after_if_else@19

assertValidGroup_if_body@18:
    frame_dig -2
    frame_bury 12

assertValidGroup_after_if_else@19:
    // smart_contracts/arc58/account/contract.algo.ts:391
    // const { hasMethodRestrictions, valid } = this.pluginCheck(key);
    frame_dig 5
    dup
    intc_3 // 4
    getbit
    swap
    pushint 5 // 5
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:393
    // assert(valid, ERR_INVALID_PLUGIN_CALL);
    assert // invalid plugin call
    frame_dig 12
    frame_bury 2
    frame_dig -2
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:395
    // if (hasMethodRestrictions) {
    bz assertValidGroup_after_if_else@27

assertValidGroup_if_body@20:
    // smart_contracts/arc58/account/contract.algo.ts:396
    // assert(methodIndex < methodOffsets.length, ERR_MALFORMED_OFFSETS);
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 8
    dup
    cover 2
    >
    assert // malformed method offsets
    // smart_contracts/arc58/account/contract.algo.ts:397
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    frame_dig -1
    extract 2 0
    swap
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    frame_dig -2
    frame_dig 11
    uncover 2
    callsub methodCheck
    swap
    frame_bury 3
    frame_bury -2
    intc_1 // 1
    bz assertValidGroup_after_if_else@22

assertValidGroup_if_body@21:
    frame_dig -2
    frame_bury 12

assertValidGroup_after_if_else@22:
    // smart_contracts/arc58/account/contract.algo.ts:397
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    frame_dig 3
    dup
    intc_0 // 0
    getbit
    swap
    pushint 2 // 2
    getbit
    frame_bury 9
    // smart_contracts/arc58/account/contract.algo.ts:398
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    bz assertValidGroup_bool_false@25

assertValidGroup_and_contd@23:
    // smart_contracts/arc58/account/contract.algo.ts:398
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    frame_dig 9
    bnz assertValidGroup_bool_false@25

assertValidGroup_bool_true@24:
    intc_1 // 1

assertValidGroup_bool_merge@26:
    // smart_contracts/arc58/account/contract.algo.ts:398
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    assert // method on cooldown
    frame_dig 12
    frame_bury 2
    frame_dig -2
    frame_bury 1

assertValidGroup_after_if_else@27:
    frame_dig 2
    frame_bury 12
    frame_dig 1
    frame_bury -2
    // smart_contracts/arc58/account/contract.algo.ts:401
    // if (initialCheck.hasCooldown) {
    frame_dig 0
    pushint 2 // 2
    getbit
    bz assertValidGroup_after_if_else@29

assertValidGroup_if_body@28:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:402
    // this.plugins(key).value.lastCalled = epochRef
    dup
    box_get
    assert // Box must have value
    frame_dig 6
    itob
    swap
    pushint 29 // 29
    uncover 2
    replace3
    dig 1
    box_del
    pop
    box_put

assertValidGroup_after_if_else@29:
    // smart_contracts/arc58/account/contract.algo.ts:405
    // methodIndex += 1;
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 8
    b assertValidGroup_block@30

assertValidGroup_bool_false@25:
    intc_0 // 0
    b assertValidGroup_bool_merge@26

assertValidGroup_after_while@31:
    b assertValidGroup_block@32

assertValidGroup_bool_false@7:
    intc_0 // 0
    b assertValidGroup_bool_merge@8

assertValidGroup_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:353
    // : Global.latestTimestamp;
    global LatestTimestamp
    b assertValidGroup_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck(key: bytes, txn: uint64, offset: uint64) -> bytes, bytes:
methodCheck:
    // smart_contracts/arc58/account/contract.algo.ts:419
    // private methodCheck(key: PluginKey, txn: gtxn.ApplicationCallTxn, offset: uint64): MethodValidation {
    proto 3 2
    bytec_0 // ""

methodCheck_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:421
    // assert(len(txn.appArgs(0)) === 4, ERR_INVALID_METHOD_SIGNATURE_LENGTH)
    frame_dig -2
    intc_0 // 0
    gtxnsas ApplicationArgs
    len
    intc_3 // 4
    ==
    assert // invalid method signature length
    // smart_contracts/arc58/account/contract.algo.ts:422
    // const selectorArg = txn.appArgs(0).toFixed({ length: 4 })
    frame_dig -2
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    len
    intc_3 // 4
    ==
    assert // Length must be 4
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:424
    // const { useRounds } = this.plugins(key).value
    box_get
    assert // Box must have value
    intc 6 // 224
    getbit
    dup
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:425
    // const { selector, cooldown, lastCalled } = this.plugins(key).value.methods[offset]
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    extract 2 0
    frame_dig -1
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    intc_3 // 4
    extract3
    swap
    dup
    intc_3 // 4
    intc_2 // 8
    extract3
    btoi
    swap
    pushint 12 // 12
    intc_2 // 8
    extract3
    btoi
    uncover 2
    cover 3
    swap
    dup
    cover 3
    swap
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:427
    // const hasCooldown = cooldown > 0
    intc_0 // 0
    >
    swap
    // smart_contracts/arc58/account/contract.algo.ts:429
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    bz methodCheck_ternary_false@2

methodCheck_ternary_true@1:
    // smart_contracts/arc58/account/contract.algo.ts:429
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    global Round

methodCheck_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:430
    // const onCooldown = (epochRef - lastCalled) < cooldown
    frame_dig 5
    -
    frame_dig 4
    <
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:432
    // if (selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 3
    frame_dig 1
    ==
    bz methodCheck_after_if_else@12

methodCheck_and_contd@4:
    // smart_contracts/arc58/account/contract.algo.ts:432
    // if (selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 6
    bz methodCheck_if_body@6

methodCheck_or_contd@5:
    // smart_contracts/arc58/account/contract.algo.ts:432
    // if (selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 0
    bnz methodCheck_after_if_else@12

methodCheck_if_body@6:
    // smart_contracts/arc58/account/contract.algo.ts:434
    // if (hasCooldown) {
    frame_dig 6
    bz methodCheck_after_if_else@11

methodCheck_if_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:435
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 2
    bz methodCheck_ternary_false@9

methodCheck_ternary_true@8:
    // smart_contracts/arc58/account/contract.algo.ts:435
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    global Round

methodCheck_ternary_merge@10:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:436
    // this.plugins(key).value.methods[offset].lastCalled = lastCalled
    dup
    box_get
    assert // Box must have value
    uncover 2
    itob
    swap
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    dup
    uncover 3
    uncover 3
    substring3
    dup
    extract 2 0
    frame_dig -1
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: index access is out of bounds
    pushint 12 // 12
    uncover 4
    replace3
    frame_dig -1
    pushint 20 // 20
    *
    pushint 2 // 2
    +
    uncover 2
    swap
    uncover 2
    replace3
    dig 1
    pushint 26 // 26
    extract_uint16
    uncover 2
    intc_0 // 0
    uncover 2
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put

methodCheck_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:439-443
    // return {
    //   methodAllowed: true,
    //   methodHasCooldown: hasCooldown,
    //   methodOnCooldown: onCooldown
    // }
    bytec 5 // 0x00
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:440
    // methodAllowed: true,
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:439-443
    // return {
    //   methodAllowed: true,
    //   methodHasCooldown: hasCooldown,
    //   methodOnCooldown: onCooldown
    // }
    setbit
    intc_1 // 1
    frame_dig 6
    setbit
    pushint 2 // 2
    frame_dig 0
    setbit
    bytec_0 // 0x
    swap
    concat
    frame_dig -3
    frame_bury 1
    frame_bury 0
    retsub

methodCheck_ternary_false@9:
    // smart_contracts/arc58/account/contract.algo.ts:435
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b methodCheck_ternary_merge@10

methodCheck_after_if_else@12:
    // smart_contracts/arc58/account/contract.algo.ts:446-450
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    bytec 5 // 0x00
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:447
    // methodAllowed: false,
    dup
    // smart_contracts/arc58/account/contract.algo.ts:446-450
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    setbit
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:448
    // methodHasCooldown: true,
    dup
    // smart_contracts/arc58/account/contract.algo.ts:446-450
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    setbit
    pushint 2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:449
    // methodOnCooldown: true
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:446-450
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    setbit
    bytec_0 // 0x
    swap
    concat
    frame_dig -3
    frame_bury 1
    frame_bury 0
    retsub

methodCheck_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:429
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    b methodCheck_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.transferFunds(key: bytes, escrowID: uint64, fundsRequests: bytes) -> bytes, bytes:
transferFunds:
    // smart_contracts/arc58/account/contract.algo.ts:453
    // private transferFunds(key: PluginKey, escrowID: uint64, fundsRequests: FundsRequest[]): void {
    proto 3 2

transferFunds_block@0:
    frame_dig -3
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:454
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0

transferFunds_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:454
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz transferFunds_after_while@8

transferFunds_while_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:458
    // asset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:456-459
    // const allowanceKey: AllowanceKey = {
    //   escrow: escrowID,
    //   asset: fundsRequests[i].asset
    // }
    frame_dig -2
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:461
    // this.verifyAllowance(allowanceKey, fundsRequests[i]);
    frame_dig -1
    extract 2 0
    dig 2
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    callsub verifyAllowance
    popn 2
    // smart_contracts/arc58/account/contract.algo.ts:463
    // if (fundsRequests[i].asset !== 0) {
    frame_dig -1
    extract 2 0
    swap
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    intc_0 // 0
    !=
    bz transferFunds_else_body@5

transferFunds_if_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:464-471
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:468
    // assetAmount: fundsRequests[i].amount,
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    intc_2 // 8
    dup
    extract3
    btoi
    swap
    // smart_contracts/arc58/account/contract.algo.ts:469
    // xferAsset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    swap
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:464-470
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

transferFunds_next_txn@4:
    // smart_contracts/arc58/account/contract.algo.ts:464-471
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_submit

transferFunds_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:454
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b transferFunds_while_top@1

transferFunds_else_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:473-479
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:477
    // amount: fundsRequests[i].amount
    frame_dig -1
    extract 2 0
    frame_dig 2
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    intc_2 // 8
    dup
    extract3
    btoi
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:473-478
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

transferFunds_next_txn@6:
    // smart_contracts/arc58/account/contract.algo.ts:473-479
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_submit
    b transferFunds_after_if_else@7

transferFunds_after_while@8:
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.verifyAllowance(key: bytes, fundRequest: bytes) -> bytes, bytes:
verifyAllowance:
    // smart_contracts/arc58/account/contract.algo.ts:484
    // private verifyAllowance(key: AllowanceKey, fundRequest: FundsRequest): void {
    proto 2 2
    bytec_0 // ""

verifyAllowance_block@0:
    frame_dig -2
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:485
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:486
    // const { type, spent, allowed, last, max, interval, start, useRounds } = this.allowances(key).value
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    swap
    dup
    pushint 17 // 17
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 33 // 33
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 41 // 41
    intc_2 // 8
    extract3
    btoi
    swap
    intc 4 // 392
    getbit
    dup
    // smart_contracts/arc58/account/contract.algo.ts:487
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    bz verifyAllowance_ternary_false@2

verifyAllowance_ternary_true@1:
    // smart_contracts/arc58/account/contract.algo.ts:487
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    global Round

verifyAllowance_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:487
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:489
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 3
    bytec 12 // 0x01
    ==
    bz verifyAllowance_else_body@5

verifyAllowance_if_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:490
    // const leftover: uint64 = allowed - spent;
    frame_dig 5
    frame_dig 4
    dup
    cover 2
    -
    // smart_contracts/arc58/account/contract.algo.ts:492
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:495
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    cover 4
    dup
    pushint 33 // 33
    intc_2 // 8
    extract3
    btoi
    cover 3
    dup
    pushint 41 // 41
    intc_2 // 8
    extract3
    btoi
    cover 3
    intc 4 // 392
    getbit
    cover 6
    // smart_contracts/arc58/account/contract.algo.ts:496
    // spent: (spent + fundRequest.amount)
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    uncover 8
    +
    // smart_contracts/arc58/account/contract.algo.ts:494-497
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount)
    // }
    bytec_0 // 0x
    uncover 6
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    bytec 5 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:494-497
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount)
    // }
    swap
    box_put

verifyAllowance_after_if_else@17:
    frame_dig 1
    frame_dig 2
    frame_bury 1
    frame_bury 0
    retsub

verifyAllowance_else_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:498
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 3
    pushbytes 0x02
    ==
    bz verifyAllowance_else_body@10

verifyAllowance_if_body@6:
    // smart_contracts/arc58/account/contract.algo.ts:499
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    frame_dig 10
    frame_dig 9
    frame_dig 8
    callsub getLatestWindowStart
    // smart_contracts/arc58/account/contract.algo.ts:501
    // if (currentWindowStart > last) {
    frame_dig 6
    >
    bz verifyAllowance_else_body@8

verifyAllowance_if_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:502
    // assert(allowed >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    frame_dig 5
    <=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:505
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    cover 4
    dup
    pushint 41 // 41
    intc_2 // 8
    extract3
    btoi
    cover 5
    intc 4 // 392
    getbit
    cover 5
    // smart_contracts/arc58/account/contract.algo.ts:506
    // spent: fundRequest.amount,
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:504-508
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: fundRequest.amount,
    //   last: newLast
    // }
    bytec_0 // 0x
    uncover 4
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    frame_dig 0
    itob
    concat
    swap
    itob
    concat
    bytec 5 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:504-508
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: fundRequest.amount,
    //   last: newLast
    // }
    swap
    box_put

verifyAllowance_after_if_else@9:

verifyAllowance_after_if_else@16:
    b verifyAllowance_after_if_else@17

verifyAllowance_else_body@8:
    // smart_contracts/arc58/account/contract.algo.ts:511
    // const leftover: uint64 = allowed - spent;
    frame_dig 5
    frame_dig 4
    dup
    cover 2
    -
    // smart_contracts/arc58/account/contract.algo.ts:512
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:515
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    cover 4
    dup
    pushint 41 // 41
    intc_2 // 8
    extract3
    btoi
    cover 5
    intc 4 // 392
    getbit
    cover 5
    // smart_contracts/arc58/account/contract.algo.ts:516
    // spent: (spent + fundRequest.amount),
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    uncover 7
    +
    // smart_contracts/arc58/account/contract.algo.ts:514-518
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount),
    //   last: newLast
    // }
    bytec_0 // 0x
    uncover 4
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    frame_dig 0
    itob
    concat
    swap
    itob
    concat
    bytec 5 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:514-518
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount),
    //   last: newLast
    // }
    swap
    box_put
    b verifyAllowance_after_if_else@9

verifyAllowance_else_body@10:
    // smart_contracts/arc58/account/contract.algo.ts:521
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 3
    pushbytes 0x03
    ==
    bz verifyAllowance_after_if_else@15

verifyAllowance_if_body@11:
    // smart_contracts/arc58/account/contract.algo.ts:522
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 10
    bz verifyAllowance_ternary_false@13

verifyAllowance_ternary_true@12:
    // smart_contracts/arc58/account/contract.algo.ts:522
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

verifyAllowance_ternary_merge@14:
    // smart_contracts/arc58/account/contract.algo.ts:524
    // const amount = fundRequest.amount
    frame_dig -1
    intc_2 // 8
    dup
    extract3
    btoi
    swap
    // smart_contracts/arc58/account/contract.algo.ts:525
    // const accrualRate = allowed
    frame_dig 5
    // smart_contracts/arc58/account/contract.algo.ts:526
    // const lastLeftover = spent
    frame_dig 4
    swap
    // smart_contracts/arc58/account/contract.algo.ts:528
    // const passed: uint64 = epochRef - last
    uncover 2
    frame_dig 6
    -
    // smart_contracts/arc58/account/contract.algo.ts:529
    // const accrued: uint64 = lastLeftover + ((passed / interval) * accrualRate)
    frame_dig 8
    /
    *
    +
    // smart_contracts/arc58/account/contract.algo.ts:531
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 7
    dup
    cover 3
    >
    swap
    uncover 2
    uncover 2
    select
    // smart_contracts/arc58/account/contract.algo.ts:533
    // assert(available >= amount, ERR_ALLOWANCE_EXCEEDED);
    dup
    dig 2
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:536
    // ...this.allowances(key).value,
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    swap
    dup
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    cover 4
    dup
    pushint 41 // 41
    intc_2 // 8
    extract3
    btoi
    cover 5
    intc 4 // 392
    getbit
    cover 5
    // smart_contracts/arc58/account/contract.algo.ts:537
    // spent: (available - amount),
    uncover 6
    uncover 7
    -
    // smart_contracts/arc58/account/contract.algo.ts:535-539
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (available - amount),
    //   last: newLast
    // }
    bytec_0 // 0x
    uncover 4
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    frame_dig 0
    itob
    concat
    swap
    itob
    concat
    bytec 5 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:535-539
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (available - amount),
    //   last: newLast
    // }
    swap
    box_put

verifyAllowance_after_if_else@15:
    b verifyAllowance_after_if_else@16

verifyAllowance_ternary_false@13:
    // smart_contracts/arc58/account/contract.algo.ts:522
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b verifyAllowance_ternary_merge@14

verifyAllowance_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:487
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b verifyAllowance_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart(useRounds: uint64, start: uint64, interval: uint64) -> uint64:
getLatestWindowStart:
    // smart_contracts/arc58/account/contract.algo.ts:543
    // private getLatestWindowStart(useRounds: boolean, start: uint64, interval: uint64): uint64 {
    proto 3 1

getLatestWindowStart_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:544
    // if (useRounds) {
    frame_dig -3
    bz getLatestWindowStart_after_if_else@2

getLatestWindowStart_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:545
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig -2
    -
    frame_dig -1
    %
    -
    retsub

getLatestWindowStart_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:547
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig -2
    -
    frame_dig -1
    %
    -
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getAuthAddr() -> bytes:
getAuthAddr:

getAuthAddr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:556
    // this.spendingAddress.value === this.controlledAddress.value
    ==
    // smart_contracts/arc58/account/contract.algo.ts:556-557
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz getAuthAddr_ternary_false@3

getAuthAddr_and_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:557
    // && this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:556-557
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz getAuthAddr_ternary_false@3

getAuthAddr_ternary_true@2:
    // smart_contracts/arc58/account/contract.algo.ts:558
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global ZeroAddress

getAuthAddr_ternary_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:555-558
    // return (
    //   this.spendingAddress.value === this.controlledAddress.value
    //   && this.controlledAddress.value === Global.currentApplicationAddress
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    retsub

getAuthAddr_ternary_false@3:
    // smart_contracts/arc58/account/contract.algo.ts:558
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global CurrentApplicationAddress
    b getAuthAddr_ternary_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(version: bytes, controlledAddress: bytes, admin: bytes, escrowFactory: uint64, revocationApp: uint64, nickname: bytes) -> void:
create:
    // smart_contracts/arc58/account/contract.algo.ts:573-581
    // @abimethod({ onCreate: 'require' })
    // create(
    //   version: string,
    //   controlledAddress: Address,
    //   admin: Address,
    //   escrowFactory: uint64,
    //   revocationApp: uint64,
    //   nickname: string
    // ): void {
    proto 6 0

create_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:582
    // assert(Global.callerApplicationId !== 0, ERR_BAD_DEPLOYER)
    global CallerApplicationID
    intc_0 // 0
    !=
    assert // This contract must be deployed from a factory
    // smart_contracts/arc58/account/contract.algo.ts:583
    // assert(admin !== controlledAddress)
    frame_dig -4
    frame_dig -5
    !=
    assert
    // smart_contracts/arc58/account/contract.algo.ts:100
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 16 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:585
    // this.version.value = version
    frame_dig -6
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:586
    // this.admin.value = admin.native
    frame_dig -4
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 8 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:586
    // this.admin.value = admin.native
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:588
    // controlledAddress.native === Global.zeroAddress
    frame_dig -5
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:588-590
    // controlledAddress.native === Global.zeroAddress
    //   ? Global.currentApplicationAddress
    //   : controlledAddress.native
    bz create_ternary_false@2

create_ternary_true@1:
    // smart_contracts/arc58/account/contract.algo.ts:589
    // ? Global.currentApplicationAddress
    global CurrentApplicationAddress

create_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_1 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:587-590
    // this.controlledAddress.value =
    //   controlledAddress.native === Global.zeroAddress
    //     ? Global.currentApplicationAddress
    //     : controlledAddress.native
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:122
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    bytec 11 // "escrow_factory"
    // smart_contracts/arc58/account/contract.algo.ts:591
    // this.escrowFactory.value = Application(escrowFactory)
    frame_dig -3
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:592
    // this.spendingAddress.value = Global.zeroAddress;
    global ZeroAddress
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 7 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:592
    // this.spendingAddress.value = Global.zeroAddress;
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:126
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 14 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:593
    // this.revocation.value = Application(revocationApp)
    frame_dig -2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:108
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 17 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:594
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:595
    // this.factoryApp.value = Application(Global.callerApplicationId)
    global CallerApplicationID
    // smart_contracts/arc58/account/contract.algo.ts:124
    // factoryApp = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysFactoryApp })
    pushbytes "factory_app"
    // smart_contracts/arc58/account/contract.algo.ts:595
    // this.factoryApp.value = Application(Global.callerApplicationId)
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:597
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:598
    // this.updateLastChange()
    callsub updateLastChange
    retsub

create_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:590
    // : controlledAddress.native
    frame_dig -5
    b create_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.init() -> void:
init:

init_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:607-618
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:122
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 11 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:613
    // receiver: this.escrowFactory.value.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:614
    // amount: ARC58WalletIDsByAccountsMbr
    pushint 12100 // 12100
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:612-615
    // itxn.payment({
    //   receiver: this.escrowFactory.value.address,
    //   amount: ARC58WalletIDsByAccountsMbr
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

init_next_txn@1:
    // smart_contracts/arc58/account/contract.algo.ts:607-618
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    itxn_next
    // smart_contracts/arc58/account/contract.algo.ts:122
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 11 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:607-618
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    pushbytes 0xf040dd0d // method "register(pay)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

init_next_txn@2:
    // smart_contracts/arc58/account/contract.algo.ts:607-618
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    itxn_submit
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(version: bytes) -> void:
update:
    // smart_contracts/arc58/account/contract.algo.ts:622-623
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(version: string): void {
    proto 1 0

update_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:624
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_UPDATE)
    callsub isAdmin
    assert // Only an admin can update the application
    // smart_contracts/arc58/account/contract.algo.ts:100
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 16 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:625
    // this.version.value = version
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(newRevocationApp: uint64) -> void:
changeRevocationApp:
    // smart_contracts/arc58/account/contract.algo.ts:635
    // changeRevocationApp(newRevocationApp: uint64): void {
    proto 1 0

changeRevocationApp_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:636
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_REVOKE)
    callsub isAdmin
    assert // Only an admin can change the revocation app
    // smart_contracts/arc58/account/contract.algo.ts:126
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 14 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:637
    // this.revocation.value = Application(newRevocationApp)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(nickname: bytes) -> void:
setNickname:
    // smart_contracts/arc58/account/contract.algo.ts:645
    // setNickname(nickname: string): void {
    proto 1 0

setNickname_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:646
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:108
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 17 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:647
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(avatar: uint64) -> void:
setAvatar:
    // smart_contracts/arc58/account/contract.algo.ts:655
    // setAvatar(avatar: uint64): void {
    proto 1 0

setAvatar_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:656
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:657
    // const amount = this.balance([avatar])
    intc_1 // 1
    itob
    extract 6 2
    frame_dig -1
    itob
    concat
    callsub balance
    pop
    // smart_contracts/arc58/account/contract.algo.ts:658
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract 2 0
    intc_0 // 0
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    intc_0 // 0
    >
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:110
    // avatar = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysAvatar })
    pushbytes "avatar"
    // smart_contracts/arc58/account/contract.algo.ts:659
    // this.avatar.value = Asset(avatar)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(banner: uint64) -> void:
setBanner:
    // smart_contracts/arc58/account/contract.algo.ts:667
    // setBanner(banner: uint64): void {
    proto 1 0

setBanner_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:668
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:669
    // const amount = this.balance([banner])
    intc_1 // 1
    itob
    extract 6 2
    frame_dig -1
    itob
    concat
    callsub balance
    pop
    // smart_contracts/arc58/account/contract.algo.ts:670
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract 2 0
    intc_0 // 0
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    intc_0 // 0
    >
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:112
    // banner = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysBanner })
    pushbytes "banner"
    // smart_contracts/arc58/account/contract.algo.ts:671
    // this.banner.value = Asset(banner)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(bio: bytes) -> void:
setBio:
    // smart_contracts/arc58/account/contract.algo.ts:679
    // setBio(bio: string): void {
    proto 1 0

setBio_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:680
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:114
    // bio = GlobalState<string>({ key: AbstractAccountGlobalStateKeysBio })
    pushbytes "bio"
    // smart_contracts/arc58/account/contract.algo.ts:681
    // this.bio.value = bio
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:689
    // arc58_changeAdmin(newAdmin: Address): void {
    proto 1 0

arc58_changeAdmin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:690
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_ADMIN);
    callsub isAdmin
    assert // Only an admin can change the admin account
    // smart_contracts/arc58/account/contract.algo.ts:691
    // this.admin.value = newAdmin.native;
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 8 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:691
    // this.admin.value = newAdmin.native;
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:692
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:693
    // this.updateLastChange()
    callsub updateLastChange
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, caller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:704
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    proto 3 0

arc58_pluginChangeAdmin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:705
    // assert(Txn.sender === Application(plugin).address, ERR_SENDER_MUST_BE_ADMIN_PLUGIN);
    txn Sender
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    assert // sender must be admin plugin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:707
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:706-709
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // smart_contracts/arc58/account/contract.algo.ts:711
    // const key: PluginKey = { plugin, caller: caller.native, escrow: '' };
    frame_dig -2
    frame_dig -3
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    bytec_0 // ""
    len
    itob
    extract 6 2
    bytec_0 // ""
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:714
    // this.plugins(key).exists && this.plugins(key).value.admin,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@3

arc58_pluginChangeAdmin_and_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 0
    concat
    // smart_contracts/arc58/account/contract.algo.ts:714
    // this.plugins(key).exists && this.plugins(key).value.admin,
    box_get
    assert // Box must have value
    pushint 64 // 64
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3

arc58_pluginChangeAdmin_bool_true@2:
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:713-716
    // assert(
    //   this.plugins(key).exists && this.plugins(key).value.admin,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // smart_contracts/arc58/account/contract.algo.ts:718
    // this.admin.value = newAdmin.native;
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 8 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:718
    // this.admin.value = newAdmin.native;
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 0
    concat
    // smart_contracts/arc58/account/contract.algo.ts:719
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    box_get
    assert // Box must have value
    pushint 9 // 9
    intc_1 // 1
    extract3
    bytec 12 // 0x01
    ==
    bz arc58_pluginChangeAdmin_after_if_else@6

arc58_pluginChangeAdmin_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:720
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction

arc58_pluginChangeAdmin_after_if_else@6:
    // smart_contracts/arc58/account/contract.algo.ts:722
    // this.updateLastChange()
    callsub updateLastChange
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:

arc58_verifyAuthAddr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:729
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    acct_params_get AcctAuthAddr
    assert // account funded
    callsub getAuthAddr
    ==
    assert
    // smart_contracts/arc58/account/contract.algo.ts:730
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 7 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:730
    // this.spendingAddress.value = Global.zeroAddress
    swap
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: uint64) -> void:
arc58_rekeyTo:
    // smart_contracts/arc58/account/contract.algo.ts:739
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    proto 2 0

arc58_rekeyTo_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:740
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:742-749
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:745
    // receiver: address.native,
    frame_dig -2
    // smart_contracts/arc58/account/contract.algo.ts:746
    // rekeyTo: address.native,
    dup
    // smart_contracts/arc58/account/contract.algo.ts:747
    // note: 'rekeying abstracted account'
    pushbytes "rekeying abstracted account"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:742-748
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_rekeyTo_next_txn@1:
    // smart_contracts/arc58/account/contract.algo.ts:742-749
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:751
    // if (flash) this.assertRekeysBack();
    frame_dig -1
    bz arc58_rekeyTo_after_if_else@3

arc58_rekeyTo_if_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:751
    // if (flash) this.assertRekeysBack();
    callsub assertRekeysBack

arc58_rekeyTo_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:753
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: uint64, address: bytes, escrow: bytes, method: bytes) -> uint64:
arc58_canCall:
    // smart_contracts/arc58/account/contract.algo.ts:765-772
    // @abimethod({ readonly: true })
    // arc58_canCall(
    //   plugin: uint64,
    //   global: boolean,
    //   address: Address,
    //   escrow: string,
    //   method: bytes<4>
    // ): boolean {
    proto 5 1

arc58_canCall_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:773
    // if (global) {
    frame_dig -4
    bz arc58_canCall_after_if_else@2

arc58_canCall_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:774
    // this.pluginCallAllowed(plugin, Global.zeroAddress, escrow, method);
    global ZeroAddress
    frame_dig -5
    swap
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:776
    // return this.pluginCallAllowed(plugin, address.native, escrow, method);
    frame_dig -3
    frame_dig -5
    swap
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: uint64, escrow: bytes, methodOffsets: bytes, fundsRequest: bytes) -> bytes, bytes:
arc58_rekeyToPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:788-794
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    proto 5 2
    intc_0 // 0

arc58_rekeyToPlugin_block@0:
    frame_dig -2
    frame_dig -1
    // smart_contracts/arc58/account/contract.algo.ts:795
    // const pluginApp = Application(plugin)
    frame_dig -5
    // smart_contracts/arc58/account/contract.algo.ts:796
    // const caller = global ? Global.zeroAddress : Txn.sender
    frame_dig -4
    bz arc58_rekeyToPlugin_ternary_false@2

arc58_rekeyToPlugin_ternary_true@1:
    // smart_contracts/arc58/account/contract.algo.ts:796
    // const caller = global ? Global.zeroAddress : Txn.sender
    global ZeroAddress

arc58_rekeyToPlugin_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:797
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -5
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:799
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:801
    // if (escrow !== '') {
    frame_dig -3
    bytec_0 // ""
    !=
    bz arc58_rekeyToPlugin_else_body@7

arc58_rekeyToPlugin_if_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:802
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:803
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:804
    // const spendingApp = Application(escrowID)
    dup
    // smart_contracts/arc58/account/contract.algo.ts:805
    // this.spendingAddress.value = spendingApp.address
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 7 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:805
    // this.spendingAddress.value = spendingApp.address
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:806
    // this.transferFunds(key, escrowID, fundsRequest)
    frame_dig 0
    swap
    frame_dig -1
    callsub transferFunds
    swap
    frame_bury 0
    frame_bury -1
    intc_1 // 1
    bz arc58_rekeyToPlugin_after_if_else@6

arc58_rekeyToPlugin_if_body@5:
    frame_dig -1
    frame_bury 2

arc58_rekeyToPlugin_after_if_else@6:

arc58_rekeyToPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:811
    // this.assertValidGroup(key, methodOffsets)
    frame_dig 0
    frame_dig -2
    callsub assertValidGroup
    swap
    frame_bury 0
    frame_bury -2
    intc_1 // 1
    bz arc58_rekeyToPlugin_after_if_else@10

arc58_rekeyToPlugin_if_body@9:
    frame_dig -2
    frame_bury 1

arc58_rekeyToPlugin_after_if_else@10:
    // smart_contracts/arc58/account/contract.algo.ts:813-820
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec 7 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:817
    // rekeyTo: pluginApp.address,
    frame_dig 3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:818
    // note: 'rekeying to plugin app'
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:813-819
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_rekeyToPlugin_next_txn@11:
    // smart_contracts/arc58/account/contract.algo.ts:813-820
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 0
    concat
    // smart_contracts/arc58/account/contract.algo.ts:822
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    box_get
    assert // Box must have value
    pushint 9 // 9
    intc_1 // 1
    extract3
    bytec 12 // 0x01
    ==
    bz arc58_rekeyToPlugin_after_if_else@13

arc58_rekeyToPlugin_if_body@12:
    // smart_contracts/arc58/account/contract.algo.ts:823
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction

arc58_rekeyToPlugin_after_if_else@13:
    frame_dig 1
    frame_dig 2
    frame_bury 1
    frame_bury 0
    retsub

arc58_rekeyToPlugin_else_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:120
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 7 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:808
    // this.spendingAddress.value = this.controlledAddress.value
    swap
    app_global_put
    b arc58_rekeyToPlugin_after_if_else@8

arc58_rekeyToPlugin_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:796
    // const caller = global ? Global.zeroAddress : Txn.sender
    txn Sender
    b arc58_rekeyToPlugin_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: uint64, escrow: bytes, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:836-841
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    proto 5 0

arc58_rekeyToNamedPlugin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -5
    concat
    // smart_contracts/arc58/account/contract.algo.ts:843
    // this.namedPlugins(name).value.plugin,
    box_get
    assert // Box must have value
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:842-848
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.plugin,
    //   global,
    //   escrow,
    //   methodOffsets,
    //   fundsRequest
    // );
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub arc58_rekeyToPlugin
    popn 2
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(plugin: uint64, caller: bytes, escrow: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useRounds: uint64, useExecutionKey: uint64, defaultToEscrow: uint64) -> void:
arc58_addPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:865-877
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    proto 11 0
    intc_0 // 0
    dupn 2
    bytec_0 // ""
    dup

arc58_addPlugin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:878
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:880
    // delegationType === DelegationTypeSelf &&
    frame_dig -7
    bytec 12 // 0x01
    ==
    // smart_contracts/arc58/account/contract.algo.ts:880-881
    // delegationType === DelegationTypeSelf &&
    // caller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3

arc58_addPlugin_and_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:881
    // caller.native === Global.zeroAddress
    frame_dig -10
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:880-881
    // delegationType === DelegationTypeSelf &&
    // caller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3

arc58_addPlugin_bool_true@2:
    intc_1 // 1

arc58_addPlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:883
    // assert(!badDelegationCombo, ERR_ZERO_ADDRESS_DELEGATION_TYPE)
    !
    assert // delegation type must not be self for global plugins
    // smart_contracts/arc58/account/contract.algo.ts:885
    // let escrowKey: string = escrow
    frame_dig -9
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:886
    // if (defaultToEscrow) {
    frame_dig -1
    bz arc58_addPlugin_after_if_else@6

arc58_addPlugin_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:887
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    frame_dig -9
    bytec_0 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:888
    // escrowKey = ''
    bytec_0 // ""
    frame_bury 0

arc58_addPlugin_after_if_else@6:
    // smart_contracts/arc58/account/contract.algo.ts:891
    // const key: PluginKey = { plugin, caller: caller.native, escrow: escrowKey }
    frame_dig -10
    frame_dig -11
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    frame_dig 0
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:893
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    extract 6 2
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:894
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 4

arc58_addPlugin_while_top@7:
    // smart_contracts/arc58/account/contract.algo.ts:894
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -4
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz arc58_addPlugin_after_while@9

arc58_addPlugin_while_body@8:
    // smart_contracts/arc58/account/contract.algo.ts:895
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    frame_dig -4
    extract 2 0
    frame_dig 4
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    intc_3 // 4
    extract3
    swap
    intc_3 // 4
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    len
    intc_3 // 4
    ==
    assert // invalid size
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    intc_0 // 0
    itob
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 2
    dup
    cover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    swap
    intc_0 // 0
    uncover 2
    replace3
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:894
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 4
    b arc58_addPlugin_while_top@7

arc58_addPlugin_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:898
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -3
    bz arc58_addPlugin_ternary_false@11

arc58_addPlugin_ternary_true@10:
    // smart_contracts/arc58/account/contract.algo.ts:898
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

arc58_addPlugin_ternary_merge@12:
    // smart_contracts/arc58/account/contract.algo.ts:898
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:900
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addPlugin_after_if_else@15

arc58_addPlugin_if_body@13:
    // smart_contracts/arc58/account/contract.algo.ts:901-907
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:904
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:905
    // amount: this.pluginsMbr(methodInfos.length)
    frame_dig 2
    intc_0 // 0
    extract_uint16
    callsub pluginsMbr
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:901-906
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_addPlugin_next_txn@14:
    // smart_contracts/arc58/account/contract.algo.ts:901-907
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length)
    //   })
    //   .submit()
    itxn_submit

arc58_addPlugin_after_if_else@15:
    // smart_contracts/arc58/account/contract.algo.ts:910
    // const escrowID = this.maybeNewEscrow(escrow);
    frame_dig -9
    callsub maybeNewEscrow
    // smart_contracts/arc58/account/contract.algo.ts:912-923
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    itob
    bytec_0 // 0x
    swap
    concat
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig -8
    setbit
    concat
    frame_dig -7
    concat
    frame_dig -6
    itob
    concat
    frame_dig -5
    itob
    concat
    pushint 45 // 45
    itob
    extract 6 2
    concat
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    intc_1 // 1
    frame_dig -2
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:921
    // lastCalled: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:912-923
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    itob
    concat
    frame_dig 3
    itob
    concat
    frame_dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:912-923
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:925
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:926
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_addPlugin_ternary_false@11:
    // smart_contracts/arc58/account/contract.algo.ts:898
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addPlugin_ternary_merge@12

arc58_addPlugin_bool_false@3:
    intc_0 // 0
    b arc58_addPlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(caller: bytes, domain: bytes) -> void:
assignDomain:
    // smart_contracts/arc58/account/contract.algo.ts:935
    // assignDomain(caller: Address, domain: string): void {
    proto 2 0

assignDomain_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:936
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_ADD_PLUGIN)
    callsub isAdmin
    assert // Only an admin can add a plugin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:938
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz assignDomain_after_if_else@3

assignDomain_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:939-945
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:942
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:943
    // amount: this.domainKeysMbr(domain)
    frame_dig -1
    callsub domainKeysMbr
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:939-944
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

assignDomain_next_txn@2:
    // smart_contracts/arc58/account/contract.algo.ts:939-945
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_submit

assignDomain_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:948
    // this.domainKeys(caller.native).value = domain
    frame_dig -2
    // smart_contracts/arc58/account/contract.algo.ts:152
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 13 // "d"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:948
    // this.domainKeys(caller.native).value = domain
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(plugin: uint64, caller: bytes, escrow: bytes) -> void:
arc58_removePlugin:
    // smart_contracts/arc58/account/contract.algo.ts:957
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    proto 3 0
    bytec_0 // ""

arc58_removePlugin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:958
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removePlugin_bool_true@2

arc58_removePlugin_or_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:958
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub canRevoke
    bz arc58_removePlugin_bool_false@3

arc58_removePlugin_bool_true@2:
    intc_1 // 1

arc58_removePlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:958
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:960
    // const key: PluginKey = { plugin, caller: caller.native, escrow }
    frame_dig -2
    frame_dig -3
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:961
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:963
    // const methodsLength: uint64 = this.plugins(key).value.methods.length
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:965
    // this.plugins(key).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:967
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removePlugin_after_if_else@7

arc58_removePlugin_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:968-973
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(methodsLength)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:971
    // amount: this.pluginsMbr(methodsLength)
    frame_dig 0
    callsub pluginsMbr
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:968-972
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(methodsLength)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_removePlugin_next_txn@6:
    // smart_contracts/arc58/account/contract.algo.ts:968-973
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(methodsLength)
    //   })
    //   .submit()
    itxn_submit

arc58_removePlugin_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:976
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:977
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_removePlugin_bool_false@3:
    intc_0 // 0
    b arc58_removePlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, plugin: uint64, caller: bytes, escrow: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useRounds: uint64, useExecutionKey: uint64, defaultToEscrow: uint64) -> void:
arc58_addNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:995-1008
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    proto 12 0
    intc_0 // 0
    dup
    bytec_0 // ""
    dup

arc58_addNamedPlugin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1009
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 8 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1009
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -12
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1010
    // assert(!this.namedPlugins(name).exists);
    box_len
    bury 1
    !
    assert
    // smart_contracts/arc58/account/contract.algo.ts:1012
    // let escrowKey: string = escrow
    frame_dig -9
    // smart_contracts/arc58/account/contract.algo.ts:1013
    // if (defaultToEscrow) {
    frame_dig -1
    bz arc58_addNamedPlugin_after_if_else@2

arc58_addNamedPlugin_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:1014
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    frame_dig -9
    bytec_0 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:1015
    // escrowKey = ''
    bytec_0 // ""
    frame_bury 4

arc58_addNamedPlugin_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:1018
    // const key: PluginKey = { plugin, caller: caller.native, escrow: escrowKey }
    frame_dig -10
    frame_dig -11
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    frame_dig 4
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -12
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1019
    // this.namedPlugins(name).value = clone(key)
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1021
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    extract 6 2
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1022
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 3

arc58_addNamedPlugin_while_top@3:
    // smart_contracts/arc58/account/contract.algo.ts:1022
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -4
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz arc58_addNamedPlugin_after_while@5

arc58_addNamedPlugin_while_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:1023
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    frame_dig -4
    extract 2 0
    frame_dig 3
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    intc_3 // 4
    extract3
    swap
    intc_3 // 4
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    len
    intc_3 // 4
    ==
    assert // invalid size
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    intc_0 // 0
    itob
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 1
    dup
    cover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    swap
    intc_0 // 0
    uncover 2
    replace3
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1022
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 3
    b arc58_addNamedPlugin_while_top@3

arc58_addNamedPlugin_after_while@5:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1026
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addNamedPlugin_after_if_else@8

arc58_addNamedPlugin_if_body@6:
    // smart_contracts/arc58/account/contract.algo.ts:1027-1033
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1030
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1031
    // amount: this.pluginsMbr(methodInfos.length) + this.namedPluginsMbr(name)
    frame_dig 1
    intc_0 // 0
    extract_uint16
    callsub pluginsMbr
    frame_dig -12
    callsub namedPluginsMbr
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1027-1032
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_addNamedPlugin_next_txn@7:
    // smart_contracts/arc58/account/contract.algo.ts:1027-1033
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_submit

arc58_addNamedPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:1036
    // const escrowID = this.maybeNewEscrow(escrow);
    frame_dig -9
    callsub maybeNewEscrow
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1038
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -3
    bz arc58_addNamedPlugin_ternary_false@10

arc58_addNamedPlugin_ternary_true@9:
    // smart_contracts/arc58/account/contract.algo.ts:1038
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global Round

arc58_addNamedPlugin_ternary_merge@11:
    // smart_contracts/arc58/account/contract.algo.ts:1040-1051
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    frame_dig 2
    itob
    bytec_0 // 0x
    swap
    concat
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig -8
    setbit
    concat
    frame_dig -7
    concat
    frame_dig -6
    itob
    concat
    frame_dig -5
    itob
    concat
    pushint 45 // 45
    itob
    extract 6 2
    concat
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    intc_1 // 1
    frame_dig -2
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1049
    // lastCalled: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1040-1051
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    itob
    concat
    swap
    itob
    concat
    frame_dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 0
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1040-1051
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1053
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1054
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_addNamedPlugin_ternary_false@10:
    // smart_contracts/arc58/account/contract.algo.ts:1038
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addNamedPlugin_ternary_merge@11


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:1062
    // arc58_removeNamedPlugin(name: string): void {
    proto 1 0
    bytec_0 // ""

arc58_removeNamedPlugin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1063
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removeNamedPlugin_bool_true@2

arc58_removeNamedPlugin_or_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:1063
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub canRevoke
    bz arc58_removeNamedPlugin_bool_false@3

arc58_removeNamedPlugin_bool_true@2:
    intc_1 // 1

arc58_removeNamedPlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:1063
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1064
    // assert(this.namedPlugins(name).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1065
    // const app = clone(this.namedPlugins(name).value)
    box_get
    assert // Box must have value
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1066
    // assert(this.plugins(app).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1068
    // const methodsLength: uint64 = this.plugins(app).value.methods.length
    box_get
    assert // Box must have value
    dup
    pushint 26 // 26
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:133
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 10 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1070
    // this.namedPlugins(name).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1071
    // this.plugins(app).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1073
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeNamedPlugin_after_if_else@7

arc58_removeNamedPlugin_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:1074-1079
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(methodsLength)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1077
    // amount: this.namedPluginsMbr(name) + this.pluginsMbr(methodsLength)
    frame_dig -1
    callsub namedPluginsMbr
    frame_dig 0
    callsub pluginsMbr
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1074-1078
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(methodsLength)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_removeNamedPlugin_next_txn@6:
    // smart_contracts/arc58/account/contract.algo.ts:1074-1079
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(methodsLength)
    //   })
    //   .submit()
    itxn_submit

arc58_removeNamedPlugin_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1082
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1083
    // this.updateLastChange();
    callsub updateLastChange
    retsub

arc58_removeNamedPlugin_bool_false@3:
    intc_0 // 0
    b arc58_removeNamedPlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_newEscrow(escrow: bytes) -> uint64:
arc58_newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1091
    // arc58_newEscrow(escrow: string): uint64 {
    proto 1 1

arc58_newEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1092
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1093
    // assert(!this.namedEscrows(escrow).exists, ERR_ESCROW_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // Escrow already exists
    // smart_contracts/arc58/account/contract.algo.ts:1094
    // return this.newEscrow(escrow);
    frame_dig -1
    callsub newEscrow
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_toggleEscrowLock(escrow: bytes) -> uint64:
arc58_toggleEscrowLock:
    // smart_contracts/arc58/account/contract.algo.ts:1102
    // arc58_toggleEscrowLock(escrow: string): boolean {
    proto 1 1

arc58_toggleEscrowLock_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1103
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1104
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1105
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1107
    // this.escrows(escrowID).value = !this.escrows(escrowID).value;
    dup
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1107
    // this.escrows(escrowID).value = !this.escrows(escrowID).value;
    box_get
    assert // Box must have value
    btoi
    !
    dig 1
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1107
    // this.escrows(escrowID).value = !this.escrows(escrowID).value;
    swap
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1109
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1110
    // this.updateLastChange();
    callsub updateLastChange
    // smart_contracts/arc58/account/contract.algo.ts:1112
    // return this.escrows(escrowID).value;
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1112
    // return this.escrows(escrowID).value;
    box_get
    assert // Box must have value
    btoi
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_reclaim(escrow: bytes, reclaims: bytes) -> void:
arc58_reclaim:
    // smart_contracts/arc58/account/contract.algo.ts:1121
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    proto 2 0
    intc_0 // 0
    dupn 3
    bytec_0 // ""
    dupn 4

arc58_reclaim_block@0:
    intc_0 // 0
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1122
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1123
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1124
    // const sender = Application(this.namedEscrows(escrow).value).address
    box_get
    assert // Box must have value
    btoi
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:1126
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    intc_0 // 0

arc58_reclaim_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:1126
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 12
    >
    bz arc58_reclaim_after_while@16

arc58_reclaim_while_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:1127
    // if (reclaims[i].asset === 0) {
    frame_dig -1
    extract 2 0
    frame_dig 12
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    intc_0 // 0
    ==
    bz arc58_reclaim_else_body@9

arc58_reclaim_if_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:1129
    // sender,
    frame_dig 11
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:1131
    // amount: reclaims[i].amount
    frame_dig -1
    extract 2 0
    frame_dig 12
    dup
    cover 2
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    intc_2 // 8
    dup
    extract3
    btoi
    frame_bury 5
    // smart_contracts/arc58/account/contract.algo.ts:1128
    // const pmt = itxn.payment({
    intc_0 // 0
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:1134
    // if (reclaims[i].closeOut) {
    frame_dig -1
    extract 2 0
    swap
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    pushint 128 // 128
    getbit
    bz arc58_reclaim_after_if_else@5

arc58_reclaim_if_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    frame_bury 4
    frame_bury 10

arc58_reclaim_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1138
    // pmt.submit();
    itxn_begin
    frame_dig 4
    intc_1 // 1
    >=
    bz arc58_reclaim_next_field@7

arc58_reclaim_set_CloseRemainderTo_0_to_0@6:
    frame_dig 10
    itxn_field CloseRemainderTo

arc58_reclaim_next_field@7:
    frame_dig 5
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    frame_dig 1
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1128-1132
    // const pmt = itxn.payment({
    //   sender,
    //   receiver: this.controlledAddress.value,
    //   amount: reclaims[i].amount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_reclaim_next_txn@8:
    // smart_contracts/arc58/account/contract.algo.ts:1138
    // pmt.submit();
    itxn_submit

arc58_reclaim_after_if_else@15:
    // smart_contracts/arc58/account/contract.algo.ts:1126
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig 12
    intc_1 // 1
    +
    frame_bury 12
    b arc58_reclaim_while_top@1

arc58_reclaim_else_body@9:
    // smart_contracts/arc58/account/contract.algo.ts:1141
    // sender,
    frame_dig 11
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1143
    // assetAmount: reclaims[i].amount,
    frame_dig -1
    extract 2 0
    frame_dig 12
    dup
    cover 2
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    intc_2 // 8
    dup
    extract3
    btoi
    frame_bury 7
    // smart_contracts/arc58/account/contract.algo.ts:1144
    // xferAsset: reclaims[i].asset
    frame_dig -1
    extract 2 0
    dig 1
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    frame_bury 8
    // smart_contracts/arc58/account/contract.algo.ts:1140
    // const xfer = itxn.assetTransfer({
    intc_0 // 0
    frame_bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1147
    // if (reclaims[i].closeOut) {
    frame_dig -1
    extract 2 0
    swap
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    pushint 128 // 128
    getbit
    bz arc58_reclaim_after_if_else@11

arc58_reclaim_if_body@10:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    frame_bury 6
    frame_bury 9

arc58_reclaim_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:1151
    // xfer.submit();
    itxn_begin
    frame_dig 6
    intc_1 // 1
    >=
    bz arc58_reclaim_next_field@13

arc58_reclaim_set_AssetCloseTo_0_to_0@12:
    frame_dig 9
    itxn_field AssetCloseTo

arc58_reclaim_next_field@13:
    frame_dig 8
    itxn_field XferAsset
    frame_dig 7
    itxn_field AssetAmount
    frame_dig 2
    itxn_field AssetReceiver
    frame_dig 3
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1140-1145
    // const xfer = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.controlledAddress.value,
    //   assetAmount: reclaims[i].amount,
    //   xferAsset: reclaims[i].asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_reclaim_next_txn@14:
    // smart_contracts/arc58/account/contract.algo.ts:1151
    // xfer.submit();
    itxn_submit
    b arc58_reclaim_after_if_else@15

arc58_reclaim_after_while@16:
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_optinEscrow(escrow: bytes, assets: bytes) -> void:
arc58_optinEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1162
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    proto 2 0
    bytec_0 // ""

arc58_optinEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1163
    // assert(this.isAdmin(), ERR_FORBIDDEN)
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1164
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1165
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    dupn 2
    // smart_contracts/arc58/account/contract.algo.ts:1166
    // const escrowAddress = Application(escrowID).address
    app_params_get AppAddress
    assert // application exists
    dup
    cover 2
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1167
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1167
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1169-1175
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1172
    // receiver: escrowAddress,
    swap
    // smart_contracts/arc58/account/contract.algo.ts:1173
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -1
    intc_0 // 0
    extract_uint16
    *
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1169-1174
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_optinEscrow_next_txn@1:
    // smart_contracts/arc58/account/contract.algo.ts:1169-1175
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1177
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 0

arc58_optinEscrow_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1177
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 0
    >
    bz arc58_optinEscrow_after_while@5

arc58_optinEscrow_while_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:1179
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    frame_dig -1
    extract 2 0
    frame_dig 0
    dup
    cover 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    frame_dig 1
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1179
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1178-1181
    // assert(
    //   this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    //   ERR_ALLOWANCE_DOES_NOT_EXIST
    // );
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1183-1190
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1185
    // sender: escrowAddress,
    frame_dig 2
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1188
    // xferAsset: assets[i]
    frame_dig -1
    extract 2 0
    uncover 3
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    itxn_field XferAsset
    // smart_contracts/arc58/account/contract.algo.ts:1187
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1183-1189
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_optinEscrow_next_txn@4:
    // smart_contracts/arc58/account/contract.algo.ts:1183-1190
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1177
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_optinEscrow_while_top@2

arc58_optinEscrow_after_while@5:
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginOptinEscrow(plugin: uint64, caller: bytes, escrow: bytes, assets: bytes, mbrPayment: uint64) -> void:
arc58_pluginOptinEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1202-1208
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    proto 5 0
    intc_0 // 0
    bytec_0 // ""

arc58_pluginOptinEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1209
    // const key: PluginKey = { plugin, caller: caller.native, escrow }
    frame_dig -4
    frame_dig -5
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    pushint 42 // 42
    itob
    extract 6 2
    uncover 2
    swap
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:131
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1211
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1213
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1216
    // Txn.sender === Application(plugin).address ||
    txn Sender
    frame_dig -5
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1216-1217
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3

arc58_pluginOptinEscrow_or_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:1217
    // Txn.sender === caller.native ||
    txn Sender
    frame_dig -4
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1216-1217
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3

arc58_pluginOptinEscrow_or_contd@2:
    // smart_contracts/arc58/account/contract.algo.ts:1218
    // caller.native === Global.zeroAddress,
    frame_dig -4
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1216-1218
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    // caller.native === Global.zeroAddress,
    bz arc58_pluginOptinEscrow_bool_false@4

arc58_pluginOptinEscrow_bool_true@3:
    intc_1 // 1

arc58_pluginOptinEscrow_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1215-1220
    // assert(
    //   Txn.sender === Application(plugin).address ||
    //   Txn.sender === caller.native ||
    //   caller.native === Global.zeroAddress,
    //   ERR_FORBIDDEN
    // )
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:1221
    // assert(this.escrows(escrowID).exists, ERR_ESCROW_DOES_NOT_EXIST)
    frame_dig 2
    dup
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1221
    // assert(this.escrows(escrowID).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1222
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    dup
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1222
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1224
    // const escrowAddress = Application(escrowID).address
    app_params_get AppAddress
    assert // application exists
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:1226-1233
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -1
    gtxns Receiver
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1226-1233
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    frame_dig -1
    gtxns Amount
    // smart_contracts/arc58/account/contract.algo.ts:1230
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    *
    // smart_contracts/arc58/account/contract.algo.ts:1226-1233
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // invalid payment
    // smart_contracts/arc58/account/contract.algo.ts:1235-1241
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1238
    // receiver: escrowAddress,
    swap
    // smart_contracts/arc58/account/contract.algo.ts:1239
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    *
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1235-1240
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_pluginOptinEscrow_next_txn@6:
    // smart_contracts/arc58/account/contract.algo.ts:1235-1241
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1243
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 1

arc58_pluginOptinEscrow_while_top@7:
    // smart_contracts/arc58/account/contract.algo.ts:1243
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz arc58_pluginOptinEscrow_after_while@10

arc58_pluginOptinEscrow_while_body@8:
    // smart_contracts/arc58/account/contract.algo.ts:1245
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    frame_dig -2
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    frame_dig 2
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1245
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1244-1247
    // assert(
    //   this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    //   ERR_ALLOWANCE_DOES_NOT_EXIST
    // );
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1249-1256
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1251
    // sender: escrowAddress,
    frame_dig 0
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1254
    // xferAsset: assets[i]
    frame_dig -2
    extract 2 0
    uncover 3
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    itxn_field XferAsset
    // smart_contracts/arc58/account/contract.algo.ts:1253
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1249-1255
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_pluginOptinEscrow_next_txn@9:
    // smart_contracts/arc58/account/contract.algo.ts:1249-1256
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1243
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b arc58_pluginOptinEscrow_while_top@7

arc58_pluginOptinEscrow_after_while@10:
    retsub

arc58_pluginOptinEscrow_bool_false@4:
    intc_0 // 0
    b arc58_pluginOptinEscrow_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowances(escrow: bytes, allowances: bytes) -> void:
arc58_addAllowances:
    // smart_contracts/arc58/account/contract.algo.ts:1266
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    proto 2 0
    intc_0 // 0
    dup
    bytec_0 // ""
    dupn 4

arc58_addAllowances_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1267
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1268
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1269
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1270
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1270
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1272
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addAllowances_after_if_else@3

arc58_addAllowances_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:1273-1279
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1276
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1277
    // amount: this.allowancesMbr() * allowances.length
    callsub allowancesMbr
    frame_dig -1
    intc_0 // 0
    extract_uint16
    *
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1273-1278
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_addAllowances_next_txn@2:
    // smart_contracts/arc58/account/contract.algo.ts:1273-1279
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    //   .submit()
    itxn_submit

arc58_addAllowances_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    intc_0 // 0
    frame_bury 3

arc58_addAllowances_while_top@4:
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz arc58_addAllowances_after_while@9

arc58_addAllowances_while_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:1283
    // const { asset, type, allowed, max, interval, useRounds } = allowances[i];
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 34 // 34
    *
    pushint 34 // 34
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    intc_2 // 8
    intc_1 // 1
    extract3
    swap
    dup
    pushint 9 // 9
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 17 // 17
    intc_2 // 8
    extract3
    btoi
    swap
    dup
    pushint 25 // 25
    intc_2 // 8
    extract3
    btoi
    swap
    pushint 264 // 264
    getbit
    uncover 5
    cover 2
    uncover 5
    frame_bury 1
    uncover 4
    frame_bury 2
    uncover 3
    frame_bury 5
    swap
    frame_bury 4
    dup
    cover 2
    frame_bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1284
    // const key: AllowanceKey = { escrow: escrowID, asset }
    frame_dig 7
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1285
    // assert(!this.allowances(key).exists, ERR_ALLOWANCE_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // allowance already exists
    // smart_contracts/arc58/account/contract.algo.ts:1286
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    bz arc58_addAllowances_ternary_false@7

arc58_addAllowances_ternary_true@6:
    // smart_contracts/arc58/account/contract.algo.ts:1286
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    global Round

arc58_addAllowances_ternary_merge@8:
    // smart_contracts/arc58/account/contract.algo.ts:1288-1297
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    bytec_0 // 0x
    frame_dig 1
    concat
    frame_dig 5
    itob
    concat
    frame_dig 2
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1290
    // spent: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1288-1297
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    itob
    concat
    frame_dig 4
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1292
    // last: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1288-1297
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    itob
    concat
    swap
    itob
    concat
    bytec 5 // 0x00
    intc_0 // 0
    frame_dig 6
    setbit
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    frame_dig 0
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1288-1297
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b arc58_addAllowances_while_top@4

arc58_addAllowances_ternary_false@7:
    // smart_contracts/arc58/account/contract.algo.ts:1286
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addAllowances_ternary_merge@8

arc58_addAllowances_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:1300
    // this.updateLastUserInteraction();
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1301
    // this.updateLastChange();
    callsub updateLastChange
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowances(escrow: bytes, assets: bytes) -> void:
arc58_removeAllowances:
    // smart_contracts/arc58/account/contract.algo.ts:1310
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    proto 2 0
    bytec_0 // ""
    dup

arc58_removeAllowances_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1311
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    callsub isAdmin
    bnz arc58_removeAllowances_bool_true@2

arc58_removeAllowances_or_contd@1:
    // smart_contracts/arc58/account/contract.algo.ts:1311
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    callsub canRevoke
    bz arc58_removeAllowances_bool_false@3

arc58_removeAllowances_bool_true@2:
    intc_1 // 1

arc58_removeAllowances_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:1311
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    assert // Only an admin or revocation app can remove method restrictions
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1312
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1313
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:1314
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    itob
    // smart_contracts/arc58/account/contract.algo.ts:135
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1314
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1316
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeAllowances_after_if_else@7

arc58_removeAllowances_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:1317-1322
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1320
    // amount: this.allowancesMbr() * assets.length
    callsub allowancesMbr
    frame_dig -1
    intc_0 // 0
    extract_uint16
    *
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1317-1321
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

arc58_removeAllowances_next_txn@6:
    // smart_contracts/arc58/account/contract.algo.ts:1317-1322
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    //   .submit()
    itxn_submit

arc58_removeAllowances_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1325
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 1

arc58_removeAllowances_while_top@8:
    // smart_contracts/arc58/account/contract.algo.ts:1325
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz arc58_removeAllowances_after_while@10

arc58_removeAllowances_while_body@9:
    // smart_contracts/arc58/account/contract.algo.ts:1328
    // asset: assets[i]
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1326-1329
    // const key: AllowanceKey = {
    //   escrow: escrowID,
    //   asset: assets[i]
    // }
    frame_dig 0
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1330
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:139
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 4 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1331
    // this.allowances(key).delete()
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1325
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 1
    b arc58_removeAllowances_while_top@8

arc58_removeAllowances_after_while@10:
    // smart_contracts/arc58/account/contract.algo.ts:1334
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1335
    // this.updateLastChange()
    callsub updateLastChange
    retsub

arc58_removeAllowances_bool_false@3:
    intc_0 // 0
    b arc58_removeAllowances_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addExecutionKey(key: bytes, lastValidRound: uint64) -> void:
arc58_addExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1338
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    proto 2 0

arc58_addExecutionKey_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1339
    // assert(this.isAdmin(), ERR_ADMIN_ONLY)
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1340
    // assert(!this.executions(key).exists, ERR_EXECUTION_KEY_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // execution key already exists
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1342
    // this.executions(key).value = lastValidRound
    frame_dig -1
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1344
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1345
    // this.updateLastChange()
    callsub updateLastChange
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeExecutionKey(key: bytes) -> void:
arc58_removeExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1348
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    proto 1 0

arc58_removeExecutionKey_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1349
    // assert(this.isAdmin(), ERR_ADMIN_ONLY)
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1350
    // assert(this.executions(key).exists, ERR_EXECUTION_KEY_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // execution key does not exist
    // smart_contracts/arc58/account/contract.algo.ts:141
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1351
    // this.executions(key).delete()
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1353
    // this.updateLastUserInteraction()
    callsub updateLastUserInteraction
    // smart_contracts/arc58/account/contract.algo.ts:1354
    // this.updateLastChange()
    callsub updateLastChange
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:

arc58_getAdmin_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:104
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 8 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1365
    // return new Address(this.admin.value)
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getEscrow(name: bytes) -> uint64:
arc58_getEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1368-1369
    // @abimethod({ readonly: true })
    // arc58_getEscrow(name: string): uint64 {
    proto 1 1

arc58_getEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1370
    // if (this.namedEscrows(name).exists) {
    box_len
    bury 1
    bz arc58_getEscrow_after_if_else@2

arc58_getEscrow_if_body@1:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1371
    // return this.namedEscrows(name).value
    box_get
    assert // Box must have value
    btoi
    retsub

arc58_getEscrow_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:1373
    // return 0
    intc_0 // 0
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_mustGetEscrow(name: bytes) -> uint64:
arc58_mustGetEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1376-1377
    // @abimethod({ readonly: true })
    // arc58_mustGetEscrow(name: string): uint64 {
    proto 1 1

arc58_mustGetEscrow_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1378
    // assert(this.namedEscrows(name).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:137
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1379
    // return this.namedEscrows(name).value
    box_get
    assert // Box must have value
    btoi
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.mbr(methodCount: uint64, pluginName: bytes, escrowName: bytes) -> bytes:
mbr:
    // smart_contracts/arc58/account/contract.algo.ts:1382-1387
    // @abimethod({ readonly: true })
    // mbr(
    //   methodCount: uint64,
    //   pluginName: string,
    //   escrowName: string
    // ): AbstractAccountBoxMBRData {
    proto 3 1

mbr_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1389
    // plugins: this.pluginsMbr(methodCount),
    frame_dig -3
    callsub pluginsMbr
    // smart_contracts/arc58/account/contract.algo.ts:1390
    // namedPlugins: this.namedPluginsMbr(pluginName),
    frame_dig -2
    callsub namedPluginsMbr
    swap
    // smart_contracts/arc58/account/contract.algo.ts:1391
    // escrows: this.escrowsMbr(),
    callsub escrowsMbr
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1392
    // namedEscrows: this.namedEscrowsMbr(escrowName),
    frame_dig -1
    callsub namedEscrowsMbr
    cover 3
    // smart_contracts/arc58/account/contract.algo.ts:1393
    // allowances: this.allowancesMbr(),
    callsub allowancesMbr
    cover 4
    // smart_contracts/arc58/account/contract.algo.ts:1394
    // domainKeys: this.domainKeysMbr(pluginName),
    frame_dig -2
    callsub domainKeysMbr
    cover 5
    // smart_contracts/arc58/account/contract.algo.ts:1388-1395
    // return {
    //   plugins: this.pluginsMbr(methodCount),
    //   namedPlugins: this.namedPluginsMbr(pluginName),
    //   escrows: this.escrowsMbr(),
    //   namedEscrows: this.namedEscrowsMbr(escrowName),
    //   allowances: this.allowancesMbr(),
    //   domainKeys: this.domainKeysMbr(pluginName),
    // }
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    swap
    itob
    concat
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(assets: bytes) -> bytes, bytes:
balance:
    // smart_contracts/arc58/account/contract.algo.ts:1399-1400
    // @abimethod({ readonly: true })
    // balance(assets: uint64[]): uint64[] {
    proto 1 2
    bytec_0 // ""
    dupn 2

balance_block@0:
    // smart_contracts/arc58/account/contract.algo.ts:1401
    // let amounts: uint64[] = []
    intc_0 // 0
    itob
    extract 6 2
    // smart_contracts/arc58/account/contract.algo.ts:1402
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

balance_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:1402
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz balance_after_while@9

balance_while_body@2:
    // smart_contracts/arc58/account/contract.algo.ts:1403
    // let amount: uint64 = 0
    intc_0 // 0
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:1404
    // const asset = Asset(assets[i])
    frame_dig -1
    extract 2 0
    frame_dig 4
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    btoi
    dup
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1406
    // if (asset.id === 0) {
    intc_0 // 0
    ==
    bz balance_else_body@4

balance_if_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:1407
    // amount = Global.currentApplicationAddress.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    frame_bury 0

balance_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1415-1421
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(this.controlledAddress.value),
    //     asset.id
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:102
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    intc_0 // 0
    pushbytes "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1416
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    callsub getAkitaAppList
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:106
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1419
    // asset.id
    frame_dig 1
    itob
    swap
    // smart_contracts/arc58/account/contract.algo.ts:1415-1421
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(this.controlledAddress.value),
    //     asset.id
    //   ]
    // }).returnValue
    pushbytes 0x19976599 // method "getEscrowInfo(byte[32],uint64)(uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee

balance_next_txn@8:
    // smart_contracts/arc58/account/contract.algo.ts:1415-1421
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     new Address(this.controlledAddress.value),
    //     asset.id
    //   ]
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/account/contract.algo.ts:1423
    // amounts = [...amounts, (amount + escrowInfo.hard + escrowInfo.lock)]
    dup
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    frame_dig 0
    +
    swap
    intc_2 // 8
    dup
    extract3
    btoi
    +
    intc_1 // 1
    itob
    extract 6 2
    swap
    itob
    concat
    extract 2 0
    frame_dig 3
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    swap
    intc_0 // 0
    uncover 2
    replace3
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:1402
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b balance_while_top@1

balance_else_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:1409
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 1
    asset_holding_get AssetBalance
    swap
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1410
    // if (optedIn) {
    bz balance_after_if_else@6

balance_if_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:1411
    // amount = holdingAmount
    frame_dig 2
    frame_bury 0

balance_after_if_else@6:
    b balance_after_if_else@7

balance_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:1426
    // return amounts
    frame_dig 3
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub
