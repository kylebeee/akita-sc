#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 4 400 392 18900 29300
    bytecblock "controlled_address" "e" "" 0x00 0x70 "last_user_interaction" "last_change" 0x151f7c75 "spending_address" "admin" 0x002a "a" 0x01 "x" "n" "current_escrow_id" "rekey_index" "escrow_factory" "d" "revocation" 0x0001 0x0000 "version" "nickname" 0x002d
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:124
    // currentEscrowID = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysCurrentEscrowID, })
    bytec 15 // "current_escrow_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:126
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 16 // "rekey_index"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txn NumAppArgs
    bz main_after_if_else@43
    pushbytess 0x70ca115d 0x83f14748 0xea9180dd 0xe500dfb6 0x9f91cccd 0x17d8bcb4 0x385658ab 0x5ef0b415 0xd24b7556 0x5fa449c6 0x6cc3f606 0xc95a5d3d 0x4727af21 0x582ff382 0xdefd5cd2 0xb3c80df9 0x57a51d88 0xeef448fd 0x38f591ea 0xe350b9d4 0x0a8cb2c2 0x096bddb0 0xebaf14a0 0x1fda3b4f 0x9d3f8918 0xbf4d7c57 0xd5dd382b 0xb071e57b 0xd58685af 0x13bc44e4 0x9e394b09 0xaecceda4 0x1e600aad 0xd153dc35 0x124c0a7f // method "create(string,address,address,uint64,uint64,string)void", method "init()void", method "update(string)void", method "changeRevocationApp(uint64)void", method "setNickname(string)void", method "setAvatar(uint64)void", method "setBanner(uint64)void", method "setBio(string)void", method "arc58_changeAdmin(address)void", method "arc58_pluginChangeAdmin(uint64,address,address)void", method "arc58_verifyAuthAddress()void", method "arc58_rekeyTo(address,bool)void", method "arc58_canCall(uint64,bool,address,string,byte[4])bool", method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void", method "arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void", method "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void", method "assignDomain(address,string)void", method "arc58_removePlugin(uint64,address,string)void", method "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void", method "arc58_removeNamedPlugin(string)void", method "arc58_newEscrow(string)uint64", method "arc58_toggleEscrowLock(string)bool", method "arc58_reclaim(string,(uint64,uint64,bool)[])void", method "arc58_optinEscrow(string,uint64[])void", method "arc58_pluginOptinEscrow(uint64,address,string,uint64[],pay)void", method "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void", method "arc58_removeAllowances(string,uint64[])void", method "arc58_addExecutionKey(byte[32],uint64)void", method "arc58_removeExecutionKey(byte[32])void", method "arc58_getAdmin()address", method "arc58_getPlugin(string)(uint64,bool,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,uint64,uint64)", method "arc58_getEscrow(string)(uint64,bool)", method "arc58_mustGetEscrow(string)(uint64,bool)", method "mbr(string,uint64,string,string)(uint64,uint64,uint64,uint64,uint64,uint64)", method "balance(uint64[])uint64[]"
    txna ApplicationArgs 0
    match main_create_route@5 main_init_route@6 main_update_route@7 main_changeRevocationApp_route@8 main_setNickname_route@9 main_setAvatar_route@10 main_setBanner_route@11 main_setBio_route@12 main_arc58_changeAdmin_route@13 main_arc58_pluginChangeAdmin_route@14 main_arc58_verifyAuthAddress_route@15 main_arc58_rekeyTo_route@16 main_arc58_canCall_route@17 main_arc58_rekeyToPlugin_route@18 main_arc58_rekeyToNamedPlugin_route@19 main_arc58_addPlugin_route@20 main_assignDomain_route@21 main_arc58_removePlugin_route@22 main_arc58_addNamedPlugin_route@23 main_arc58_removeNamedPlugin_route@24 main_arc58_newEscrow_route@25 main_arc58_toggleEscrowLock_route@26 main_arc58_reclaim_route@27 main_arc58_optinEscrow_route@28 main_arc58_pluginOptinEscrow_route@29 main_arc58_addAllowances_route@30 main_arc58_removeAllowances_route@31 main_arc58_addExecutionKey_route@32 main_arc58_removeExecutionKey_route@33 main_arc58_getAdmin_route@34 main_arc58_getPlugin_route@35 main_arc58_getEscrow_route@36 main_arc58_mustGetEscrow_route@37 main_mbr_route@38 main_balance_route@39

main_after_if_else@43:
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    intc_0 // 0
    return

main_balance_route@39:
    // smart_contracts/arc58/account/contract.algo.ts:1420
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1420
    // @abimethod({ readonly: true })
    callsub balance
    pop
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mbr_route@38:
    // smart_contracts/arc58/account/contract.algo.ts:1402
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1402
    // @abimethod({ readonly: true })
    callsub mbr
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_mustGetEscrow_route@37:
    // smart_contracts/arc58/account/contract.algo.ts:1394
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1394
    // @abimethod({ readonly: true })
    callsub arc58_mustGetEscrow
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_getEscrow_route@36:
    // smart_contracts/arc58/account/contract.algo.ts:1385
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1385
    // @abimethod({ readonly: true })
    callsub arc58_getEscrow
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_getPlugin_route@35:
    // smart_contracts/arc58/account/contract.algo.ts:1380
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1380
    // @abimethod({ readonly: true })
    callsub arc58_getPlugin
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_getAdmin_route@34:
    // smart_contracts/arc58/account/contract.algo.ts:1375
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_removeExecutionKey_route@33:
    // smart_contracts/arc58/account/contract.algo.ts:1360
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1360
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    callsub arc58_removeExecutionKey
    intc_1 // 1
    return

main_arc58_addExecutionKey_route@32:
    // smart_contracts/arc58/account/contract.algo.ts:1350
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1350
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    callsub arc58_addExecutionKey
    intc_1 // 1
    return

main_arc58_removeAllowances_route@31:
    // smart_contracts/arc58/account/contract.algo.ts:1322
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1322
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    callsub arc58_removeAllowances
    intc_1 // 1
    return

main_arc58_addAllowances_route@30:
    // smart_contracts/arc58/account/contract.algo.ts:1278
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1278
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    callsub arc58_addAllowances
    intc_1 // 1
    return

main_arc58_pluginOptinEscrow_route@29:
    // smart_contracts/arc58/account/contract.algo.ts:1214-1220
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/arc58/account/contract.algo.ts:1214-1220
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    callsub arc58_pluginOptinEscrow
    intc_1 // 1
    return

main_arc58_optinEscrow_route@28:
    // smart_contracts/arc58/account/contract.algo.ts:1174
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1174
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    callsub arc58_optinEscrow
    intc_1 // 1
    return

main_arc58_reclaim_route@27:
    // smart_contracts/arc58/account/contract.algo.ts:1133
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/arc58/account/contract.algo.ts:1133
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    callsub arc58_reclaim
    intc_1 // 1
    return

main_arc58_toggleEscrowLock_route@26:
    // smart_contracts/arc58/account/contract.algo.ts:1114
    // arc58_toggleEscrowLock(escrow: string): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1114
    // arc58_toggleEscrowLock(escrow: string): boolean {
    callsub arc58_toggleEscrowLock
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_newEscrow_route@25:
    // smart_contracts/arc58/account/contract.algo.ts:1103
    // arc58_newEscrow(escrow: string): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1103
    // arc58_newEscrow(escrow: string): uint64 {
    callsub arc58_newEscrow
    itob
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_removeNamedPlugin_route@24:
    // smart_contracts/arc58/account/contract.algo.ts:1074
    // arc58_removeNamedPlugin(name: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1074
    // arc58_removeNamedPlugin(name: string): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    return

main_arc58_addNamedPlugin_route@23:
    // smart_contracts/arc58/account/contract.algo.ts:1007-1020
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    btoi
    txna ApplicationArgs 9
    txna ApplicationArgs 10
    intc_0 // 0
    getbit
    txna ApplicationArgs 11
    intc_0 // 0
    getbit
    txna ApplicationArgs 12
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:1007-1020
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    callsub arc58_addNamedPlugin
    intc_1 // 1
    return

main_arc58_removePlugin_route@22:
    // smart_contracts/arc58/account/contract.algo.ts:969
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:969
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    callsub arc58_removePlugin
    intc_1 // 1
    return

main_assignDomain_route@21:
    // smart_contracts/arc58/account/contract.algo.ts:947
    // assignDomain(caller: Address, domain: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:947
    // assignDomain(caller: Address, domain: string): void {
    callsub assignDomain
    intc_1 // 1
    return

main_arc58_addPlugin_route@20:
    // smart_contracts/arc58/account/contract.algo.ts:877-889
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    txna ApplicationArgs 8
    txna ApplicationArgs 9
    intc_0 // 0
    getbit
    txna ApplicationArgs 10
    intc_0 // 0
    getbit
    txna ApplicationArgs 11
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:877-889
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    callsub arc58_addPlugin
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@19:
    // smart_contracts/arc58/account/contract.algo.ts:848-853
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:848-853
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@18:
    // smart_contracts/arc58/account/contract.algo.ts:796-802
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:796-802
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    callsub arc58_rekeyToPlugin
    popn 2
    intc_1 // 1
    return

main_arc58_canCall_route@17:
    // smart_contracts/arc58/account/contract.algo.ts:773
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    // smart_contracts/arc58/account/contract.algo.ts:773
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_rekeyTo_route@16:
    // smart_contracts/arc58/account/contract.algo.ts:747
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:747
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    return

main_arc58_verifyAuthAddress_route@15:
    // smart_contracts/arc58/account/contract.algo.ts:734
    // arc58_verifyAuthAddress(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddress
    intc_1 // 1
    return

main_arc58_pluginChangeAdmin_route@14:
    // smart_contracts/arc58/account/contract.algo.ts:710
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/arc58/account/contract.algo.ts:710
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    return

main_arc58_changeAdmin_route@13:
    // smart_contracts/arc58/account/contract.algo.ts:695
    // arc58_changeAdmin(newAdmin: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:695
    // arc58_changeAdmin(newAdmin: Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    return

main_setBio_route@12:
    // smart_contracts/arc58/account/contract.algo.ts:685
    // setBio(bio: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:685
    // setBio(bio: string): void {
    callsub setBio
    intc_1 // 1
    return

main_setBanner_route@11:
    // smart_contracts/arc58/account/contract.algo.ts:673
    // setBanner(banner: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:673
    // setBanner(banner: uint64): void {
    callsub setBanner
    intc_1 // 1
    return

main_setAvatar_route@10:
    // smart_contracts/arc58/account/contract.algo.ts:661
    // setAvatar(avatar: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:661
    // setAvatar(avatar: uint64): void {
    callsub setAvatar
    intc_1 // 1
    return

main_setNickname_route@9:
    // smart_contracts/arc58/account/contract.algo.ts:651
    // setNickname(nickname: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:651
    // setNickname(nickname: string): void {
    callsub setNickname
    intc_1 // 1
    return

main_changeRevocationApp_route@8:
    // smart_contracts/arc58/account/contract.algo.ts:641
    // changeRevocationApp(newRevocationApp: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:641
    // changeRevocationApp(newRevocationApp: uint64): void {
    callsub changeRevocationApp
    intc_1 // 1
    return

main_update_route@7:
    // smart_contracts/arc58/account/contract.algo.ts:628
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:628
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub update
    intc_1 // 1
    return

main_init_route@6:
    // smart_contracts/arc58/account/contract.algo.ts:612
    // init(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub init
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/arc58/account/contract.algo.ts:579
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/arc58/account/contract.algo.ts:97
    // export class AbstractedAccount extends Contract implements AbstractedAccountInterface {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:579
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginsMbr(escrow: bytes, methodCount: uint64) -> uint64:
pluginsMbr:
    // smart_contracts/arc58/account/contract.algo.ts:170
    // private pluginsMbr(escrow: string, methodCount: uint64): uint64 {
    proto 2 1
    // smart_contracts/arc58/account/contract.algo.ts:172
    // BoxCostPerByte * ((MethodRestrictionByteLength * methodCount) + Bytes(escrow).length)
    pushint 20 // 20
    frame_dig -1
    *
    frame_dig -2
    len
    +
    intc 4 // 400
    *
    // smart_contracts/arc58/account/contract.algo.ts:171
    // return MinPluginMBR + (
    pushint 42900 // 42900
    // smart_contracts/arc58/account/contract.algo.ts:171-173
    // return MinPluginMBR + (
    //   BoxCostPerByte * ((MethodRestrictionByteLength * methodCount) + Bytes(escrow).length)
    // );
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.maybeNewEscrow(escrow: bytes) -> uint64:
maybeNewEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:196
    // private maybeNewEscrow(escrow: string): uint64 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:197
    // if (escrow === '') {
    frame_dig -1
    bytec_2 // ""
    ==
    bz maybeNewEscrow_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:198
    // return 0
    intc_0 // 0
    swap
    retsub

maybeNewEscrow_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:201
    // return this.namedEscrows(escrow).exists
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:201-203
    // return this.namedEscrows(escrow).exists
    //   ? this.namedEscrows(escrow).value
    //   : this.newEscrow(escrow)
    bz maybeNewEscrow_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:202
    // ? this.namedEscrows(escrow).value
    frame_dig 0
    box_get
    assert // Box must have value
    btoi

maybeNewEscrow_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:201-203
    // return this.namedEscrows(escrow).exists
    //   ? this.namedEscrows(escrow).value
    //   : this.newEscrow(escrow)
    swap
    retsub

maybeNewEscrow_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:203
    // : this.newEscrow(escrow)
    frame_dig -1
    callsub newEscrow
    b maybeNewEscrow_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.newEscrow(escrow: bytes) -> uint64:
newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:206
    // private newEscrow(escrow: string): uint64 {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:207
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz newEscrow_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:208-214
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:211
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:185
    // return MinNamedEscrowsMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -1
    len
    intc 4 // 400
    *
    // smart_contracts/arc58/account/contract.algo.ts:212
    // amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    pushint 12600 // 12600
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:208-213
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:208-214
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.namedEscrowsMbr(escrow) + this.escrowsMbr()
    //   })
    //   .submit()
    itxn_submit

newEscrow_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:217-230
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:225
    // amount: NewCostForARC58 + Global.minBalance,
    pushint 112100 // 112100
    global MinBalance
    +
    // smart_contracts/arc58/account/contract.algo.ts:128
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 17 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:226
    // receiver: this.escrowFactory.value.address
    dup
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    swap
    itxn_field Amount
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:223-227
    // itxn.payment({
    //   sender: this.controlledAddress.value,
    //   amount: NewCostForARC58 + Global.minBalance,
    //   receiver: this.escrowFactory.value.address
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:217-230
    // const id = abiCall(
    //   EscrowFactory.prototype.new,
    //   {
    //     sender: this.controlledAddress.value,
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         sender: this.controlledAddress.value,
    //         amount: NewCostForARC58 + Global.minBalance,
    //         receiver: this.escrowFactory.value.address
    //       }),
    //     ]
    //   }
    // ).returnValue
    itxn_next
    pushbytes 0xd85cf184 // method "new(pay)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 7 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:232
    // this.escrows(id).value = false
    dup
    itob
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:232
    // this.escrows(id).value = false
    intc_0 // 0
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:233
    // this.namedEscrows(escrow).value = id
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:235
    // return id;
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin() -> uint64:
isAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:241
    // Txn.sender === this.admin.value ||
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 9 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:241
    // Txn.sender === this.admin.value ||
    ==
    // smart_contracts/arc58/account/contract.algo.ts:241-242
    // Txn.sender === this.admin.value ||
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    bnz isAdmin_bool_true@3
    // smart_contracts/arc58/account/contract.algo.ts:158
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 18 // "d"
    // smart_contracts/arc58/account/contract.algo.ts:242
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:158
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:242
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    box_len
    bury 1
    bz isAdmin_bool_false@4
    // smart_contracts/arc58/account/contract.algo.ts:158
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 18 // "d"
    // smart_contracts/arc58/account/contract.algo.ts:242
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:158
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:242
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    box_get
    assert // Box must have value
    pushbytes "akita.community"
    ==
    bz isAdmin_bool_false@4

isAdmin_bool_true@3:
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:240-243
    // return (
    //   Txn.sender === this.admin.value ||
    //   (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    // )
    retsub

isAdmin_bool_false@4:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:240-243
    // return (
    //   Txn.sender === this.admin.value ||
    //   (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === AkitaDomain)
    // )
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke() -> uint64:
canRevoke:
    // smart_contracts/arc58/account/contract.algo.ts:248
    // return Txn.sender === this.revocation.value.address
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:132
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    intc_0 // 0
    bytec 19 // "revocation"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:248
    // return Txn.sender === this.revocation.value.address
    app_params_get AppAddress
    assert // application exists
    ==
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin: uint64, caller: bytes, escrow: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/arc58/account/contract.algo.ts:251
    // private pluginCallAllowed(plugin: uint64, caller: Account, escrow: string, method: bytes<4>): boolean {
    proto 4 1
    bytec_2 // ""
    dupn 5
    // smart_contracts/arc58/account/contract.algo.ts:252
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -4
    itob
    frame_dig -3
    concat
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:254
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:255
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:258
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = clone(this.plugins(key).value)
    frame_dig 6
    dup
    pushint 28 // 28
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    frame_bury 5
    dig 1
    pushint 29 // 29
    intc_2 // 8
    box_extract
    btoi
    frame_bury 3
    swap
    pushint 18 // 18
    intc_2 // 8
    box_extract
    btoi
    frame_bury 0
    intc_1 // 1
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:260
    // if (useExecutionKey) {
    bz pluginCallAllowed_after_if_else@4
    // smart_contracts/arc58/account/contract.algo.ts:261
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:258
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = clone(this.plugins(key).value)
    frame_dig 6
    pushints 45 2 // 45, 2
    box_extract
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:264
    // let methodAllowed = methods.length > 0 ? false : true;
    !
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:265
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@5:
    // smart_contracts/arc58/account/contract.algo.ts:258
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = clone(this.plugins(key).value)
    frame_dig 6
    pushints 45 2 // 45, 2
    box_extract
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:265
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    >
    bz pluginCallAllowed_block@10
    // smart_contracts/arc58/account/contract.algo.ts:258
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = clone(this.plugins(key).value)
    frame_dig 2
    pushint 20 // 20
    *
    pushint 47 // 47
    +
    frame_dig 6
    swap
    pushint 20 // 20
    box_extract
    extract 0 4
    // smart_contracts/arc58/account/contract.algo.ts:266
    // if (methods[i].selector === method) {
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:267
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 4

pluginCallAllowed_block@10:
    // smart_contracts/arc58/account/contract.algo.ts:272
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 5
    bz pluginCallAllowed_ternary_false@12
    global Round
    frame_bury 1

pluginCallAllowed_ternary_merge@13:
    // smart_contracts/arc58/account/contract.algo.ts:275
    // lastCalled >= epochRef &&
    frame_dig 3
    frame_dig 1
    >=
    // smart_contracts/arc58/account/contract.algo.ts:275-276
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    // smart_contracts/arc58/account/contract.algo.ts:276
    // (epochRef - lastCalled) >= cooldown &&
    frame_dig 1
    frame_dig 3
    -
    frame_dig 0
    >=
    // smart_contracts/arc58/account/contract.algo.ts:275-276
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    intc_1 // 1

pluginCallAllowed_bool_merge@17:
    // smart_contracts/arc58/account/contract.algo.ts:275-277
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    // methodAllowed
    frame_dig 4
    &&
    // smart_contracts/arc58/account/contract.algo.ts:274-278
    // return (
    //   lastCalled >= epochRef &&
    //   (epochRef - lastCalled) >= cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@16:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@17

pluginCallAllowed_ternary_false@12:
    // smart_contracts/arc58/account/contract.algo.ts:272
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 1
    b pluginCallAllowed_ternary_merge@13

pluginCallAllowed_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:265
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // smart_contracts/arc58/account/contract.algo.ts:281
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:284
    // txn.sender === this.controlledAddress.value &&
    frame_dig -1
    gtxns Sender
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:284
    // txn.sender === this.controlledAddress.value &&
    ==
    // smart_contracts/arc58/account/contract.algo.ts:284-285
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:285
    // txn.rekeyTo === Global.currentApplicationAddress
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:284-285
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:287
    // return true;
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:291
    // txn.type === TransactionType.ApplicationCall
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // smart_contracts/arc58/account/contract.algo.ts:291-292
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:292
    // && txn.appId === Global.currentApplicationId
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/arc58/account/contract.algo.ts:291-292
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:293
    // && txn.numAppArgs === 1
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // smart_contracts/arc58/account/contract.algo.ts:291-293
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:294
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig -1
    gtxns OnCompletion
    // smart_contracts/arc58/account/contract.algo.ts:291-294
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bnz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:295
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
    ==
    // smart_contracts/arc58/account/contract.algo.ts:291-295
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    bz txnRekeysBack_bool_false@9
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:290-296
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:290-296
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> bytes, bytes:
pluginCheck:
    // smart_contracts/arc58/account/contract.algo.ts:313
    // private pluginCheck(key: PluginKey): PluginValidation {
    proto 1 2
    bytec_2 // ""
    dupn 5
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig -1
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:315
    // const exists = this.plugins(key).exists;
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/arc58/account/contract.algo.ts:316
    // if (!exists) {
    bnz pluginCheck_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:317-324
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    bytec 4 // 0x70
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:327
    // const { useRounds, lastValid, cooldown, lastCalled, methods } = clone(this.plugins(key).value)
    frame_dig 6
    dup
    pushint 28 // 28
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dig 1
    pushint 10 // 10
    intc_2 // 8
    box_extract
    btoi
    frame_bury 4
    dig 1
    pushint 18 // 18
    intc_2 // 8
    box_extract
    btoi
    frame_bury 1
    swap
    pushint 29 // 29
    intc_2 // 8
    box_extract
    btoi
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:328
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCheck_ternary_false@4
    global Round

pluginCheck_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:330
    // const expired = epochRef > lastValid;
    dup
    frame_dig 4
    >
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:332
    // const onCooldown = (epochRef - lastCalled) < cooldown;
    frame_dig 3
    -
    frame_dig 1
    <
    frame_bury 5
    // smart_contracts/arc58/account/contract.algo.ts:327
    // const { useRounds, lastValid, cooldown, lastCalled, methods } = clone(this.plugins(key).value)
    frame_dig 6
    pushints 45 2 // 45, 2
    box_extract
    btoi
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:335
    // const valid = exists && !expired && !onCooldown;
    frame_dig 7
    bz pluginCheck_bool_false@9
    frame_dig 2
    bnz pluginCheck_bool_false@9
    frame_dig 5
    bnz pluginCheck_bool_false@9
    intc_1 // 1

pluginCheck_bool_merge@10:
    // smart_contracts/arc58/account/contract.algo.ts:337-344
    // return {
    //   exists,
    //   expired,
    //   hasCooldown,
    //   onCooldown,
    //   hasMethodRestrictions,
    //   valid
    // }
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    intc_1 // 1
    frame_dig 2
    setbit
    pushint 2 // 2
    frame_dig 1
    setbit
    pushint 3 // 3
    frame_dig 5
    setbit
    intc_3 // 4
    frame_dig 0
    setbit
    pushint 5 // 5
    uncover 2
    setbit
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_bool_false@9:
    intc_0 // 0
    b pluginCheck_bool_merge@10

pluginCheck_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:328
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCheck_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create(version: bytes, controlledAddress: bytes, admin: bytes, escrowFactory: uint64, revocationApp: uint64, nickname: bytes) -> void:
create:
    // smart_contracts/arc58/account/contract.algo.ts:579-587
    // @abimethod({ onCreate: 'require' })
    // create(
    //   version: string,
    //   controlledAddress: Address,
    //   admin: Address,
    //   escrowFactory: uint64,
    //   revocationApp: uint64,
    //   nickname: string
    // ): void {
    proto 6 0
    // smart_contracts/arc58/account/contract.algo.ts:588
    // assert(Global.callerApplicationId !== 0, ERR_BAD_DEPLOYER)
    global CallerApplicationID
    assert // This contract must be deployed from a factory
    // smart_contracts/arc58/account/contract.algo.ts:589
    // assert(admin !== controlledAddress)
    frame_dig -4
    frame_dig -5
    !=
    assert
    // smart_contracts/arc58/account/contract.algo.ts:102
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 22 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:591
    // this.version.value = version
    frame_dig -6
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 9 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:592
    // this.admin.value = admin.native
    frame_dig -4
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:594
    // controlledAddress.native === Global.zeroAddress
    frame_dig -5
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:594-596
    // controlledAddress.native === Global.zeroAddress
    //   ? Global.currentApplicationAddress
    //   : controlledAddress.native
    bz create_ternary_false@2
    // smart_contracts/arc58/account/contract.algo.ts:595
    // ? Global.currentApplicationAddress
    global CurrentApplicationAddress

create_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:593-596
    // this.controlledAddress.value =
    //   controlledAddress.native === Global.zeroAddress
    //     ? Global.currentApplicationAddress
    //     : controlledAddress.native
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:128
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    bytec 17 // "escrow_factory"
    // smart_contracts/arc58/account/contract.algo.ts:597
    // this.escrowFactory.value = Application(escrowFactory)
    frame_dig -3
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 8 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:598
    // this.spendingAddress.value = Global.zeroAddress;
    global ZeroAddress
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:132
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 19 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:599
    // this.revocation.value = Application(revocationApp)
    frame_dig -2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:110
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 23 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:600
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:130
    // factoryApp = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysFactoryApp })
    pushbytes "factory_app"
    // smart_contracts/arc58/account/contract.algo.ts:601
    // this.factoryApp.value = Application(Global.callerApplicationId)
    global CallerApplicationID
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

create_ternary_false@2:
    frame_dig -5
    b create_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.init() -> void:
init:
    // smart_contracts/arc58/account/contract.algo.ts:613-624
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:128
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    intc_0 // 0
    bytec 17 // "escrow_factory"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:619
    // receiver: this.escrowFactory.value.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:620
    // amount: ARC58WalletIDsByAccountsMbr
    pushint 12100 // 12100
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:618-621
    // itxn.payment({
    //   receiver: this.escrowFactory.value.address,
    //   amount: ARC58WalletIDsByAccountsMbr
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:613-624
    // abiCall(
    //   EscrowFactory.prototype.register,
    //   {
    //     appId: this.escrowFactory.value,
    //     args: [
    //       itxn.payment({
    //         receiver: this.escrowFactory.value.address,
    //         amount: ARC58WalletIDsByAccountsMbr
    //       })
    //     ]
    //   }
    // )
    itxn_next
    pushbytes 0xf040dd0d // method "register(pay)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update(version: bytes) -> void:
update:
    // smart_contracts/arc58/account/contract.algo.ts:628-629
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // update(version: string): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:630
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_UPDATE)
    callsub isAdmin
    assert // Only an admin can update the application
    // smart_contracts/arc58/account/contract.algo.ts:102
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 22 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:631
    // this.version.value = version
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.changeRevocationApp(newRevocationApp: uint64) -> void:
changeRevocationApp:
    // smart_contracts/arc58/account/contract.algo.ts:641
    // changeRevocationApp(newRevocationApp: uint64): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:642
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_REVOKE)
    callsub isAdmin
    assert // Only an admin can change the revocation app
    // smart_contracts/arc58/account/contract.algo.ts:132
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 19 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:643
    // this.revocation.value = Application(newRevocationApp)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname(nickname: bytes) -> void:
setNickname:
    // smart_contracts/arc58/account/contract.algo.ts:651
    // setNickname(nickname: string): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:652
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:110
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 23 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:653
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar(avatar: uint64) -> void:
setAvatar:
    // smart_contracts/arc58/account/contract.algo.ts:661
    // setAvatar(avatar: uint64): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:662
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:663
    // const amount = this.balance([avatar])
    frame_dig -1
    itob
    bytec 20 // 0x0001
    swap
    concat
    callsub balance
    pop
    pushint 2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:664
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:112
    // avatar = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysAvatar })
    pushbytes "avatar"
    // smart_contracts/arc58/account/contract.algo.ts:665
    // this.avatar.value = Asset(avatar)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner(banner: uint64) -> void:
setBanner:
    // smart_contracts/arc58/account/contract.algo.ts:673
    // setBanner(banner: uint64): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:674
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:675
    // const amount = this.balance([banner])
    frame_dig -1
    itob
    bytec 20 // 0x0001
    swap
    concat
    callsub balance
    pop
    pushint 2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:676
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:114
    // banner = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysBanner })
    pushbytes "banner"
    // smart_contracts/arc58/account/contract.algo.ts:677
    // this.banner.value = Asset(banner)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio(bio: bytes) -> void:
setBio:
    // smart_contracts/arc58/account/contract.algo.ts:685
    // setBio(bio: string): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:686
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:116
    // bio = GlobalState<string>({ key: AbstractAccountGlobalStateKeysBio })
    pushbytes "bio"
    // smart_contracts/arc58/account/contract.algo.ts:687
    // this.bio.value = bio
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:695
    // arc58_changeAdmin(newAdmin: Address): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:696
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_ADMIN);
    callsub isAdmin
    assert // Only an admin can change the admin account
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 9 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:697
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, caller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:710
    // arc58_pluginChangeAdmin(plugin: uint64, caller: Address, newAdmin: Address): void {
    proto 3 0
    // smart_contracts/arc58/account/contract.algo.ts:711
    // assert(Txn.sender === Application(plugin).address, ERR_SENDER_MUST_BE_ADMIN_PLUGIN);
    txn Sender
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    assert // sender must be admin plugin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:713
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:712-715
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // smart_contracts/arc58/account/contract.algo.ts:717
    // const key: PluginKey = { plugin, caller: caller.native, escrow: '' };
    frame_dig -3
    itob
    frame_dig -2
    concat
    pushbytes 0x002a0000
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:720
    // this.plugins(key).exists && this.plugins(key).value.admin,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@3
    frame_dig 0
    intc_2 // 8
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:719-722
    // assert(
    //   this.plugins(key).exists && this.plugins(key).value.admin,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 9 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:724
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:725
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    frame_dig 0
    pushint 9 // 9
    intc_1 // 1
    box_extract
    bytec 12 // 0x01
    ==
    bz arc58_pluginChangeAdmin_after_if_else@6
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put

arc58_pluginChangeAdmin_after_if_else@6:
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddress() -> void:
arc58_verifyAuthAddress:
    // smart_contracts/arc58/account/contract.algo.ts:734
    // arc58_verifyAuthAddress(): void {
    proto 0 0
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 8 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:735
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    dup
    acct_params_get AcctAuthAddr
    swap
    cover 2
    assert // account funded
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:562
    // this.spendingAddress.value === this.controlledAddress.value
    ==
    // smart_contracts/arc58/account/contract.algo.ts:562-563
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddress_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:563
    // && this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:562-563
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddress_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:564
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global ZeroAddress

arc58_verifyAuthAddress_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:735
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddr());
    frame_dig 0
    ==
    assert
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 8 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:736
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:124
    // currentEscrowID = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysCurrentEscrowID, })
    bytec 15 // "current_escrow_id"
    // smart_contracts/arc58/account/contract.algo.ts:737
    // this.currentEscrowID.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:126
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 16 // "rekey_index"
    // smart_contracts/arc58/account/contract.algo.ts:738
    // this.rekeyIndex.value = 0
    intc_0 // 0
    app_global_put
    retsub

arc58_verifyAuthAddress_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:564
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global CurrentApplicationAddress
    b arc58_verifyAuthAddress_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: uint64) -> void:
arc58_rekeyTo:
    // smart_contracts/arc58/account/contract.algo.ts:747
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    proto 2 0
    bytec_2 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:748
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:750-757
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:755
    // note: 'rekeying abstracted account'
    pushbytes "rekeying abstracted account"
    itxn_field Note
    frame_dig -2
    itxn_field RekeyTo
    frame_dig -2
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:750-756
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:750-757
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:759
    // if (flash) this.assertRekeysBack();
    frame_dig -1
    bz arc58_rekeyTo_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:300
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:301
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 0

arc58_rekeyTo_while_top@5:
    // smart_contracts/arc58/account/contract.algo.ts:301
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    global GroupSize
    <
    bz arc58_rekeyTo_block@10
    // smart_contracts/arc58/account/contract.algo.ts:304
    // if (this.txnRekeysBack(txn)) {
    frame_dig 0
    callsub txnRekeysBack
    bz arc58_rekeyTo_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:305
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 1

arc58_rekeyTo_block@10:
    // smart_contracts/arc58/account/contract.algo.ts:310
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 1
    assert // missing rekey back

arc58_rekeyTo_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_rekeyTo_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:301
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_rekeyTo_while_top@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, global: uint64, address: bytes, escrow: bytes, method: bytes) -> uint64:
arc58_canCall:
    // smart_contracts/arc58/account/contract.algo.ts:773-780
    // @abimethod({ readonly: true })
    // arc58_canCall(
    //   plugin: uint64,
    //   global: boolean,
    //   address: Address,
    //   escrow: string,
    //   method: bytes<4>
    // ): boolean {
    proto 5 1
    // smart_contracts/arc58/account/contract.algo.ts:781
    // if (global) {
    frame_dig -4
    bz arc58_canCall_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:782
    // this.pluginCallAllowed(plugin, Global.zeroAddress, escrow, method);
    frame_dig -5
    global ZeroAddress
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:784
    // return this.pluginCallAllowed(plugin, address.native, escrow, method);
    frame_dig -5
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: uint64, escrow: bytes, methodOffsets: bytes, fundsRequest: bytes) -> bytes, bytes:
arc58_rekeyToPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:796-802
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    proto 5 2
    intc_0 // 0
    dupn 8
    bytec_2 // ""
    dupn 19
    // smart_contracts/arc58/account/contract.algo.ts:804
    // const caller = global ? Global.zeroAddress : Txn.sender
    frame_dig -4
    bz arc58_rekeyToPlugin_ternary_false@2
    global ZeroAddress

arc58_rekeyToPlugin_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:805
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -5
    itob
    swap
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    dup
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:807
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:809
    // if (escrow !== '') {
    frame_dig -3
    bytec_2 // ""
    !=
    bz arc58_rekeyToPlugin_else_body@7
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:810
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:811
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    pop
    btoi
    dup
    frame_bury 13
    // smart_contracts/arc58/account/contract.algo.ts:813
    // this.spendingAddress.value = spendingApp.address
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 8 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:813
    // this.spendingAddress.value = spendingApp.address
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:124
    // currentEscrowID = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysCurrentEscrowID, })
    bytec 15 // "current_escrow_id"
    // smart_contracts/arc58/account/contract.algo.ts:814
    // this.currentEscrowID.value = escrowID
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:460
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0
    frame_bury 14

arc58_rekeyToPlugin_while_top@56:
    // smart_contracts/arc58/account/contract.algo.ts:460
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 14
    >
    bz arc58_rekeyToPlugin_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:464
    // asset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    frame_dig 14
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 28
    // smart_contracts/arc58/account/contract.algo.ts:462-465
    // const allowanceKey: AllowanceKey = {
    //   escrow: escrowID,
    //   asset: fundsRequests[i].asset
    // }
    frame_dig 13
    itob
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:145
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 11 // "a"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:491
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:492
    // const { type, spent, allowed, last, max, interval, start, useRounds } = this.allowances(key).value
    box_get
    pop
    dup
    extract 0 1
    frame_bury 8
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 24
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 9
    dup
    pushint 33 // 33
    extract_uint64
    frame_bury 16
    dup
    intc_1 // 1
    extract_uint64
    frame_bury 18
    dup
    pushint 25 // 25
    extract_uint64
    frame_bury 15
    dup
    pushint 41 // 41
    extract_uint64
    frame_bury 25
    intc 5 // 392
    getbit
    dup
    frame_bury 27
    // smart_contracts/arc58/account/contract.algo.ts:493
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    bz arc58_rekeyToPlugin_ternary_false@59
    global Round
    frame_bury 21

arc58_rekeyToPlugin_ternary_merge@60:
    // smart_contracts/arc58/account/contract.algo.ts:495
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 8
    bytec 12 // 0x01
    ==
    bz arc58_rekeyToPlugin_else_body@62
    // smart_contracts/arc58/account/contract.algo.ts:496
    // const leftover: uint64 = allowed - spent;
    frame_dig 9
    frame_dig 24
    dup
    cover 2
    -
    // smart_contracts/arc58/account/contract.algo.ts:498
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_2 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:501
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    pushint 25 // 25
    extract_uint64
    dig 4
    pushint 33 // 33
    extract_uint64
    dig 5
    pushint 41 // 41
    extract_uint64
    uncover 6
    intc 5 // 392
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:502
    // spent: (spent + fundRequest.amount)
    uncover 8
    uncover 8
    +
    // smart_contracts/arc58/account/contract.algo.ts:500-503
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount)
    // }
    uncover 6
    itob
    uncover 7
    swap
    concat
    uncover 6
    itob
    concat
    swap
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put

arc58_rekeyToPlugin_after_if_else@71:
    // smart_contracts/arc58/account/contract.algo.ts:469
    // if (fundsRequests[i].asset !== 0) {
    frame_dig 28
    bz arc58_rekeyToPlugin_else_body@73
    // smart_contracts/arc58/account/contract.algo.ts:470-477
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 8 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:474
    // assetAmount: fundsRequests[i].amount,
    frame_dig 0
    intc_2 // 8
    extract_uint64
    frame_dig 28
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:470-476
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:470-477
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: this.spendingAddress.value,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_submit

arc58_rekeyToPlugin_after_if_else@74:
    // smart_contracts/arc58/account/contract.algo.ts:460
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 14
    intc_1 // 1
    +
    frame_bury 14
    b arc58_rekeyToPlugin_while_top@56

arc58_rekeyToPlugin_else_body@73:
    // smart_contracts/arc58/account/contract.algo.ts:479-485
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 8 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:483
    // amount: fundsRequests[i].amount
    frame_dig 0
    intc_2 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:479-484
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:479-485
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.spendingAddress.value,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_submit
    b arc58_rekeyToPlugin_after_if_else@74

arc58_rekeyToPlugin_else_body@62:
    // smart_contracts/arc58/account/contract.algo.ts:504
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 8
    pushbytes 0x02
    ==
    bz arc58_rekeyToPlugin_else_body@66
    // smart_contracts/arc58/account/contract.algo.ts:550
    // if (useRounds) {
    frame_dig 27
    bz arc58_rekeyToPlugin_after_if_else@78
    // smart_contracts/arc58/account/contract.algo.ts:551
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig 25
    -
    frame_dig 15
    %
    -

arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart@79:
    // smart_contracts/arc58/account/contract.algo.ts:507
    // if (currentWindowStart > last) {
    frame_dig 16
    >
    bz arc58_rekeyToPlugin_else_body@65
    // smart_contracts/arc58/account/contract.algo.ts:508
    // assert(allowed >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_2 // 8
    extract_uint64
    frame_dig 9
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:511
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 2
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    pushint 25 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 5 // 392
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:510-514
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: fundRequest.amount,
    //   last: newLast
    // }
    uncover 4
    itob
    uncover 5
    swap
    concat
    uncover 4
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 21
    itob
    concat
    uncover 2
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@71

arc58_rekeyToPlugin_else_body@65:
    // smart_contracts/arc58/account/contract.algo.ts:517
    // const leftover: uint64 = allowed - spent;
    frame_dig 9
    frame_dig 24
    dup
    cover 2
    -
    // smart_contracts/arc58/account/contract.algo.ts:518
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_2 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:521
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    pushint 25 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 5 // 392
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:522
    // spent: (spent + fundRequest.amount),
    uncover 7
    uncover 7
    +
    // smart_contracts/arc58/account/contract.algo.ts:520-524
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (spent + fundRequest.amount),
    //   last: newLast
    // }
    uncover 5
    itob
    uncover 6
    swap
    concat
    uncover 5
    itob
    concat
    swap
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 21
    itob
    concat
    uncover 2
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@71

arc58_rekeyToPlugin_after_if_else@78:
    // smart_contracts/arc58/account/contract.algo.ts:553
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig 25
    -
    frame_dig 15
    %
    -
    // smart_contracts/arc58/account/contract.algo.ts:505
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart@79

arc58_rekeyToPlugin_else_body@66:
    // smart_contracts/arc58/account/contract.algo.ts:527
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 8
    pushbytes 0x03
    ==
    bz arc58_rekeyToPlugin_after_if_else@71
    // smart_contracts/arc58/account/contract.algo.ts:528
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 27
    bz arc58_rekeyToPlugin_ternary_false@69
    global Round
    frame_bury 12

arc58_rekeyToPlugin_ternary_merge@70:
    // smart_contracts/arc58/account/contract.algo.ts:530
    // const amount = fundRequest.amount
    frame_dig 0
    intc_2 // 8
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:534
    // const passed: uint64 = epochRef - last
    frame_dig 12
    frame_dig 16
    -
    // smart_contracts/arc58/account/contract.algo.ts:535
    // const accrued: uint64 = lastLeftover + ((passed / interval) * accrualRate)
    frame_dig 15
    /
    frame_dig 9
    *
    frame_dig 24
    +
    // smart_contracts/arc58/account/contract.algo.ts:537
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 18
    dup
    cover 3
    >
    swap
    cover 2
    select
    // smart_contracts/arc58/account/contract.algo.ts:539
    // assert(available >= amount, ERR_ALLOWANCE_EXCEEDED);
    dup
    dig 2
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:542
    // ...this.allowances(key).value,
    frame_dig 2
    dup
    cover 3
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dig 1
    intc_1 // 1
    extract_uint64
    dig 2
    pushint 9 // 9
    extract_uint64
    dig 3
    pushint 25 // 25
    extract_uint64
    dig 4
    pushint 41 // 41
    extract_uint64
    uncover 5
    intc 5 // 392
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:543
    // spent: (available - amount),
    uncover 6
    uncover 7
    -
    // smart_contracts/arc58/account/contract.algo.ts:541-545
    // this.allowances(key).value = {
    //   ...this.allowances(key).value,
    //   spent: (available - amount),
    //   last: newLast
    // }
    uncover 5
    itob
    uncover 6
    swap
    concat
    uncover 5
    itob
    concat
    swap
    itob
    concat
    uncover 3
    itob
    concat
    frame_dig 21
    itob
    concat
    uncover 2
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    concat
    box_put
    b arc58_rekeyToPlugin_after_if_else@71

arc58_rekeyToPlugin_ternary_false@69:
    // smart_contracts/arc58/account/contract.algo.ts:528
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 12
    b arc58_rekeyToPlugin_ternary_merge@70

arc58_rekeyToPlugin_ternary_false@59:
    // smart_contracts/arc58/account/contract.algo.ts:493
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 21
    b arc58_rekeyToPlugin_ternary_merge@60

arc58_rekeyToPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:355
    // const { useRounds, useExecutionKey } = this.plugins(key).value
    frame_dig 1
    pushint 28 // 28
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    frame_bury 26
    // smart_contracts/arc58/account/contract.algo.ts:357-359
    // const epochRef = useRounds
    //   ? Global.round
    //   : Global.latestTimestamp;
    bz arc58_rekeyToPlugin_ternary_false@16
    // smart_contracts/arc58/account/contract.algo.ts:358
    // ? Global.round
    global Round
    frame_bury 12

arc58_rekeyToPlugin_ternary_merge@17:
    // smart_contracts/arc58/account/contract.algo.ts:361
    // if (useExecutionKey) {
    frame_dig 26
    bz arc58_rekeyToPlugin_after_if_else@23
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 13 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:363
    // this.executions(Global.groupId).exists &&
    global GroupID
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:363
    // this.executions(Global.groupId).exists &&
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:363-364
    // this.executions(Global.groupId).exists &&
    // epochRef < this.executions(Global.groupId).value,
    bz arc58_rekeyToPlugin_bool_false@21
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 13 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:364
    // epochRef < this.executions(Global.groupId).value,
    global GroupID
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:364
    // epochRef < this.executions(Global.groupId).value,
    box_get
    assert // Box must have value
    btoi
    frame_dig 12
    >
    // smart_contracts/arc58/account/contract.algo.ts:363-364
    // this.executions(Global.groupId).exists &&
    // epochRef < this.executions(Global.groupId).value,
    bz arc58_rekeyToPlugin_bool_false@21
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@22:
    // smart_contracts/arc58/account/contract.algo.ts:362-366
    // assert(
    //   this.executions(Global.groupId).exists &&
    //   epochRef < this.executions(Global.groupId).value,
    //   ERR_BAD_EXECUTION_KEY
    // )
    assert // The execution key does not match the group ID of the transaction

arc58_rekeyToPlugin_after_if_else@23:
    // smart_contracts/arc58/account/contract.algo.ts:369
    // const initialCheck = this.pluginCheck(key);
    frame_dig 4
    callsub pluginCheck
    swap
    dup
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:371
    // assert(initialCheck.exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    intc_0 // 0
    getbit
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:372
    // assert(!initialCheck.expired, ERR_PLUGIN_EXPIRED);
    dup
    intc_1 // 1
    getbit
    !
    assert // plugin expired
    // smart_contracts/arc58/account/contract.algo.ts:373
    // assert(!initialCheck.onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    pushint 3 // 3
    getbit
    !
    assert // plugin on cooldown
    // smart_contracts/arc58/account/contract.algo.ts:375
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 23
    // smart_contracts/arc58/account/contract.algo.ts:376
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 19
    // smart_contracts/arc58/account/contract.algo.ts:378
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 14
    dup
    frame_bury 5
    frame_bury 4

arc58_rekeyToPlugin_while_top@24:
    // smart_contracts/arc58/account/contract.algo.ts:378
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 14
    global GroupSize
    <
    bz arc58_rekeyToPlugin_block@53
    // smart_contracts/arc58/account/contract.algo.ts:381
    // if (this.txnRekeysBack(txn)) {
    frame_dig 14
    callsub txnRekeysBack
    bz arc58_rekeyToPlugin_after_if_else@27
    // smart_contracts/arc58/account/contract.algo.ts:382
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 23

arc58_rekeyToPlugin_block@53:
    // smart_contracts/arc58/account/contract.algo.ts:414
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 23
    assert // missing rekey back
    // smart_contracts/arc58/account/contract.algo.ts:822-829
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    intc_0 // 0
    bytec 8 // "spending_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:826
    // rekeyTo: pluginApp.address,
    frame_dig -5
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:827
    // note: 'rekeying to plugin app'
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:822-828
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:822-829
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:126
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 16 // "rekey_index"
    // smart_contracts/arc58/account/contract.algo.ts:832
    // this.rekeyIndex.value = Txn.groupIndex
    txn GroupIndex
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig 5
    concat
    // smart_contracts/arc58/account/contract.algo.ts:834
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    pushint 9 // 9
    intc_1 // 1
    box_extract
    bytec 12 // 0x01
    ==
    bz arc58_rekeyToPlugin_after_if_else@13
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put

arc58_rekeyToPlugin_after_if_else@13:
    frame_dig -2
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

arc58_rekeyToPlugin_after_if_else@27:
    // smart_contracts/arc58/account/contract.algo.ts:386
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 14
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bz arc58_rekeyToPlugin_after_if_else@29
    frame_dig 5

arc58_rekeyToPlugin_block@51:
    // smart_contracts/arc58/account/contract.algo.ts:378
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 14
    intc_1 // 1
    +
    frame_bury 14
    frame_bury 5
    b arc58_rekeyToPlugin_while_top@24

arc58_rekeyToPlugin_after_if_else@29:
    // smart_contracts/arc58/account/contract.algo.ts:390
    // assert(txn.appId.id === key.plugin, ERR_CANNOT_CALL_OTHER_APPS_DURING_REKEY);
    frame_dig 14
    dup
    gtxns ApplicationID
    frame_dig 4
    dup
    cover 3
    intc_0 // 0
    extract_uint64
    ==
    assert // cannot call other apps during rekey
    // smart_contracts/arc58/account/contract.algo.ts:391
    // assert(txn.onCompletion === OnCompleteAction.NoOp, ERR_INVALID_ONCOMPLETE);
    dup
    gtxns OnCompletion
    !
    assert // invalid oncomplete must be no op
    // smart_contracts/arc58/account/contract.algo.ts:394
    // assert(txn.numAppArgs > 1, ERR_INVALID_SENDER_ARG);
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // invalid sender must be this app id
    // smart_contracts/arc58/account/contract.algo.ts:395
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, ERR_INVALID_SENDER_VALUE);
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // invalid sender app id
    // smart_contracts/arc58/account/contract.algo.ts:397
    // const { hasMethodRestrictions, valid } = this.pluginCheck(key);
    callsub pluginCheck
    frame_bury 4
    dup
    intc_3 // 4
    getbit
    swap
    pushint 5 // 5
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:399
    // assert(valid, ERR_INVALID_PLUGIN_CALL);
    assert // invalid plugin call
    // smart_contracts/arc58/account/contract.algo.ts:401
    // if (hasMethodRestrictions) {
    bz arc58_rekeyToPlugin_after_if_else@48
    // smart_contracts/arc58/account/contract.algo.ts:402
    // assert(methodIndex < methodOffsets.length, ERR_MALFORMED_OFFSETS);
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig 19
    dup
    uncover 2
    <
    assert // malformed method offsets
    // smart_contracts/arc58/account/contract.algo.ts:403
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    frame_dig -2
    extract 2 0
    swap
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:427
    // assert(len(txn.appArgs(0)) === 4, ERR_INVALID_METHOD_SIGNATURE_LENGTH)
    frame_dig 14
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    frame_bury 7
    len
    intc_3 // 4
    ==
    assert // invalid method signature length
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig 4
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:430
    // const { useRounds } = this.plugins(key).value
    dup
    pushint 28 // 28
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    dup
    cover 2
    frame_bury 27
    // smart_contracts/arc58/account/contract.algo.ts:431
    // const { selector, cooldown, lastCalled } = this.plugins(key).value.methods[offset]
    uncover 2
    pushint 20 // 20
    *
    dup
    frame_bury 10
    pushint 47 // 47
    +
    pushint 20 // 20
    box_extract
    dup
    extract 0 4
    frame_bury 6
    dup
    intc_3 // 4
    extract_uint64
    frame_bury 11
    pushint 12 // 12
    extract_uint64
    frame_bury 17
    // smart_contracts/arc58/account/contract.algo.ts:435
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    bz arc58_rekeyToPlugin_ternary_false@32
    global Round

arc58_rekeyToPlugin_ternary_merge@33:
    // smart_contracts/arc58/account/contract.algo.ts:436
    // const onCooldown = (epochRef - lastCalled) < cooldown
    frame_dig 17
    -
    frame_dig 11
    <
    frame_bury 22
    // smart_contracts/arc58/account/contract.algo.ts:438
    // if (selector === selectorArg && (!hasCooldown || !onCooldown)) {
    frame_dig 6
    frame_dig 7
    ==
    bz arc58_rekeyToPlugin_after_if_else@42
    frame_dig 11
    bz arc58_rekeyToPlugin_if_body@36
    frame_dig 22
    bnz arc58_rekeyToPlugin_after_if_else@42

arc58_rekeyToPlugin_if_body@36:
    // smart_contracts/arc58/account/contract.algo.ts:440
    // if (hasCooldown) {
    frame_dig 11
    bz arc58_rekeyToPlugin_after_if_else@41
    // smart_contracts/arc58/account/contract.algo.ts:441
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 27
    bz arc58_rekeyToPlugin_ternary_false@39
    global Round

arc58_rekeyToPlugin_ternary_merge@40:
    // smart_contracts/arc58/account/contract.algo.ts:442
    // this.plugins(key).value.methods[offset].lastCalled = lastCalled
    itob
    frame_dig 10
    pushint 59 // 59
    +
    frame_dig 1
    swap
    uncover 2
    box_replace

arc58_rekeyToPlugin_after_if_else@41:
    // smart_contracts/arc58/account/contract.algo.ts:445-449
    // return {
    //   methodAllowed: true,
    //   methodHasCooldown: hasCooldown,
    //   methodOnCooldown: onCooldown
    // }
    pushbytes 0x80
    intc_1 // 1
    frame_dig 11
    setbit
    pushint 2 // 2
    frame_dig 22
    setbit

arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck@43:
    // smart_contracts/arc58/account/contract.algo.ts:403
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    dup
    intc_0 // 0
    getbit
    swap
    pushint 2 // 2
    getbit
    frame_bury 20
    // smart_contracts/arc58/account/contract.algo.ts:404
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    bz arc58_rekeyToPlugin_bool_false@46
    frame_dig 20
    bnz arc58_rekeyToPlugin_bool_false@46
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@47:
    // smart_contracts/arc58/account/contract.algo.ts:404
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    assert // method on cooldown

arc58_rekeyToPlugin_after_if_else@48:
    // smart_contracts/arc58/account/contract.algo.ts:407
    // if (initialCheck.hasCooldown) {
    frame_dig 3
    pushint 2 // 2
    getbit
    bz arc58_rekeyToPlugin_after_if_else@50
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig 4
    concat
    // smart_contracts/arc58/account/contract.algo.ts:408
    // this.plugins(key).value.lastCalled = epochRef
    frame_dig 12
    itob
    pushint 29 // 29
    swap
    box_replace

arc58_rekeyToPlugin_after_if_else@50:
    // smart_contracts/arc58/account/contract.algo.ts:411
    // methodIndex += 1;
    frame_dig 19
    intc_1 // 1
    +
    frame_bury 19
    frame_dig 4
    dup
    frame_bury 4
    b arc58_rekeyToPlugin_block@51

arc58_rekeyToPlugin_bool_false@46:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@47

arc58_rekeyToPlugin_ternary_false@39:
    // smart_contracts/arc58/account/contract.algo.ts:441
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_rekeyToPlugin_ternary_merge@40

arc58_rekeyToPlugin_after_if_else@42:
    // smart_contracts/arc58/account/contract.algo.ts:452-456
    // return {
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    pushbytes 0x60
    // smart_contracts/arc58/account/contract.algo.ts:403
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    b arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck@43

arc58_rekeyToPlugin_ternary_false@32:
    // smart_contracts/arc58/account/contract.algo.ts:435
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    b arc58_rekeyToPlugin_ternary_merge@33

arc58_rekeyToPlugin_bool_false@21:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@22

arc58_rekeyToPlugin_ternary_false@16:
    // smart_contracts/arc58/account/contract.algo.ts:359
    // : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 12
    b arc58_rekeyToPlugin_ternary_merge@17

arc58_rekeyToPlugin_else_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:122
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 8 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:817
    // this.spendingAddress.value = this.controlledAddress.value
    swap
    app_global_put
    b arc58_rekeyToPlugin_after_if_else@8

arc58_rekeyToPlugin_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:804
    // const caller = global ? Global.zeroAddress : Txn.sender
    txn Sender
    b arc58_rekeyToPlugin_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, global: uint64, escrow: bytes, methodOffsets: bytes, fundsRequest: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:848-853
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    proto 5 0
    // smart_contracts/arc58/account/contract.algo.ts:139
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 14 // "n"
    frame_dig -5
    concat
    // smart_contracts/arc58/account/contract.algo.ts:855
    // this.namedPlugins(name).value.plugin,
    intc_0 // 0
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:854-860
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.plugin,
    //   global,
    //   escrow,
    //   methodOffsets,
    //   fundsRequest
    // );
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub arc58_rekeyToPlugin
    frame_bury -1
    frame_bury -2
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin(plugin: uint64, caller: bytes, escrow: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useRounds: uint64, useExecutionKey: uint64, defaultToEscrow: uint64) -> void:
arc58_addPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:877-889
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    proto 11 0
    intc_0 // 0
    dupn 3
    bytec_2 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:890
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:892
    // delegationType === DelegationTypeSelf &&
    frame_dig -7
    bytec 12 // 0x01
    ==
    // smart_contracts/arc58/account/contract.algo.ts:892-893
    // delegationType === DelegationTypeSelf &&
    // caller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3
    // smart_contracts/arc58/account/contract.algo.ts:893
    // caller.native === Global.zeroAddress
    frame_dig -10
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:892-893
    // delegationType === DelegationTypeSelf &&
    // caller.native === Global.zeroAddress
    bz arc58_addPlugin_bool_false@3
    intc_1 // 1

arc58_addPlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:895
    // assert(!badDelegationCombo, ERR_ZERO_ADDRESS_DELEGATION_TYPE)
    !
    assert // delegation type must not be self for global plugins
    frame_dig -9
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:898
    // if (defaultToEscrow) {
    frame_dig -1
    bz arc58_addPlugin_after_if_else@6
    // smart_contracts/arc58/account/contract.algo.ts:899
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    frame_dig -9
    bytec_2 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:900
    // escrowKey = ''
    bytec_2 // ""
    frame_bury 1

arc58_addPlugin_after_if_else@6:
    // smart_contracts/arc58/account/contract.algo.ts:903
    // const key: PluginKey = { plugin, caller: caller.native, escrow: escrowKey }
    frame_dig -11
    itob
    frame_dig -10
    concat
    frame_dig 1
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:905
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    frame_bury 0
    bytec 21 // 0x0000
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:906
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 5

arc58_addPlugin_while_top@7:
    // smart_contracts/arc58/account/contract.algo.ts:906
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -4
    intc_0 // 0
    extract_uint16
    frame_dig 5
    >
    bz arc58_addPlugin_after_while@9
    // smart_contracts/arc58/account/contract.algo.ts:907
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    frame_dig -4
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    extract 0 4
    swap
    intc_3 // 4
    extract_uint64
    dig 1
    len
    intc_3 // 4
    ==
    assert // invalid size
    itob
    concat
    frame_dig 0
    concat
    frame_dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:906
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 5
    b arc58_addPlugin_while_top@7

arc58_addPlugin_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:910
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -3
    bz arc58_addPlugin_ternary_false@11
    global Round
    frame_bury 4

arc58_addPlugin_ternary_merge@12:
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:912
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addPlugin_after_if_else@15
    // smart_contracts/arc58/account/contract.algo.ts:913-919
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:916
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:917
    // amount: this.pluginsMbr(escrowKey, methodInfos.length)
    frame_dig 3
    intc_0 // 0
    extract_uint16
    frame_dig 1
    swap
    callsub pluginsMbr
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:913-918
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:913-919
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    //   .submit()
    itxn_submit

arc58_addPlugin_after_if_else@15:
    // smart_contracts/arc58/account/contract.algo.ts:922
    // const escrowID = this.maybeNewEscrow(escrow);
    frame_dig -9
    callsub maybeNewEscrow
    // smart_contracts/arc58/account/contract.algo.ts:924-935
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    itob
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -8
    setbit
    concat
    frame_dig -7
    concat
    frame_dig -6
    itob
    concat
    frame_dig -5
    itob
    concat
    bytec 24 // 0x002d
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    intc_1 // 1
    frame_dig -2
    setbit
    concat
    frame_dig 0
    concat
    frame_dig 4
    itob
    concat
    frame_dig 3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:924-935
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_addPlugin_ternary_false@11:
    // smart_contracts/arc58/account/contract.algo.ts:910
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 4
    b arc58_addPlugin_ternary_merge@12

arc58_addPlugin_bool_false@3:
    intc_0 // 0
    b arc58_addPlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain(caller: bytes, domain: bytes) -> void:
assignDomain:
    // smart_contracts/arc58/account/contract.algo.ts:947
    // assignDomain(caller: Address, domain: string): void {
    proto 2 0
    // smart_contracts/arc58/account/contract.algo.ts:948
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_ADD_PLUGIN)
    callsub isAdmin
    assert // Only an admin can add a plugin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:950
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz assignDomain_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:951-957
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:954
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:193
    // return MinDomainKeysMBR + (BoxCostPerByte * Bytes(domain).length)
    frame_dig -1
    len
    intc 4 // 400
    *
    pushint 15700 // 15700
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:951-956
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:951-957
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_submit

assignDomain_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:158
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 18 // "d"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:960
    // this.domainKeys(caller.native).value = domain
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin(plugin: uint64, caller: bytes, escrow: bytes) -> void:
arc58_removePlugin:
    // smart_contracts/arc58/account/contract.algo.ts:969
    // arc58_removePlugin(plugin: uint64, caller: Address, escrow: string): void {
    proto 3 0
    bytec_2 // ""
    // smart_contracts/arc58/account/contract.algo.ts:970
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removePlugin_bool_true@2
    callsub canRevoke
    bz arc58_removePlugin_bool_false@3

arc58_removePlugin_bool_true@2:
    intc_1 // 1

arc58_removePlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:970
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:972
    // const key: PluginKey = { plugin, caller: caller.native, escrow }
    frame_dig -3
    itob
    frame_dig -2
    concat
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:973
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:975
    // const methodsLength: uint64 = this.plugins(key).value.methods.length
    dup
    pushints 45 2 // 45, 2
    box_extract
    btoi
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:977
    // this.plugins(key).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:979
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removePlugin_after_if_else@7
    // smart_contracts/arc58/account/contract.algo.ts:980-985
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(escrow, methodsLength)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:983
    // amount: this.pluginsMbr(escrow, methodsLength)
    frame_dig -1
    frame_dig 0
    callsub pluginsMbr
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:980-984
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(escrow, methodsLength)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:980-985
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.pluginsMbr(escrow, methodsLength)
    //   })
    //   .submit()
    itxn_submit

arc58_removePlugin_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_removePlugin_bool_false@3:
    intc_0 // 0
    b arc58_removePlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, plugin: uint64, caller: bytes, escrow: bytes, admin: uint64, delegationType: bytes, lastValid: uint64, cooldown: uint64, methods: bytes, useRounds: uint64, useExecutionKey: uint64, defaultToEscrow: uint64) -> void:
arc58_addNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:1007-1020
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    proto 12 0
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1021
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 9 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1021
    // assert(Txn.sender === this.admin.value, ERR_ADMIN_ONLY);
    ==
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:139
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 14 // "n"
    frame_dig -12
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1022
    // assert(!this.namedPlugins(name).exists);
    box_len
    bury 1
    !
    assert
    frame_dig -9
    // smart_contracts/arc58/account/contract.algo.ts:1025
    // if (defaultToEscrow) {
    frame_dig -1
    bz arc58_addNamedPlugin_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:1026
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    frame_dig -9
    bytec_2 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:1027
    // escrowKey = ''
    bytec_2 // ""
    frame_bury 6

arc58_addNamedPlugin_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:1030
    // const key: PluginKey = { plugin, caller: caller.native, escrow: escrowKey }
    frame_dig -11
    itob
    frame_dig -10
    concat
    frame_dig 6
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1031
    // this.namedPlugins(name).value = clone(key)
    frame_dig 5
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1033
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    frame_bury 0
    bytec 21 // 0x0000
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1034
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 4

arc58_addNamedPlugin_while_top@3:
    // smart_contracts/arc58/account/contract.algo.ts:1034
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -4
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz arc58_addNamedPlugin_after_while@5
    // smart_contracts/arc58/account/contract.algo.ts:1035
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    frame_dig -4
    extract 2 0
    frame_dig 4
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    extract 0 4
    swap
    intc_3 // 4
    extract_uint64
    dig 1
    len
    intc_3 // 4
    ==
    assert // invalid size
    itob
    concat
    frame_dig 0
    concat
    frame_dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1034
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 4
    b arc58_addNamedPlugin_while_top@3

arc58_addNamedPlugin_after_while@5:
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1038
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addNamedPlugin_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:1039-1045
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1042
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1043
    // amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    frame_dig 2
    intc_0 // 0
    extract_uint16
    frame_dig 6
    swap
    callsub pluginsMbr
    // smart_contracts/arc58/account/contract.algo.ts:177
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -12
    len
    intc 4 // 400
    *
    intc 6 // 18900
    +
    // smart_contracts/arc58/account/contract.algo.ts:1043
    // amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1039-1044
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1039-1045
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_submit

arc58_addNamedPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:1048
    // const escrowID = this.maybeNewEscrow(escrow);
    frame_dig -9
    callsub maybeNewEscrow
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:1050
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig -3
    bz arc58_addNamedPlugin_ternary_false@10
    global Round

arc58_addNamedPlugin_ternary_merge@11:
    // smart_contracts/arc58/account/contract.algo.ts:1052-1063
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    frame_dig 3
    itob
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -8
    setbit
    concat
    frame_dig -7
    concat
    frame_dig -6
    itob
    concat
    frame_dig -5
    itob
    concat
    bytec 24 // 0x002d
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig -3
    setbit
    intc_1 // 1
    frame_dig -2
    setbit
    concat
    frame_dig 0
    concat
    swap
    itob
    concat
    frame_dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    frame_dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1052-1063
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_addNamedPlugin_ternary_false@10:
    // smart_contracts/arc58/account/contract.algo.ts:1050
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addNamedPlugin_ternary_merge@11


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:1074
    // arc58_removeNamedPlugin(name: string): void {
    proto 1 0
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1075
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removeNamedPlugin_bool_true@2
    callsub canRevoke
    bz arc58_removeNamedPlugin_bool_false@3

arc58_removeNamedPlugin_bool_true@2:
    intc_1 // 1

arc58_removeNamedPlugin_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:1075
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:139
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 14 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1076
    // assert(this.namedPlugins(name).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1077
    // const app = clone(this.namedPlugins(name).value)
    dup
    box_get
    pop
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1078
    // assert(this.plugins(app).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1080
    // const methodsLength: uint64 = this.plugins(app).value.methods.length
    dup
    pushints 45 2 // 45, 2
    box_extract
    btoi
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1082
    // this.namedPlugins(name).delete();
    swap
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1083
    // this.plugins(app).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1085
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeNamedPlugin_after_if_else@7
    // smart_contracts/arc58/account/contract.algo.ts:1086-1091
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:177
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -1
    len
    intc 4 // 400
    *
    intc 6 // 18900
    +
    // smart_contracts/arc58/account/contract.algo.ts:1089
    // amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    frame_dig 0
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    frame_dig 1
    callsub pluginsMbr
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1086-1090
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1086-1091
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    //   .submit()
    itxn_submit

arc58_removeNamedPlugin_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_removeNamedPlugin_bool_false@3:
    intc_0 // 0
    b arc58_removeNamedPlugin_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_newEscrow(escrow: bytes) -> uint64:
arc58_newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1103
    // arc58_newEscrow(escrow: string): uint64 {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:1104
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1105
    // assert(!this.namedEscrows(escrow).exists, ERR_ESCROW_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // Escrow already exists
    // smart_contracts/arc58/account/contract.algo.ts:1106
    // return this.newEscrow(escrow);
    frame_dig -1
    callsub newEscrow
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_toggleEscrowLock(escrow: bytes) -> uint64:
arc58_toggleEscrowLock:
    // smart_contracts/arc58/account/contract.algo.ts:1114
    // arc58_toggleEscrowLock(escrow: string): boolean {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:1115
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1116
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1117
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    pop
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1119
    // this.escrows(escrowID).value = !this.escrows(escrowID).value;
    itob
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1119
    // this.escrows(escrowID).value = !this.escrows(escrowID).value;
    dup
    box_get
    assert // Box must have value
    btoi
    !
    itob
    swap
    dig 1
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1124
    // return this.escrows(escrowID).value;
    btoi
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_reclaim(escrow: bytes, reclaims: bytes) -> void:
arc58_reclaim:
    // smart_contracts/arc58/account/contract.algo.ts:1133
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    proto 2 0
    intc_0 // 0
    dup
    bytec_2 // ""
    dupn 4
    intc_0 // 0
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1134
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1135
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1136
    // const sender = Application(this.namedEscrows(escrow).value).address
    box_get
    pop
    btoi
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:1138
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    intc_0 // 0

arc58_reclaim_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:1138
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 10
    >
    bz arc58_reclaim_after_while@16
    // smart_contracts/arc58/account/contract.algo.ts:1139
    // if (reclaims[i].asset === 0) {
    frame_dig -1
    extract 2 0
    frame_dig 10
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 3
    bnz arc58_reclaim_else_body@9
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    swap
    frame_bury 0
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1143
    // amount: reclaims[i].amount
    dup
    intc_2 // 8
    extract_uint64
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:1140
    // const pmt = itxn.payment({
    intc_0 // 0
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1146
    // if (reclaims[i].closeOut) {
    pushint 128 // 128
    getbit
    bz arc58_reclaim_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    frame_bury 2
    frame_bury 8

arc58_reclaim_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1150
    // pmt.submit();
    itxn_begin
    frame_dig 2
    bz arc58_reclaim_next_field@7
    frame_dig 8
    itxn_field CloseRemainderTo

arc58_reclaim_next_field@7:
    frame_dig 4
    itxn_field Amount
    frame_dig 0
    itxn_field Receiver
    frame_dig 9
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1140-1144
    // const pmt = itxn.payment({
    //   sender,
    //   receiver: this.controlledAddress.value,
    //   amount: reclaims[i].amount
    // })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1150
    // pmt.submit();
    itxn_submit

arc58_reclaim_after_if_else@15:
    // smart_contracts/arc58/account/contract.algo.ts:1138
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig 10
    intc_1 // 1
    +
    frame_bury 10
    b arc58_reclaim_while_top@1

arc58_reclaim_else_body@9:
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    swap
    frame_bury 1
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1155
    // assetAmount: reclaims[i].amount,
    dup
    intc_2 // 8
    extract_uint64
    frame_bury 5
    // smart_contracts/arc58/account/contract.algo.ts:1152
    // const xfer = itxn.assetTransfer({
    intc_0 // 0
    frame_bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1159
    // if (reclaims[i].closeOut) {
    pushint 128 // 128
    getbit
    bz arc58_reclaim_after_if_else@11
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    frame_bury 6
    frame_bury 7

arc58_reclaim_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:1163
    // xfer.submit();
    itxn_begin
    frame_dig 6
    bz arc58_reclaim_next_field@13
    frame_dig 7
    itxn_field AssetCloseTo

arc58_reclaim_next_field@13:
    frame_dig 3
    itxn_field XferAsset
    frame_dig 5
    itxn_field AssetAmount
    frame_dig 1
    itxn_field AssetReceiver
    frame_dig 9
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1152-1157
    // const xfer = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.controlledAddress.value,
    //   assetAmount: reclaims[i].amount,
    //   xferAsset: reclaims[i].asset
    // })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1163
    // xfer.submit();
    itxn_submit
    b arc58_reclaim_after_if_else@15

arc58_reclaim_after_while@16:
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_optinEscrow(escrow: bytes, assets: bytes) -> void:
arc58_optinEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1174
    // arc58_optinEscrow(escrow: string, assets: uint64[]): void {
    proto 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1175
    // assert(this.isAdmin(), ERR_FORBIDDEN)
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1176
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1177
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    pop
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1178
    // const escrowAddress = Application(escrowID).address
    dup
    app_params_get AppAddress
    swap
    dup
    cover 3
    cover 3
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:1179
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    itob
    dup
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1179
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1181-1187
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1185
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    cover 4
    *
    itxn_field Amount
    itxn_field Sender
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1181-1186
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1181-1187
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1189
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

arc58_optinEscrow_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1189
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 3
    frame_dig 2
    <
    bz arc58_optinEscrow_after_while@5
    // smart_contracts/arc58/account/contract.algo.ts:1191
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    frame_dig -1
    extract 2 0
    frame_dig 3
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    dup
    itob
    frame_dig 1
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:145
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 11 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1191
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1190-1193
    // assert(
    //   this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    //   ERR_ALLOWANCE_DOES_NOT_EXIST
    // );
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1195-1202
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_begin
    itxn_field XferAsset
    // smart_contracts/arc58/account/contract.algo.ts:1199
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    frame_dig 0
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1195-1201
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1195-1202
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1189
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 3
    b arc58_optinEscrow_while_top@2

arc58_optinEscrow_after_while@5:
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginOptinEscrow(plugin: uint64, caller: bytes, escrow: bytes, assets: bytes, mbrPayment: uint64) -> void:
arc58_pluginOptinEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1214-1220
    // arc58_pluginOptinEscrow(
    //   plugin: uint64,
    //   caller: Address,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    proto 5 0
    intc_0 // 0
    dup
    bytec_2 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1221
    // const key: PluginKey = { plugin, caller: caller.native, escrow }
    frame_dig -5
    itob
    frame_dig -4
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    swap
    bytec 10 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1223
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1225
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1228
    // Txn.sender === Application(plugin).address ||
    txn Sender
    frame_dig -5
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1228-1229
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3
    // smart_contracts/arc58/account/contract.algo.ts:1229
    // Txn.sender === caller.native ||
    txn Sender
    frame_dig -4
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1228-1229
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    bnz arc58_pluginOptinEscrow_bool_true@3
    // smart_contracts/arc58/account/contract.algo.ts:1230
    // caller.native === Global.zeroAddress,
    frame_dig -4
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1228-1230
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller.native ||
    // caller.native === Global.zeroAddress,
    bz arc58_pluginOptinEscrow_bool_false@4

arc58_pluginOptinEscrow_bool_true@3:
    intc_1 // 1

arc58_pluginOptinEscrow_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1227-1232
    // assert(
    //   Txn.sender === Application(plugin).address ||
    //   Txn.sender === caller.native ||
    //   caller.native === Global.zeroAddress,
    //   ERR_FORBIDDEN
    // )
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:1233
    // assert(this.escrows(escrowID).exists, ERR_ESCROW_DOES_NOT_EXIST)
    frame_dig 4
    dup
    itob
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1233
    // assert(this.escrows(escrowID).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1234
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED)
    box_get
    pop
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1236
    // const escrowAddress = Application(escrowID).address
    app_params_get AppAddress
    swap
    dup
    cover 2
    frame_bury 1
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:1238-1245
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -1
    gtxns Receiver
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1238-1245
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    swap
    dig 1
    ==
    frame_dig -1
    gtxns Amount
    // smart_contracts/arc58/account/contract.algo.ts:1242
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    swap
    dig 1
    *
    // smart_contracts/arc58/account/contract.algo.ts:1238-1245
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    uncover 2
    ==
    uncover 2
    &&
    assert // invalid payment
    // smart_contracts/arc58/account/contract.algo.ts:1247-1253
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1251
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    *
    itxn_field Amount
    itxn_field Sender
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1247-1252
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1247-1253
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1255
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 3

arc58_pluginOptinEscrow_while_top@7:
    // smart_contracts/arc58/account/contract.algo.ts:1255
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 3
    frame_dig 2
    <
    bz arc58_pluginOptinEscrow_after_while@10
    // smart_contracts/arc58/account/contract.algo.ts:1257
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    frame_dig -2
    extract 2 0
    frame_dig 3
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    dup
    itob
    frame_dig 0
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:145
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 11 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1257
    // this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1256-1259
    // assert(
    //   this.allowances({ escrow: escrowID, asset: assets[i] }).exists,
    //   ERR_ALLOWANCE_DOES_NOT_EXIST
    // );
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1261-1268
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_begin
    itxn_field XferAsset
    // smart_contracts/arc58/account/contract.algo.ts:1265
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    frame_dig 1
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1261-1267
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1261-1268
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:1255
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 3
    b arc58_pluginOptinEscrow_while_top@7

arc58_pluginOptinEscrow_after_while@10:
    retsub

arc58_pluginOptinEscrow_bool_false@4:
    intc_0 // 0
    b arc58_pluginOptinEscrow_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowances(escrow: bytes, allowances: bytes) -> void:
arc58_addAllowances:
    // smart_contracts/arc58/account/contract.algo.ts:1278
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    proto 2 0
    intc_0 // 0
    dup
    bytec_2 // ""
    dupn 4
    // smart_contracts/arc58/account/contract.algo.ts:1279
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1280
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1281
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    pop
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    itob
    dup
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1284
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_addAllowances_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:1285-1291
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1288
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1289
    // amount: this.allowancesMbr() * allowances.length
    frame_dig -1
    intc_0 // 0
    extract_uint16
    // smart_contracts/arc58/account/contract.algo.ts:189
    // return AllowanceMBR;
    intc 7 // 29300
    // smart_contracts/arc58/account/contract.algo.ts:1289
    // amount: this.allowancesMbr() * allowances.length
    *
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1285-1290
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1285-1291
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr() * allowances.length
    //   })
    //   .submit()
    itxn_submit

arc58_addAllowances_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:1294
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    intc_0 // 0
    frame_bury 3

arc58_addAllowances_while_top@4:
    // smart_contracts/arc58/account/contract.algo.ts:1294
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 3
    >
    bz arc58_addAllowances_after_while@9
    // smart_contracts/arc58/account/contract.algo.ts:1295
    // const { asset, type, allowed, max, interval, useRounds } = allowances[i];
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 34 // 34
    *
    pushint 34 // 34
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    extract 8 1
    frame_bury 1
    dig 1
    pushint 9 // 9
    extract_uint64
    frame_bury 2
    dig 1
    pushint 17 // 17
    extract_uint64
    frame_bury 5
    dig 1
    pushint 25 // 25
    extract_uint64
    frame_bury 4
    swap
    pushint 264 // 264
    getbit
    dup
    cover 2
    frame_bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1296
    // const key: AllowanceKey = { escrow: escrowID, asset }
    itob
    frame_dig 7
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:145
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 11 // "a"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:1297
    // assert(!this.allowances(key).exists, ERR_ALLOWANCE_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // allowance already exists
    // smart_contracts/arc58/account/contract.algo.ts:1298
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    bz arc58_addAllowances_ternary_false@7
    global Round

arc58_addAllowances_ternary_merge@8:
    // smart_contracts/arc58/account/contract.algo.ts:1300-1309
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    frame_dig 5
    itob
    frame_dig 1
    swap
    concat
    frame_dig 2
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1302
    // spent: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1300-1309
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   allowed,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    itob
    swap
    dig 1
    concat
    frame_dig 4
    itob
    concat
    swap
    concat
    swap
    itob
    concat
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 6
    setbit
    concat
    frame_dig 0
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1294
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b arc58_addAllowances_while_top@4

arc58_addAllowances_ternary_false@7:
    // smart_contracts/arc58/account/contract.algo.ts:1298
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addAllowances_ternary_merge@8

arc58_addAllowances_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowances(escrow: bytes, assets: bytes) -> void:
arc58_removeAllowances:
    // smart_contracts/arc58/account/contract.algo.ts:1322
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    proto 2 0
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1323
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    callsub isAdmin
    bnz arc58_removeAllowances_bool_true@2
    callsub canRevoke
    bz arc58_removeAllowances_bool_false@3

arc58_removeAllowances_bool_true@2:
    intc_1 // 1

arc58_removeAllowances_bool_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:1323
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    assert // Only an admin or revocation app can remove method restrictions
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1324
    // assert(this.namedEscrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1325
    // const escrowID = this.namedEscrows(escrow).value
    box_get
    pop
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1326
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    itob
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1326
    // assert(!this.escrows(escrowID).value, ERR_ESCROW_LOCKED);
    box_get
    assert // Box must have value
    btoi
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1328
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    global CurrentApplicationAddress
    !=
    bz arc58_removeAllowances_after_if_else@7
    // smart_contracts/arc58/account/contract.algo.ts:1329-1334
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1332
    // amount: this.allowancesMbr() * assets.length
    frame_dig -1
    intc_0 // 0
    extract_uint16
    // smart_contracts/arc58/account/contract.algo.ts:189
    // return AllowanceMBR;
    intc 7 // 29300
    // smart_contracts/arc58/account/contract.algo.ts:1332
    // amount: this.allowancesMbr() * assets.length
    *
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1329-1333
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1329-1334
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr() * assets.length
    //   })
    //   .submit()
    itxn_submit

arc58_removeAllowances_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1337
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    frame_bury 1

arc58_removeAllowances_while_top@8:
    // smart_contracts/arc58/account/contract.algo.ts:1337
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 1
    >
    bz arc58_removeAllowances_after_while@10
    // smart_contracts/arc58/account/contract.algo.ts:1340
    // asset: assets[i]
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:1338-1341
    // const key: AllowanceKey = {
    //   escrow: escrowID,
    //   asset: assets[i]
    // }
    itob
    frame_dig 0
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:145
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 11 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1342
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1343
    // this.allowances(key).delete()
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1337
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 1
    b arc58_removeAllowances_while_top@8

arc58_removeAllowances_after_while@10:
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub

arc58_removeAllowances_bool_false@3:
    intc_0 // 0
    b arc58_removeAllowances_bool_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addExecutionKey(key: bytes, lastValidRound: uint64) -> void:
arc58_addExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1350
    // arc58_addExecutionKey(key: ExecutionKey, lastValidRound: uint64): void {
    proto 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1351
    // assert(this.isAdmin(), ERR_ADMIN_ONLY)
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 13 // "x"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1352
    // assert(!this.executions(key).exists, ERR_EXECUTION_KEY_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // execution key already exists
    // smart_contracts/arc58/account/contract.algo.ts:1354
    // this.executions(key).value = lastValidRound
    frame_dig -1
    itob
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeExecutionKey(key: bytes) -> void:
arc58_removeExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1360
    // arc58_removeExecutionKey(key: ExecutionKey): void {
    proto 1 0
    // smart_contracts/arc58/account/contract.algo.ts:1361
    // assert(this.isAdmin(), ERR_ADMIN_ONLY)
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:147
    // executions = BoxMap<ExecutionKey, uint64>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 13 // "x"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1362
    // assert(this.executions(key).exists, ERR_EXECUTION_KEY_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // execution key does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1363
    // this.executions(key).delete()
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:118
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 5 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:163
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:120
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:167
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:106
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    intc_0 // 0
    bytec 9 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1377
    // return new Address(this.admin.value)
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getPlugin(name: bytes) -> bytes:
arc58_getPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:1380-1381
    // @abimethod({ readonly: true })
    // arc58_getPlugin(name: string): PluginInfo {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:139
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 14 // "n"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1382
    // return this.plugins(this.namedPlugins(name).value).value
    box_get
    assert // Box must have value
    // smart_contracts/arc58/account/contract.algo.ts:137
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec 4 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1382
    // return this.plugins(this.namedPlugins(name).value).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getEscrow(name: bytes) -> bytes:
arc58_getEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1385-1386
    // @abimethod({ readonly: true })
    // arc58_getEscrow(name: string): EscrowInfo {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1387
    // if (this.namedEscrows(name).exists) {
    box_len
    bury 1
    bz arc58_getEscrow_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:1388
    // const id = this.namedEscrows(name).value
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1389
    // return { id, locked: this.escrows(id).value }
    itob
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1389
    // return { id, locked: this.escrows(id).value }
    box_get
    assert // Box must have value
    btoi
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    swap
    retsub

arc58_getEscrow_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:1391
    // return { id: 0, locked: false }
    pushbytes 0x000000000000000000
    swap
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_mustGetEscrow(name: bytes) -> bytes:
arc58_mustGetEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1394-1395
    // @abimethod({ readonly: true })
    // arc58_mustGetEscrow(name: string): EscrowInfo {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:143
    // namedEscrows = BoxMap<string, uint64>({ keyPrefix: AbstractAccountBoxPrefixEscrows }) // 6_100
    bytec_1 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1396
    // assert(this.namedEscrows(name).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1397
    // const id = this.namedEscrows(name).value
    box_get
    pop
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:1398
    // assert(this.escrows(id).exists, ERR_ESCROW_DOES_NOT_EXIST);
    itob
    // smart_contracts/arc58/account/contract.algo.ts:141
    // escrows = BoxMap<uint64, boolean>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_1 // "e"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1398
    // assert(this.escrows(id).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1399
    // return { id, locked: this.escrows(id).value }
    box_get
    pop
    btoi
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.mbr(escrow: bytes, methodCount: uint64, pluginName: bytes, escrowName: bytes) -> bytes:
mbr:
    // smart_contracts/arc58/account/contract.algo.ts:1402-1408
    // @abimethod({ readonly: true })
    // mbr(
    //   escrow: string,
    //   methodCount: uint64,
    //   pluginName: string,
    //   escrowName: string
    // ): AbstractAccountBoxMBRData {
    proto 4 1
    // smart_contracts/arc58/account/contract.algo.ts:1410
    // plugins: this.pluginsMbr(escrow, methodCount),
    frame_dig -4
    frame_dig -3
    callsub pluginsMbr
    // smart_contracts/arc58/account/contract.algo.ts:177
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -2
    len
    intc 4 // 400
    *
    intc 6 // 18900
    dig 1
    +
    // smart_contracts/arc58/account/contract.algo.ts:185
    // return MinNamedEscrowsMBR + (BoxCostPerByte * Bytes(name).length);
    frame_dig -1
    len
    intc 4 // 400
    *
    pushint 6100 // 6100
    +
    // smart_contracts/arc58/account/contract.algo.ts:193
    // return MinDomainKeysMBR + (BoxCostPerByte * Bytes(domain).length)
    pushint 15700 // 15700
    uncover 3
    +
    // smart_contracts/arc58/account/contract.algo.ts:1409-1416
    // return {
    //   plugins: this.pluginsMbr(escrow, methodCount),
    //   namedPlugins: this.namedPluginsMbr(pluginName),
    //   escrows: this.escrowsMbr(),
    //   namedEscrows: this.namedEscrowsMbr(escrowName),
    //   allowances: this.allowancesMbr(),
    //   domainKeys: this.domainKeysMbr(pluginName),
    // }
    uncover 3
    itob
    uncover 3
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:181
    // return EscrowsMBR;
    pushint 6500 // 6500
    // smart_contracts/arc58/account/contract.algo.ts:1409-1416
    // return {
    //   plugins: this.pluginsMbr(escrow, methodCount),
    //   namedPlugins: this.namedPluginsMbr(pluginName),
    //   escrows: this.escrowsMbr(),
    //   namedEscrows: this.namedEscrowsMbr(escrowName),
    //   allowances: this.allowancesMbr(),
    //   domainKeys: this.domainKeysMbr(pluginName),
    // }
    itob
    concat
    uncover 2
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:189
    // return AllowanceMBR;
    intc 7 // 29300
    // smart_contracts/arc58/account/contract.algo.ts:1409-1416
    // return {
    //   plugins: this.pluginsMbr(escrow, methodCount),
    //   namedPlugins: this.namedPluginsMbr(pluginName),
    //   escrows: this.escrowsMbr(),
    //   namedEscrows: this.namedEscrowsMbr(escrowName),
    //   allowances: this.allowancesMbr(),
    //   domainKeys: this.domainKeysMbr(pluginName),
    // }
    itob
    concat
    swap
    itob
    concat
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(assets: bytes) -> bytes, bytes:
balance:
    // smart_contracts/arc58/account/contract.algo.ts:1420-1421
    // @abimethod({ readonly: true })
    // balance(assets: uint64[]): uint64[] {
    proto 1 2
    intc_0 // 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/arc58/account/contract.algo.ts:1422
    // let amounts: uint64[] = []
    bytec 21 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1423
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

balance_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:1423
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 5
    >
    bz balance_after_while@9
    // smart_contracts/arc58/account/contract.algo.ts:1424
    // let amount: uint64 = 0
    intc_0 // 0
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1425
    // const asset = Asset(assets[i])
    frame_dig -1
    extract 2 0
    frame_dig 5
    intc_2 // 8
    *
    dup2
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    frame_bury 0
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1427
    // if (asset.id === 0) {
    bnz balance_else_body@4
    // smart_contracts/arc58/account/contract.algo.ts:1428
    // amount = Global.currentApplicationAddress.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    swap
    frame_bury 1
    assert // account funded

balance_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1436-1445
    // const escrowInfo = abiCall(
    //   Staking.prototype.getEscrowInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).staking,
    //     args: [
    //       new Address(this.controlledAddress.value),
    //       asset.id
    //     ]
    //   }
    // ).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:104
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    intc_0 // 0
    pushbytes "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:25
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    pushbytes "akita_al"
    app_global_get_ex
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1439
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:108
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    intc_0 // 0
    bytec_0 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1436-1445
    // const escrowInfo = abiCall(
    //   Staking.prototype.getEscrowInfo,
    //   {
    //     appId: getAkitaAppList(this.akitaDAO.value).staking,
    //     args: [
    //       new Address(this.controlledAddress.value),
    //       asset.id
    //     ]
    //   }
    // ).returnValue
    pushbytes 0x19976599 // method "getEscrowInfo(byte[32],uint64)(uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 7 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/account/contract.algo.ts:1447
    // amounts = [...amounts, (amount + escrowInfo.hard + escrowInfo.lock)]
    dup
    intc_3 // 4
    extract_uint64
    frame_dig 1
    +
    swap
    pushint 12 // 12
    extract_uint64
    +
    itob
    bytec 20 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 4
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:1423
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    b balance_while_top@1

balance_else_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:1430
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 2
    asset_holding_get AssetBalance
    swap
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:1431
    // if (optedIn) {
    bz balance_after_if_else@7
    frame_dig 3
    frame_bury 1
    b balance_after_if_else@7

balance_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:1450
    // return amounts
    frame_dig 4
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub
