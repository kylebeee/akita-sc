#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8 400 18900 27700
    bytecblock "controlled_address" "" "e" "p" "last_user_interaction" 0x151f7c75 "last_change" 0x0000 0x00 "x" "spending_address" 0x002a 0x0002 "admin" 0x01 "n" "d" 0x000a "a" "rekey_index" "akita_dao" "domain" "escrow_factory" "revocation" 0x0001 "current_plugin" 0x6cc3f606 "version" "nickname" "factory_app" 0x002c
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:150
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 19 // "rekey_index"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:113-119
    // @contract({
    //   stateTotals: {
    //     globalBytes: AbstractAccountNumGlobalBytes,
    //     globalUints: AbstractAccountNumGlobalUints
    //   }
    // })
    // export class AbstractedAccount extends Contract {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/arc58/account/contract.algo.ts:113-119
    // @contract({
    //   stateTotals: {
    //     globalBytes: AbstractAccountNumGlobalBytes,
    //     globalUints: AbstractAccountNumGlobalUints
    //   }
    // })
    // export class AbstractedAccount extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@47
    pushbytess 0xbd6099e5 0x7787867d 0x2d7711b7 0x401a6d80 0x9f91cccd 0x17d8bcb4 0x385658ab 0x5ef0b415 0xd24b7556 0x147b6cd6 // method "register(string)void", method "setDomain(string)void", method "setRevocationApp(uint64)void", method "setAkitaDAO(uint64)void", method "setNickname(string)void", method "setAvatar(uint64)void", method "setBanner(uint64)void", method "setBio(string)void", method "arc58_changeAdmin(address)void", method "arc58_pluginChangeAdmin(address)void"
    bytec 26 // method "arc58_verifyAuthAddress()void"
    pushbytess 0xc95a5d3d 0x4727af21 0x582ff382 0xdefd5cd2 0x5672462e 0x57a51d88 0xeef448fd 0x572fd1ea 0xe350b9d4 0x0a8cb2c2 0x25b713ca 0xebaf14a0 0x6a205cfc 0xae1a4dca 0x644d2dec 0xbf4d7c57 0xd5dd382b 0x5cebed43 0xd58685af 0x13bc44e4 0x89a76826 0x05794d7d 0xa2403ddf 0x02fe4515 0x41bdc680 0x882bb1c2 0x1760c652 0x124c0a7f // method "arc58_rekeyTo(address,bool)void", method "arc58_canCall(uint64,bool,address,string,byte[4])bool", method "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void", method "arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void", method "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void", method "assignDomain(address,string)void", method "arc58_removePlugin(uint64,address,string)void", method "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void", method "arc58_removeNamedPlugin(string)void", method "arc58_newEscrow(string)uint64", method "arc58_toggleEscrowLock(string)(uint64,bool)", method "arc58_reclaim(string,(uint64,uint64,bool)[])void", method "arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void", method "arc58_optInEscrow(string,uint64[])void", method "arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void", method "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void", method "arc58_removeAllowances(string,uint64[])void", method "arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void", method "arc58_removeExecutionKey(byte[32])void", method "arc58_getAdmin()address", method "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", method "arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", method "arc58_getEscrows(string[])(uint64,bool)[]", method "arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]", method "arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]", method "arc58_getDomainKeys(address[])string[]", method "mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)", method "balance(uint64[])uint64[]"
    txna ApplicationArgs 0
    match register setDomain setRevocationApp setAkitaDAO setNickname setAvatar setBanner setBio arc58_changeAdmin arc58_pluginChangeAdmin arc58_verifyAuthAddress arc58_rekeyTo arc58_canCall arc58_rekeyToPlugin arc58_rekeyToNamedPlugin arc58_addPlugin assignDomain arc58_removePlugin arc58_addNamedPlugin arc58_removeNamedPlugin arc58_newEscrow arc58_toggleEscrowLock arc58_reclaim arc58_pluginReclaim arc58_optInEscrow arc58_pluginOptInEscrow arc58_addAllowances arc58_removeAllowances arc58_addExecutionKey arc58_removeExecutionKey arc58_getAdmin arc58_getPlugins arc58_getNamedPlugins arc58_getEscrows arc58_getAllowances arc58_getExecutions arc58_getDomainKeys mbr balance
    err

main_create_NoOp@47:
    // smart_contracts/arc58/account/contract.algo.ts:113-119
    // @contract({
    //   stateTotals: {
    //     globalBytes: AbstractAccountNumGlobalBytes,
    //     globalUints: AbstractAccountNumGlobalUints
    //   }
    // })
    // export class AbstractedAccount extends Contract {
    pushbytes 0xa3dbd377 // method "create(string,uint64,address,address,string,uint64,uint64,string,address)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/arc58/account/contract.algo.ts:688
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_0 // 0

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@4
    frame_dig 3
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 4
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 3
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@4:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_1 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_0 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_0 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// smart_contracts/utils/types/base.ts::uint8(v: uint64) -> bytes:
uint8:
    // smart_contracts/utils/types/base.ts:3
    // export function uint8(v: uint64) {
    proto 1 1
    // smart_contracts/utils/types/base.ts:4
    // return new arc4.Uint8(v)
    frame_dig -1
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// smart_contracts/arc58/account/utils.ts::emptyPluginInfo() -> bytes:
emptyPluginInfo:
    // smart_contracts/arc58/account/utils.ts:7
    // delegationType: uint8(0),
    intc_0 // 0
    callsub uint8
    // smart_contracts/arc58/account/utils.ts:10
    // methods: [],
    intc_0 // 0
    itob
    // smart_contracts/arc58/account/utils.ts:5-18
    // return {
    //   escrow: 0,
    //   delegationType: uint8(0),
    //   lastValid: 0,
    //   cooldown: 0,
    //   methods: [],
    //   admin: false,
    //   useRounds: false,
    //   useExecutionKey: false,
    //   coverFees: false,
    //   canReclaim: false,
    //   lastCalled: 0,
    //   start: 0,
    // };
    dup
    uncover 2
    concat
    dig 1
    concat
    dig 1
    concat
    pushbytes 0x002c00
    concat
    dig 1
    concat
    swap
    concat
    // smart_contracts/arc58/account/utils.ts:10
    // methods: [],
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/utils.ts:5-18
    // return {
    //   escrow: 0,
    //   delegationType: uint8(0),
    //   lastValid: 0,
    //   cooldown: 0,
    //   methods: [],
    //   admin: false,
    //   useRounds: false,
    //   useExecutionKey: false,
    //   coverFees: false,
    //   canReclaim: false,
    //   lastCalled: 0,
    //   start: 0,
    // };
    concat
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.create[routing]() -> void:
create:
    // smart_contracts/arc58/account/contract.algo.ts:627
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 6
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 5
    txna ApplicationArgs 7
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 5
    txna ApplicationArgs 8
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    cover 5
    txna ApplicationArgs 9
    dup
    cover 6
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/account/contract.algo.ts:639
    // assert(Global.callerApplicationId !== 0, ERR_BAD_DEPLOYER)
    global CallerApplicationID
    assert // This contract must be deployed from a factory
    // smart_contracts/arc58/account/contract.algo.ts:640
    // assert(admin !== controlledAddress)
    dig 1
    dig 3
    !=
    assert
    // smart_contracts/arc58/account/contract.algo.ts:124
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 27 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:642
    // this.version.value = version
    uncover 5
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:126
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 20 // "akita_dao"
    // smart_contracts/arc58/account/contract.algo.ts:643
    // this.akitaDAO.value = Application(akitaDAO)
    uncover 4
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:128
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 13 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:644
    // this.admin.value = admin
    uncover 2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:130
    // domain = GlobalState<string>({ key: AbstractAccountGlobalStateKeysDomain });
    bytec 21 // "domain"
    // smart_contracts/arc58/account/contract.algo.ts:645
    // this.domain.value = domain
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:647
    // controlledAddress === Global.zeroAddress
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:647-649
    // controlledAddress === Global.zeroAddress
    //   ? Global.currentApplicationAddress
    //   : controlledAddress
    bz create_ternary_false@3
    // smart_contracts/arc58/account/contract.algo.ts:648
    // ? Global.currentApplicationAddress
    global CurrentApplicationAddress

create_ternary_merge@4:
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:646-649
    // this.controlledAddress.value =
    //   controlledAddress === Global.zeroAddress
    //     ? Global.currentApplicationAddress
    //     : controlledAddress
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:152
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    bytec 22 // "escrow_factory"
    // smart_contracts/arc58/account/contract.algo.ts:650
    // this.escrowFactory.value = Application(escrowFactory)
    dig 4
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:651
    // this.spendingAddress.value = Global.zeroAddress;
    global ZeroAddress
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:156
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 23 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:652
    // this.revocation.value = Application(revocationApp)
    dig 3
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:134
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 28 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:653
    // this.nickname.value = nickname
    dig 2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:154
    // factoryApp = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysFactoryApp })
    bytec 29 // "factory_app"
    // smart_contracts/arc58/account/contract.algo.ts:654
    // this.factoryApp.value = Application(Global.callerApplicationId)
    global CallerApplicationID
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:158
    // referrer = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysReferrer })
    pushbytes "referrer"
    // smart_contracts/arc58/account/contract.algo.ts:655
    // this.referrer.value = referrer
    dig 1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:627
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return

create_ternary_false@3:
    dig 4
    b create_ternary_merge@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.register[routing]() -> void:
register:
    // smart_contracts/arc58/account/contract.algo.ts:668
    // register(escrow: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    // smart_contracts/arc58/account/contract.algo.ts:669
    // let app: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/arc58/account/contract.algo.ts:670
    // if (escrow !== '') {
    bytec_1 // ""
    !=
    bz register_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:671
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:672
    // app = this.escrows(escrow).value.id
    box_get
    pop
    intc_0 // 0
    extract_uint64
    bury 1

register_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:675-684
    // abiCall<typeof EscrowFactory.prototype.register>({
    //   appId: this.escrowFactory.value,
    //   args: [
    //     itxn.payment({
    //       receiver: this.escrowFactory.value.address,
    //       amount: ARC58WalletIDsByAccountsMbr
    //     }),
    //     app
    //   ]
    // })
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:679
    // receiver: this.escrowFactory.value.address,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:152
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    bytec 22 // "escrow_factory"
    // smart_contracts/arc58/account/contract.algo.ts:679
    // receiver: this.escrowFactory.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:680
    // amount: ARC58WalletIDsByAccountsMbr
    pushint 12100 // 12100
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:678-681
    // itxn.payment({
    //   receiver: this.escrowFactory.value.address,
    //   amount: ARC58WalletIDsByAccountsMbr
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:675-684
    // abiCall<typeof EscrowFactory.prototype.register>({
    //   appId: this.escrowFactory.value,
    //   args: [
    //     itxn.payment({
    //       receiver: this.escrowFactory.value.address,
    //       amount: ARC58WalletIDsByAccountsMbr
    //     }),
    //     app
    //   ]
    // })
    itxn_next
    // smart_contracts/arc58/account/contract.algo.ts:682
    // app
    dig 1
    itob
    // smart_contracts/arc58/account/contract.algo.ts:675-684
    // abiCall<typeof EscrowFactory.prototype.register>({
    //   appId: this.escrowFactory.value,
    //   args: [
    //     itxn.payment({
    //       receiver: this.escrowFactory.value.address,
    //       amount: ARC58WalletIDsByAccountsMbr
    //     }),
    //     app
    //   ]
    // })
    pushbytes 0x607e7046 // method "register(pay,uint64)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:668
    // register(escrow: string): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.update[routing]() -> void:
update:
    // smart_contracts/arc58/account/contract.algo.ts:688
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:690
    // assert(this.isAdmin() || Txn.sender === this.factoryApp.value.address, ERR_ONLY_ADMIN_CAN_UPDATE)
    callsub isAdmin
    bnz update_bool_true@3
    txn Sender
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:154
    // factoryApp = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysFactoryApp })
    bytec 29 // "factory_app"
    // smart_contracts/arc58/account/contract.algo.ts:690
    // assert(this.isAdmin() || Txn.sender === this.factoryApp.value.address, ERR_ONLY_ADMIN_CAN_UPDATE)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    bz update_bool_false@4

update_bool_true@3:
    intc_1 // 1

update_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:690
    // assert(this.isAdmin() || Txn.sender === this.factoryApp.value.address, ERR_ONLY_ADMIN_CAN_UPDATE)
    assert // Only an admin can update the application
    // smart_contracts/arc58/account/contract.algo.ts:124
    // version = GlobalState<string>({ key: GlobalStateKeyVersion })
    bytec 27 // "version"
    // smart_contracts/arc58/account/contract.algo.ts:691
    // this.version.value = version
    dig 1
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:688
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return

update_bool_false@4:
    intc_0 // 0
    b update_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setDomain[routing]() -> void:
setDomain:
    // smart_contracts/arc58/account/contract.algo.ts:701
    // setDomain(domain: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:702
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_UPDATE)
    callsub isAdmin
    assert // Only an admin can update the application
    // smart_contracts/arc58/account/contract.algo.ts:130
    // domain = GlobalState<string>({ key: AbstractAccountGlobalStateKeysDomain });
    bytec 21 // "domain"
    // smart_contracts/arc58/account/contract.algo.ts:703
    // this.domain.value = domain
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:701
    // setDomain(domain: string): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setRevocationApp[routing]() -> void:
setRevocationApp:
    // smart_contracts/arc58/account/contract.algo.ts:711
    // setRevocationApp(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:712
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_REVOKE)
    callsub isAdmin
    assert // Only an admin can change the revocation app
    // smart_contracts/arc58/account/contract.algo.ts:156
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 23 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:713
    // this.revocation.value = Application(app)
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:711
    // setRevocationApp(app: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAkitaDAO[routing]() -> void:
setAkitaDAO:
    // smart_contracts/arc58/account/contract.algo.ts:721
    // setAkitaDAO(akitaDAO: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:722
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_AKITA_DAO)
    callsub isAdmin
    assert // Only an admin can change the Akita DAO
    // smart_contracts/arc58/account/contract.algo.ts:126
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 20 // "akita_dao"
    // smart_contracts/arc58/account/contract.algo.ts:723
    // this.akitaDAO.value = akitaDAO
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:721
    // setAkitaDAO(akitaDAO: Application): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setNickname[routing]() -> void:
setNickname:
    // smart_contracts/arc58/account/contract.algo.ts:731
    // setNickname(nickname: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:732
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:134
    // nickname = GlobalState<string>({ key: AbstractAccountGlobalStateKeysNickname })
    bytec 28 // "nickname"
    // smart_contracts/arc58/account/contract.algo.ts:733
    // this.nickname.value = nickname
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:731
    // setNickname(nickname: string): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setAvatar[routing]() -> void:
setAvatar:
    // smart_contracts/arc58/account/contract.algo.ts:741
    // setAvatar(avatar: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:742
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:743
    // const amount = this.balance([avatar])
    dup
    itob
    bytec 24 // 0x0001
    swap
    concat
    callsub smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance
    pop
    intc_2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:744
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:136
    // avatar = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysAvatar })
    pushbytes "avatar"
    // smart_contracts/arc58/account/contract.algo.ts:745
    // this.avatar.value = Asset(avatar)
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:741
    // setAvatar(avatar: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBanner[routing]() -> void:
setBanner:
    // smart_contracts/arc58/account/contract.algo.ts:753
    // setBanner(banner: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:754
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:755
    // const amount = this.balance([banner])
    dup
    itob
    bytec 24 // 0x0001
    swap
    concat
    callsub smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance
    pop
    intc_2 // 2
    // smart_contracts/arc58/account/contract.algo.ts:756
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // smart_contracts/arc58/account/contract.algo.ts:138
    // banner = GlobalState<Asset>({ key: AbstractAccountGlobalStateKeysBanner })
    pushbytes "banner"
    // smart_contracts/arc58/account/contract.algo.ts:757
    // this.banner.value = Asset(banner)
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:753
    // setBanner(banner: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.setBio[routing]() -> void:
setBio:
    // smart_contracts/arc58/account/contract.algo.ts:765
    // setBio(bio: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:766
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // smart_contracts/arc58/account/contract.algo.ts:140
    // bio = GlobalState<string>({ key: AbstractAccountGlobalStateKeysBio })
    pushbytes "bio"
    // smart_contracts/arc58/account/contract.algo.ts:767
    // this.bio.value = bio
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:765
    // setBio(bio: string): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_changeAdmin[routing]() -> void:
arc58_changeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:775
    // arc58_changeAdmin(newAdmin: Account): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/account/contract.algo.ts:776
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_ADMIN);
    callsub isAdmin
    assert // Only an admin can change the admin account
    // smart_contracts/arc58/account/contract.algo.ts:128
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 13 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:777
    // this.admin.value = newAdmin;
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:775
    // arc58_changeAdmin(newAdmin: Account): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin[routing]() -> void:
arc58_pluginChangeAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:788
    // arc58_pluginChangeAdmin(newAdmin: Account): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/account/contract.algo.ts:789
    // const key = clone(this.currentPlugin.value)
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:148
    // currentPlugin = GlobalState<PluginKey>({ key: AbstractAccountGlobalStateKeysCurrentPlugin })
    bytec 25 // "current_plugin"
    // smart_contracts/arc58/account/contract.algo.ts:789
    // const key = clone(this.currentPlugin.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:790
    // const { plugin, escrow } = key
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 40 // 40
    extract_uint16
    dig 2
    len
    dig 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:792
    // assert(escrow === '', ERR_ADMIN_PLUGINS_CANNOT_USE_ESCROWS);
    bytec_1 // ""
    ==
    assert // admin plugins cannot use escrows
    // smart_contracts/arc58/account/contract.algo.ts:793
    // assert(Txn.sender === Application(plugin).address, ERR_SENDER_MUST_BE_ADMIN_PLUGIN);
    txn Sender
    dig 1
    app_params_get AppAddress
    assert // application exists
    ==
    assert // sender must be admin plugin
    // smart_contracts/arc58/account/contract.algo.ts:795
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:795
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    app_global_get_ex
    assert // check GlobalState exists
    acct_params_get AcctAuthAddr
    assert // account funded
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:794-797
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:800
    // this.plugins(key).exists && this.plugins(key).value.admin,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@4
    dup
    pushint 27 // 27
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@4
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:799-802
    // assert(
    //   this.plugins(key).exists && this.plugins(key).value.admin,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // smart_contracts/arc58/account/contract.algo.ts:128
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 13 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:804
    // this.admin.value = newAdmin;
    dig 2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:805
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    dup
    intc_3 // 8
    intc_1 // 1
    box_extract
    bytec 14 // 0x01
    ==
    bz arc58_pluginChangeAdmin_after_if_else@7
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put

arc58_pluginChangeAdmin_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:788
    // arc58_pluginChangeAdmin(newAdmin: Account): void {
    intc_1 // 1
    return

arc58_pluginChangeAdmin_bool_false@4:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_verifyAuthAddress[routing]() -> void:
arc58_verifyAuthAddress:
    // smart_contracts/arc58/account/contract.algo.ts:815
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddress());
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:815
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddress());
    app_global_get_ex
    assert // check GlobalState exists
    dup
    acct_params_get AcctAuthAddr
    swap
    cover 2
    assert // account funded
    // smart_contracts/arc58/account/contract.algo.ts:607
    // this.spendingAddress.value === this.controlledAddress.value
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:607
    // this.spendingAddress.value === this.controlledAddress.value
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:607-608
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddress_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:608
    // && this.controlledAddress.value === Global.currentApplicationAddress
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:608
    // && this.controlledAddress.value === Global.currentApplicationAddress
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:607-608
    // this.spendingAddress.value === this.controlledAddress.value
    // && this.controlledAddress.value === Global.currentApplicationAddress
    bz arc58_verifyAuthAddress_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:609
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global ZeroAddress

arc58_verifyAuthAddress_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:815
    // assert(this.spendingAddress.value.authAddress === this.getAuthAddress());
    dig 1
    ==
    assert
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:816
    // this.spendingAddress.value = Global.zeroAddress
    global ZeroAddress
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:817
    // this.currentPlugin.value = { plugin: 0, caller: Global.currentApplicationAddress, escrow: '' }
    global CurrentApplicationAddress
    intc_0 // 0
    itob
    swap
    concat
    pushbytes 0x002a0000
    concat
    // smart_contracts/arc58/account/contract.algo.ts:148
    // currentPlugin = GlobalState<PluginKey>({ key: AbstractAccountGlobalStateKeysCurrentPlugin })
    bytec 25 // "current_plugin"
    // smart_contracts/arc58/account/contract.algo.ts:817
    // this.currentPlugin.value = { plugin: 0, caller: Global.currentApplicationAddress, escrow: '' }
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:150
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 19 // "rekey_index"
    // smart_contracts/arc58/account/contract.algo.ts:818
    // this.rekeyIndex.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:814
    // arc58_verifyAuthAddress(): void {
    intc_1 // 1
    return

arc58_verifyAuthAddress_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:609
    // ) ? Global.zeroAddress : Global.currentApplicationAddress
    global CurrentApplicationAddress
    b arc58_verifyAuthAddress_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyTo[routing]() -> void:
arc58_rekeyTo:
    bytec_1 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:827
    // arc58_rekeyTo(address: Account, flash: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:828
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:830-837
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address,
    //     rekeyTo: address,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:832
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:832
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:835
    // note: 'rekeying abstracted account'
    pushbytes "rekeying abstracted account"
    itxn_field Note
    dig 2
    itxn_field RekeyTo
    uncover 2
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:830-836
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address,
    //     rekeyTo: address,
    //     note: 'rekeying abstracted account'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:830-837
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address,
    //     rekeyTo: address,
    //     note: 'rekeying abstracted account'
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:839
    // if (flash) this.assertRekeysBack();
    bz arc58_rekeyTo_after_if_else@4
    // smart_contracts/arc58/account/contract.algo.ts:320
    // let rekeysBack = false;
    intc_0 // 0
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:321
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    bury 2

arc58_rekeyTo_while_top@6:
    // smart_contracts/arc58/account/contract.algo.ts:321
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    dig 1
    global GroupSize
    <
    bz arc58_rekeyTo_block@11
    // smart_contracts/arc58/account/contract.algo.ts:324
    // if (this.txnRekeysBack(txn)) {
    dig 1
    callsub txnRekeysBack
    bz arc58_rekeyTo_after_if_else@9
    // smart_contracts/arc58/account/contract.algo.ts:325
    // rekeysBack = true;
    intc_1 // 1
    bury 1

arc58_rekeyTo_block@11:
    // smart_contracts/arc58/account/contract.algo.ts:330
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    dup
    assert // missing rekey back

arc58_rekeyTo_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:827
    // arc58_rekeyTo(address: Account, flash: boolean): void {
    intc_1 // 1
    return

arc58_rekeyTo_after_if_else@9:
    // smart_contracts/arc58/account/contract.algo.ts:321
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    dig 1
    intc_1 // 1
    +
    bury 2
    b arc58_rekeyTo_while_top@6


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_canCall[routing]() -> void:
arc58_canCall:
    // smart_contracts/arc58/account/contract.algo.ts:854
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    cover 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    swap
    txna ApplicationArgs 5
    dup
    cover 2
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for uint8[4]
    // smart_contracts/arc58/account/contract.algo.ts:862
    // if (global) {
    bz arc58_canCall_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:863
    // this.pluginCallAllowed(plugin, Global.zeroAddress, escrow, method);
    dig 3
    global ZeroAddress
    dig 3
    dig 3
    callsub pluginCallAllowed
    pop

arc58_canCall_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:865
    // return this.pluginCallAllowed(plugin, address, escrow, method);
    dig 3
    dig 3
    dig 3
    dig 3
    callsub pluginCallAllowed
    // smart_contracts/arc58/account/contract.algo.ts:854
    // @abimethod({ readonly: true })
    bytec 8 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin[routing]() -> void:
arc58_rekeyToPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:877-883
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 16 // 16
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64)[])
    callsub smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin
    popn 2
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin[routing]() -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:945-950
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16
    pushint 16 // 16
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64)[])
    // smart_contracts/arc58/account/contract.algo.ts:165
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 15 // "n"
    uncover 5
    concat
    // smart_contracts/arc58/account/contract.algo.ts:952
    // this.namedPlugins(name).value.plugin,
    intc_0 // 0
    intc_3 // 8
    box_extract
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:951-957
    // this.arc58_rekeyToPlugin(
    //   this.namedPlugins(name).value.plugin,
    //   global,
    //   escrow,
    //   methodOffsets,
    //   fundsRequest
    // );
    cover 4
    callsub smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin
    popn 2
    // smart_contracts/arc58/account/contract.algo.ts:945-950
    // arc58_rekeyToNamedPlugin(
    //   name: string,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addPlugin[routing]() -> void:
arc58_addPlugin:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:977-991
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   coverFees: boolean,
    //   canReclaim: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 4
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    txna ApplicationArgs 5
    dupn 2
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 6
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 7
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 8
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 12 // 12
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[4],uint64)[])
    txna ApplicationArgs 9
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 10
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 11
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 12
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 13
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    // smart_contracts/arc58/account/contract.algo.ts:992
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:995
    // delegationType === DelegationTypeSelf &&
    bytec 14 // 0x01
    ==
    // smart_contracts/arc58/account/contract.algo.ts:995-996
    // delegationType === DelegationTypeSelf &&
    // caller === Global.zeroAddress
    bz arc58_addPlugin_bool_false@4
    // smart_contracts/arc58/account/contract.algo.ts:996
    // caller === Global.zeroAddress
    dig 12
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:995-996
    // delegationType === DelegationTypeSelf &&
    // caller === Global.zeroAddress
    bz arc58_addPlugin_bool_false@4
    intc_1 // 1

arc58_addPlugin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:994-997
    // !(
    //   delegationType === DelegationTypeSelf &&
    //   caller === Global.zeroAddress
    // ),
    !
    // smart_contracts/arc58/account/contract.algo.ts:993-999
    // assert(
    //   !(
    //     delegationType === DelegationTypeSelf &&
    //     caller === Global.zeroAddress
    //   ),
    //   ERR_ZERO_ADDRESS_DELEGATION_TYPE
    // )
    assert // delegation type must not be self for global plugins
    // smart_contracts/arc58/account/contract.algo.ts:1002-1003
    // useExecutionKey &&
    // caller !== Global.zeroAddress
    dig 3
    bz arc58_addPlugin_bool_false@8
    // smart_contracts/arc58/account/contract.algo.ts:1003
    // caller !== Global.zeroAddress
    dig 12
    global ZeroAddress
    !=
    // smart_contracts/arc58/account/contract.algo.ts:1002-1003
    // useExecutionKey &&
    // caller !== Global.zeroAddress
    bz arc58_addPlugin_bool_false@8
    intc_1 // 1

arc58_addPlugin_bool_merge@9:
    // smart_contracts/arc58/account/contract.algo.ts:1001-1004
    // !(
    //   useExecutionKey &&
    //   caller !== Global.zeroAddress
    // ),
    !
    // smart_contracts/arc58/account/contract.algo.ts:1000-1006
    // assert(
    //   !(
    //     useExecutionKey &&
    //     caller !== Global.zeroAddress
    //   ),
    //   ERR_USING_EXECUTION_KEY_REQUIRES_GLOBAL
    // )
    assert // using execution key requires global plugin
    // smart_contracts/arc58/account/contract.algo.ts:1009
    // if (defaultToEscrow) {
    dup
    bnz arc58_addPlugin_if_body@10
    dig 11
    bury 18

arc58_addPlugin_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:1014
    // const key: PluginKey = { plugin, caller, escrow: escrowKey }
    dig 13
    itob
    dig 13
    concat
    dig 18
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    dup
    bury 20
    // smart_contracts/arc58/account/contract.algo.ts:1016
    // assert(!this.plugins(key).exists, ERR_PLUGIN_ALREADY_EXISTS)
    box_len
    bury 1
    !
    assert // plugin already exists
    // smart_contracts/arc58/account/contract.algo.ts:1018
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    bury 20
    bytec 7 // 0x0000
    bury 17
    // smart_contracts/arc58/account/contract.algo.ts:1019
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    bury 15

arc58_addPlugin_while_top@12:
    // smart_contracts/arc58/account/contract.algo.ts:1019
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    dig 14
    dig 6
    <
    bz arc58_addPlugin_after_while@14
    // smart_contracts/arc58/account/contract.algo.ts:1020
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    dig 6
    extract 2 0
    dig 15
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    extract 0 4
    swap
    extract 4 8
    dig 1
    len
    pushint 4 // 4
    ==
    assert // invalid size
    concat
    dig 21
    concat
    dig 18
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 18
    // smart_contracts/arc58/account/contract.algo.ts:1019
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    bury 15
    b arc58_addPlugin_while_top@12

arc58_addPlugin_after_while@14:
    // smart_contracts/arc58/account/contract.algo.ts:1023
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    dig 4
    bz arc58_addPlugin_ternary_false@16
    global Round
    bury 16

arc58_addPlugin_ternary_merge@17:
    // smart_contracts/arc58/account/contract.algo.ts:1025
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1025
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz arc58_addPlugin_after_if_else@20
    // smart_contracts/arc58/account/contract.algo.ts:1026-1032
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1028
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1028
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1029
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1030
    // amount: this.pluginsMbr(escrowKey, methodInfos.length)
    dig 18
    intc_0 // 0
    extract_uint16
    dig 20
    swap
    callsub pluginsMbr
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1026-1031
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1026-1032
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length)
    //   })
    //   .submit()
    itxn_submit

arc58_addPlugin_after_if_else@20:
    // smart_contracts/arc58/account/contract.algo.ts:1035
    // const escrowID = this.maybeNewEscrow(escrow);
    dig 11
    dup
    callsub maybeNewEscrow
    // smart_contracts/arc58/account/contract.algo.ts:1047
    // canReclaim: escrow !== '' ? canReclaim : false,
    swap
    bytec_1 // ""
    !=
    intc_0 // 0
    dig 4
    uncover 2
    select
    // smart_contracts/arc58/account/contract.algo.ts:1037-1050
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   coverFees,
    //   canReclaim: escrow !== '' ? canReclaim : false,
    //   lastCalled: 0,
    //   start: epochRef,
    // }
    swap
    itob
    dig 11
    concat
    dig 10
    itob
    concat
    dig 9
    itob
    concat
    bytec 30 // 0x002c
    concat
    bytec 8 // 0x00
    intc_0 // 0
    dig 14
    setbit
    intc_1 // 1
    dig 8
    setbit
    intc_2 // 2
    dig 7
    setbit
    pushint 3 // 3
    dig 6
    setbit
    pushint 4 // 4
    uncover 3
    setbit
    concat
    dig 20
    concat
    dig 16
    itob
    concat
    dig 17
    concat
    dig 19
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:977-991
    // arc58_addPlugin(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   coverFees: boolean,
    //   canReclaim: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    intc_1 // 1
    return

arc58_addPlugin_ternary_false@16:
    // smart_contracts/arc58/account/contract.algo.ts:1023
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    bury 16
    b arc58_addPlugin_ternary_merge@17

arc58_addPlugin_if_body@10:
    // smart_contracts/arc58/account/contract.algo.ts:1010
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    dig 11
    bytec_1 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:1011
    // escrowKey = ''
    bytec_1 // ""
    bury 18
    b arc58_addPlugin_after_if_else@11

arc58_addPlugin_bool_false@8:
    intc_0 // 0
    b arc58_addPlugin_bool_merge@9

arc58_addPlugin_bool_false@4:
    intc_0 // 0
    b arc58_addPlugin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.assignDomain[routing]() -> void:
assignDomain:
    // smart_contracts/arc58/account/contract.algo.ts:1062
    // assignDomain(caller: Account, domain: string): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1063
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_ADD_PLUGIN)
    callsub isAdmin
    assert // Only an admin can add a plugin
    // smart_contracts/arc58/account/contract.algo.ts:1065
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1065
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz assignDomain_after_if_else@4
    // smart_contracts/arc58/account/contract.algo.ts:1066-1072
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1068
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1068
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1069
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:217
    // return MinDomainKeysMBR + (BoxCostPerByte * Bytes(domain).length)
    dig 2
    len
    intc 4 // 400
    *
    pushint 15700 // 15700
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1066-1071
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1066-1072
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.domainKeysMbr(domain)
    //   })
    //   .submit()
    itxn_submit

assignDomain_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 16 // "d"
    dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1075
    // this.domainKeys(caller).value = domain
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1062
    // assignDomain(caller: Account, domain: string): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removePlugin[routing]() -> void:
arc58_removePlugin:
    // smart_contracts/arc58/account/contract.algo.ts:1085
    // arc58_removePlugin(plugin: uint64, caller: Account, escrow: string): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1086
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removePlugin_bool_true@3
    callsub canRevoke
    bz arc58_removePlugin_bool_false@4

arc58_removePlugin_bool_true@3:
    intc_1 // 1

arc58_removePlugin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1086
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:1088
    // const key: PluginKey = { plugin, caller: caller, escrow }
    dig 2
    itob
    dig 2
    concat
    dig 1
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1089
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1091
    // this.plugins(key).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1085
    // arc58_removePlugin(plugin: uint64, caller: Account, escrow: string): void {
    intc_1 // 1
    return

arc58_removePlugin_bool_false@4:
    intc_0 // 0
    b arc58_removePlugin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addNamedPlugin[routing]() -> void:
arc58_addNamedPlugin:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1114-1129
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   coverFees: boolean,
    //   canReclaim: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    cover 2
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    swap
    txna ApplicationArgs 5
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    swap
    txna ApplicationArgs 6
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    txna ApplicationArgs 7
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 8
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 9
    dup
    cover 3
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 4
    pushint 12 // 12
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8[4],uint64)[])
    txna ApplicationArgs 10
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    txna ApplicationArgs 11
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    txna ApplicationArgs 12
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    txna ApplicationArgs 13
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    txna ApplicationArgs 14
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    intc_0 // 0
    getbit
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1130
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:165
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 15 // "n"
    uncover 2
    concat
    dup
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1131
    // assert(!this.namedPlugins(name).exists);
    box_len
    bury 1
    !
    assert
    // smart_contracts/arc58/account/contract.algo.ts:1134
    // delegationType === DelegationTypeSelf &&
    bytec 14 // 0x01
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1134-1135
    // delegationType === DelegationTypeSelf &&
    // caller === Global.zeroAddress
    bz arc58_addNamedPlugin_bool_false@4
    // smart_contracts/arc58/account/contract.algo.ts:1135
    // caller === Global.zeroAddress
    dig 13
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1134-1135
    // delegationType === DelegationTypeSelf &&
    // caller === Global.zeroAddress
    bz arc58_addNamedPlugin_bool_false@4
    intc_1 // 1

arc58_addNamedPlugin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1133-1136
    // !(
    //   delegationType === DelegationTypeSelf &&
    //   caller === Global.zeroAddress
    // ),
    !
    // smart_contracts/arc58/account/contract.algo.ts:1132-1138
    // assert(
    //   !(
    //     delegationType === DelegationTypeSelf &&
    //     caller === Global.zeroAddress
    //   ),
    //   ERR_ZERO_ADDRESS_DELEGATION_TYPE
    // )
    assert // delegation type must not be self for global plugins
    // smart_contracts/arc58/account/contract.algo.ts:1141-1142
    // useExecutionKey &&
    // caller !== Global.zeroAddress
    dig 4
    bz arc58_addNamedPlugin_bool_false@8
    // smart_contracts/arc58/account/contract.algo.ts:1142
    // caller !== Global.zeroAddress
    dig 13
    global ZeroAddress
    !=
    // smart_contracts/arc58/account/contract.algo.ts:1141-1142
    // useExecutionKey &&
    // caller !== Global.zeroAddress
    bz arc58_addNamedPlugin_bool_false@8
    intc_1 // 1

arc58_addNamedPlugin_bool_merge@9:
    // smart_contracts/arc58/account/contract.algo.ts:1140-1143
    // !(
    //   useExecutionKey &&
    //   caller !== Global.zeroAddress
    // ),
    !
    // smart_contracts/arc58/account/contract.algo.ts:1139-1145
    // assert(
    //   !(
    //     useExecutionKey &&
    //     caller !== Global.zeroAddress
    //   ),
    //   ERR_USING_EXECUTION_KEY_REQUIRES_GLOBAL
    // )
    assert // using execution key requires global plugin
    // smart_contracts/arc58/account/contract.algo.ts:1148
    // if (defaultToEscrow) {
    dig 1
    bnz arc58_addNamedPlugin_if_body@10
    dig 12
    bury 21

arc58_addNamedPlugin_after_if_else@11:
    // smart_contracts/arc58/account/contract.algo.ts:1153
    // const key: PluginKey = { plugin, caller: caller, escrow: escrowKey }
    dig 14
    itob
    dig 14
    concat
    dig 21
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    dup
    bury 21
    // smart_contracts/arc58/account/contract.algo.ts:1154
    // this.namedPlugins(name).value = clone(key)
    dig 1
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1156
    // let methodInfos: MethodInfo[] = []
    intc_0 // 0
    itob
    bury 22
    bytec 7 // 0x0000
    bury 19
    // smart_contracts/arc58/account/contract.algo.ts:1157
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    bury 17

arc58_addNamedPlugin_while_top@12:
    // smart_contracts/arc58/account/contract.algo.ts:1157
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    dig 16
    dig 7
    <
    bz arc58_addNamedPlugin_after_while@14
    // smart_contracts/arc58/account/contract.algo.ts:1158
    // methodInfos.push({ ...methods[i], lastCalled: 0 })
    dig 7
    extract 2 0
    dig 17
    dup
    cover 2
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: index access is out of bounds
    dup
    extract 0 4
    swap
    extract 4 8
    dig 1
    len
    pushint 4 // 4
    ==
    assert // invalid size
    concat
    dig 23
    concat
    dig 20
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 20
    // smart_contracts/arc58/account/contract.algo.ts:1157
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    bury 17
    b arc58_addNamedPlugin_while_top@12

arc58_addNamedPlugin_after_while@14:
    // smart_contracts/arc58/account/contract.algo.ts:1161
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1161
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz arc58_addNamedPlugin_after_if_else@17
    // smart_contracts/arc58/account/contract.algo.ts:1162-1168
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1164
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1164
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1165
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:1166
    // amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    dig 20
    intc_0 // 0
    extract_uint16
    dig 23
    swap
    callsub pluginsMbr
    // smart_contracts/arc58/account/contract.algo.ts:201
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    dig 18
    len
    intc 4 // 400
    *
    intc 5 // 18900
    +
    // smart_contracts/arc58/account/contract.algo.ts:1166
    // amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1162-1167
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1162-1168
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.pluginsMbr(escrowKey, methodInfos.length) + this.namedPluginsMbr(name)
    //   })
    //   .submit()
    itxn_submit

arc58_addNamedPlugin_after_if_else@17:
    // smart_contracts/arc58/account/contract.algo.ts:1171
    // const escrowID = this.maybeNewEscrow(escrow);
    dig 12
    callsub maybeNewEscrow
    bury 18
    // smart_contracts/arc58/account/contract.algo.ts:1173
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    dig 5
    bz arc58_addNamedPlugin_ternary_false@19
    global Round

arc58_addNamedPlugin_ternary_merge@20:
    // smart_contracts/arc58/account/contract.algo.ts:1185
    // canReclaim: escrow !== '' ? canReclaim : false,
    dig 13
    bytec_1 // ""
    !=
    intc_0 // 0
    dig 5
    uncover 2
    select
    // smart_contracts/arc58/account/contract.algo.ts:1175-1188
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   coverFees,
    //   canReclaim: escrow !== '' ? canReclaim : false,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    dig 19
    itob
    dig 13
    concat
    dig 12
    itob
    concat
    dig 11
    itob
    concat
    bytec 30 // 0x002c
    concat
    bytec 8 // 0x00
    intc_0 // 0
    dig 16
    setbit
    intc_1 // 1
    dig 10
    setbit
    intc_2 // 2
    dig 9
    setbit
    pushint 3 // 3
    dig 8
    setbit
    pushint 4 // 4
    uncover 3
    setbit
    concat
    dig 23
    concat
    swap
    itob
    concat
    dig 19
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 21
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1175-1188
    // this.plugins(key).value = {
    //   escrow: escrowID,
    //   admin,
    //   delegationType,
    //   lastValid,
    //   cooldown,
    //   methods: clone(methodInfos),
    //   useRounds,
    //   useExecutionKey,
    //   coverFees,
    //   canReclaim: escrow !== '' ? canReclaim : false,
    //   lastCalled: 0,
    //   start: epochRef
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1114-1129
    // arc58_addNamedPlugin(
    //   name: string,
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   admin: boolean,
    //   delegationType: Uint8,
    //   lastValid: uint64,
    //   cooldown: uint64,
    //   methods: MethodRestriction[],
    //   useRounds: boolean,
    //   useExecutionKey: boolean,
    //   coverFees: boolean,
    //   canReclaim: boolean,
    //   defaultToEscrow: boolean
    // ): void {
    intc_1 // 1
    return

arc58_addNamedPlugin_ternary_false@19:
    // smart_contracts/arc58/account/contract.algo.ts:1173
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addNamedPlugin_ternary_merge@20

arc58_addNamedPlugin_if_body@10:
    // smart_contracts/arc58/account/contract.algo.ts:1149
    // assert(escrow !== '', ERR_ESCROW_REQUIRED_TO_BE_SET_AS_DEFAULT)
    dig 12
    bytec_1 // ""
    !=
    assert // escrow must be set if defaultToEscrow is true
    // smart_contracts/arc58/account/contract.algo.ts:1150
    // escrowKey = ''
    bytec_1 // ""
    bury 21
    b arc58_addNamedPlugin_after_if_else@11

arc58_addNamedPlugin_bool_false@8:
    intc_0 // 0
    b arc58_addNamedPlugin_bool_merge@9

arc58_addNamedPlugin_bool_false@4:
    intc_0 // 0
    b arc58_addNamedPlugin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeNamedPlugin[routing]() -> void:
arc58_removeNamedPlugin:
    intc_0 // 0
    bytec_1 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1199
    // arc58_removeNamedPlugin(name: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1200
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    callsub isAdmin
    bnz arc58_removeNamedPlugin_bool_true@3
    callsub canRevoke
    bz arc58_removeNamedPlugin_bool_false@4

arc58_removeNamedPlugin_bool_true@3:
    intc_1 // 1

arc58_removeNamedPlugin_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1200
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_PLUGIN);
    assert // Only an admin or revocation app can remove plugins
    // smart_contracts/arc58/account/contract.algo.ts:165
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 15 // "n"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1201
    // assert(this.namedPlugins(name).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1202
    // const app = clone(this.namedPlugins(name).value)
    dup
    box_get
    pop
    dup
    bury 5
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1203
    // assert(this.plugins(app).exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1205
    // const methodsLength: uint64 = this.plugins(app).value.methods.length
    dup
    pushint 44 // 44
    intc_2 // 2
    box_extract
    btoi
    bury 4
    // smart_contracts/arc58/account/contract.algo.ts:1207
    // this.namedPlugins(name).delete();
    swap
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1208
    // this.plugins(app).delete();
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1210
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1210
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz arc58_removeNamedPlugin_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:1211-1216
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1213
    // receiver: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1213
    // receiver: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:201
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    dig 1
    len
    intc 4 // 400
    *
    intc 5 // 18900
    +
    // smart_contracts/arc58/account/contract.algo.ts:1214
    // amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    dig 4
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dig 4
    callsub pluginsMbr
    +
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1211-1215
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1211-1216
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.namedPluginsMbr(name) + this.pluginsMbr(app.escrow, methodsLength)
    //   })
    //   .submit()
    itxn_submit

arc58_removeNamedPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1199
    // arc58_removeNamedPlugin(name: string): void {
    intc_1 // 1
    return

arc58_removeNamedPlugin_bool_false@4:
    intc_0 // 0
    b arc58_removeNamedPlugin_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_newEscrow[routing]() -> void:
arc58_newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1228
    // arc58_newEscrow(escrow: string): uint64 {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1229
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1230
    // assert(!this.escrows(escrow).exists, ERR_ESCROW_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // Escrow already exists
    // smart_contracts/arc58/account/contract.algo.ts:1231
    // assert(escrow !== '', ERR_ESCROW_NAME_REQUIRED);
    dup
    bytec_1 // ""
    !=
    assert // Escrow name is required
    // smart_contracts/arc58/account/contract.algo.ts:1232
    // return this.newEscrow(escrow);
    callsub newEscrow
    // smart_contracts/arc58/account/contract.algo.ts:1228
    // arc58_newEscrow(escrow: string): uint64 {
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_toggleEscrowLock[routing]() -> void:
arc58_toggleEscrowLock:
    // smart_contracts/arc58/account/contract.algo.ts:1240
    // arc58_toggleEscrowLock(escrow: string): EscrowInfo {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:1241
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1242
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1244
    // this.escrows(escrow).value.locked = !this.escrows(escrow).value.locked;
    dup
    box_get
    pop
    pushint 64 // 64
    getbit
    !
    dig 1
    intc_3 // 8
    intc_1 // 1
    box_extract
    intc_0 // 0
    uncover 2
    setbit
    dig 1
    intc_3 // 8
    uncover 2
    box_replace
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1249
    // return this.escrows(escrow).value;
    box_get
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1240
    // arc58_toggleEscrowLock(escrow: string): EscrowInfo {
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_reclaim[routing]() -> void:
arc58_reclaim:
    // smart_contracts/arc58/account/contract.algo.ts:1258
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    pushint 17 // 17
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64,bool1)[])
    // smart_contracts/arc58/account/contract.algo.ts:1259
    // assert(this.isAdmin(), ERR_FORBIDDEN);
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1260
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1261
    // this.reclaim(escrow, reclaims, true);
    intc_1 // 1
    callsub reclaim
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1258
    // arc58_reclaim(escrow: string, reclaims: EscrowReclaim[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginReclaim[routing]() -> void:
arc58_pluginReclaim:
    // smart_contracts/arc58/account/contract.algo.ts:1273-1278
    // arc58_pluginReclaim(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   reclaims: EscrowReclaim[]
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 3
    txna ApplicationArgs 4
    dup
    cover 4
    dup
    intc_0 // 0
    extract_uint16
    pushint 17 // 17
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64,bool1)[])
    // smart_contracts/arc58/account/contract.algo.ts:1279
    // const key: PluginKey = { plugin, caller: caller, escrow }
    dig 2
    itob
    uncover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    dig 2
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1281
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1282
    // assert(this.plugins(key).value.canReclaim, ERR_FORBIDDEN)
    pushint 27 // 27
    intc_1 // 1
    box_extract
    pushint 4 // 4
    getbit
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    dup
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1283
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1286
    // Txn.sender === Application(plugin).address ||
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1286-1287
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    bnz arc58_pluginReclaim_bool_true@4
    // smart_contracts/arc58/account/contract.algo.ts:1287
    // Txn.sender === caller ||
    txn Sender
    dig 4
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1286-1287
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    bnz arc58_pluginReclaim_bool_true@4
    // smart_contracts/arc58/account/contract.algo.ts:1288
    // caller === Global.zeroAddress,
    dig 3
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1286-1288
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    // caller === Global.zeroAddress,
    bz arc58_pluginReclaim_bool_false@5

arc58_pluginReclaim_bool_true@4:
    intc_1 // 1

arc58_pluginReclaim_bool_merge@6:
    // smart_contracts/arc58/account/contract.algo.ts:1285-1290
    // assert(
    //   Txn.sender === Application(plugin).address ||
    //   Txn.sender === caller ||
    //   caller === Global.zeroAddress,
    //   ERR_FORBIDDEN
    // )
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:1292
    // this.reclaim(escrow, reclaims, !this.escrows(escrow).value.locked);
    dup
    box_get
    assert // Box must have value
    pushint 64 // 64
    getbit
    !
    dig 3
    dig 3
    uncover 2
    callsub reclaim
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1273-1278
    // arc58_pluginReclaim(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   reclaims: EscrowReclaim[]
    // ): void {
    intc_1 // 1
    return

arc58_pluginReclaim_bool_false@5:
    intc_0 // 0
    b arc58_pluginReclaim_bool_merge@6


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_optInEscrow[routing]() -> void:
arc58_optInEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1301
    // arc58_optInEscrow(escrow: string, assets: uint64[]): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/arc58/account/contract.algo.ts:1302
    // assert(this.isAdmin(), ERR_FORBIDDEN)
    callsub isAdmin
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    dig 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1303
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1304
    // assert(!this.escrows(escrow).value.locked, ERR_ESCROW_LOCKED)
    box_get
    pop
    pushint 64 // 64
    getbit
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1305
    // this.optInEscrow(escrow, assets);
    callsub optInEscrow
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1301
    // arc58_optInEscrow(escrow: string, assets: uint64[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_pluginOptInEscrow[routing]() -> void:
arc58_pluginOptInEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:1317-1323
    // arc58_pluginOptInEscrow(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 3
    txna ApplicationArgs 4
    dup
    cover 4
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 5
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    txn GroupIndex
    intc_1 // 1
    -
    dup
    cover 4
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/arc58/account/contract.algo.ts:1324
    // const key: PluginKey = { plugin, caller: caller, escrow }
    dig 2
    itob
    uncover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    dig 2
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1326
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1327
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1328
    // assert(!this.escrows(escrow).value.locked, ERR_ESCROW_LOCKED)
    box_get
    pop
    pushint 64 // 64
    getbit
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1331
    // Txn.sender === Application(plugin).address ||
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1331-1332
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    bnz arc58_pluginOptInEscrow_bool_true@4
    // smart_contracts/arc58/account/contract.algo.ts:1332
    // Txn.sender === caller ||
    txn Sender
    dig 5
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1331-1332
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    bnz arc58_pluginOptInEscrow_bool_true@4
    // smart_contracts/arc58/account/contract.algo.ts:1333
    // caller === Global.zeroAddress,
    dig 4
    global ZeroAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:1331-1333
    // Txn.sender === Application(plugin).address ||
    // Txn.sender === caller ||
    // caller === Global.zeroAddress,
    bz arc58_pluginOptInEscrow_bool_false@5

arc58_pluginOptInEscrow_bool_true@4:
    intc_1 // 1

arc58_pluginOptInEscrow_bool_merge@6:
    // smart_contracts/arc58/account/contract.algo.ts:1330-1335
    // assert(
    //   Txn.sender === Application(plugin).address ||
    //   Txn.sender === caller ||
    //   caller === Global.zeroAddress,
    //   ERR_FORBIDDEN
    // )
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/account/contract.algo.ts:1337-1344
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dupn 2
    gtxns Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1340
    // receiver: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1340
    // receiver: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1337-1344
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/arc58/account/contract.algo.ts:1341
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    dig 4
    *
    // smart_contracts/arc58/account/contract.algo.ts:1337-1344
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: this.controlledAddress.value,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // invalid payment
    // smart_contracts/arc58/account/contract.algo.ts:1346
    // this.optInEscrow(escrow, assets);
    dig 3
    dig 3
    callsub optInEscrow
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1317-1323
    // arc58_pluginOptInEscrow(
    //   plugin: uint64,
    //   caller: Account,
    //   escrow: string,
    //   assets: uint64[],
    //   mbrPayment: gtxn.PaymentTxn
    // ): void {
    intc_1 // 1
    return

arc58_pluginOptInEscrow_bool_false@5:
    intc_0 // 0
    b arc58_pluginOptInEscrow_bool_merge@6


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addAllowances[routing]() -> void:
arc58_addAllowances:
    intc_0 // 0
    dupn 4
    bytec_1 // ""
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1355
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 34 // 34
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint8,uint64,uint64,uint64,bool1)[])
    // smart_contracts/arc58/account/contract.algo.ts:1356
    // assert(this.isAdmin(), ERR_ADMIN_ONLY);
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1357
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1358
    // assert(!this.escrows(escrow).value.locked, ERR_ESCROW_LOCKED);
    box_get
    pop
    pushint 64 // 64
    getbit
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1360
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1360
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz arc58_addAllowances_after_if_else@4
    // smart_contracts/arc58/account/contract.algo.ts:1361-1367
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr(escrow) * allowances.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1363
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1363
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1364
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:209
    // return MinAllowanceMBR + (BoxCostPerByte * Bytes(escrow).length);
    dig 4
    len
    intc 4 // 400
    *
    intc 6 // 27700
    +
    // smart_contracts/arc58/account/contract.algo.ts:1365
    // amount: this.allowancesMbr(escrow) * allowances.length
    dig 3
    *
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:1361-1366
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr(escrow) * allowances.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1361-1367
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.allowancesMbr(escrow) * allowances.length
    //   })
    //   .submit()
    itxn_submit

arc58_addAllowances_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:1370
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    intc_0 // 0
    bury 5

arc58_addAllowances_while_top@5:
    // smart_contracts/arc58/account/contract.algo.ts:1370
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    dig 4
    dig 1
    <
    bz arc58_addAllowances_after_while@10
    // smart_contracts/arc58/account/contract.algo.ts:1371
    // const { asset, type, amount, max, interval, useRounds } = allowances[i];
    dig 1
    extract 2 0
    dig 5
    pushint 34 // 34
    *
    pushint 34 // 34
    extract3 // on error: index access is out of bounds
    dup
    extract 0 8
    dig 1
    extract 8 1
    bury 8
    dig 1
    extract 9 8
    bury 12
    dig 1
    extract 17 8
    bury 11
    dig 1
    extract 25 8
    bury 10
    swap
    pushint 264 // 264
    getbit
    dup
    cover 2
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1372
    // const key: AllowanceKey = { escrow, asset }
    dig 4
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 17 // 0x000a
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:169
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 18 // "a"
    swap
    concat
    dup
    bury 9
    // smart_contracts/arc58/account/contract.algo.ts:1373
    // assert(!this.allowances(key).exists, ERR_ALLOWANCE_ALREADY_EXISTS);
    box_len
    bury 1
    !
    assert // allowance already exists
    // smart_contracts/arc58/account/contract.algo.ts:1374
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    bz arc58_addAllowances_ternary_false@8
    global Round

arc58_addAllowances_ternary_merge@9:
    // smart_contracts/arc58/account/contract.algo.ts:1376-1385
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   amount,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    dig 6
    dig 10
    concat
    dig 11
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1378
    // spent: 0,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1376-1385
    // this.allowances(key).value = {
    //   type,
    //   spent: 0,
    //   amount,
    //   last: 0,
    //   max,
    //   interval,
    //   start,
    //   useRounds
    // }
    itob
    swap
    dig 1
    concat
    dig 10
    concat
    swap
    concat
    swap
    itob
    concat
    bytec 8 // 0x00
    intc_0 // 0
    dig 6
    setbit
    concat
    dig 7
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:1370
    // for (let i: uint64 = 0; i < allowances.length; i += 1) {
    dig 4
    intc_1 // 1
    +
    bury 5
    b arc58_addAllowances_while_top@5

arc58_addAllowances_ternary_false@8:
    // smart_contracts/arc58/account/contract.algo.ts:1374
    // const start = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b arc58_addAllowances_ternary_merge@9

arc58_addAllowances_after_while@10:
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1355
    // arc58_addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeAllowances[routing]() -> void:
arc58_removeAllowances:
    bytec_1 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1398
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/arc58/account/contract.algo.ts:1399
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    callsub isAdmin
    bnz arc58_removeAllowances_bool_true@3
    callsub canRevoke
    bz arc58_removeAllowances_bool_false@4

arc58_removeAllowances_bool_true@3:
    intc_1 // 1

arc58_removeAllowances_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1399
    // assert(this.isAdmin() || this.canRevoke(), ERR_ONLY_ADMIN_OR_REVOCATION_APP_CAN_REMOVE_METHOD_RESTRICTION);
    assert // Only an admin or revocation app can remove method restrictions
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    dig 3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1400
    // assert(this.escrows(escrow).exists, ERR_ESCROW_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // Escrow does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1401
    // assert(!this.escrows(escrow).value.locked, ERR_ESCROW_LOCKED);
    box_get
    pop
    pushint 64 // 64
    getbit
    !
    assert // Escrow is locked
    // smart_contracts/arc58/account/contract.algo.ts:1403
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1403
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz arc58_removeAllowances_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:1404-1409
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr(escrow) * assets.length
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1406
    // receiver: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1406
    // receiver: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:209
    // return MinAllowanceMBR + (BoxCostPerByte * Bytes(escrow).length);
    dig 3
    len
    intc 4 // 400
    *
    intc 6 // 27700
    +
    // smart_contracts/arc58/account/contract.algo.ts:1407
    // amount: this.allowancesMbr(escrow) * assets.length
    dig 2
    *
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:1404-1408
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr(escrow) * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:1404-1409
    // itxn
    //   .payment({
    //     receiver: this.controlledAddress.value,
    //     amount: this.allowancesMbr(escrow) * assets.length
    //   })
    //   .submit()
    itxn_submit

arc58_removeAllowances_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:1412
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0
    bury 4

arc58_removeAllowances_while_top@9:
    // smart_contracts/arc58/account/contract.algo.ts:1412
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    dig 3
    dig 1
    <
    bz arc58_removeAllowances_after_while@11
    // smart_contracts/arc58/account/contract.algo.ts:1415
    // asset: assets[i]
    dig 1
    extract 2 0
    dig 4
    dup
    cover 2
    intc_3 // 8
    *
    intc_3 // 8
    extract3 // on error: index access is out of bounds
    // smart_contracts/arc58/account/contract.algo.ts:1413-1416
    // const key: AllowanceKey = {
    //   escrow,
    //   asset: assets[i]
    // }
    dig 4
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 17 // 0x000a
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:169
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 18 // "a"
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1417
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:1418
    // this.allowances(key).delete()
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1412
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    bury 4
    b arc58_removeAllowances_while_top@9

arc58_removeAllowances_after_while@11:
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1398
    // arc58_removeAllowances(escrow: string, assets: uint64[]): void {
    intc_1 // 1
    return

arc58_removeAllowances_bool_false@4:
    intc_0 // 0
    b arc58_removeAllowances_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_addExecutionKey[routing]() -> void:
arc58_addExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1433
    // arc58_addExecutionKey(lease: bytes<32>, groups: bytes<32>[], firstValid: uint64, lastValid: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    pushint 32 // 32
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    cover 2
    // smart_contracts/arc58/account/contract.algo.ts:1434
    // assert(this.isAdmin(), ERR_ADMIN_ONLY)
    callsub isAdmin
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    swap
    concat
    dup
    cover 3
    // smart_contracts/arc58/account/contract.algo.ts:1435
    // if (!this.executions(lease).exists) {
    box_len
    bury 1
    bnz arc58_addExecutionKey_else_body@3
    // smart_contracts/arc58/account/contract.algo.ts:1436-1440
    // this.executions(lease).value = {
    //   groups: clone(groups),
    //   firstValid,
    //   lastValid
    // }
    dig 3
    itob
    pushbytes 0x0012
    swap
    concat
    uncover 2
    itob
    concat
    swap
    concat
    dig 1
    dup
    box_del
    pop
    swap
    box_put

arc58_addExecutionKey_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1433
    // arc58_addExecutionKey(lease: bytes<32>, groups: bytes<32>[], firstValid: uint64, lastValid: uint64): void {
    intc_1 // 1
    return

arc58_addExecutionKey_else_body@3:
    // smart_contracts/arc58/account/contract.algo.ts:1442
    // assert(this.executions(lease).value.firstValid === firstValid, ERR_EXECUTION_KEY_UPDATE_MUST_MATCH_FIRST_VALID)
    dig 2
    dup
    intc_2 // 2
    intc_3 // 8
    box_extract
    btoi
    dig 5
    ==
    assert // execution key update must match first valid
    // smart_contracts/arc58/account/contract.algo.ts:1443
    // assert(this.executions(lease).value.lastValid === lastValid, ERR_EXECUTION_KEY_UPDATE_MUST_MATCH_LAST_VALID)
    dup
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    uncover 3
    ==
    assert // execution key update must match last valid
    // smart_contracts/arc58/account/contract.algo.ts:1445
    // this.executions(lease).value.groups = [...clone(this.executions(lease).value.groups), ...clone(groups)]
    dup
    box_get
    pop
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    uncover 4
    extract 2 0
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    pushint 32 // 32
    /
    itob
    extract 6 2
    replace2 0
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    b arc58_addExecutionKey_after_if_else@4


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_removeExecutionKey[routing]() -> void:
arc58_removeExecutionKey:
    // smart_contracts/arc58/account/contract.algo.ts:1457
    // arc58_removeExecutionKey(lease: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:1458
    // assert(this.executions(lease).exists, ERR_EXECUTION_KEY_NOT_FOUND)
    box_len
    bury 1
    assert // Execution key not found
    // smart_contracts/arc58/account/contract.algo.ts:1459
    // assert(this.isAdmin() || this.executions(lease).value.lastValid < Global.round, ERR_ADMIN_ONLY)
    callsub isAdmin
    bnz arc58_removeExecutionKey_bool_true@3
    dup
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    global Round
    <
    bz arc58_removeExecutionKey_bool_false@4

arc58_removeExecutionKey_bool_true@3:
    intc_1 // 1

arc58_removeExecutionKey_bool_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:1459
    // assert(this.isAdmin() || this.executions(lease).value.lastValid < Global.round, ERR_ADMIN_ONLY)
    assert // admin only
    // smart_contracts/arc58/account/contract.algo.ts:1461
    // this.executions(lease).delete()
    dup
    box_del
    pop
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:144
    // lastChange = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastChange })
    bytec 6 // "last_change"
    // smart_contracts/arc58/account/contract.algo.ts:191
    // this.lastChange.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:1457
    // arc58_removeExecutionKey(lease: bytes<32>): void {
    intc_1 // 1
    return

arc58_removeExecutionKey_bool_false@4:
    intc_0 // 0
    b arc58_removeExecutionKey_bool_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAdmin[routing]() -> void:
arc58_getAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:1475
    // return this.admin.value
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:128
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 13 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:1475
    // return this.admin.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1473
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getPlugins[routing]() -> void:
arc58_getPlugins:
    intc_0 // 0
    bytec_1 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1484
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1486
    // let plugins: PluginInfo[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1487
    // for (let i: uint64 = 0; i < keys.length; i += 1) {
    intc_0 // 0

arc58_getPlugins_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1487
    // for (let i: uint64 = 0; i < keys.length; i += 1) {
    dig 2
    intc_0 // 0
    extract_uint16
    dup
    bury 5
    dig 1
    >
    bz arc58_getPlugins_after_while@7
    // smart_contracts/arc58/account/contract.algo.ts:1488
    // if (this.plugins(keys[i]).exists) {
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    bury 4
    dig 6
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    dup
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1488
    // if (this.plugins(keys[i]).exists) {
    box_len
    bury 1
    bz arc58_getPlugins_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:1489
    // plugins.push(this.plugins(keys[i]).value)
    dig 4
    box_get
    assert // Box must have value
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1490
    // continue
    b arc58_getPlugins_while_top@2

arc58_getPlugins_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1492
    // plugins.push(emptyPluginInfo())
    callsub emptyPluginInfo
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2
    b arc58_getPlugins_while_top@2

arc58_getPlugins_after_while@7:
    // smart_contracts/arc58/account/contract.algo.ts:1484
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getNamedPlugins[routing]() -> void:
arc58_getNamedPlugins:
    intc_0 // 0
    dup
    bytec_1 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1503
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1505
    // let plugins: PluginInfo[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1506
    // for (let i: uint64 = 0; i < names.length; i += 1) {
    intc_0 // 0

arc58_getNamedPlugins_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1506
    // for (let i: uint64 = 0; i < names.length; i += 1) {
    dig 2
    intc_0 // 0
    extract_uint16
    dig 1
    >
    dup
    bury 5
    bz arc58_getNamedPlugins_after_while@9
    // smart_contracts/arc58/account/contract.algo.ts:1507
    // if (this.namedPlugins(names[i]).exists) {
    dig 2
    extract 2 0
    dig 4
    assert // index access is out of bounds
    dig 1
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:165
    // namedPlugins = BoxMap<string, PluginKey>({ keyPrefix: AbstractAccountBoxPrefixNamedPlugins });
    bytec 15 // "n"
    swap
    concat
    dup
    bury 7
    // smart_contracts/arc58/account/contract.algo.ts:1507
    // if (this.namedPlugins(names[i]).exists) {
    box_len
    bury 1
    bz arc58_getNamedPlugins_after_if_else@7
    // smart_contracts/arc58/account/contract.algo.ts:1508
    // const nameKey = clone(this.namedPlugins(names[i]).value)
    dig 5
    box_get
    assert // Box must have value
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    dup
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1509
    // if (this.plugins(nameKey).exists) {
    box_len
    bury 1
    bz arc58_getNamedPlugins_after_if_else@6
    // smart_contracts/arc58/account/contract.algo.ts:1510
    // plugins.push(this.plugins(nameKey).value)
    dig 4
    box_get
    assert // Box must have value
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2

arc58_getNamedPlugins_block@8:
    // smart_contracts/arc58/account/contract.algo.ts:1506
    // for (let i: uint64 = 0; i < names.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b arc58_getNamedPlugins_while_top@2

arc58_getNamedPlugins_after_if_else@6:
    // smart_contracts/arc58/account/contract.algo.ts:1513
    // plugins.push(emptyPluginInfo())
    callsub emptyPluginInfo
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1514
    // continue
    b arc58_getNamedPlugins_block@8

arc58_getNamedPlugins_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1516
    // plugins.push(emptyPluginInfo())
    callsub emptyPluginInfo
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2
    b arc58_getNamedPlugins_block@8

arc58_getNamedPlugins_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:1503
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getEscrows[routing]() -> void:
arc58_getEscrows:
    intc_0 // 0
    bytec_1 // ""
    // smart_contracts/arc58/account/contract.algo.ts:1527
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // smart_contracts/arc58/account/contract.algo.ts:1529
    // let result: EscrowInfo[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1530
    // for (let i: uint64 = 0; i < escrows.length; i += 1) {
    intc_0 // 0

arc58_getEscrows_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1530
    // for (let i: uint64 = 0; i < escrows.length; i += 1) {
    dig 2
    intc_0 // 0
    extract_uint16
    dig 1
    >
    dup
    bury 5
    bz arc58_getEscrows_after_while@7
    // smart_contracts/arc58/account/contract.algo.ts:1531
    // if (this.escrows(escrows[i]).exists) {
    dig 2
    extract 2 0
    dig 4
    assert // index access is out of bounds
    dig 1
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    swap
    concat
    dup
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1531
    // if (this.escrows(escrows[i]).exists) {
    box_len
    bury 1
    bz arc58_getEscrows_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:1532
    // result.push(this.escrows(escrows[i]).value)
    dig 4
    box_get
    assert // Box must have value
    dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2

arc58_getEscrows_block@6:
    // smart_contracts/arc58/account/contract.algo.ts:1530
    // for (let i: uint64 = 0; i < escrows.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b arc58_getEscrows_while_top@2

arc58_getEscrows_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1535
    // result.push(emptyEscrowInfo())
    dig 1
    dup
    // smart_contracts/arc58/account/utils.ts:22-25
    // return {
    //   id: 0,
    //   locked: false
    // };
    pushbytes 0x000000000000000000
    // smart_contracts/arc58/account/contract.algo.ts:1535
    // result.push(emptyEscrowInfo())
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2
    b arc58_getEscrows_block@6

arc58_getEscrows_after_while@7:
    // smart_contracts/arc58/account/contract.algo.ts:1527
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getAllowances[routing]() -> void:
arc58_getAllowances:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1547
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    // smart_contracts/arc58/account/contract.algo.ts:1549
    // let result: AllowanceInfo[] = []
    intc_0 // 0
    itob
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1550
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

arc58_getAllowances_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1550
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    dup
    dig 4
    <
    bz arc58_getAllowances_after_while@7
    // smart_contracts/arc58/account/contract.algo.ts:1551
    // const key: AllowanceKey = { escrow, asset: assets[i] }
    dig 4
    extract 2 0
    dig 1
    intc_3 // 8
    *
    intc_3 // 8
    extract3 // on error: index access is out of bounds
    dig 6
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 17 // 0x000a
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:169
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 18 // "a"
    swap
    concat
    dup
    bury 8
    // smart_contracts/arc58/account/contract.algo.ts:1552
    // if (this.allowances(key).exists) {
    box_len
    bury 1
    bz arc58_getAllowances_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:1553
    // result.push(this.allowances(key).value)
    dig 6
    box_get
    assert // Box must have value
    dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2

arc58_getAllowances_block@6:
    // smart_contracts/arc58/account/contract.algo.ts:1550
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b arc58_getAllowances_while_top@2

arc58_getAllowances_after_if_else@5:
    // smart_contracts/arc58/account/utils.ts:30
    // type: uint8(0),
    intc_0 // 0
    callsub uint8
    // smart_contracts/arc58/account/utils.ts:29-38
    // return {
    //   type: uint8(0),
    //   max: 0,
    //   amount: 0,
    //   spent: 0,
    //   interval: 0,
    //   last: 0,
    //   start: 0,
    //   useRounds: false
    // };
    dig 3
    dup
    cover 2
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    bytec 8 // 0x00
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1556
    // result.push(emptyAllowanceInfo())
    dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2
    b arc58_getAllowances_block@6

arc58_getAllowances_after_while@7:
    // smart_contracts/arc58/account/contract.algo.ts:1547
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getExecutions[routing]() -> void:
arc58_getExecutions:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1567
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 32 // 32
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/arc58/account/contract.algo.ts:1569
    // let result: ExecutionInfo[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1570
    // for (let i: uint64 = 0; i < leases.length; i += 1) {
    intc_0 // 0

arc58_getExecutions_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1570
    // for (let i: uint64 = 0; i < leases.length; i += 1) {
    dup
    dig 3
    <
    bz arc58_getExecutions_after_while@7
    // smart_contracts/arc58/account/contract.algo.ts:1571
    // if (this.executions(leases[i]).exists) {
    dig 3
    extract 2 0
    dig 1
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    swap
    concat
    dup
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1571
    // if (this.executions(leases[i]).exists) {
    box_len
    bury 1
    bz arc58_getExecutions_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:1572
    // result.push(this.executions(leases[i]).value)
    dig 4
    box_get
    assert // Box must have value
    dig 2
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 12 // 0x0002
    uncover 3
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 2

arc58_getExecutions_block@6:
    // smart_contracts/arc58/account/contract.algo.ts:1570
    // for (let i: uint64 = 0; i < leases.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b arc58_getExecutions_while_top@2

arc58_getExecutions_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1575
    // result.push(emptyExecutionInfo())
    dig 1
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    intc_1 // 1
    pushbytes 0x00020012000000000000000000000000000000000000
    callsub dynamic_array_concat_dynamic_element
    bury 2
    b arc58_getExecutions_block@6

arc58_getExecutions_after_while@7:
    // smart_contracts/arc58/account/contract.algo.ts:1567
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_getDomainKeys[routing]() -> void:
arc58_getDomainKeys:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:1586
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 32 // 32
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/arc58/account/contract.algo.ts:1588
    // let result: string[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1589
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    intc_0 // 0

arc58_getDomainKeys_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:1589
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    dup
    dig 3
    <
    bz arc58_getDomainKeys_after_while@7
    // smart_contracts/arc58/account/contract.algo.ts:1590
    // if (this.domainKeys(addresses[i]).exists) {
    dig 3
    extract 2 0
    dig 1
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 16 // "d"
    swap
    concat
    dup
    bury 6
    // smart_contracts/arc58/account/contract.algo.ts:1590
    // if (this.domainKeys(addresses[i]).exists) {
    box_len
    bury 1
    bz arc58_getDomainKeys_after_if_else@5
    // smart_contracts/arc58/account/contract.algo.ts:1591
    // result.push(this.domainKeys(addresses[i]).value)
    dig 4
    box_get
    assert // Box must have value
    dup
    len
    itob
    extract 6 2
    swap
    concat
    dig 2
    swap
    intc_1 // 1
    callsub dynamic_array_concat_byte_length_head
    bury 2

arc58_getDomainKeys_block@6:
    // smart_contracts/arc58/account/contract.algo.ts:1589
    // for (let i: uint64 = 0; i < addresses.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b arc58_getDomainKeys_while_top@2

arc58_getDomainKeys_after_if_else@5:
    // smart_contracts/arc58/account/contract.algo.ts:1594
    // result.push("")
    dig 1
    bytec 7 // 0x0000
    intc_1 // 1
    callsub dynamic_array_concat_byte_length_head
    bury 2
    b arc58_getDomainKeys_block@6

arc58_getDomainKeys_after_while@7:
    // smart_contracts/arc58/account/contract.algo.ts:1586
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.mbr[routing]() -> void:
mbr:
    // smart_contracts/arc58/account/contract.algo.ts:1608
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:205
    // return MinEscrowsMBR + (BoxCostPerByte * Bytes(escrow).length);
    dig 3
    len
    intc 4 // 400
    *
    pushint 6500 // 6500
    dig 1
    +
    // smart_contracts/arc58/account/contract.algo.ts:1618
    // plugins: this.pluginsMbr(escrow, methodCount),
    dig 5
    uncover 5
    callsub pluginsMbr
    // smart_contracts/arc58/account/contract.algo.ts:201
    // return MinNamedPluginMBR + (BoxCostPerByte * Bytes(name).length);
    uncover 4
    len
    intc 4 // 400
    *
    intc 5 // 18900
    dig 1
    +
    // smart_contracts/arc58/account/contract.algo.ts:209
    // return MinAllowanceMBR + (BoxCostPerByte * Bytes(escrow).length);
    intc 6 // 27700
    uncover 5
    +
    // smart_contracts/arc58/account/contract.algo.ts:217
    // return MinDomainKeysMBR + (BoxCostPerByte * Bytes(domain).length)
    pushint 15700 // 15700
    uncover 3
    +
    // smart_contracts/arc58/account/contract.algo.ts:213
    // return MinExecutionsMBR + (BoxCostPerByte * (groups * 32));
    uncover 5
    pushint 12800 // 12800
    *
    pushint 20500 // 20500
    +
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    uncover 7
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1624
    // escrowExists: this.escrows(escrow).exists,
    box_len
    cover 6
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1627
    // Global.minBalance +
    global MinBalance
    // smart_contracts/arc58/account/contract.algo.ts:1626-1628
    // NewCostForARC58 +
    // Global.minBalance +
    // ARC58WalletIDsByAccountsMbr +
    pushint 162100 // 162100
    +
    // smart_contracts/arc58/account/contract.algo.ts:1626-1629
    // NewCostForARC58 +
    // Global.minBalance +
    // ARC58WalletIDsByAccountsMbr +
    // escrows
    dig 7
    +
    // smart_contracts/arc58/account/contract.algo.ts:1617-1631
    // return {
    //   plugins: this.pluginsMbr(escrow, methodCount),
    //   namedPlugins: this.namedPluginsMbr(plugin),
    //   escrows,
    //   allowances: this.allowancesMbr(escrow),
    //   domainKeys: this.domainKeysMbr(plugin),
    //   executions: this.executionsMbr(groups),
    //   escrowExists: this.escrows(escrow).exists,
    //   newEscrowMintCost: (
    //     NewCostForARC58 +
    //     Global.minBalance +
    //     ARC58WalletIDsByAccountsMbr +
    //     escrows
    //   )
    // }
    uncover 5
    itob
    uncover 5
    itob
    concat
    uncover 6
    itob
    concat
    uncover 4
    itob
    concat
    uncover 2
    itob
    concat
    uncover 2
    itob
    concat
    bytec 8 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    concat
    swap
    itob
    concat
    // smart_contracts/arc58/account/contract.algo.ts:1608
    // @abimethod({ readonly: true })
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance[routing]() -> void:
balance:
    // smart_contracts/arc58/account/contract.algo.ts:1640
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    callsub smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance
    pop
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginsMbr(escrow: bytes, methodCount: uint64) -> uint64:
pluginsMbr:
    // smart_contracts/arc58/account/contract.algo.ts:194
    // private pluginsMbr(escrow: string, methodCount: uint64): uint64 {
    proto 2 1
    // smart_contracts/arc58/account/contract.algo.ts:196
    // BoxCostPerByte * ((MethodRestrictionByteLength * methodCount) + Bytes(escrow).length)
    pushint 20 // 20
    frame_dig -1
    *
    frame_dig -2
    len
    +
    intc 4 // 400
    *
    // smart_contracts/arc58/account/contract.algo.ts:195
    // return MinPluginMBR + (
    pushint 38900 // 38900
    // smart_contracts/arc58/account/contract.algo.ts:195-197
    // return MinPluginMBR + (
    //   BoxCostPerByte * ((MethodRestrictionByteLength * methodCount) + Bytes(escrow).length)
    // );
    +
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.maybeNewEscrow(escrow: bytes) -> uint64:
maybeNewEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:220
    // private maybeNewEscrow(escrow: string): uint64 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:221
    // if (escrow === '') {
    frame_dig -1
    bytec_1 // ""
    ==
    bz maybeNewEscrow_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:222
    // return 0
    intc_0 // 0
    swap
    retsub

maybeNewEscrow_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/account/contract.algo.ts:225
    // return this.escrows(escrow).exists
    box_len
    bury 1
    // smart_contracts/arc58/account/contract.algo.ts:225-227
    // return this.escrows(escrow).exists
    //   ? this.escrows(escrow).value.id
    //   : this.newEscrow(escrow)
    bz maybeNewEscrow_ternary_false@4
    // smart_contracts/arc58/account/contract.algo.ts:226
    // ? this.escrows(escrow).value.id
    frame_dig 0
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64

maybeNewEscrow_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:225-227
    // return this.escrows(escrow).exists
    //   ? this.escrows(escrow).value.id
    //   : this.newEscrow(escrow)
    swap
    retsub

maybeNewEscrow_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:227
    // : this.newEscrow(escrow)
    frame_dig -1
    callsub newEscrow
    b maybeNewEscrow_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.newEscrow(escrow: bytes) -> uint64:
newEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:230
    // private newEscrow(escrow: string): uint64 {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:231
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:231
    // if (this.controlledAddress.value !== Global.currentApplicationAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationAddress
    !=
    bz newEscrow_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:232-238
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.escrowsMbr(escrow)
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:234
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:234
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:235
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/account/contract.algo.ts:205
    // return MinEscrowsMBR + (BoxCostPerByte * Bytes(escrow).length);
    frame_dig -1
    len
    intc 4 // 400
    *
    pushint 6500 // 6500
    +
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:232-237
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.escrowsMbr(escrow)
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:232-238
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.escrowsMbr(escrow)
    //   })
    //   .submit()
    itxn_submit

newEscrow_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:241-251
    // const id = abiCall<typeof EscrowFactory.prototype.new>({
    //   sender: this.controlledAddress.value,
    //   appId: this.escrowFactory.value,
    //   args: [
    //     itxn.payment({
    //       sender: this.controlledAddress.value,
    //       amount: NewCostForARC58 + Global.minBalance,
    //       receiver: this.escrowFactory.value.address
    //     }),
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:246
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:246
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:247
    // amount: NewCostForARC58 + Global.minBalance,
    pushint 150000 // 150000
    global MinBalance
    +
    // smart_contracts/arc58/account/contract.algo.ts:248
    // receiver: this.escrowFactory.value.address
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:152
    // escrowFactory = GlobalState<Application>({ key: AbstractAccountGlobalStateKeysEscrowFactory })
    bytec 22 // "escrow_factory"
    // smart_contracts/arc58/account/contract.algo.ts:248
    // receiver: this.escrowFactory.value.address
    app_global_get_ex
    assert // check GlobalState exists
    dup
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    swap
    itxn_field Amount
    dig 1
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:245-249
    // itxn.payment({
    //   sender: this.controlledAddress.value,
    //   amount: NewCostForARC58 + Global.minBalance,
    //   receiver: this.escrowFactory.value.address
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:241-251
    // const id = abiCall<typeof EscrowFactory.prototype.new>({
    //   sender: this.controlledAddress.value,
    //   appId: this.escrowFactory.value,
    //   args: [
    //     itxn.payment({
    //       sender: this.controlledAddress.value,
    //       amount: NewCostForARC58 + Global.minBalance,
    //       receiver: this.escrowFactory.value.address
    //     }),
    //   ]
    // }).returnValue
    itxn_next
    pushbytes 0xd85cf184 // method "new(pay)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field Sender
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/account/contract.algo.ts:253
    // this.escrows(escrow).value = { id, locked: false }
    dup
    itob
    bytec 8 // 0x00
    concat
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:253
    // this.escrows(escrow).value = { id, locked: false }
    swap
    box_put
    // smart_contracts/arc58/account/contract.algo.ts:255
    // return id;
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.isAdmin() -> uint64:
isAdmin:
    // smart_contracts/arc58/account/contract.algo.ts:261
    // Txn.sender === this.admin.value ||
    txn Sender
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:128
    // admin = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysAdmin })
    bytec 13 // "admin"
    // smart_contracts/arc58/account/contract.algo.ts:261
    // Txn.sender === this.admin.value ||
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:261-262
    // Txn.sender === this.admin.value ||
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    bnz isAdmin_bool_true@3
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 16 // "d"
    // smart_contracts/arc58/account/contract.algo.ts:262
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:262
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    box_len
    bury 1
    bz isAdmin_bool_false@4
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    bytec 16 // "d"
    // smart_contracts/arc58/account/contract.algo.ts:262
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:182
    // domainKeys = BoxMap<Account, string>({ keyPrefix: AbstractAccountBoxPrefixDomainKeys })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:262
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    box_get
    assert // Box must have value
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:130
    // domain = GlobalState<string>({ key: AbstractAccountGlobalStateKeysDomain });
    bytec 21 // "domain"
    // smart_contracts/arc58/account/contract.algo.ts:262
    // (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz isAdmin_bool_false@4

isAdmin_bool_true@3:
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:260-263
    // return (
    //   Txn.sender === this.admin.value ||
    //   (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    // )
    retsub

isAdmin_bool_false@4:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:260-263
    // return (
    //   Txn.sender === this.admin.value ||
    //   (this.domainKeys(Txn.sender).exists && this.domainKeys(Txn.sender).value === this.domain.value)
    // )
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.canRevoke() -> uint64:
canRevoke:
    // smart_contracts/arc58/account/contract.algo.ts:268
    // return Txn.sender === this.revocation.value.address
    txn Sender
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:156
    // revocation = GlobalState<Application>({ key: GlobalStateKeyRevocation })
    bytec 23 // "revocation"
    // smart_contracts/arc58/account/contract.algo.ts:268
    // return Txn.sender === this.revocation.value.address
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCallAllowed(plugin: uint64, caller: bytes, escrow: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/arc58/account/contract.algo.ts:271
    // private pluginCallAllowed(plugin: uint64, caller: Account, escrow: string, method: bytes<4>): boolean {
    proto 4 1
    bytec_1 // ""
    dupn 5
    // smart_contracts/arc58/account/contract.algo.ts:272
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -4
    itob
    frame_dig -3
    concat
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:274
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:275
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:278
    // const { methods, useRounds, lastCalled, cooldown, useExecutionKey } = this.plugins(key).value as Readonly<PluginInfo>
    frame_dig 6
    dup
    pushint 17 // 17
    intc_3 // 8
    box_extract
    btoi
    frame_bury 0
    dup
    pushint 27 // 27
    intc_1 // 1
    box_extract
    dup
    intc_1 // 1
    getbit
    frame_bury 5
    intc_2 // 2
    getbit
    swap
    pushint 28 // 28
    intc_3 // 8
    box_extract
    btoi
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:280
    // if (useExecutionKey) {
    bz pluginCallAllowed_after_if_else@4
    // smart_contracts/arc58/account/contract.algo.ts:281
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@4:
    // smart_contracts/arc58/account/contract.algo.ts:284
    // let methodAllowed = methods.length > 0 ? false : true;
    frame_dig 6
    pushint 44 // 44
    intc_2 // 2
    box_extract
    btoi
    !
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:285
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@5:
    // smart_contracts/arc58/account/contract.algo.ts:285
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 6
    pushint 44 // 44
    intc_2 // 2
    box_extract
    btoi
    frame_dig 2
    >
    bz pluginCallAllowed_block@10
    // smart_contracts/arc58/account/contract.algo.ts:286
    // if (methods[i].selector === method) {
    frame_dig 2
    pushint 20 // 20
    *
    pushint 46 // 46
    +
    frame_dig 6
    swap
    pushint 20 // 20
    box_extract
    extract 0 4
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:287
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 4

pluginCallAllowed_block@10:
    // smart_contracts/arc58/account/contract.algo.ts:292
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 5
    bz pluginCallAllowed_ternary_false@12
    global Round
    frame_bury 1

pluginCallAllowed_ternary_merge@13:
    // smart_contracts/arc58/account/contract.algo.ts:295
    // lastCalled >= epochRef &&
    frame_dig 3
    frame_dig 1
    >=
    // smart_contracts/arc58/account/contract.algo.ts:295-296
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    // smart_contracts/arc58/account/contract.algo.ts:296
    // (epochRef - lastCalled) >= cooldown &&
    frame_dig 1
    frame_dig 3
    -
    frame_dig 0
    >=
    // smart_contracts/arc58/account/contract.algo.ts:295-296
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    bz pluginCallAllowed_bool_false@16
    intc_1 // 1

pluginCallAllowed_bool_merge@17:
    // smart_contracts/arc58/account/contract.algo.ts:295-297
    // lastCalled >= epochRef &&
    // (epochRef - lastCalled) >= cooldown &&
    // methodAllowed
    frame_dig 4
    &&
    // smart_contracts/arc58/account/contract.algo.ts:294-298
    // return (
    //   lastCalled >= epochRef &&
    //   (epochRef - lastCalled) >= cooldown &&
    //   methodAllowed
    // )
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@16:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@17

pluginCallAllowed_ternary_false@12:
    // smart_contracts/arc58/account/contract.algo.ts:292
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 1
    b pluginCallAllowed_ternary_merge@13

pluginCallAllowed_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:285
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // smart_contracts/arc58/account/contract.algo.ts:301
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1
    // smart_contracts/arc58/account/contract.algo.ts:304
    // txn.sender === this.controlledAddress.value &&
    frame_dig -1
    gtxns Sender
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:304
    // txn.sender === this.controlledAddress.value &&
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // smart_contracts/arc58/account/contract.algo.ts:304-305
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:305
    // txn.rekeyTo === Global.currentApplicationAddress
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    // smart_contracts/arc58/account/contract.algo.ts:304-305
    // txn.sender === this.controlledAddress.value &&
    // txn.rekeyTo === Global.currentApplicationAddress
    bz txnRekeysBack_after_if_else@3
    // smart_contracts/arc58/account/contract.algo.ts:307
    // return true;
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // smart_contracts/arc58/account/contract.algo.ts:311
    // txn.type === TransactionType.ApplicationCall
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // smart_contracts/arc58/account/contract.algo.ts:311-312
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:312
    // && txn.appId === Global.currentApplicationId
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/arc58/account/contract.algo.ts:311-312
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:313
    // && txn.numAppArgs === 1
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // smart_contracts/arc58/account/contract.algo.ts:311-313
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:314
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig -1
    gtxns OnCompletion
    // smart_contracts/arc58/account/contract.algo.ts:311-314
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bnz txnRekeysBack_bool_false@9
    // smart_contracts/arc58/account/contract.algo.ts:315
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddress()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 26 // method "arc58_verifyAuthAddress()void"
    ==
    // smart_contracts/arc58/account/contract.algo.ts:311-315
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddress()void')
    bz txnRekeysBack_bool_false@9
    intc_1 // 1
    // smart_contracts/arc58/account/contract.algo.ts:310-316
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddress()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:310-316
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddress()void')
    // )
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> bytes, bytes:
pluginCheck:
    // smart_contracts/arc58/account/contract.algo.ts:333
    // private pluginCheck(key: PluginKey): PluginValidation {
    proto 1 2
    bytec_1 // ""
    dupn 2
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig -1
    concat
    dup
    // smart_contracts/arc58/account/contract.algo.ts:335
    // const exists = this.plugins(key).exists;
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/arc58/account/contract.algo.ts:336
    // if (!exists) {
    bnz pluginCheck_after_if_else@2
    // smart_contracts/arc58/account/contract.algo.ts:337-342
    // return {
    //   exists: false,
    //   expired: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    // }
    pushbytes 0x60
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_after_if_else@2:
    // smart_contracts/arc58/account/contract.algo.ts:345
    // const { useRounds, lastValid, cooldown, lastCalled, methods } = this.plugins(key).value as Readonly<PluginInfo>
    frame_dig 3
    dup
    pushint 9 // 9
    intc_3 // 8
    box_extract
    btoi
    frame_bury 2
    dup
    pushint 17 // 17
    intc_3 // 8
    box_extract
    btoi
    frame_bury 0
    dup
    pushint 27 // 27
    intc_1 // 1
    box_extract
    intc_1 // 1
    getbit
    swap
    pushint 28 // 28
    intc_3 // 8
    box_extract
    btoi
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:346
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    bz pluginCheck_ternary_false@4
    global Round

pluginCheck_ternary_merge@5:
    // smart_contracts/arc58/account/contract.algo.ts:350
    // expired: epochRef > lastValid,
    dup
    frame_dig 2
    >
    // smart_contracts/arc58/account/contract.algo.ts:351
    // onCooldown: (epochRef - lastCalled) < cooldown,
    swap
    frame_dig 1
    -
    frame_dig 0
    <
    // smart_contracts/arc58/account/contract.algo.ts:352
    // hasMethodRestrictions: methods.length > 0,
    frame_dig 3
    pushint 44 // 44
    intc_2 // 2
    box_extract
    btoi
    intc_0 // 0
    >
    // smart_contracts/arc58/account/contract.algo.ts:348-353
    // return {
    //   exists,
    //   expired: epochRef > lastValid,
    //   onCooldown: (epochRef - lastCalled) < cooldown,
    //   hasMethodRestrictions: methods.length > 0,
    // }
    bytec 8 // 0x00
    intc_0 // 0
    frame_dig 4
    setbit
    intc_1 // 1
    uncover 4
    setbit
    intc_2 // 2
    uncover 3
    setbit
    pushint 3 // 3
    uncover 2
    setbit
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

pluginCheck_ternary_false@4:
    // smart_contracts/arc58/account/contract.algo.ts:346
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b pluginCheck_ternary_merge@5


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.optInEscrow(escrow: bytes, assets: bytes) -> bytes:
optInEscrow:
    // smart_contracts/arc58/account/contract.algo.ts:474
    // private optInEscrow(escrow: string, assets: uint64[]): void {
    proto 2 1
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:475
    // const escrowAddress = Application(this.escrows(escrow).value.id).address
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    app_params_get AppAddress
    swap
    dup
    uncover 2
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:477-483
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:479
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:479
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:481
    // amount: Global.assetOptInMinBalance * assets.length
    global AssetOptInMinBalance
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    cover 4
    *
    itxn_field Amount
    itxn_field Sender
    itxn_field Receiver
    // smart_contracts/arc58/account/contract.algo.ts:477-482
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:477-483
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: Global.assetOptInMinBalance * assets.length
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:485
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

optInEscrow_while_top@2:
    // smart_contracts/arc58/account/contract.algo.ts:485
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 2
    frame_dig 1
    <
    bz optInEscrow_after_while@5
    // smart_contracts/arc58/account/contract.algo.ts:486-493
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:491
    // xferAsset: assets[i]
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    itxn_field XferAsset
    // smart_contracts/arc58/account/contract.algo.ts:490
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    frame_dig 0
    dup
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:486-492
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:486-493
    // itxn
    //   .assetTransfer({
    //     sender: escrowAddress,
    //     assetReceiver: escrowAddress,
    //     assetAmount: 0,
    //     xferAsset: assets[i]
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/arc58/account/contract.algo.ts:485
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 2
    b optInEscrow_while_top@2

optInEscrow_after_while@5:
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.reclaim(escrow: bytes, reclaims: bytes, allowCloseOut: uint64) -> bytes:
reclaim:
    // smart_contracts/arc58/account/contract.algo.ts:497
    // private reclaim(escrow: string, reclaims: EscrowReclaim[], allowCloseOut: boolean): void {
    proto 3 1
    intc_0 // 0
    dup
    bytec_1 // ""
    dupn 2
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:498
    // const sender = Application(this.escrows(escrow).value.id).address
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:500
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    intc_0 // 0

reclaim_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:500
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig 7
    >
    bz reclaim_after_while@13
    // smart_contracts/arc58/account/contract.algo.ts:501
    // if (reclaims[i].asset === 0) {
    frame_dig -2
    extract 2 0
    frame_dig 7
    pushint 17 // 17
    *
    pushint 17 // 17
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 2
    bnz reclaim_else_body@5
    // smart_contracts/arc58/account/contract.algo.ts:502-506
    // itxn.payment({
    //   sender,
    //   receiver: this.controlledAddress.value,
    //   amount: reclaims[i].amount
    // }).submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:504
    // receiver: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:504
    // receiver: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:505
    // amount: reclaims[i].amount
    frame_dig 0
    intc_3 // 8
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    frame_dig 6
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:502-506
    // itxn.payment({
    //   sender,
    //   receiver: this.controlledAddress.value,
    //   amount: reclaims[i].amount
    // }).submit();
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

reclaim_after_if_else@12:
    // smart_contracts/arc58/account/contract.algo.ts:500
    // for (let i: uint64 = 0; i < reclaims.length; i += 1) {
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    b reclaim_while_top@1

reclaim_else_body@5:
    // smart_contracts/arc58/account/contract.algo.ts:510
    // assetReceiver: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:510
    // assetReceiver: this.controlledAddress.value,
    app_global_get_ex
    swap
    frame_bury 1
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:511
    // assetAmount: reclaims[i].amount,
    frame_dig 0
    intc_3 // 8
    extract_uint64
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:508
    // const xfer = itxn.assetTransfer({
    intc_0 // 0
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:515
    // if (allowCloseOut && reclaims[i].closeOut) {
    frame_dig -1
    bz reclaim_after_if_else@8
    frame_dig 0
    pushint 128 // 128
    getbit
    bz reclaim_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:516
    // xfer.set({ assetCloseTo: this.controlledAddress.value });
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:516
    // xfer.set({ assetCloseTo: this.controlledAddress.value });
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    frame_bury 4
    frame_bury 5

reclaim_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:519
    // xfer.submit();
    itxn_begin
    frame_dig 4
    bz reclaim_next_field@10
    frame_dig 5
    itxn_field AssetCloseTo

reclaim_next_field@10:
    frame_dig 2
    itxn_field XferAsset
    frame_dig 3
    itxn_field AssetAmount
    frame_dig 1
    itxn_field AssetReceiver
    frame_dig 6
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:508-513
    // const xfer = itxn.assetTransfer({
    //   sender,
    //   assetReceiver: this.controlledAddress.value,
    //   assetAmount: reclaims[i].amount,
    //   xferAsset: reclaims[i].asset
    // })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:519
    // xfer.submit();
    itxn_submit
    b reclaim_after_if_else@12

reclaim_after_while@13:
    frame_dig -2
    frame_bury 0
    retsub


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, global: uint64, escrow: bytes, methodOffsets: bytes, fundsRequest: bytes) -> bytes, bytes:
smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin:
    // smart_contracts/arc58/account/contract.algo.ts:877-883
    // arc58_rekeyToPlugin(
    //   plugin: uint64,
    //   global: boolean,
    //   escrow: string,
    //   methodOffsets: uint64[],
    //   fundsRequest: FundsRequest[]
    // ): void {
    proto 5 2
    intc_0 // 0
    dupn 11
    bytec_1 // ""
    dupn 20
    // smart_contracts/arc58/account/contract.algo.ts:885
    // const caller = global ? Global.zeroAddress : Txn.sender
    frame_dig -4
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@2
    global ZeroAddress

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@3:
    // smart_contracts/arc58/account/contract.algo.ts:886
    // const key: PluginKey = { plugin, caller, escrow }
    frame_dig -5
    itob
    swap
    concat
    frame_dig -3
    len
    itob
    extract 6 2
    frame_dig -3
    concat
    dup
    frame_bury 1
    swap
    bytec 11 // 0x002a
    concat
    swap
    concat
    dup
    frame_bury 7
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    dig 1
    concat
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:888
    // assert(this.plugins(key).exists, ERR_PLUGIN_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:148
    // currentPlugin = GlobalState<PluginKey>({ key: AbstractAccountGlobalStateKeysCurrentPlugin })
    bytec 25 // "current_plugin"
    // smart_contracts/arc58/account/contract.algo.ts:889
    // this.currentPlugin.value = clone(key)
    uncover 2
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:890
    // const { escrow: escrowID } = this.plugins(key).value
    intc_0 // 0
    intc_3 // 8
    box_extract
    btoi
    dup
    frame_bury 16
    // smart_contracts/arc58/account/contract.algo.ts:892
    // if (escrowID !== 0) {
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@7
    // smart_contracts/arc58/account/contract.algo.ts:894
    // this.spendingAddress.value = spendingApp.address
    frame_dig 16
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:894
    // this.spendingAddress.value = spendingApp.address
    swap
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:167
    // escrows = BoxMap<string, EscrowInfo>({ keyPrefix: AbstractAccountBoxPrefixEscrows })
    bytec_2 // "e"
    frame_dig -3
    concat
    // smart_contracts/arc58/account/contract.algo.ts:525
    // const escrowID = this.escrows(escrow).value.id;
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:526
    // const escrowAddress = Application(escrowID).address;
    app_params_get AppAddress
    swap
    frame_bury 6
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:528
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    intc_0 // 0
    frame_bury 18

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@63:
    // smart_contracts/arc58/account/contract.algo.ts:528
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 18
    >
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@8
    // smart_contracts/arc58/account/contract.algo.ts:532
    // asset: fundsRequests[i].asset
    frame_dig -1
    extract 2 0
    frame_dig 18
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 32
    // smart_contracts/arc58/account/contract.algo.ts:530-533
    // const allowanceKey: AllowanceKey = {
    //   escrow,
    //   asset: fundsRequests[i].asset
    // }
    itob
    bytec 17 // 0x000a
    swap
    concat
    frame_dig 1
    concat
    // smart_contracts/arc58/account/contract.algo.ts:169
    // allowances = BoxMap<AllowanceKey, AllowanceInfo>({ keyPrefix: AbstractAccountBoxPrefixAllowances }) // 38_500
    bytec 18 // "a"
    swap
    concat
    dup
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:559
    // assert(this.allowances(key).exists, ERR_ALLOWANCE_DOES_NOT_EXIST);
    dup
    box_len
    bury 1
    assert // allowance does not exist
    // smart_contracts/arc58/account/contract.algo.ts:560
    // const { type, spent, amount, last, max, interval, start, useRounds } = this.allowances(key).value
    box_get
    pop
    dup
    extract 0 1
    frame_bury 11
    dup
    pushint 17 // 17
    extract_uint64
    frame_bury 29
    dup
    pushint 9 // 9
    extract_uint64
    frame_bury 12
    dup
    pushint 33 // 33
    extract_uint64
    frame_bury 21
    dup
    intc_1 // 1
    extract_uint64
    frame_bury 23
    dup
    pushint 25 // 25
    extract_uint64
    frame_bury 19
    dup
    pushint 41 // 41
    extract_uint64
    frame_bury 30
    pushint 392 // 392
    getbit
    dup
    frame_bury 31
    // smart_contracts/arc58/account/contract.algo.ts:561
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@66
    global Round
    frame_bury 27

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@67:
    // smart_contracts/arc58/account/contract.algo.ts:563
    // if (type === SpendAllowanceTypeFlat) {
    frame_dig 11
    bytec 14 // 0x01
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@69
    // smart_contracts/arc58/account/contract.algo.ts:564
    // const leftover: uint64 = amount - spent;
    frame_dig 12
    frame_dig 29
    -
    // smart_contracts/arc58/account/contract.algo.ts:565
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_3 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:566
    // this.allowances(key).value.spent += fundRequest.amount
    frame_dig 3
    dup
    cover 2
    box_get
    assert // Box must have value
    pushint 17 // 17
    extract_uint64
    +
    itob
    pushint 17 // 17
    swap
    box_replace

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@78:
    // smart_contracts/arc58/account/contract.algo.ts:591
    // this.allowances(key).value.last = newLast
    frame_dig 27
    itob
    frame_dig 3
    pushint 33 // 33
    uncover 2
    box_replace
    // smart_contracts/arc58/account/contract.algo.ts:537
    // if (fundsRequests[i].asset !== 0) {
    frame_dig 32
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@80
    // smart_contracts/arc58/account/contract.algo.ts:538-545
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: escrowAddress,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:540
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:540
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:542
    // assetAmount: fundsRequests[i].amount,
    frame_dig 0
    intc_3 // 8
    extract_uint64
    frame_dig 32
    itxn_field XferAsset
    itxn_field AssetAmount
    frame_dig 6
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:538-544
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: escrowAddress,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:538-545
    // itxn
    //   .assetTransfer({
    //     sender: this.controlledAddress.value,
    //     assetReceiver: escrowAddress,
    //     assetAmount: fundsRequests[i].amount,
    //     xferAsset: fundsRequests[i].asset
    //   })
    //   .submit();
    itxn_submit

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@81:
    // smart_contracts/arc58/account/contract.algo.ts:528
    // for (let i: uint64 = 0; i < fundsRequests.length; i += 1) {
    frame_dig 18
    intc_1 // 1
    +
    frame_bury 18
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@63

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@80:
    // smart_contracts/arc58/account/contract.algo.ts:547-553
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:549
    // sender: this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:549
    // sender: this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:551
    // amount: fundsRequests[i].amount
    frame_dig 0
    intc_3 // 8
    extract_uint64
    itxn_field Amount
    frame_dig 6
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:547-552
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: fundsRequests[i].amount
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:547-553
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: escrowAddress,
    //     amount: fundsRequests[i].amount
    //   })
    //   .submit();
    itxn_submit
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@81

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@69:
    // smart_contracts/arc58/account/contract.algo.ts:567
    // } else if (type === SpendAllowanceTypeWindow) {
    frame_dig 11
    pushbytes 0x02
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@73
    // smart_contracts/arc58/account/contract.algo.ts:595
    // if (useRounds) {
    frame_dig 31
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@84
    // smart_contracts/arc58/account/contract.algo.ts:596
    // return Global.round - ((Global.round - start) % interval)
    global Round
    dup
    frame_dig 30
    -
    frame_dig 19
    %
    -

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart@85:
    // smart_contracts/arc58/account/contract.algo.ts:570
    // if (currentWindowStart > last) {
    frame_dig 21
    >
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@72
    // smart_contracts/arc58/account/contract.algo.ts:571
    // assert(amount >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    dup
    extract 8 8
    swap
    intc_3 // 8
    extract_uint64
    frame_dig 12
    <=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:572
    // this.allowances(key).value.spent = fundRequest.amount
    frame_dig 3
    pushint 17 // 17
    uncover 2
    box_replace
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@78

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@72:
    // smart_contracts/arc58/account/contract.algo.ts:575
    // const leftover: uint64 = amount - spent;
    frame_dig 12
    frame_dig 29
    -
    // smart_contracts/arc58/account/contract.algo.ts:576
    // assert(leftover >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_3 // 8
    extract_uint64
    swap
    dig 1
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:577
    // this.allowances(key).value.spent += fundRequest.amount
    frame_dig 3
    dup
    cover 2
    box_get
    assert // Box must have value
    pushint 17 // 17
    extract_uint64
    +
    itob
    pushint 17 // 17
    swap
    box_replace
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@78

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@84:
    // smart_contracts/arc58/account/contract.algo.ts:598
    // return Global.latestTimestamp - ((Global.latestTimestamp - start) % interval)
    global LatestTimestamp
    dup
    frame_dig 30
    -
    frame_dig 19
    %
    -
    // smart_contracts/arc58/account/contract.algo.ts:568
    // const currentWindowStart = this.getLatestWindowStart(useRounds, start, interval)
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.getLatestWindowStart@85

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@73:
    // smart_contracts/arc58/account/contract.algo.ts:579
    // } else if (type === SpendAllowanceTypeDrip) {
    frame_dig 11
    pushbytes 0x03
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@78
    // smart_contracts/arc58/account/contract.algo.ts:580
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 31
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@76
    global Round
    frame_bury 15

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@77:
    // smart_contracts/arc58/account/contract.algo.ts:581
    // const passed: uint64 = epochRef - last
    frame_dig 15
    frame_dig 21
    -
    // smart_contracts/arc58/account/contract.algo.ts:585
    // const accrued: uint64 = spent + ((passed / interval) * amount)
    frame_dig 19
    /
    frame_dig 12
    *
    frame_dig 29
    +
    // smart_contracts/arc58/account/contract.algo.ts:586
    // const available: uint64 = accrued > max ? max : accrued
    dup
    frame_dig 23
    dup
    cover 3
    >
    swap
    cover 2
    select
    // smart_contracts/arc58/account/contract.algo.ts:588
    // assert(available >= fundRequest.amount, ERR_ALLOWANCE_EXCEEDED);
    frame_dig 0
    intc_3 // 8
    extract_uint64
    dup2
    >=
    assert // Allowance exceeded
    // smart_contracts/arc58/account/contract.algo.ts:589
    // this.allowances(key).value.spent = (available - fundRequest.amount)
    -
    itob
    frame_dig 3
    pushint 17 // 17
    uncover 2
    box_replace
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@78

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@76:
    // smart_contracts/arc58/account/contract.algo.ts:580
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 15
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@77

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@66:
    // smart_contracts/arc58/account/contract.algo.ts:561
    // const newLast = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 27
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@67

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@8:
    // smart_contracts/arc58/account/contract.algo.ts:364
    // const { useRounds, useExecutionKey } = this.plugins(key).value
    frame_dig 2
    pushint 27 // 27
    intc_1 // 1
    box_extract
    dup
    intc_1 // 1
    getbit
    frame_bury 31
    intc_2 // 2
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:366
    // if (useExecutionKey && !this.isAdmin()) {
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@29
    callsub isAdmin
    bnz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@29
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:367
    // assert(this.executions(Txn.lease).exists, ERR_EXECUTION_KEY_NOT_FOUND);
    txn Lease
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:367
    // assert(this.executions(Txn.lease).exists, ERR_EXECUTION_KEY_NOT_FOUND);
    box_len
    bury 1
    assert // Execution key not found
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:368
    // assert(this.executions(Txn.lease).value.firstValid <= Global.round, ERR_EXECUTION_NOT_READY);
    txn Lease
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:368
    // assert(this.executions(Txn.lease).value.firstValid <= Global.round, ERR_EXECUTION_NOT_READY);
    intc_2 // 2
    intc_3 // 8
    box_extract
    btoi
    global Round
    <=
    assert // Execution key not ready
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:369
    // assert(this.executions(Txn.lease).value.lastValid >= Global.round, ERR_EXECUTION_EXPIRED);
    txn Lease
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:369
    // assert(this.executions(Txn.lease).value.lastValid >= Global.round, ERR_EXECUTION_EXPIRED);
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    global Round
    >=
    assert // Execution key expired
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:371
    // const groups = this.executions(Txn.lease).value.groups as Readonly<bytes<32>[]>;
    txn Lease
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    frame_bury 5
    // smart_contracts/arc58/account/contract.algo.ts:373
    // let foundGroup = false;
    intc_0 // 0
    frame_bury 17
    // smart_contracts/arc58/account/contract.algo.ts:374
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    intc_0 // 0
    frame_bury 18

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@24:
    // smart_contracts/arc58/account/contract.algo.ts:374
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    frame_dig 5
    pushint 18 // 18
    intc_2 // 2
    box_extract
    btoi
    frame_dig 18
    >
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_while@28
    // smart_contracts/arc58/account/contract.algo.ts:375
    // if (groups[i] === Global.groupId) {
    frame_dig 18
    pushint 32 // 32
    *
    pushint 20 // 20
    +
    frame_dig 5
    swap
    pushint 32 // 32
    box_extract
    global GroupID
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@27
    // smart_contracts/arc58/account/contract.algo.ts:376
    // foundGroup = true;
    intc_1 // 1
    frame_bury 17

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@27:
    // smart_contracts/arc58/account/contract.algo.ts:374
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    frame_dig 18
    intc_1 // 1
    +
    frame_bury 18
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@24

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_while@28:
    // smart_contracts/arc58/account/contract.algo.ts:380
    // assert(foundGroup, ERR_GROUP_NOT_FOUND);
    frame_dig 17
    assert // Group not found
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 9 // "x"
    // smart_contracts/arc58/account/contract.algo.ts:381
    // this.executions(Txn.lease).delete();
    txn Lease
    // smart_contracts/arc58/account/contract.algo.ts:171
    // executions = BoxMap<bytes<32>, ExecutionInfo>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/account/contract.algo.ts:381
    // this.executions(Txn.lease).delete();
    box_del
    pop

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@29:
    // smart_contracts/arc58/account/contract.algo.ts:384
    // const initialCheck = this.pluginCheck(key);
    frame_dig 7
    callsub pluginCheck
    frame_bury 7
    // smart_contracts/arc58/account/contract.algo.ts:386
    // assert(initialCheck.exists, ERR_PLUGIN_DOES_NOT_EXIST);
    dup
    intc_0 // 0
    getbit
    assert // Plugin does not exist
    // smart_contracts/arc58/account/contract.algo.ts:387
    // assert(!initialCheck.expired, ERR_PLUGIN_EXPIRED);
    dup
    intc_1 // 1
    getbit
    !
    assert // plugin expired
    // smart_contracts/arc58/account/contract.algo.ts:388
    // assert(!initialCheck.onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    intc_2 // 2
    getbit
    !
    assert // plugin on cooldown
    // smart_contracts/arc58/account/contract.algo.ts:390-392
    // const epochRef = useRounds
    //   ? Global.round
    //   : Global.latestTimestamp;
    frame_dig 31
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@31
    // smart_contracts/arc58/account/contract.algo.ts:391
    // ? Global.round
    global Round
    frame_bury 15

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@32:
    // smart_contracts/arc58/account/contract.algo.ts:394
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 28
    // smart_contracts/arc58/account/contract.algo.ts:395
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 25
    // smart_contracts/arc58/account/contract.algo.ts:397
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 20
    frame_dig 7
    frame_bury 8

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@33:
    // smart_contracts/arc58/account/contract.algo.ts:397
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 20
    global GroupSize
    <
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_block@60
    // smart_contracts/arc58/account/contract.algo.ts:400
    // if (this.txnRekeysBack(txn)) {
    frame_dig 20
    callsub txnRekeysBack
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@36
    // smart_contracts/arc58/account/contract.algo.ts:401
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 28

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_block@60:
    // smart_contracts/arc58/account/contract.algo.ts:431
    // assert(rekeysBack, ERR_MISSING_REKEY_BACK);
    frame_dig 28
    assert // missing rekey back
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 8
    concat
    dup
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:903
    // if (this.plugins(key).value.coverFees) {
    pushint 27 // 27
    intc_1 // 1
    box_extract
    pushint 3 // 3
    getbit
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@16
    // smart_contracts/arc58/account/contract.algo.ts:905
    // const maxFee: uint64 = (MAX_INNER_TXN_COUNT + MAX_OUTER_TXN_COUNT) * Global.minTxnFee
    pushint 272 // 272
    global MinTxnFee
    *
    dup
    frame_bury 24
    // smart_contracts/arc58/account/contract.algo.ts:906
    // const reimbursement = Txn.fee < maxFee ? Txn.fee : maxFee
    txn Fee
    >
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@13
    txn Fee

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@14:
    // smart_contracts/arc58/account/contract.algo.ts:908-916
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: Txn.sender,
    //     amount: reimbursement,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app & reimbursing caller'
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:910
    // sender: this.spendingAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:910
    // sender: this.spendingAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:911
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/arc58/account/contract.algo.ts:913
    // rekeyTo: pluginApp.address,
    frame_dig -5
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:914
    // note: 'rekeying to plugin app & reimbursing caller'
    pushbytes "rekeying to plugin app & reimbursing caller"
    itxn_field Note
    itxn_field RekeyTo
    uncover 2
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:908-915
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: Txn.sender,
    //     amount: reimbursement,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app & reimbursing caller'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:908-916
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: Txn.sender,
    //     amount: reimbursement,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app & reimbursing caller'
    //   })
    //   .submit()
    itxn_submit

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@18:
    // smart_contracts/arc58/account/contract.algo.ts:150
    // rekeyIndex = GlobalState<uint64>({ initialValue: 0, key: AbstractAccountGlobalStateKeysRekeyIndex })
    bytec 19 // "rekey_index"
    // smart_contracts/arc58/account/contract.algo.ts:929
    // this.rekeyIndex.value = Txn.groupIndex
    txn GroupIndex
    app_global_put
    // smart_contracts/arc58/account/contract.algo.ts:931
    // if (this.plugins(key).value.delegationType === DelegationTypeSelf) {
    frame_dig 4
    intc_3 // 8
    intc_1 // 1
    box_extract
    bytec 14 // 0x01
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@20
    // smart_contracts/arc58/account/contract.algo.ts:142
    // lastUserInteraction = GlobalState<uint64>({ key: AbstractAccountGlobalStateKeysLastUserInteraction })
    bytec 4 // "last_user_interaction"
    // smart_contracts/arc58/account/contract.algo.ts:187
    // this.lastUserInteraction.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@20:
    frame_dig -2
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@13:
    frame_dig 24
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@14

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@16:
    // smart_contracts/arc58/account/contract.algo.ts:918-925
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:920
    // sender: this.spendingAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:920
    // sender: this.spendingAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:922
    // rekeyTo: pluginApp.address,
    frame_dig -5
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/arc58/account/contract.algo.ts:923
    // note: 'rekeying to plugin app'
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    dup
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/arc58/account/contract.algo.ts:918-924
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/account/contract.algo.ts:918-925
    // itxn
    //   .payment({
    //     sender: this.spendingAddress.value,
    //     receiver: this.spendingAddress.value,
    //     rekeyTo: pluginApp.address,
    //     note: 'rekeying to plugin app'
    //   })
    //   .submit();
    itxn_submit
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@18

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@36:
    // smart_contracts/arc58/account/contract.algo.ts:405
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 20
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@38
    frame_dig 8

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_block@58:
    // smart_contracts/arc58/account/contract.algo.ts:397
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 20
    intc_1 // 1
    +
    frame_bury 20
    frame_bury 8
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_while_top@33

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@38:
    // smart_contracts/arc58/account/contract.algo.ts:409
    // assert(txn.appId.id === key.plugin, ERR_CANNOT_CALL_OTHER_APPS_DURING_REKEY);
    frame_dig 20
    dup
    gtxns ApplicationID
    frame_dig 7
    dup
    cover 3
    intc_0 // 0
    extract_uint64
    ==
    assert // cannot call other apps during rekey
    // smart_contracts/arc58/account/contract.algo.ts:410
    // assert(txn.onCompletion === OnCompleteAction.NoOp, ERR_INVALID_ONCOMPLETE);
    dup
    gtxns OnCompletion
    !
    assert // invalid oncomplete must be no op
    // smart_contracts/arc58/account/contract.algo.ts:413
    // assert(txn.numAppArgs > 1, ERR_INVALID_SENDER_ARG);
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // invalid sender must be this app id
    // smart_contracts/arc58/account/contract.algo.ts:414
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, ERR_INVALID_SENDER_VALUE);
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // invalid sender app id
    // smart_contracts/arc58/account/contract.algo.ts:416
    // const { expired, onCooldown, hasMethodRestrictions } = this.pluginCheck(key);
    callsub pluginCheck
    frame_bury 7
    dup
    intc_1 // 1
    getbit
    dig 1
    intc_2 // 2
    getbit
    uncover 2
    pushint 3 // 3
    getbit
    // smart_contracts/arc58/account/contract.algo.ts:418
    // assert(!expired, ERR_PLUGIN_EXPIRED);
    uncover 2
    !
    assert // plugin expired
    // smart_contracts/arc58/account/contract.algo.ts:419
    // assert(!onCooldown, ERR_PLUGIN_ON_COOLDOWN);
    swap
    !
    assert // plugin on cooldown
    // smart_contracts/arc58/account/contract.algo.ts:421
    // if (hasMethodRestrictions) {
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@57
    // smart_contracts/arc58/account/contract.algo.ts:422
    // assert(methodIndex < methodOffsets.length, ERR_MALFORMED_OFFSETS);
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig 25
    dup
    uncover 2
    <
    assert // malformed method offsets
    // smart_contracts/arc58/account/contract.algo.ts:423
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    frame_dig -2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:444
    // assert(len(txn.appArgs(0)) === 4, ERR_INVALID_METHOD_SIGNATURE_LENGTH)
    frame_dig 20
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    frame_bury 10
    len
    pushint 4 // 4
    ==
    assert // invalid method signature length
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 7
    concat
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:447
    // const { useRounds } = this.plugins(key).value
    dup
    pushint 27 // 27
    intc_1 // 1
    box_extract
    intc_1 // 1
    getbit
    dup
    cover 2
    frame_bury 31
    // smart_contracts/arc58/account/contract.algo.ts:448
    // const { selector, cooldown, lastCalled } = this.plugins(key).value.methods[offset]
    uncover 2
    pushint 20 // 20
    *
    dup
    frame_bury 13
    pushint 46 // 46
    +
    pushint 20 // 20
    box_extract
    dup
    extract 0 4
    frame_bury 9
    dup
    pushint 4 // 4
    extract_uint64
    frame_bury 14
    pushint 12 // 12
    extract_uint64
    frame_bury 22
    // smart_contracts/arc58/account/contract.algo.ts:452
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@41
    global Round

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@42:
    // smart_contracts/arc58/account/contract.algo.ts:453
    // const methodOnCooldown = (epochRef - lastCalled) < cooldown
    frame_dig 22
    -
    frame_dig 14
    <
    frame_bury 26
    // smart_contracts/arc58/account/contract.algo.ts:455
    // if (selector === selectorArg && (!hasCooldown || !methodOnCooldown)) {
    frame_dig 9
    frame_dig 10
    ==
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@51
    frame_dig 14
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_if_body@45
    frame_dig 26
    bnz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@51

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_if_body@45:
    // smart_contracts/arc58/account/contract.algo.ts:457
    // if (hasCooldown) {
    frame_dig 14
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@50
    // smart_contracts/arc58/account/contract.algo.ts:458
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    frame_dig 31
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@48
    global Round

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@49:
    // smart_contracts/arc58/account/contract.algo.ts:459
    // this.plugins(key).value.methods[offset].lastCalled = lastCalled
    itob
    frame_dig 13
    pushint 58 // 58
    +
    frame_dig 2
    swap
    uncover 2
    box_replace

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@50:
    // smart_contracts/arc58/account/contract.algo.ts:462-465
    // return {
    //   methodAllowed: true,
    //   methodOnCooldown
    // }
    pushbytes 0x80
    intc_1 // 1
    frame_dig 26
    setbit

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck@52:
    // smart_contracts/arc58/account/contract.algo.ts:423
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    dup
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    frame_bury 26
    // smart_contracts/arc58/account/contract.algo.ts:424
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_bool_false@55
    frame_dig 26
    bnz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_bool_false@55
    intc_1 // 1

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_bool_merge@56:
    // smart_contracts/arc58/account/contract.algo.ts:424
    // assert(methodAllowed && !methodOnCooldown, ERR_METHOD_ON_COOLDOWN);
    assert // method on cooldown

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@57:
    // smart_contracts/arc58/account/contract.algo.ts:163
    // plugins = BoxMap<PluginKey, PluginInfo>({ keyPrefix: AbstractAccountBoxPrefixPlugins });
    bytec_3 // "p"
    frame_dig 7
    dup
    cover 2
    concat
    // smart_contracts/arc58/account/contract.algo.ts:427
    // this.plugins(key).value.lastCalled = epochRef
    frame_dig 15
    itob
    pushint 28 // 28
    swap
    box_replace
    // smart_contracts/arc58/account/contract.algo.ts:428
    // methodIndex += 1;
    frame_dig 25
    intc_1 // 1
    +
    frame_bury 25
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_block@58

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_bool_false@55:
    intc_0 // 0
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_bool_merge@56

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@48:
    // smart_contracts/arc58/account/contract.algo.ts:458
    // const lastCalled = useRounds ? Global.round : Global.latestTimestamp;
    global LatestTimestamp
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@49

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@51:
    // smart_contracts/arc58/account/contract.algo.ts:468-471
    // return {
    //   methodAllowed: false,
    //   methodOnCooldown: true
    // }
    pushbytes 0x40
    // smart_contracts/arc58/account/contract.algo.ts:423
    // const { methodAllowed, methodOnCooldown } = this.methodCheck(key, txn, methodOffsets[methodIndex]);
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_inlined_smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.methodCheck@52

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@41:
    // smart_contracts/arc58/account/contract.algo.ts:452
    // const epochRef = useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@42

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@31:
    // smart_contracts/arc58/account/contract.algo.ts:392
    // : Global.latestTimestamp;
    global LatestTimestamp
    frame_bury 15
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@32

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_else_body@7:
    // smart_contracts/arc58/account/contract.algo.ts:897
    // this.spendingAddress.value = this.controlledAddress.value
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:897
    // this.spendingAddress.value = this.controlledAddress.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:146
    // spendingAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysSpendingAddress })
    bytec 10 // "spending_address"
    // smart_contracts/arc58/account/contract.algo.ts:897
    // this.spendingAddress.value = this.controlledAddress.value
    swap
    app_global_put
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_after_if_else@8

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_false@2:
    // smart_contracts/arc58/account/contract.algo.ts:885
    // const caller = global ? Global.zeroAddress : Txn.sender
    txn Sender
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.arc58_rekeyToPlugin_ternary_merge@3


// smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance(assets: bytes) -> bytes, bytes:
smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance:
    // smart_contracts/arc58/account/contract.algo.ts:1640-1641
    // @abimethod({ readonly: true })
    // balance(assets: uint64[]): uint64[] {
    proto 1 2
    intc_0 // 0
    bytec_1 // ""
    dupn 2
    // smart_contracts/arc58/account/contract.algo.ts:1642
    // let amounts: uint64[] = []
    bytec 7 // 0x0000
    // smart_contracts/arc58/account/contract.algo.ts:1643
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_while_top@1:
    // smart_contracts/arc58/account/contract.algo.ts:1643
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 5
    >
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_after_while@9
    // smart_contracts/arc58/account/contract.algo.ts:1644
    // let amount: uint64 = 0
    intc_0 // 0
    frame_bury 1
    // smart_contracts/arc58/account/contract.algo.ts:1645
    // const asset = Asset(assets[i])
    frame_dig -1
    extract 2 0
    frame_dig 5
    intc_3 // 8
    *
    dup2
    intc_3 // 8
    extract3 // on error: index access is out of bounds
    frame_bury 0
    extract_uint64
    dup
    frame_bury 2
    // smart_contracts/arc58/account/contract.algo.ts:1647
    // if (asset.id === 0) {
    bnz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_else_body@4
    // smart_contracts/arc58/account/contract.algo.ts:1648
    // amount = Global.currentApplicationAddress.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    swap
    frame_bury 1
    assert // account funded

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_after_if_else@7:
    // smart_contracts/arc58/account/contract.algo.ts:1656-1662
    // const escrowInfo = abiCall<typeof Staking.prototype.getEscrowInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     this.controlledAddress.value,
    //     asset.id
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/account/contract.algo.ts:1657
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:126
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec 20 // "akita_dao"
    // smart_contracts/arc58/account/contract.algo.ts:1657
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/functions.ts:40
    // const [appListBytes] = op.AppGlobal.getExBytes(akitaDAO, Bytes(AkitaDAOGlobalStateKeysAkitaAppList))
    pushbytes "aal"
    app_global_get_ex
    pop
    // smart_contracts/arc58/account/contract.algo.ts:1657
    // appId: getAkitaAppList(this.akitaDAO.value).staking,
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/account/contract.algo.ts:1659
    // this.controlledAddress.value,
    intc_0 // 0
    // smart_contracts/arc58/account/contract.algo.ts:132
    // controlledAddress = GlobalState<Account>({ key: AbstractAccountGlobalStateKeysControlledAddress });
    bytec_0 // "controlled_address"
    // smart_contracts/arc58/account/contract.algo.ts:1659
    // this.controlledAddress.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/account/contract.algo.ts:1656-1662
    // const escrowInfo = abiCall<typeof Staking.prototype.getEscrowInfo>({
    //   appId: getAkitaAppList(this.akitaDAO.value).staking,
    //   args: [
    //     this.controlledAddress.value,
    //     asset.id
    //   ]
    // }).returnValue
    pushbytes 0x4c88eace // method "getEscrowInfo(address,uint64)(uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec 5 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for (uint64,uint64)
    // smart_contracts/arc58/account/contract.algo.ts:1664
    // amounts = [...amounts, (amount + escrowInfo.hard + escrowInfo.lock)]
    dup
    pushint 4 // 4
    extract_uint64
    frame_dig 1
    +
    swap
    pushint 12 // 12
    extract_uint64
    +
    itob
    bytec 24 // 0x0001
    swap
    concat
    extract 2 0
    frame_dig 4
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    frame_bury 4
    // smart_contracts/arc58/account/contract.algo.ts:1643
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_while_top@1

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_else_body@4:
    // smart_contracts/arc58/account/contract.algo.ts:1650
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 2
    asset_holding_get AssetBalance
    swap
    frame_bury 3
    // smart_contracts/arc58/account/contract.algo.ts:1651
    // if (optedIn) {
    bz smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_after_if_else@7
    frame_dig 3
    frame_bury 1
    b smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_after_if_else@7

smart_contracts/arc58/account/contract.algo.ts::AbstractedAccount.balance_after_while@9:
    // smart_contracts/arc58/account/contract.algo.ts:1667
    // return amounts
    frame_dig 4
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub
