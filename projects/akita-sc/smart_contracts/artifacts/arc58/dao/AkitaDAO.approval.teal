#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8 100000 1000 1000000
    bytecblock 0x151f7c75 "wallet" "" 0x00 "l" "other_al" 0x14 0x28 "akita_al" "initialized" "akita_assets" 0x32 0x0a 0x1e "proposal_action_limit" "upgrade_app_ps" "add_plugin_ps" "remove_plugin_ps" "add_allowance_ps" "remove_allowance_ps" "new_escrow_ps" "update_fields_ps" "version" "content_policy" "min_rewards_impact" "plugn_al" "wallet_fees" "social_fees" "staking_fees" "subscription_fees" "nft_fees" "swap_fees" "x" 0x15 0x00010002 "proposal_id" 0x1f 0x0000 0x29 0x3c 0x46 0x47 0x50 0x002a 0x000a "p" 0x000000000000016d00000000000f4240 "remove_execute_plugin_ps" 0x7c37156e 0x000000000000000000000000000000000000000000000000 0x0077
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    intc_0 // 0
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:28
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 22 // "version"
    bytec_2 // ""
    app_global_put

main_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:20-21
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/arc58/dao/contract.algo.ts:20-21
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@39
    pushbytess 0xd9bacd94 0xfd2c93cd 0x73bf8fbe 0x0198fe3b 0xfe20c269 0xcb37e668 0x28f80154 0x103a6b88 0xa4b236b6 0x62ce9b5b 0xf1ff28aa 0x49013b5f 0x9699d108 0x501f50b4 0x1f9f8b20 0xdbbec6d2 0x2c2f51c3 0x92b35896 0xe45e26e1 0x4684e5e6 0xf3941a2c 0xf1cf22cc 0xbd4ef730 0xebab5e14 0x6b8abd2f 0xfcaf8420 0x55ce5ca9 0xa638be23 0x50aab81d 0x149d3ccb 0x854dede0 // method "setup(string)uint64", method "initialize()void", method "newProposalPreInitialized(byte[36],(uint8,byte[])[])uint64", method "newProposal(pay,byte[36],(uint8,byte[])[])uint64", method "editProposal(uint64,byte[36],(uint8,byte[])[])void", method "editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void", method "deleteProposal(uint64)void", method "submitProposal(uint64)void", method "voteProposal(pay,uint64,uint8)void", method "finalizeProposal(uint64)void", method "executeProposal(uint64)void", method "deleteProposalVotes(uint64,address[])void", method "setupCost()uint64", method "proposalCost((uint8,byte[])[])(uint64,uint64)", method "getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])", method "mustGetExecution(byte[32])(uint64,uint64)", method "isValidUpgrade(byte[32],uint64)bool", method "proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)", method "proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])", method "proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])", method "proposalRemovePluginShape((uint64,address,string))(uint64,address,string)", method "proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)", method "proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)", method "proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)", method "proposalRemoveExecutePluginShape((byte[32]))(byte[32])", method "proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])", method "proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])", method "proposalNewEscrowShape((string))(string)", method "proposalToggleEscrowLockShape((string))(string)", method "proposalUpdateFieldShape((string,byte[]))(string,byte[])", method "opUp()void"
    txna ApplicationArgs 0
    match setup initialize newProposalPreInitialized newProposal editProposal editProposalWithPayment deleteProposal submitProposal voteProposal finalizeProposal executeProposal deleteProposalVotes setupCost proposalCost getProposal mustGetExecution isValidUpgrade proposalUpgradeAppShape proposalAddPluginShape proposalAddNamedPluginShape proposalRemovePluginShape proposalRemoveNamedPluginShape proposalExecutePluginShape proposalExecuteNamedPluginShape proposalRemoveExecutePluginShape proposalAddAllowancesShape proposalRemoveAllowancesShape proposalNewEscrowShape proposalToggleEscrowLockShape proposalUpdateFieldShape main_opUp_route@37
    err

main_opUp_route@37:
    // smart_contracts/arc58/dao/contract.algo.ts:1358
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@39:
    // smart_contracts/arc58/dao/contract.algo.ts:20-21
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    pushbytes 0x11edb79d // method "create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)))void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/arc58/dao/contract.algo.ts:852
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/utils/functions.ts::wideRatio(numerators: bytes, denominators: bytes) -> uint64:
wideRatio:
    // smart_contracts/utils/functions.ts:101
    // export function wideRatio(numerators: [uint64, uint64], denominators: [uint64, uint64]): uint64 {
    proto 2 1
    // smart_contracts/utils/functions.ts:102
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    dup
    bz wideRatio_bool_false@3
    frame_dig -1
    intc_3 // 8
    extract_uint64
    bz wideRatio_bool_false@3
    intc_1 // 1

wideRatio_bool_merge@4:
    // smart_contracts/utils/functions.ts:102
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:103
    // const [overflow, result] = op.divmodw(...op.mulw(...numerators), ...op.mulw(...denominators))
    frame_dig -2
    intc_0 // 0
    extract_uint64
    frame_dig -2
    intc_3 // 8
    extract_uint64
    mulw
    frame_dig -1
    intc_3 // 8
    extract_uint64
    frame_dig 0
    mulw
    divmodw
    popn 2
    swap
    // smart_contracts/utils/functions.ts:104
    // assert(overflow === 0, ERR_INVALID_PERCENTAGE)
    !
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return result
    swap
    retsub

wideRatio_bool_false@3:
    intc_0 // 0
    b wideRatio_bool_merge@4


// smart_contracts/utils/functions.ts::getOrigin(escrowFactory: uint64, address: bytes) -> bytes:
getOrigin:
    // smart_contracts/utils/functions.ts:182
    // export function getOrigin(escrowFactory: uint64, address: Account): Account {
    proto 2 1
    bytec_2 // ""
    // smart_contracts/utils/functions.ts:170-173
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:175
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getOrigin_if_body@7
    frame_dig 2
    intc_3 // 8
    !=
    bz getOrigin_after_if_else@8

getOrigin_if_body@7:
    // smart_contracts/utils/functions.ts:176
    // return 0
    intc_0 // 0
    frame_bury 0

getOrigin_after_inlined_smart_contracts/utils/functions.ts::getWalletID@9:
    // smart_contracts/utils/functions.ts:185
    // if (wallet === 0) {
    frame_dig 0
    bnz getOrigin_after_if_else@2
    // smart_contracts/utils/functions.ts:186
    // return Txn.sender
    txn Sender
    frame_bury 0
    retsub

getOrigin_after_if_else@2:
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:151
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:149-152
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:189
    // return getOriginAccount(Application(wallet))
    frame_bury 0
    retsub

getOrigin_after_if_else@8:
    // smart_contracts/utils/functions.ts:179
    // return btoi(data)
    frame_dig 1
    btoi
    frame_bury 0
    // smart_contracts/utils/functions.ts:183
    // const wallet = getWalletID(escrowFactory, address)
    b getOrigin_after_inlined_smart_contracts/utils/functions.ts::getWalletID@9


// smart_contracts/utils/functions.ts::getStakingPower(stakingApp: uint64, user: bytes, asset: uint64) -> uint64:
getStakingPower:
    // smart_contracts/utils/functions.ts:421
    // export function getStakingPower(stakingApp: uint64, user: Account, asset: uint64): uint64 {
    proto 3 1
    bytec_2 // ""
    // smart_contracts/utils/functions.ts:422-431
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:426-429
    // {
    //   asset,
    //   type: STAKING_TYPE_LOCK,
    // },
    frame_dig -1
    itob
    // smart_contracts/utils/functions.ts:428
    // type: STAKING_TYPE_LOCK,
    bytec 7 // 0x28
    // smart_contracts/utils/functions.ts:426-429
    // {
    //   asset,
    //   type: STAKING_TYPE_LOCK,
    // },
    concat
    // smart_contracts/utils/functions.ts:422-431
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    pushbytes 0xc9068809 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 20 // 20
    // smart_contracts/utils/functions.ts:433
    // if (info.expiration <= Global.latestTimestamp) {
    extract_uint64
    dup
    global LatestTimestamp
    <=
    bz getStakingPower_after_if_else@3
    // smart_contracts/utils/functions.ts:434
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getStakingPower_after_if_else@3:
    // smart_contracts/utils/functions.ts:437
    // const remainingTime: uint64 = info.expiration - Global.latestTimestamp
    frame_dig 2
    global LatestTimestamp
    -
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:439
    // if (remainingTime < ONE_WEEK) {
    pushint 604800 // 604800
    <
    bz getStakingPower_after_if_else@5
    // smart_contracts/utils/functions.ts:440
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getStakingPower_after_if_else@5:
    // smart_contracts/utils/functions.ts:443
    // const remainingDays: uint64 = remainingTime / ONE_DAY
    frame_dig 0
    pushint 86400 // 86400
    /
    // smart_contracts/utils/functions.ts:444
    // return op.divw(...op.mulw(wideRatio([info.amount, 1_000_000], [ONE_YEAR_IN_DAYS, 1_000_000]), remainingDays), 1_000_000)
    frame_dig 1
    extract 4 8
    intc 6 // 1000000
    itob
    concat
    dup
    bytec 46 // 0x000000000000016d00000000000f4240
    callsub wideRatio
    dig 2
    mulw
    pop
    cover 2
    bytec 46 // 0x000000000000016d00000000000f4240
    callsub wideRatio
    mulw
    bury 1
    intc 6 // 1000000
    divw
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.create[routing]() -> void:
create:
    // smart_contracts/arc58/dao/contract.algo.ts:706
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    pushint 168 // 168
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
    txna ApplicationArgs 6
    dup
    len
    pushint 264 // 264
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
    txna ApplicationArgs 7
    dup
    len
    pushint 320 // 320
    ==
    assert // invalid number of bytes for ((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64))
    // smart_contracts/arc58/dao/contract.algo.ts:725
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:28
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 22 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:725
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    bytec_2 // ""
    ==
    assert // Already initialized
    // smart_contracts/arc58/dao/contract.algo.ts:726
    // assert(version !== '', ERR_VERSION_CANNOT_BE_EMPTY)
    dig 6
    bytec_2 // ""
    !=
    assert // Version cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:728
    // this.initialized.value = false
    intc_0 // 0
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:28
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 22 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:729
    // this.version.value = version
    uncover 7
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 14 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:730
    // this.proposalActionLimit.value = 5
    pushint 5 // 5
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:731
    // this.akitaAssets.value = { akta, bones: 0 }
    uncover 5
    itob
    intc_0 // 0
    itob
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 10 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:731
    // this.akitaAssets.value = { akta, bones: 0 }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // contentPolicy = GlobalState<CID>({ key: AkitaDAOGlobalStateKeysContentPolicy })
    bytec 23 // "content_policy"
    // smart_contracts/arc58/dao/contract.algo.ts:732
    // this.contentPolicy.value = contentPolicy
    uncover 5
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:36
    // minRewardsImpact = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysMinRewardsImpact })
    bytec 24 // "min_rewards_impact"
    // smart_contracts/arc58/dao/contract.algo.ts:733
    // this.minRewardsImpact.value = minRewardsImpact
    uncover 4
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:736
    // staking: apps.staking,
    dig 2
    extract 0 8
    // smart_contracts/arc58/dao/contract.algo.ts:737
    // rewards: apps.rewards,
    dig 3
    extract 8 8
    // smart_contracts/arc58/dao/contract.algo.ts:738
    // pool: apps.pool,
    dig 4
    extract 16 8
    // smart_contracts/arc58/dao/contract.algo.ts:739
    // prizeBox: apps.prizeBox,
    dig 5
    extract 24 8
    // smart_contracts/arc58/dao/contract.algo.ts:740
    // subscriptions: apps.subscriptions,
    dig 6
    extract 32 8
    // smart_contracts/arc58/dao/contract.algo.ts:741
    // gate: apps.gate,
    dig 7
    extract 40 8
    // smart_contracts/arc58/dao/contract.algo.ts:742
    // auction: apps.auction,
    dig 8
    extract 48 8
    // smart_contracts/arc58/dao/contract.algo.ts:743
    // hyperSwap: apps.hyperSwap,
    dig 9
    extract 56 8
    // smart_contracts/arc58/dao/contract.algo.ts:744
    // raffle: apps.raffle,
    dig 10
    extract 64 8
    // smart_contracts/arc58/dao/contract.algo.ts:745
    // metaMerkles: apps.metaMerkles,
    dig 11
    extract 72 8
    // smart_contracts/arc58/dao/contract.algo.ts:746
    // marketplace: apps.marketplace,
    dig 12
    extract 80 8
    // smart_contracts/arc58/dao/contract.algo.ts:747
    // wallet: apps.wallet,
    dig 13
    extract 144 8
    // smart_contracts/arc58/dao/contract.algo.ts:748
    // social: apps.social,
    dig 14
    extract 104 8
    // smart_contracts/arc58/dao/contract.algo.ts:749
    // impact: apps.impact
    dig 15
    extract 112 8
    // smart_contracts/arc58/dao/contract.algo.ts:735-750
    // this.akitaAppList.value = {
    //   staking: apps.staking,
    //   rewards: apps.rewards,
    //   pool: apps.pool,
    //   prizeBox: apps.prizeBox,
    //   subscriptions: apps.subscriptions,
    //   gate: apps.gate,
    //   auction: apps.auction,
    //   hyperSwap: apps.hyperSwap,
    //   raffle: apps.raffle,
    //   metaMerkles: apps.metaMerkles,
    //   marketplace: apps.marketplace,
    //   wallet: apps.wallet,
    //   social: apps.social,
    //   impact: apps.impact
    // }
    uncover 13
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:735-750
    // this.akitaAppList.value = {
    //   staking: apps.staking,
    //   rewards: apps.rewards,
    //   pool: apps.pool,
    //   prizeBox: apps.prizeBox,
    //   subscriptions: apps.subscriptions,
    //   gate: apps.gate,
    //   auction: apps.auction,
    //   hyperSwap: apps.hyperSwap,
    //   raffle: apps.raffle,
    //   metaMerkles: apps.metaMerkles,
    //   marketplace: apps.marketplace,
    //   wallet: apps.wallet,
    //   social: apps.social,
    //   impact: apps.impact
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:753
    // optin: apps.optin,
    dig 2
    extract 96 8
    // smart_contracts/arc58/dao/contract.algo.ts:40
    // pluginAppList = GlobalState<PluginAppList>({ key: AkitaDAOGlobalStateKeysPluginAppList })
    bytec 25 // "plugn_al"
    // smart_contracts/arc58/dao/contract.algo.ts:752-754
    // this.pluginAppList.value = {
    //   optin: apps.optin,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:757
    // vrfBeacon: apps.vrfBeacon,
    dig 2
    extract 120 8
    // smart_contracts/arc58/dao/contract.algo.ts:758
    // nfdRegistry: apps.nfdRegistry,
    dig 3
    extract 128 8
    // smart_contracts/arc58/dao/contract.algo.ts:759
    // assetInbox: apps.assetInbox,
    dig 4
    extract 136 8
    // smart_contracts/arc58/dao/contract.algo.ts:760
    // escrow: apps.escrow,
    dig 5
    extract 152 8
    // smart_contracts/arc58/dao/contract.algo.ts:761
    // akitaNfd: apps.akitaNfd,
    dig 6
    extract 88 8
    // smart_contracts/arc58/dao/contract.algo.ts:762
    // poll: apps.poll
    uncover 7
    extract 160 8
    // smart_contracts/arc58/dao/contract.algo.ts:756-763
    // this.otherAppList.value = {
    //   vrfBeacon: apps.vrfBeacon,
    //   nfdRegistry: apps.nfdRegistry,
    //   assetInbox: apps.assetInbox,
    //   escrow: apps.escrow,
    //   akitaNfd: apps.akitaNfd,
    //   poll: apps.poll
    // }
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:756-763
    // this.otherAppList.value = {
    //   vrfBeacon: apps.vrfBeacon,
    //   nfdRegistry: apps.nfdRegistry,
    //   assetInbox: apps.assetInbox,
    //   escrow: apps.escrow,
    //   akitaNfd: apps.akitaNfd,
    //   poll: apps.poll
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:766
    // createFee: fees.walletCreateFee,
    dig 1
    extract 0 8
    // smart_contracts/arc58/dao/contract.algo.ts:767
    // referrerPercentage: fees.walletReferrerPercentage
    dig 2
    extract 8 8
    // smart_contracts/arc58/dao/contract.algo.ts:765-768
    // this.walletFees.value = {
    //   createFee: fees.walletCreateFee,
    //   referrerPercentage: fees.walletReferrerPercentage
    // }
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:44
    // walletFees = GlobalState<WalletFees>({ key: AkitaDAOGlobalStateKeysWalletFees })
    bytec 26 // "wallet_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:765-768
    // this.walletFees.value = {
    //   createFee: fees.walletCreateFee,
    //   referrerPercentage: fees.walletReferrerPercentage
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:771
    // postFee: fees.postFee,
    dig 1
    extract 16 8
    // smart_contracts/arc58/dao/contract.algo.ts:772
    // reactFee: fees.reactFee,
    dig 2
    extract 24 8
    // smart_contracts/arc58/dao/contract.algo.ts:773
    // impactTaxMin: fees.impactTaxMin,
    dig 3
    extract 32 8
    // smart_contracts/arc58/dao/contract.algo.ts:774
    // impactTaxMax: fees.impactTaxMax,
    dig 4
    extract 40 8
    // smart_contracts/arc58/dao/contract.algo.ts:770-775
    // this.socialFees.value = {
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // }
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:46
    // socialFees = GlobalState<SocialFees>({ key: AkitaDAOGlobalStateKeysSocialFees })
    bytec 27 // "social_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:770-775
    // this.socialFees.value = {
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:778
    // creationFee: fees.poolCreationFee,
    dig 1
    extract 48 8
    // smart_contracts/arc58/dao/contract.algo.ts:779
    // impactTaxMin: fees.poolImpactTaxMin,
    dig 2
    extract 56 8
    // smart_contracts/arc58/dao/contract.algo.ts:780
    // impactTaxMax: fees.poolImpactTaxMax
    dig 3
    extract 64 8
    // smart_contracts/arc58/dao/contract.algo.ts:777-781
    // this.stakingFees.value = {
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // }
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // stakingFees = GlobalState<StakingFees>({ key: AkitaDAOGlobalStateKeysStakingFees })
    bytec 28 // "staking_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:777-781
    // this.stakingFees.value = {
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:784
    // serviceCreationFee: fees.subscriptionServiceCreationFee,
    dig 1
    extract 72 8
    // smart_contracts/arc58/dao/contract.algo.ts:785
    // paymentPercentage: fees.subscriptionPaymentPercentage,
    dig 2
    extract 80 8
    // smart_contracts/arc58/dao/contract.algo.ts:786
    // triggerPercentage: fees.subscriptionTriggerPercentage,
    dig 3
    extract 88 8
    // smart_contracts/arc58/dao/contract.algo.ts:783-787
    // this.subscriptionFees.value = {
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // }
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:50
    // subscriptionFees = GlobalState<SubscriptionFees>({ key: AkitaDAOGlobalStateKeysSubscriptionFees })
    bytec 29 // "subscription_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:783-787
    // this.subscriptionFees.value = {
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:790
    // marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    dig 1
    extract 96 8
    // smart_contracts/arc58/dao/contract.algo.ts:791
    // marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    dig 2
    extract 104 8
    // smart_contracts/arc58/dao/contract.algo.ts:792
    // marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    dig 3
    extract 112 8
    // smart_contracts/arc58/dao/contract.algo.ts:793
    // marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    dig 4
    extract 120 8
    // smart_contracts/arc58/dao/contract.algo.ts:794
    // shuffleSalePercentage: fees.shuffleSalePercentage,
    dig 5
    extract 128 8
    // smart_contracts/arc58/dao/contract.algo.ts:795
    // omnigemSaleFee: fees.omnigemSaleFee,
    dig 6
    extract 136 8
    // smart_contracts/arc58/dao/contract.algo.ts:796
    // auctionCreationFee: fees.auctionCreationFee,
    dig 7
    extract 144 8
    // smart_contracts/arc58/dao/contract.algo.ts:797
    // auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    dig 8
    extract 152 8
    // smart_contracts/arc58/dao/contract.algo.ts:798
    // auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    dig 9
    extract 160 8
    // smart_contracts/arc58/dao/contract.algo.ts:799
    // auctionComposablePercentage: fees.auctionComposablePercentage,
    dig 10
    extract 168 8
    // smart_contracts/arc58/dao/contract.algo.ts:800
    // auctionRafflePercentage: fees.auctionRafflePercentage,
    dig 11
    extract 176 8
    // smart_contracts/arc58/dao/contract.algo.ts:801
    // raffleCreationFee: fees.raffleCreationFee,
    dig 12
    extract 184 8
    // smart_contracts/arc58/dao/contract.algo.ts:802
    // raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    dig 13
    extract 192 8
    // smart_contracts/arc58/dao/contract.algo.ts:803
    // raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    dig 14
    extract 200 8
    // smart_contracts/arc58/dao/contract.algo.ts:804
    // raffleComposablePercentage: fees.raffleComposablePercentage,
    dig 15
    extract 208 8
    // smart_contracts/arc58/dao/contract.algo.ts:789-805
    // this.nftFees.value = {
    //   marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    //   marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   shuffleSalePercentage: fees.shuffleSalePercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // }
    uncover 14
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:52
    // nftFees = GlobalState<NFTFees>({ key: AkitaDAOGlobalStateKeysNFTFees })
    bytec 30 // "nft_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:789-805
    // this.nftFees.value = {
    //   marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    //   marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   shuffleSalePercentage: fees.shuffleSalePercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:808
    // impactTaxMin: fees.swapFeeImpactTaxMin,
    dig 1
    extract 216 8
    // smart_contracts/arc58/dao/contract.algo.ts:809
    // impactTaxMax: fees.swapFeeImpactTaxMax,
    uncover 2
    extract 224 8
    // smart_contracts/arc58/dao/contract.algo.ts:807-810
    // this.swapFees.value = {
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // }
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:54
    // swapFees = GlobalState<SwapFees>({ key: AkitaDAOGlobalStateKeysSwapFees })
    bytec 31 // "swap_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:807-810
    // this.swapFees.value = {
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:812
    // this.upgradeAppProposalSettings.value = clone(proposalSettings.upgradeApp)
    dup
    extract 0 40
    // smart_contracts/arc58/dao/contract.algo.ts:60
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:812
    // this.upgradeAppProposalSettings.value = clone(proposalSettings.upgradeApp)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:813
    // this.addPluginProposalSettings.value = clone(proposalSettings.addPlugin)
    dup
    extract 40 40
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:813
    // this.addPluginProposalSettings.value = clone(proposalSettings.addPlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:814
    // this.removeExecutePluginProposalSettings.value = clone(proposalSettings.removeExecutePlugin)
    dup
    extract 80 40
    // smart_contracts/arc58/dao/contract.algo.ts:66
    // removeExecutePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveExecutePluginProposalSettings })
    bytec 47 // "remove_execute_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:814
    // this.removeExecutePluginProposalSettings.value = clone(proposalSettings.removeExecutePlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:815
    // this.removePluginProposalSettings.value = clone(proposalSettings.removePlugin)
    dup
    extract 120 40
    // smart_contracts/arc58/dao/contract.algo.ts:64
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:815
    // this.removePluginProposalSettings.value = clone(proposalSettings.removePlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:816
    // this.addAllowancesProposalSettings.value = clone(proposalSettings.addAllowance)
    dup
    extract 160 40
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:816
    // this.addAllowancesProposalSettings.value = clone(proposalSettings.addAllowance)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:817
    // this.removeAllowancesProposalSettings.value = clone(proposalSettings.removeAllowance)
    dup
    extract 200 40
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:817
    // this.removeAllowancesProposalSettings.value = clone(proposalSettings.removeAllowance)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:818
    // this.newEscrowProposalSettings.value = clone(proposalSettings.newEscrow)
    dup
    extract 240 40
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:818
    // this.newEscrowProposalSettings.value = clone(proposalSettings.newEscrow)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:819
    // this.updateFieldsProposalSettings.value = clone(proposalSettings.updateFields)
    pushints 280 40 // 280, 40
    extract3
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:819
    // this.updateFieldsProposalSettings.value = clone(proposalSettings.updateFields)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 35 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:821
    // this.proposalID.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:706
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.update[routing]() -> void:
update:
    // smart_contracts/arc58/dao/contract.algo.ts:852
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:854
    // assert(this.isValidUpgrade(Txn.lease, Global.currentApplicationId.id), ERR_INVALID_UPGRADE)
    txn Lease
    global CurrentApplicationID
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade
    assert // Invalid upgrade
    // smart_contracts/arc58/dao/contract.algo.ts:28
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 22 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:855
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:89
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 32 // "x"
    // smart_contracts/arc58/dao/contract.algo.ts:856
    // this.executions(Txn.lease).delete()
    txn Lease
    // smart_contracts/arc58/dao/contract.algo.ts:89
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:856
    // this.executions(Txn.lease).delete()
    box_del
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:852
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setup[routing]() -> void:
setup:
    // smart_contracts/arc58/dao/contract.algo.ts:859
    // setup(nickname: string): uint64 {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/arc58/dao/contract.algo.ts:860
    // assert(!this.wallet.hasValue, ERR_WALLET_ALREADY_SETUP)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:860
    // assert(!this.wallet.hasValue, ERR_WALLET_ALREADY_SETUP)
    app_global_get_ex
    bury 1
    !
    assert // Wallet already setup
    // smart_contracts/arc58/dao/contract.algo.ts:862
    // const { wallet: appId } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:862
    // const { wallet: appId } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    pushint 88 // 88
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:864
    // const cost = this.setupCost()
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost
    // smart_contracts/arc58/dao/contract.algo.ts:866-878
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:870
    // receiver: Application(appId).address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/arc58/dao/contract.algo.ts:869-872
    // itxn.payment({
    //   receiver: Application(appId).address,
    //   amount: cost,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/dao/contract.algo.ts:866-878
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/arc58/dao/contract.algo.ts:873
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/arc58/dao/contract.algo.ts:874
    // Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:876
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/arc58/dao/contract.algo.ts:866-878
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    pushbytes 0x37485541 // method "newAccount(pay,address,address,string,address)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    dup
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:880
    // this.wallet.value = Application(walletID)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:859
    // setup(nickname: string): uint64 {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.initialize[routing]() -> void:
initialize:
    // smart_contracts/arc58/dao/contract.algo.ts:886
    // assert(Txn.sender === Global.creatorAddress, ERR_FORBIDDEN)
    txn Sender
    global CreatorAddress
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:887
    // this.initialized.value = true
    intc_1 // 1
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:885
    // initialize(): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newProposalPreInitialized[routing]() -> void:
newProposalPreInitialized:
    // smart_contracts/arc58/dao/contract.algo.ts:892
    // newProposalPreInitialized(cid: CID, actions: ProposalAction[]): uint64 {
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    // smart_contracts/arc58/dao/contract.algo.ts:893
    // assert(this.initialized.value === false, ERR_ALREADY_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:893
    // assert(this.initialized.value === false, ERR_ALREADY_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Already initialized
    // smart_contracts/arc58/dao/contract.algo.ts:895
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:895
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:896
    // const { powerRequired } = this.proposalCost(actions)
    swap
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    swap
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:898
    // this.validateActions(actions)
    swap
    callsub validateActions
    // smart_contracts/arc58/dao/contract.algo.ts:900
    // return this.createOrUpdateProposal(0, cid, actions, origin, 0, powerRequired)
    intc_0 // 0
    uncover 4
    uncover 2
    uncover 4
    intc_0 // 0
    uncover 5
    callsub createOrUpdateProposal
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:892
    // newProposalPreInitialized(cid: CID, actions: ProposalAction[]): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newProposal[routing]() -> void:
newProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:903
    // newProposal(payment: gtxn.PaymentTxn, cid: CID, actions: ProposalAction[]): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    // smart_contracts/arc58/dao/contract.algo.ts:904
    // assert(this.initialized.value === true, ERR_ALREADY_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:904
    // assert(this.initialized.value === true, ERR_ALREADY_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // Already initialized
    // smart_contracts/arc58/dao/contract.algo.ts:906
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:906
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:907
    // const { totalFee, powerRequired } = this.proposalCost(actions)
    swap
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    dig 1
    intc_0 // 0
    extract_uint64
    uncover 2
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:909-916
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: totalFee
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 5
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:912
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:909-916
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: totalFee
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 6
    gtxns Amount
    dig 3
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:918
    // this.validateActions(actions)
    uncover 2
    callsub validateActions
    // smart_contracts/arc58/dao/contract.algo.ts:920
    // return this.createOrUpdateProposal(0, cid, actions, origin, totalFee, powerRequired)
    intc_0 // 0
    uncover 5
    uncover 2
    uncover 5
    uncover 5
    uncover 5
    callsub createOrUpdateProposal
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:903
    // newProposal(payment: gtxn.PaymentTxn, cid: CID, actions: ProposalAction[]): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.editProposal[routing]() -> void:
editProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:923
    // editProposal(id: uint64, cid: CID, actions: ProposalAction[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 3
    // smart_contracts/arc58/dao/contract.algo.ts:924
    // assert(this.validEditOrSubmit(id), ERR_INVALID_PROPOSAL_STATE)
    dig 2
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:926
    // const { feesPaid } = this.proposals(id).value
    dig 2
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:926
    // const { feesPaid } = this.proposals(id).value
    pushint 109 // 109
    intc_3 // 8
    box_extract
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:927
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:927
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:928
    // const { totalFee, powerRequired } = this.proposalCost(actions)
    uncover 2
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    dig 1
    intc_0 // 0
    extract_uint64
    uncover 2
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:930
    // assert(totalFee <= feesPaid, ERR_PAYMENT_REQUIRED)
    dig 1
    uncover 5
    <=
    assert // Payment required
    // smart_contracts/arc58/dao/contract.algo.ts:932
    // this.createOrUpdateProposal(id, cid, actions, origin, totalFee, powerRequired)
    uncover 5
    uncover 5
    uncover 4
    uncover 5
    uncover 5
    uncover 5
    callsub createOrUpdateProposal
    popn 2
    // smart_contracts/arc58/dao/contract.algo.ts:923
    // editProposal(id: uint64, cid: CID, actions: ProposalAction[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.editProposalWithPayment[routing]() -> void:
editProposalWithPayment:
    // smart_contracts/arc58/dao/contract.algo.ts:935
    // editProposalWithPayment(payment: gtxn.PaymentTxn, id: uint64, cid: CID, actions: ProposalAction[]): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 3
    // smart_contracts/arc58/dao/contract.algo.ts:936
    // assert(this.validEditOrSubmit(id), ERR_INVALID_PROPOSAL_STATE)
    dig 2
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:938
    // const { feesPaid } = this.proposals(id).value
    dig 2
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:938
    // const { feesPaid } = this.proposals(id).value
    pushint 109 // 109
    intc_3 // 8
    box_extract
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:939
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:939
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:940
    // const { totalFee, powerRequired } = this.proposalCost(actions)
    uncover 2
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    dig 1
    intc_0 // 0
    extract_uint64
    uncover 2
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:942
    // assert(totalFee > feesPaid, ERR_PAYMENT_NOT_REQUIRED)
    dig 1
    dig 5
    >
    assert // Payment not required
    // smart_contracts/arc58/dao/contract.algo.ts:944-951
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: totalFee - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 7
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:947
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:944-951
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: totalFee - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 8
    gtxns Amount
    // smart_contracts/arc58/dao/contract.algo.ts:948
    // amount: totalFee - feesPaid
    dig 3
    uncover 7
    -
    // smart_contracts/arc58/dao/contract.algo.ts:944-951
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: totalFee - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:953
    // this.createOrUpdateProposal(id, cid, actions, origin, totalFee, powerRequired)
    uncover 5
    uncover 5
    uncover 4
    uncover 5
    uncover 5
    uncover 5
    callsub createOrUpdateProposal
    popn 2
    // smart_contracts/arc58/dao/contract.algo.ts:935
    // editProposalWithPayment(payment: gtxn.PaymentTxn, id: uint64, cid: CID, actions: ProposalAction[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.deleteProposal[routing]() -> void:
deleteProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:956
    // deleteProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:957
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:957
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:959
    // const { status, creator } = this.proposals(proposalID).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    dup
    uncover 2
    pushints 61 32 // 61, 32
    box_extract
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:961
    // status === ProposalStatusDraft ||
    bytec_3 // 0x00
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:961-962
    // status === ProposalStatusDraft ||
    // status === ProposalStatusExecuted,
    bnz deleteProposal_bool_true@3
    // smart_contracts/arc58/dao/contract.algo.ts:962
    // status === ProposalStatusExecuted,
    dig 1
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:961-962
    // status === ProposalStatusDraft ||
    // status === ProposalStatusExecuted,
    bz deleteProposal_bool_false@4

deleteProposal_bool_true@3:
    intc_1 // 1

deleteProposal_bool_merge@5:
    // smart_contracts/arc58/dao/contract.algo.ts:960-964
    // assert(
    //   status === ProposalStatusDraft ||
    //   status === ProposalStatusExecuted,
    //   ERR_INVALID_PROPOSAL_STATE
    // )
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:966
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:966
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:967
    // assert(origin === creator, ERR_INCORRECT_SENDER)
    dig 1
    ==
    assert // Incorrect sender
    // smart_contracts/arc58/dao/contract.algo.ts:969
    // this.proposals(proposalID).delete()
    dig 2
    box_del
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:956
    // deleteProposal(proposalID: uint64): void {
    intc_1 // 1
    return

deleteProposal_bool_false@4:
    intc_0 // 0
    b deleteProposal_bool_merge@5


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.submitProposal[routing]() -> void:
submitProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:972
    // submitProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:973
    // assert(this.validEditOrSubmit(proposalID), ERR_INVALID_PROPOSAL_STATE)
    dup
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:975
    // this.proposals(proposalID).value.votingTs = Global.latestTimestamp
    global LatestTimestamp
    swap
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:975
    // this.proposals(proposalID).value.votingTs = Global.latestTimestamp
    swap
    itob
    dig 1
    pushint 93 // 93
    uncover 2
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:976
    // this.proposals(proposalID).value.status = ProposalStatusVoting
    intc_0 // 0
    bytec 6 // 0x14
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:972
    // submitProposal(proposalID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.voteProposal[routing]() -> void:
voteProposal:
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/arc58/dao/contract.algo.ts:979
    // voteProposal(mbrPayment: gtxn.PaymentTxn, proposalID: uint64, vote: ProposalVoteType): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 3
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    // smart_contracts/arc58/dao/contract.algo.ts:980
    // assert(this.initialized.value === true, ERR_ALREADY_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:980
    // assert(this.initialized.value === true, ERR_ALREADY_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // Already initialized
    // smart_contracts/arc58/dao/contract.algo.ts:981
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    dig 1
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:981
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:983-990
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:986
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:983-990
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 3
    gtxns Amount
    // smart_contracts/arc58/dao/contract.algo.ts:987
    // amount: DAOProposalVotesMBR,
    pushint 22500 // 22500
    // smart_contracts/arc58/dao/contract.algo.ts:983-990
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:992
    // const { status } = this.proposals(proposalID).value
    intc_0 // 0
    intc_1 // 1
    box_extract
    // smart_contracts/arc58/dao/contract.algo.ts:993
    // assert(status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATE)
    bytec 6 // 0x14
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:995
    // const voter = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:995
    // const voter = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    dup
    cover 2
    // smart_contracts/arc58/dao/contract.algo.ts:998
    // if (this.proposalVotes({ proposalID, voter }).exists) {
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:87
    // proposalVotes = BoxMap<ProposalVoteKey, ProposalVoteInfo>({ keyPrefix: AkitaDAOBoxPrefixProposalVotes })
    pushbytes "v"
    swap
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:998
    // if (this.proposalVotes({ proposalID, voter }).exists) {
    box_len
    bury 1
    bz voteProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:999
    // const { type, power: previousPower } = this.proposalVotes({ proposalID, voter }).value
    dup
    box_get
    assert // Box must have value
    extract 0 1
    dup
    bury 6
    // smart_contracts/arc58/dao/contract.algo.ts:1002
    // case ProposalVoteTypeApprove: {
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1002-1005
    // case ProposalVoteTypeApprove: {
    //   proposal.votes.approvals -= previousPower
    //   break;
    // }
    bnz voteProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:1006
    // case ProposalVoteTypeReject: {
    dig 4
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1006-1009
    // case ProposalVoteTypeReject: {
    //   proposal.votes.rejections -= previousPower
    //   break;
    // }
    bnz voteProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:1010
    // case ProposalVoteTypeAbstain: {
    dig 4
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1010-1013
    // case ProposalVoteTypeAbstain: {
    //   proposal.votes.abstains -= previousPower
    //   break;
    // }
    assert // Invalid proposal action

voteProposal_after_if_else@18:
    // smart_contracts/arc58/dao/contract.algo.ts:1020
    // const { staking } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:1020
    // const { staking } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1021
    // const { bones } = this.akitaAssets.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 10 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:1021
    // const { bones } = this.akitaAssets.value
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1022
    // const power = getStakingPower(staking, voter, bones)
    dig 3
    swap
    callsub getStakingPower
    dup
    bury 5
    // smart_contracts/arc58/dao/contract.algo.ts:1025
    // assert(power > 0, ERR_FORBIDDEN)
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:1028
    // case ProposalVoteTypeApprove: {
    dig 2
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1028-1031
    // case ProposalVoteTypeApprove: {
    //   proposal.votes.approvals += power
    //   break;
    // }
    bnz voteProposal_block@33
    // smart_contracts/arc58/dao/contract.algo.ts:1032
    // case ProposalVoteTypeReject: {
    dig 2
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1032-1035
    // case ProposalVoteTypeReject: {
    //   proposal.votes.rejections += power
    //   break;
    // }
    bnz voteProposal_block@33
    // smart_contracts/arc58/dao/contract.algo.ts:1036
    // case ProposalVoteTypeAbstain: {
    dig 2
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1036-1039
    // case ProposalVoteTypeAbstain: {
    //   proposal.votes.abstains += power
    //   break;
    // }
    assert // Invalid proposal action

voteProposal_block@33:
    // smart_contracts/arc58/dao/contract.algo.ts:1045
    // this.proposalVotes({ proposalID, voter }).value = { type: vote, power }
    dig 3
    itob
    dig 3
    swap
    concat
    dig 1
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:979
    // voteProposal(mbrPayment: gtxn.PaymentTxn, proposalID: uint64, vote: ProposalVoteType): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.finalizeProposal[routing]() -> void:
finalizeProposal:
    bytec_2 // ""
    dupn 7
    // smart_contracts/arc58/dao/contract.algo.ts:1048
    // finalizeProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1049
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1049
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1051
    // const { status, creator, votes: { approvals, rejections, abstains }, votingTs, actions } = clone(this.proposals(proposalID).value)
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    dig 1
    pushints 61 32 // 61, 32
    box_extract
    dig 2
    pushints 37 24 // 37, 24
    box_extract
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 5
    cover 5
    dup
    intc_3 // 8
    extract_uint64
    swap
    pushint 16 // 16
    extract_uint64
    uncover 4
    pushint 93 // 93
    intc_3 // 8
    box_extract
    btoi
    cover 5
    // smart_contracts/arc58/dao/contract.algo.ts:1053
    // assert(Txn.sender === creator, ERR_INCORRECT_SENDER)
    txn Sender
    uncover 3
    ==
    assert // Incorrect sender
    // smart_contracts/arc58/dao/contract.algo.ts:1054
    // assert(status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATE)
    uncover 2
    bytec 6 // 0x14
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1056
    // const bones = Asset(this.akitaAssets.value.bones)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 10 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:1056
    // const bones = Asset(this.akitaAssets.value.bones)
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1057
    // const nonCirculatingSupply = op.AssetHolding.assetBalance(this.wallet.value.address, bones)[0]
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:1057
    // const nonCirculatingSupply = op.AssetHolding.assetBalance(this.wallet.value.address, bones)[0]
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    dig 1
    asset_holding_get AssetBalance
    pop
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:1058
    // const circulatingSupply: uint64 = bones.total - nonCirculatingSupply
    asset_params_get AssetTotal
    assert // asset exists
    swap
    -
    cover 3
    // smart_contracts/arc58/dao/contract.algo.ts:1059
    // const totalVotes: uint64 = approvals + rejections + abstains
    uncover 2
    dig 2
    +
    dup
    cover 3
    +
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:1063
    // if (rejections > 0) {
    bz finalizeProposal_else_body@3
    // smart_contracts/utils/functions.ts:97
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    dig 4
    dup
    dig 3
    dup
    cover 3
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:98
    // return op.divw(...op.mulw(a, DIVISOR), b)
    intc 4 // 100000
    mulw
    uncover 2
    divw
    bury 14

finalizeProposal_after_if_else@4:
    // smart_contracts/arc58/dao/contract.algo.ts:1069
    // let highestDuration: uint64 = 0
    intc_0 // 0
    bury 11
    // smart_contracts/arc58/dao/contract.algo.ts:1070
    // let highestParticipation: uint64 = 0
    intc_0 // 0
    bury 10
    // smart_contracts/arc58/dao/contract.algo.ts:1071
    // let highestApproval: uint64 = 0
    intc_0 // 0
    bury 12
    // smart_contracts/arc58/dao/contract.algo.ts:1073
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0
    bury 9

finalizeProposal_while_top@5:
    // smart_contracts/arc58/dao/contract.algo.ts:1073
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dig 6
    pushint 119 // 119
    intc_2 // 2
    box_extract
    btoi
    dig 9
    >
    bz finalizeProposal_after_while@13
    // smart_contracts/arc58/dao/contract.algo.ts:1075
    // const { type, data } = actions[i]
    dig 6
    dup
    pushint 119 // 119
    intc_2 // 2
    box_extract
    btoi
    dig 10
    dup
    uncover 2
    <
    assert // index out of bounds
    intc_2 // 2
    dig 1
    *
    pushint 121 // 121
    +
    dig 2
    swap
    intc_2 // 2
    box_extract
    btoi
    pushint 121 // 121
    +
    uncover 2
    swap
    intc_1 // 1
    box_extract
    dig 7
    dup
    pushint 117 // 117
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 3
    intc_2 // 2
    *
    dig 2
    swap
    extract_uint16
    uncover 4
    intc_1 // 1
    +
    dup
    bury 14
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1077
    // const { duration, participation, approval } = this.getProposalSettings(type, data)
    callsub getProposalSettings
    dup
    pushint 16 // 16
    extract_uint64
    dup
    cover 2
    bury 15
    dup
    pushint 24 // 24
    extract_uint64
    bury 10
    pushint 32 // 32
    extract_uint64
    bury 16
    // smart_contracts/arc58/dao/contract.algo.ts:1079
    // if (duration > highestDuration) {
    dig 11
    >
    bz finalizeProposal_after_if_else@8
    dig 12
    bury 11

finalizeProposal_after_if_else@8:
    // smart_contracts/arc58/dao/contract.algo.ts:1083
    // if (participation > highestParticipation) {
    dig 7
    dig 10
    >
    bz finalizeProposal_after_if_else@10
    dig 7
    bury 10

finalizeProposal_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1087
    // if (approval > highestApproval) {
    dig 14
    dig 12
    >
    bz finalizeProposal_while_top@5
    dig 14
    bury 12
    b finalizeProposal_while_top@5

finalizeProposal_after_while@13:
    // smart_contracts/arc58/dao/contract.algo.ts:1092
    // assert(Global.latestTimestamp > (votingTs + highestDuration), ERR_VOTING_DURATION_NOT_MET)
    global LatestTimestamp
    dig 4
    dig 12
    +
    >
    assert // Voting duration not met
    // smart_contracts/utils/functions.ts:92
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dig 9
    dup
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:93
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 3
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/arc58/dao/contract.algo.ts:1095
    // assert(totalVotes >= participationThreshold, ERR_VOTING_PARTICIPATION_NOT_MET)
    dig 1
    <=
    assert // Voting participation not met
    // smart_contracts/arc58/dao/contract.algo.ts:1097
    // if (approvalPercentage >= highestApproval) {
    dig 13
    dig 12
    >=
    bz finalizeProposal_else_body@15
    // smart_contracts/arc58/dao/contract.algo.ts:1098
    // this.proposals(proposalID).value.status = ProposalStatusApproved
    dig 6
    intc_0 // 0
    bytec 7 // 0x28
    box_replace

finalizeProposal_after_if_else@16:
    // smart_contracts/arc58/dao/contract.algo.ts:1048
    // finalizeProposal(proposalID: uint64): void {
    intc_1 // 1
    return

finalizeProposal_else_body@15:
    // smart_contracts/arc58/dao/contract.algo.ts:1100
    // this.proposals(proposalID).value.status = ProposalStatusRejected
    dig 6
    intc_0 // 0
    bytec 13 // 0x1e
    box_replace
    b finalizeProposal_after_if_else@16

finalizeProposal_else_body@3:
    // smart_contracts/arc58/dao/contract.algo.ts:1066
    // approvalPercentage = ONE_HUNDRED_PERCENT
    intc 4 // 100000
    bury 14
    b finalizeProposal_after_if_else@4


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.executeProposal[routing]() -> void:
executeProposal:
    intc_0 // 0
    dupn 4
    bytec_2 // ""
    // smart_contracts/arc58/dao/contract.algo.ts:1104
    // executeProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1105
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1105
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1107
    // const { status, actions } = clone(this.proposals(proposalID).value)
    dup
    box_get
    pop
    swap
    intc_0 // 0
    intc_1 // 1
    box_extract
    // smart_contracts/arc58/dao/contract.algo.ts:1109
    // assert(status === ProposalStatusApproved, ERR_INVALID_PROPOSAL_STATE)
    bytec 7 // 0x28
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1111
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0

executeProposal_while_top@2:
    // smart_contracts/arc58/dao/contract.algo.ts:1111
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dig 2
    pushint 119 // 119
    intc_2 // 2
    box_extract
    btoi
    dig 1
    >
    bz executeProposal_after_while@52
    // smart_contracts/arc58/dao/contract.algo.ts:1113
    // const { type, data } = actions[i]
    dig 2
    dup
    pushint 119 // 119
    intc_2 // 2
    box_extract
    btoi
    dig 2
    dup
    uncover 2
    <
    assert // index out of bounds
    intc_2 // 2
    dig 1
    *
    pushint 121 // 121
    +
    dig 2
    swap
    intc_2 // 2
    box_extract
    btoi
    pushint 121 // 121
    +
    uncover 2
    swap
    intc_1 // 1
    box_extract
    dup
    cover 2
    bury 9
    dig 3
    dup
    pushint 117 // 117
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 2
    intc_2 // 2
    *
    dig 2
    swap
    extract_uint16
    uncover 3
    intc_1 // 1
    +
    dup
    bury 10
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    bury 12
    extract 2 0
    bury 10
    // smart_contracts/arc58/dao/contract.algo.ts:1116
    // case ProposalActionTypeUpgradeApp:
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1116-1121
    // case ProposalActionTypeUpgradeApp:
    //   const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(data)
    //   // track the proposal that created the execution by lease so they can be verified without explicit proposal id being provided
    //   this.executions(executionKey).value = { proposalID, index: i }
    //   this.newExecution(executionKey, groups, firstValid, lastValid)
    //   break
    bz executeProposal_after_if_else@6
    // smart_contracts/arc58/dao/contract.algo.ts:1117
    // const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(data)
    dig 9
    dup
    extract 10 32
    dig 10
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    dig 2
    pushint 44 // 44
    extract_uint64
    uncover 3
    pushint 52 // 52
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1119
    // this.executions(executionKey).value = { proposalID, index: i }
    dig 4
    itob
    dig 8
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:89
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 32 // "x"
    dig 5
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1119
    // this.executions(executionKey).value = { proposalID, index: i }
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:1120
    // this.newExecution(executionKey, groups, firstValid, lastValid)
    callsub newExecution
    pop

executeProposal_block@51:
    dig 4
    bury 1
    b executeProposal_while_top@2

executeProposal_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1122
    // case ProposalActionTypeExecutePlugin: {
    dig 6
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1122-1126
    // case ProposalActionTypeExecutePlugin: {
    //   const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalExecutePlugin>(data)
    //   this.newExecution(executionKey, groups, firstValid, lastValid)
    //   break
    // }
    bz executeProposal_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:1123
    // const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalExecutePlugin>(data)
    dig 9
    dup
    extract 12 32
    dig 10
    dup
    pushint 42 // 42
    extract_uint16
    dig 1
    len
    substring3
    dig 2
    pushint 46 // 46
    extract_uint64
    uncover 3
    pushint 54 // 54
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1124
    // this.newExecution(executionKey, groups, firstValid, lastValid)
    callsub newExecution
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1125
    // break
    b executeProposal_block@51

executeProposal_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1127
    // case ProposalActionTypeRemoveExecutePlugin: {
    dig 6
    bytec 36 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1127-1131
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(data)
    //   this.removeExecution(executionKey)
    //   break
    // }
    bz executeProposal_after_if_else@14
    // smart_contracts/arc58/dao/contract.algo.ts:1128
    // const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(data)
    dig 9
    extract 2 32
    // smart_contracts/arc58/dao/contract.algo.ts:692-695
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:693
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:693
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:694
    // args: [key]
    dig 1
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:692-695
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key]
    // })
    pushbytes 0xd58685af // method "arc58_removeExecutionKey(byte[32])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:1130
    // break
    b executeProposal_block@51

executeProposal_after_if_else@14:
    // smart_contracts/arc58/dao/contract.algo.ts:1132
    // case ProposalActionTypeAddPlugin: {
    dig 6
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1132-1135
    // case ProposalActionTypeAddPlugin: {
    //   this.addPlugin({ name: '', ...decodeArc4<ProposalAddPlugin>(data) })
    //   break
    // }
    bz executeProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:1133
    // this.addPlugin({ name: '', ...decodeArc4<ProposalAddPlugin>(data) })
    dig 9
    dup
    extract 2 8
    dig 1
    extract 10 32
    dig 11
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    pushint 59 // 59
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 5
    extract 44 1
    dig 6
    extract 45 8
    dig 7
    extract 53 8
    dig 5
    pushint 102 // 102
    extract_uint16
    dig 6
    uncover 6
    dig 2
    substring3
    dig 6
    pushint 488 // 488
    getbit
    dig 7
    pushint 489 // 489
    getbit
    dig 8
    pushint 490 // 490
    getbit
    dig 12
    extract 64 8
    dig 13
    extract 72 8
    dig 14
    extract 80 8
    dig 15
    extract 88 8
    uncover 16
    extract 96 8
    dig 14
    pushint 104 // 104
    extract_uint16
    dig 15
    uncover 11
    dig 2
    substring3
    extract 2 0
    dig 15
    len
    uncover 16
    uncover 3
    uncover 2
    substring3
    pushbytes 0x006c
    uncover 17
    concat
    uncover 16
    concat
    dig 15
    len
    itob
    extract 6 2
    uncover 16
    concat
    swap
    pushbytes 0x006e
    concat
    dig 1
    len
    pushint 110 // 110
    +
    swap
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    dig 1
    itob
    extract 6 2
    concat
    dig 13
    len
    uncover 2
    +
    bytec_3 // 0x00
    intc_0 // 0
    uncover 14
    setbit
    intc_1 // 1
    uncover 13
    setbit
    intc_2 // 2
    uncover 12
    setbit
    uncover 2
    swap
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    dig 2
    itob
    extract 6 2
    uncover 2
    swap
    concat
    dig 1
    len
    uncover 3
    +
    itob
    extract 6 2
    concat
    bytec 37 // 0x0000
    concat
    uncover 2
    concat
    uncover 3
    concat
    swap
    concat
    swap
    concat
    callsub addPlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1134
    // break
    b executeProposal_block@51

executeProposal_after_if_else@18:
    // smart_contracts/arc58/dao/contract.algo.ts:1136
    // case ProposalActionTypeAddNamedPlugin: {
    dig 6
    bytec 33 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1136-1139
    // case ProposalActionTypeAddNamedPlugin: {
    //   this.addPlugin(decodeArc4<ProposalAddNamedPlugin>(data))
    //   break
    // }
    bz executeProposal_after_if_else@22
    // smart_contracts/arc58/dao/contract.algo.ts:1137
    // this.addPlugin(decodeArc4<ProposalAddNamedPlugin>(data))
    dig 8
    callsub addPlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1138
    // break
    b executeProposal_block@51

executeProposal_after_if_else@22:
    // smart_contracts/arc58/dao/contract.algo.ts:1140
    // case ProposalActionTypeRemovePlugin: {
    dig 6
    bytec 7 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1140-1143
    // case ProposalActionTypeRemovePlugin: {
    //   this.removePlugin({ name: '', ...decodeArc4<ProposalRemovePlugin>(data) })
    //   break
    // }
    bz executeProposal_after_if_else@26
    // smart_contracts/arc58/dao/contract.algo.ts:1141
    // this.removePlugin({ name: '', ...decodeArc4<ProposalRemovePlugin>(data) })
    dig 9
    dup
    extract 2 8
    swap
    extract 10 32
    dig 10
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    pushbytes 0x002c
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    pushbytes 0x002e0000
    concat
    swap
    concat
    callsub removePlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1142
    // break
    b executeProposal_block@51

executeProposal_after_if_else@26:
    // smart_contracts/arc58/dao/contract.algo.ts:1144
    // case ProposalActionTypeRemoveNamedPlugin: {
    dig 6
    bytec 38 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1144-1147
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   this.removePlugin(decodeArc4<ProposalRemoveNamedPlugin>(data))
    //   break
    // }
    bz executeProposal_after_if_else@30
    // smart_contracts/arc58/dao/contract.algo.ts:1145
    // this.removePlugin(decodeArc4<ProposalRemoveNamedPlugin>(data))
    dig 8
    callsub removePlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1146
    // break
    b executeProposal_block@51

executeProposal_after_if_else@30:
    // smart_contracts/arc58/dao/contract.algo.ts:1148
    // case ProposalActionTypeAddAllowances: {
    dig 6
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1148-1152
    // case ProposalActionTypeAddAllowances: {
    //   const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(data)
    //   this.addAllowances(escrow, allowances)
    //   break
    // }
    bz executeProposal_after_if_else@34
    // smart_contracts/arc58/dao/contract.algo.ts:1149
    // const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:1150
    // this.addAllowances(escrow, allowances)
    callsub addAllowances
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1151
    // break
    b executeProposal_block@51

executeProposal_after_if_else@34:
    // smart_contracts/arc58/dao/contract.algo.ts:1153
    // case ProposalActionTypeRemoveAllowances: {
    dig 6
    bytec 39 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1153-1157
    // case ProposalActionTypeRemoveAllowances: {
    //   const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(data)
    //   this.removeAllowances(escrow, assets)
    //   break
    // }
    bz executeProposal_after_if_else@38
    // smart_contracts/arc58/dao/contract.algo.ts:1154
    // const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:542-545
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:543
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:543
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:542-545
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // })
    pushbytes 0xd5dd382b // method "arc58_removeAllowances(string,uint64[])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:1156
    // break
    b executeProposal_block@51

executeProposal_after_if_else@38:
    // smart_contracts/arc58/dao/contract.algo.ts:1158
    // case ProposalActionTypeNewEscrow: {
    dig 6
    bytec 40 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1158-1162
    // case ProposalActionTypeNewEscrow: {
    //   const { escrow } = decodeArc4<ProposalNewEscrow>(data)
    //   this.newEscrow(escrow)
    //   break
    // }
    bz executeProposal_after_if_else@42
    // smart_contracts/arc58/dao/contract.algo.ts:1159
    // const { escrow } = decodeArc4<ProposalNewEscrow>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:570-573
    // return abiCall<typeof AbstractedAccount.prototype.arc58_newEscrow>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:571
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:571
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:570-573
    // return abiCall<typeof AbstractedAccount.prototype.arc58_newEscrow>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    pushbytes 0x0a8cb2c2 // method "arc58_newEscrow(string)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1161
    // break
    b executeProposal_block@51

executeProposal_after_if_else@42:
    // smart_contracts/arc58/dao/contract.algo.ts:1163
    // case ProposalActionTypeToggleEscrowLock: {
    dig 6
    bytec 41 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1163-1167
    // case ProposalActionTypeToggleEscrowLock: {
    //   const { escrow } = decodeArc4<ProposalToggleEscrowLock>(data)
    //   this.toggleEscrowLock(escrow)
    //   break
    // }
    bz executeProposal_after_if_else@46
    // smart_contracts/arc58/dao/contract.algo.ts:1164
    // const { escrow } = decodeArc4<ProposalToggleEscrowLock>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:577-580
    // return abiCall<typeof AbstractedAccount.prototype.arc58_toggleEscrowLock>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:578
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:578
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:577-580
    // return abiCall<typeof AbstractedAccount.prototype.arc58_toggleEscrowLock>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    pushbytes 0x25b713ca // method "arc58_toggleEscrowLock(string)(uint64,bool)"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 9 // 9
    ==
    assert // invalid number of bytes for (uint64,bool1)
    // smart_contracts/arc58/dao/contract.algo.ts:1166
    // break
    b executeProposal_block@51

executeProposal_after_if_else@46:
    // smart_contracts/arc58/dao/contract.algo.ts:1168
    // case ProposalActionTypeUpdateFields: {
    dig 6
    bytec 42 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1168-1172
    // case ProposalActionTypeUpdateFields: {
    //   const { field, value } = decodeArc4<ProposalUpdateField>(data)
    //   this.updateField(field, value)
    //   break
    // }
    bz executeProposal_block@51
    // smart_contracts/arc58/dao/contract.algo.ts:1169
    // const { field, value } = decodeArc4<ProposalUpdateField>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dup
    cover 3
    bury 11
    dig 1
    len
    substring3
    extract 2 0
    bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:585
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    bytec 23 // "content_policy"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:585-588
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    //   this.contentPolicy.value = value.toFixed({ length: 36 })
    //   break
    // }
    bz executeProposal_after_if_else@55
    // smart_contracts/arc58/dao/contract.algo.ts:586
    // this.contentPolicy.value = value.toFixed({ length: 36 })
    dig 5
    dup
    len
    pushint 36 // 36
    ==
    assert // Length must be 36
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // contentPolicy = GlobalState<CID>({ key: AkitaDAOGlobalStateKeysContentPolicy })
    bytec 23 // "content_policy"
    // smart_contracts/arc58/dao/contract.algo.ts:586
    // this.contentPolicy.value = value.toFixed({ length: 36 })
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:587
    // break
    b executeProposal_block@51

executeProposal_after_if_else@55:
    // smart_contracts/arc58/dao/contract.algo.ts:589
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    dig 7
    bytec 14 // "proposal_action_limit"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:589-592
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //   this.proposalActionLimit.value = btoi(value)
    //   break
    // }
    bz executeProposal_after_if_else@57
    // smart_contracts/arc58/dao/contract.algo.ts:590
    // this.proposalActionLimit.value = btoi(value)
    dig 5
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 14 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:590
    // this.proposalActionLimit.value = btoi(value)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:591
    // break
    b executeProposal_block@51

executeProposal_after_if_else@57:
    // smart_contracts/arc58/dao/contract.algo.ts:593
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    dig 7
    bytec 24 // "min_rewards_impact"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:593-596
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //   this.minRewardsImpact.value = btoi(value)
    //   break
    // }
    bz executeProposal_after_if_else@59
    // smart_contracts/arc58/dao/contract.algo.ts:594
    // this.minRewardsImpact.value = btoi(value)
    dig 5
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:36
    // minRewardsImpact = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysMinRewardsImpact })
    bytec 24 // "min_rewards_impact"
    // smart_contracts/arc58/dao/contract.algo.ts:594
    // this.minRewardsImpact.value = btoi(value)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:595
    // break
    b executeProposal_block@51

executeProposal_after_if_else@59:
    // smart_contracts/arc58/dao/contract.algo.ts:597
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    dig 7
    bytec 8 // "akita_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:597-601
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    //   const akitaAppList = decodeArc4<AkitaAppList>(value)
    //   this.akitaAppList.value = clone(akitaAppList)
    //   break
    // }
    bz executeProposal_after_if_else@61
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:599
    // this.akitaAppList.value = clone(akitaAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:600
    // break
    b executeProposal_block@51

executeProposal_after_if_else@61:
    // smart_contracts/arc58/dao/contract.algo.ts:602
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    dig 7
    bytec 25 // "plugn_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:602-606
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    //   const pluginAppList = decodeArc4<PluginAppList>(value)
    //   this.pluginAppList.value = clone(pluginAppList)
    //   break
    // }
    bz executeProposal_after_if_else@63
    // smart_contracts/arc58/dao/contract.algo.ts:40
    // pluginAppList = GlobalState<PluginAppList>({ key: AkitaDAOGlobalStateKeysPluginAppList })
    bytec 25 // "plugn_al"
    // smart_contracts/arc58/dao/contract.algo.ts:604
    // this.pluginAppList.value = clone(pluginAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:605
    // break
    b executeProposal_block@51

executeProposal_after_if_else@63:
    // smart_contracts/arc58/dao/contract.algo.ts:607
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    dig 7
    bytec 5 // "other_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:607-611
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    //   const otherAppList = decodeArc4<OtherAppList>(value)
    //   this.otherAppList.value = clone(otherAppList)
    //   break
    // }
    bz executeProposal_after_if_else@65
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:609
    // this.otherAppList.value = clone(otherAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:610
    // break
    b executeProposal_block@51

executeProposal_after_if_else@65:
    // smart_contracts/arc58/dao/contract.algo.ts:612
    // case AkitaDAOGlobalStateKeysWalletFees: {
    dig 7
    bytec 26 // "wallet_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:612-616
    // case AkitaDAOGlobalStateKeysWalletFees: {
    //   const walletFees = decodeArc4<WalletFees>(value)
    //   this.walletFees.value = clone(walletFees)
    //   break
    // }
    bz executeProposal_after_if_else@67
    // smart_contracts/arc58/dao/contract.algo.ts:44
    // walletFees = GlobalState<WalletFees>({ key: AkitaDAOGlobalStateKeysWalletFees })
    bytec 26 // "wallet_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:614
    // this.walletFees.value = clone(walletFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:615
    // break
    b executeProposal_block@51

executeProposal_after_if_else@67:
    // smart_contracts/arc58/dao/contract.algo.ts:617
    // case AkitaDAOGlobalStateKeysSocialFees: {
    dig 7
    bytec 27 // "social_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:617-621
    // case AkitaDAOGlobalStateKeysSocialFees: {
    //   const socialFees = decodeArc4<SocialFees>(value)
    //   this.socialFees.value = clone(socialFees)
    //   break
    // }
    bz executeProposal_after_if_else@69
    // smart_contracts/arc58/dao/contract.algo.ts:46
    // socialFees = GlobalState<SocialFees>({ key: AkitaDAOGlobalStateKeysSocialFees })
    bytec 27 // "social_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:619
    // this.socialFees.value = clone(socialFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:620
    // break
    b executeProposal_block@51

executeProposal_after_if_else@69:
    // smart_contracts/arc58/dao/contract.algo.ts:622
    // case AkitaDAOGlobalStateKeysStakingFees: {
    dig 7
    bytec 28 // "staking_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:622-626
    // case AkitaDAOGlobalStateKeysStakingFees: {
    //   const stakingFees = decodeArc4<StakingFees>(value)
    //   this.stakingFees.value = clone(stakingFees)
    //   break
    // }
    bz executeProposal_after_if_else@71
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // stakingFees = GlobalState<StakingFees>({ key: AkitaDAOGlobalStateKeysStakingFees })
    bytec 28 // "staking_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:624
    // this.stakingFees.value = clone(stakingFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:625
    // break
    b executeProposal_block@51

executeProposal_after_if_else@71:
    // smart_contracts/arc58/dao/contract.algo.ts:627
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    dig 7
    bytec 29 // "subscription_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:627-631
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //   const subscriptionFees = decodeArc4<SubscriptionFees>(value)
    //   this.subscriptionFees.value = clone(subscriptionFees)
    //   break
    // }
    bz executeProposal_after_if_else@73
    // smart_contracts/arc58/dao/contract.algo.ts:50
    // subscriptionFees = GlobalState<SubscriptionFees>({ key: AkitaDAOGlobalStateKeysSubscriptionFees })
    bytec 29 // "subscription_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:629
    // this.subscriptionFees.value = clone(subscriptionFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:630
    // break
    b executeProposal_block@51

executeProposal_after_if_else@73:
    // smart_contracts/arc58/dao/contract.algo.ts:632
    // case AkitaDAOGlobalStateKeysNFTFees: {
    dig 7
    bytec 30 // "nft_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:632-636
    // case AkitaDAOGlobalStateKeysNFTFees: {
    //   const nftFees = decodeArc4<NFTFees>(value)
    //   this.nftFees.value = clone(nftFees)
    //   break
    // }
    bz executeProposal_after_if_else@75
    // smart_contracts/arc58/dao/contract.algo.ts:52
    // nftFees = GlobalState<NFTFees>({ key: AkitaDAOGlobalStateKeysNFTFees })
    bytec 30 // "nft_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:634
    // this.nftFees.value = clone(nftFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:635
    // break
    b executeProposal_block@51

executeProposal_after_if_else@75:
    // smart_contracts/arc58/dao/contract.algo.ts:637
    // case AkitaDAOGlobalStateKeysSwapFees: {
    dig 7
    bytec 31 // "swap_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:637-641
    // case AkitaDAOGlobalStateKeysSwapFees: {
    //   const swapFees = decodeArc4<SwapFees>(value)
    //   this.swapFees.value = clone(swapFees)
    //   break
    // }
    bz executeProposal_after_if_else@77
    // smart_contracts/arc58/dao/contract.algo.ts:54
    // swapFees = GlobalState<SwapFees>({ key: AkitaDAOGlobalStateKeysSwapFees })
    bytec 31 // "swap_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:639
    // this.swapFees.value = clone(swapFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:640
    // break
    b executeProposal_block@51

executeProposal_after_if_else@77:
    // smart_contracts/arc58/dao/contract.algo.ts:642
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    dig 7
    bytec 10 // "akita_assets"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:642-645
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    //   this.akitaAssets.value = decodeArc4<AkitaAssets>(value)
    //   break
    // }
    bz executeProposal_after_if_else@79
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 10 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:643
    // this.akitaAssets.value = decodeArc4<AkitaAssets>(value)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:644
    // break
    b executeProposal_block@51

executeProposal_after_if_else@79:
    // smart_contracts/arc58/dao/contract.algo.ts:646
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings: {
    dig 7
    bytec 15 // "upgrade_app_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:646-650
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings: {
    //   const upgradeAppSettings = decodeArc4<ProposalSettings>(value)
    //   this.upgradeAppProposalSettings.value = clone(upgradeAppSettings)
    //   break
    // }
    bz executeProposal_after_if_else@81
    // smart_contracts/arc58/dao/contract.algo.ts:60
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:648
    // this.upgradeAppProposalSettings.value = clone(upgradeAppSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:649
    // break
    b executeProposal_block@51

executeProposal_after_if_else@81:
    // smart_contracts/arc58/dao/contract.algo.ts:651
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings: {
    dig 7
    bytec 16 // "add_plugin_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:651-655
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings: {
    //   const addPluginSettings = decodeArc4<ProposalSettings>(value)
    //   this.addPluginProposalSettings.value = clone(addPluginSettings)
    //   break
    // }
    bz executeProposal_after_if_else@83
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:653
    // this.addPluginProposalSettings.value = clone(addPluginSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:654
    // break
    b executeProposal_block@51

executeProposal_after_if_else@83:
    // smart_contracts/arc58/dao/contract.algo.ts:656
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings: {
    dig 7
    bytec 17 // "remove_plugin_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:656-660
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings: {
    //   const removePluginSettings = decodeArc4<ProposalSettings>(value)
    //   this.removePluginProposalSettings.value = clone(removePluginSettings)
    //   break
    // }
    bz executeProposal_after_if_else@85
    // smart_contracts/arc58/dao/contract.algo.ts:64
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:658
    // this.removePluginProposalSettings.value = clone(removePluginSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:659
    // break
    b executeProposal_block@51

executeProposal_after_if_else@85:
    // smart_contracts/arc58/dao/contract.algo.ts:661
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings: {
    dig 7
    bytec 18 // "add_allowance_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:661-665
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings: {
    //   const addAllowanceSettings = decodeArc4<ProposalSettings>(value)
    //   this.addAllowancesProposalSettings.value = clone(addAllowanceSettings)
    //   break
    // }
    bz executeProposal_after_if_else@87
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:663
    // this.addAllowancesProposalSettings.value = clone(addAllowanceSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:664
    // break
    b executeProposal_block@51

executeProposal_after_if_else@87:
    // smart_contracts/arc58/dao/contract.algo.ts:666
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings: {
    dig 7
    bytec 19 // "remove_allowance_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:666-670
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings: {
    //   const removeAllowanceSettings = decodeArc4<ProposalSettings>(value)
    //   this.removeAllowancesProposalSettings.value = clone(removeAllowanceSettings)
    //   break
    // }
    bz executeProposal_after_if_else@89
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:668
    // this.removeAllowancesProposalSettings.value = clone(removeAllowanceSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:669
    // break
    b executeProposal_block@51

executeProposal_after_if_else@89:
    // smart_contracts/arc58/dao/contract.algo.ts:671
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings: {
    dig 7
    bytec 20 // "new_escrow_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:671-675
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings: {
    //   const newEscrowSettings = decodeArc4<ProposalSettings>(value)
    //   this.newEscrowProposalSettings.value = clone(newEscrowSettings)
    //   break
    // }
    bz executeProposal_after_if_else@91
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:673
    // this.newEscrowProposalSettings.value = clone(newEscrowSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:674
    // break
    b executeProposal_block@51

executeProposal_after_if_else@91:
    // smart_contracts/arc58/dao/contract.algo.ts:676
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    dig 7
    bytec 21 // "update_fields_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:676-680
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //   const updateFieldsSettings = decodeArc4<ProposalSettings>(value)
    //   this.updateFieldsProposalSettings.value = clone(updateFieldsSettings)
    //   break
    // }
    bz executeProposal_block@51
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:678
    // this.updateFieldsProposalSettings.value = clone(updateFieldsSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:679
    // break
    b executeProposal_block@51

executeProposal_after_while@52:
    // smart_contracts/arc58/dao/contract.algo.ts:1176
    // this.proposals(proposalID).value.status = ProposalStatusExecuted
    dig 2
    intc_0 // 0
    bytec 11 // 0x32
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:1104
    // executeProposal(proposalID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.deleteProposalVotes[routing]() -> void:
deleteProposalVotes:
    bytec_2 // ""
    // smart_contracts/arc58/dao/contract.algo.ts:1179
    // deleteProposalVotes(proposalID: uint64, voters: Account[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 32 // 32
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/arc58/dao/contract.algo.ts:1180
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1180
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1182
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 7 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1182-1183
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    bnz deleteProposalVotes_bool_true@4
    // smart_contracts/arc58/dao/contract.algo.ts:1183
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1182-1183
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    bnz deleteProposalVotes_bool_true@4
    // smart_contracts/arc58/dao/contract.algo.ts:1184
    // this.proposals(proposalID).value.status === ProposalStatusExecuted,
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1182-1184
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    // this.proposals(proposalID).value.status === ProposalStatusExecuted,
    bz deleteProposalVotes_bool_false@5

deleteProposalVotes_bool_true@4:
    intc_1 // 1

deleteProposalVotes_bool_merge@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1181-1186
    // assert(
    //   this.proposals(proposalID).value.status === ProposalStatusApproved ||
    //   this.proposals(proposalID).value.status === ProposalStatusRejected ||
    //   this.proposals(proposalID).value.status === ProposalStatusExecuted,
    //   ERR_INVALID_PROPOSAL_STATE
    // )
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1188
    // for (let i: uint64 = 0; i < voters.length; i++) {
    intc_0 // 0
    bury 5

deleteProposalVotes_while_top@7:
    // smart_contracts/arc58/dao/contract.algo.ts:1188
    // for (let i: uint64 = 0; i < voters.length; i++) {
    dig 4
    dig 3
    <
    bz deleteProposalVotes_after_while@9
    // smart_contracts/arc58/dao/contract.algo.ts:1189
    // assert(this.proposalVotes({ proposalID, voter: voters[i] }).exists, ERR_PROPOSAL_VOTE_NOT_FOUND)
    dig 3
    extract 2 0
    dig 5
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dig 3
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:87
    // proposalVotes = BoxMap<ProposalVoteKey, ProposalVoteInfo>({ keyPrefix: AkitaDAOBoxPrefixProposalVotes })
    pushbytes "v"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1189
    // assert(this.proposalVotes({ proposalID, voter: voters[i] }).exists, ERR_PROPOSAL_VOTE_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Proposal Vote not found
    // smart_contracts/arc58/dao/contract.algo.ts:1190
    // this.proposalVotes({ proposalID, voter: voters[i] }).delete()
    box_del
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1188
    // for (let i: uint64 = 0; i < voters.length; i++) {
    intc_1 // 1
    +
    bury 5
    b deleteProposalVotes_while_top@7

deleteProposalVotes_after_while@9:
    // smart_contracts/arc58/dao/contract.algo.ts:1179
    // deleteProposalVotes(proposalID: uint64, voters: Account[]): void {
    intc_1 // 1
    return

deleteProposalVotes_bool_false@5:
    intc_0 // 0
    b deleteProposalVotes_bool_merge@6


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost[routing]() -> void:
setupCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1194
    // @abimethod({ readonly: true })
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost[routing]() -> void:
proposalCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1200
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    pop
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposal[routing]() -> void:
getProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:1231
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1233
    // if (this.proposals(proposalID).exists) {
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:1233
    // if (this.proposals(proposalID).exists) {
    box_len
    bury 1
    bz getProposal_else_body@3
    // smart_contracts/arc58/dao/contract.algo.ts:1234
    // return this.proposals(proposalID).value
    dup
    box_get
    assert // Box must have value

getProposal_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposal@4:
    // smart_contracts/arc58/dao/contract.algo.ts:1231
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getProposal_else_body@3:
    // smart_contracts/arc58/dao/contract.algo.ts:1236-1249
    // return {
    //   status: uint8(0),
    //   cid: op.bzero(36).toFixed({ length: 36 }),
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Global.zeroAddress,
    //   votingTs: 0,
    //   created: 0,
    //   feesPaid: 0,
    //   actions: []
    // }
    pushbytes base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5YAAA)
    // smart_contracts/arc58/dao/contract.algo.ts:1231
    // @abimethod({ readonly: true })
    b getProposal_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposal@4


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.mustGetExecution[routing]() -> void:
mustGetExecution:
    // smart_contracts/arc58/dao/contract.algo.ts:1253
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/dao/contract.algo.ts:89
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 32 // "x"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1255
    // assert(this.executions(lease).exists, ERR_EXECUTION_KEY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Execution key not found
    // smart_contracts/arc58/dao/contract.algo.ts:1256
    // return this.executions(lease).value
    box_get
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1253
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade[routing]() -> void:
isValidUpgrade:
    // smart_contracts/arc58/dao/contract.algo.ts:1259
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalUpgradeAppShape[routing]() -> void:
proposalUpgradeAppShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1293
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalAddPluginShape[routing]() -> void:
proposalAddPluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1298
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalAddNamedPluginShape[routing]() -> void:
proposalAddNamedPluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1303
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalRemovePluginShape[routing]() -> void:
proposalRemovePluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1308
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalRemoveNamedPluginShape[routing]() -> void:
proposalRemoveNamedPluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1313
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalExecutePluginShape[routing]() -> void:
proposalExecutePluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1318
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalExecuteNamedPluginShape[routing]() -> void:
proposalExecuteNamedPluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1323
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalRemoveExecutePluginShape[routing]() -> void:
proposalRemoveExecutePluginShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1328
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for (uint8[32])
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalAddAllowancesShape[routing]() -> void:
proposalAddAllowancesShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1333
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalRemoveAllowancesShape[routing]() -> void:
proposalRemoveAllowancesShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1338
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalNewEscrowShape[routing]() -> void:
proposalNewEscrowShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1343
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalToggleEscrowLockShape[routing]() -> void:
proposalToggleEscrowLockShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1348
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalUpdateFieldShape[routing]() -> void:
proposalUpdateFieldShape:
    // smart_contracts/arc58/dao/contract.algo.ts:1353
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    txna ApplicationArgs 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.pluginExists(key: bytes) -> uint64, bytes:
pluginExists:
    // smart_contracts/arc58/dao/contract.algo.ts:105
    // private pluginExists(key: PluginKey): boolean {
    proto 1 2
    // smart_contracts/arc58/dao/contract.algo.ts:106-109
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:107
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:107
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:108
    // args: [[key]]
    bytec 34 // 0x00010002
    frame_dig -1
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:106-109
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    bytec 48 // method "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:111
    // return info.start !== 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    uncover 2
    select
    substring3
    pushint 36 // 36
    extract_uint64
    intc_0 // 0
    !=
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.namedPluginExists(name: bytes) -> uint64:
namedPluginExists:
    // smart_contracts/arc58/dao/contract.algo.ts:121
    // private namedPluginExists(name: string): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:122-125
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getNamedPlugins>({
    //   appId: this.wallet.value,
    //   args: [[name]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:123
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:123
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:124
    // args: [[name]]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 34 // 0x00010002
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:122-125
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getNamedPlugins>({
    //   appId: this.wallet.value,
    //   args: [[name]]
    // }).returnValue[0]
    pushbytes 0xaffaa4e8 // method "arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:127
    // return info.start !== 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    uncover 2
    select
    substring3
    pushint 36 // 36
    extract_uint64
    intc_0 // 0
    !=
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.escrowExists(escrow: bytes) -> uint64:
escrowExists:
    // smart_contracts/arc58/dao/contract.algo.ts:130
    // private escrowExists(escrow: string): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:131-134
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId: this.wallet.value,
    //   args: [[escrow]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:132
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:132
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:133
    // args: [[escrow]]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 34 // 0x00010002
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:131-134
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId: this.wallet.value,
    //   args: [[escrow]]
    // }).returnValue[0]
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/arc58/dao/contract.algo.ts:136
    // return info.id !== 0
    extract 6 9
    intc_0 // 0
    extract_uint64
    intc_0 // 0
    !=
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.allowanceCheck(escrow: bytes, assets: bytes) -> bytes, bytes:
allowanceCheck:
    // smart_contracts/arc58/dao/contract.algo.ts:139
    // private allowanceCheck(escrow: string, assets: uint64[]): { existences: boolean[], anyExist: boolean, allExist: boolean } {
    proto 2 2
    intc_0 // 0
    dup
    bytec_2 // ""
    dupn 6
    // smart_contracts/arc58/dao/contract.algo.ts:140-143
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:141
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:141
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:142
    // args: [escrow, assets]
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:140-143
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // }).returnValue
    pushbytes 0x02fe4515 // method "arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 50 // 50
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool1)[])
    // smart_contracts/arc58/dao/contract.algo.ts:145
    // let existences: boolean[] = []
    bytec 37 // 0x0000
    // smart_contracts/arc58/dao/contract.algo.ts:146
    // let anyExist: boolean = false
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:147
    // let allExist: boolean = true
    intc_1 // 1
    // smart_contracts/arc58/dao/contract.algo.ts:148
    // for (let i: uint64 = 0; i < info.length; i++) {
    intc_0 // 0

allowanceCheck_while_top@2:
    // smart_contracts/arc58/dao/contract.algo.ts:148
    // for (let i: uint64 = 0; i < info.length; i++) {
    frame_dig 14
    frame_dig 10
    <
    bz allowanceCheck_after_while@7
    // smart_contracts/arc58/dao/contract.algo.ts:149
    // const exists = info[i].start !== 0
    frame_dig 9
    extract 6 0
    frame_dig 14
    pushint 50 // 50
    *
    pushint 50 // 50
    extract3 // on error: index access is out of bounds
    pushint 41 // 41
    extract_uint64
    dup
    frame_bury 6
    intc_0 // 0
    !=
    // smart_contracts/arc58/dao/contract.algo.ts:150
    // existences.push(exists)
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    frame_bury 0
    frame_dig 11
    dup
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:150
    // existences.push(exists)
    intc_1 // 1
    +
    dup
    itob
    extract 6 0
    uncover 3
    swap
    replace2 0
    frame_bury 1
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    frame_bury 3
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    frame_bury 5
    <
    bz allowanceCheck_after_if_else@10
    frame_dig 5
    frame_dig 3
    -
    bzero
    frame_dig 1
    swap
    concat
    frame_bury 1

allowanceCheck_after_if_else@10:
    intc_0 // 0
    frame_bury 4
    frame_dig 2
    pushint 16 // 16
    +
    dup
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:150
    // existences.push(exists)
    intc_1 // 1
    +
    frame_bury 7

allowanceCheck_while_top@11:
    frame_dig 8
    frame_dig 7
    <
    bz allowanceCheck_after_while@13
    frame_dig 0
    frame_dig 4
    dup
    cover 2
    getbit
    frame_dig 1
    frame_dig 8
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 1
    intc_1 // 1
    +
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:150
    // existences.push(exists)
    intc_3 // 8
    +
    frame_bury 4
    b allowanceCheck_while_top@11

allowanceCheck_after_while@13:
    // smart_contracts/arc58/dao/contract.algo.ts:151
    // if (exists) {
    frame_dig 6
    bz allowanceCheck_else_body@5
    // smart_contracts/arc58/dao/contract.algo.ts:152
    // anyExist = true
    intc_1 // 1
    frame_bury 12

allowanceCheck_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:148
    // for (let i: uint64 = 0; i < info.length; i++) {
    frame_dig 14
    intc_1 // 1
    +
    frame_bury 14
    frame_dig 1
    frame_bury 11
    b allowanceCheck_while_top@2

allowanceCheck_else_body@5:
    // smart_contracts/arc58/dao/contract.algo.ts:154
    // allExist = false
    intc_0 // 0
    frame_bury 13
    b allowanceCheck_after_if_else@6

allowanceCheck_after_while@7:
    // smart_contracts/arc58/dao/contract.algo.ts:158
    // return { existences, anyExist, allExist }
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    intc_1 // 1
    frame_dig 13
    setbit
    pushbytes 0x0003
    swap
    concat
    frame_dig 11
    concat
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.validateActions(actions: bytes) -> bytes:
validateActions:
    // smart_contracts/arc58/dao/contract.algo.ts:170
    // private validateActions(actions: ProposalAction[]): void {
    proto 1 1
    intc_0 // 0
    dupn 7
    bytec_2 // ""
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:171
    // assert(actions.length > 0, ERR_EMPTY_ACTION_LIST)
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    assert // Action list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:173
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0

validateActions_while_top@1:
    // smart_contracts/arc58/dao/contract.algo.ts:173
    // for (let i: uint64 = 0; i < actions.length; i++) {
    frame_dig 11
    frame_dig 10
    <
    bz validateActions_after_while@137
    // smart_contracts/arc58/dao/contract.algo.ts:174
    // switch (actions[i].type) {
    frame_dig -1
    extract 2 0
    frame_dig 11
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 11
    frame_dig 10
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    frame_bury 1
    extract 0 1
    dup
    frame_bury 0
    // smart_contracts/arc58/dao/contract.algo.ts:175
    // case ProposalActionTypeUpgradeApp: {
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:175-178
    // case ProposalActionTypeUpgradeApp: {
    //   // TODO: make sure its an app we control
    //   break;
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:179
    // case ProposalActionTypeAddPlugin: {
    frame_dig 0
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:179-184
    // case ProposalActionTypeAddPlugin: {
    //   const { plugin, caller, escrow, fee, power, duration, participation, approval } = decodeArc4<ProposalAddPlugin>(actions[i].data)
    //   this.validateSettings({ fee, power, duration, participation, approval })
    //   assert(!this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_ALREADY_EXISTS)
    //   break;
    // }
    bz validateActions_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:180
    // const { plugin, caller, escrow, fee, power, duration, participation, approval } = decodeArc4<ProposalAddPlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    dig 1
    extract 2 8
    dig 2
    extract 10 32
    dig 2
    pushint 40 // 40
    extract_uint16
    dig 3
    pushint 59 // 59
    extract_uint16
    uncover 4
    cover 2
    substring3
    extract 2 0
    dig 3
    extract 64 8
    dig 4
    extract 72 8
    dig 5
    extract 80 8
    dig 6
    extract 88 8
    uncover 7
    extract 96 8
    // smart_contracts/arc58/dao/contract.algo.ts:181
    // this.validateSettings({ fee, power, duration, participation, approval })
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    callsub validateSettings
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:182
    // assert(!this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_ALREADY_EXISTS)
    cover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 43 // 0x002a
    concat
    swap
    concat
    callsub pluginExists
    pop
    !
    assert // Plugin already exists
    // smart_contracts/arc58/dao/contract.algo.ts:183
    // break;
    b validateActions_while_top@1

validateActions_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:185
    // case ProposalActionTypeAddNamedPlugin: {
    frame_dig 0
    bytec 33 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:185-189
    // case ProposalActionTypeAddNamedPlugin: {
    //   const { name } = decodeArc4<ProposalAddNamedPlugin>(actions[i].data)
    //   assert(!this.namedPluginExists(name), ERR_PLUGIN_ALREADY_EXISTS)
    //   break
    // }
    bz validateActions_after_if_else@14
    // smart_contracts/arc58/dao/contract.algo.ts:186
    // const { name } = decodeArc4<ProposalAddNamedPlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 42 // 42
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:187
    // assert(!this.namedPluginExists(name), ERR_PLUGIN_ALREADY_EXISTS)
    callsub namedPluginExists
    !
    assert // Plugin already exists
    // smart_contracts/arc58/dao/contract.algo.ts:188
    // break
    b validateActions_while_top@1

validateActions_after_if_else@14:
    // smart_contracts/arc58/dao/contract.algo.ts:190
    // case ProposalActionTypeExecutePlugin: {
    frame_dig 0
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:190-198
    // case ProposalActionTypeExecutePlugin: {
    //   const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(actions[i].data)
    //   const pluginInfo = this.getPlugin({ plugin, caller: Global.zeroAddress, escrow })
    //   assert(pluginInfo.start !== 0, ERR_PLUGIN_DOES_NOT_EXIST)
    //   assert(pluginInfo.useExecutionKey, ERR_NOT_EXECUTABLE_PLUGIN)
    //   const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    //   assert(pluginInfo.lastValid > epochRef, ERR_PLUGIN_EXPIRED)
    //   break
    // }
    bz validateActions_after_if_else@21
    // smart_contracts/arc58/dao/contract.algo.ts:191
    // const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    swap
    extract 2 8
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    pushint 42 // 42
    extract_uint16
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:192
    // const pluginInfo = this.getPlugin({ plugin, caller: Global.zeroAddress, escrow })
    global ZeroAddress
    uncover 2
    swap
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 43 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:115-118
    // return abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:116
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:116
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:117
    // args: [[key]]
    bytec 34 // 0x00010002
    uncover 2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:115-118
    // return abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    bytec 48 // method "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:193
    // assert(pluginInfo.start !== 0, ERR_PLUGIN_DOES_NOT_EXIST)
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    uncover 2
    select
    substring3
    dup
    frame_bury 2
    dup
    pushint 36 // 36
    extract_uint64
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:194
    // assert(pluginInfo.useExecutionKey, ERR_NOT_EXECUTABLE_PLUGIN)
    dup
    pushint 218 // 218
    getbit
    assert // Plugin is not executable
    // smart_contracts/arc58/dao/contract.algo.ts:195
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    pushint 217 // 217
    getbit
    bz validateActions_ternary_false@19
    global Round

validateActions_ternary_merge@20:
    // smart_contracts/arc58/dao/contract.algo.ts:196
    // assert(pluginInfo.lastValid > epochRef, ERR_PLUGIN_EXPIRED)
    frame_dig 2
    pushint 9 // 9
    extract_uint64
    <
    assert // Plugin has expired
    // smart_contracts/arc58/dao/contract.algo.ts:197
    // break
    b validateActions_while_top@1

validateActions_ternary_false@19:
    // smart_contracts/arc58/dao/contract.algo.ts:195
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    b validateActions_ternary_merge@20

validateActions_after_if_else@21:
    // smart_contracts/arc58/dao/contract.algo.ts:199
    // case ProposalActionTypeRemoveExecutePlugin: {
    frame_dig 0
    bytec 36 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:199-203
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(actions[i].data)
    //   assert(this.executionExists(executionKey), ERR_EXECUTION_KEY_NOT_FOUND)
    //   break
    // }
    bz validateActions_after_if_else@25
    // smart_contracts/arc58/dao/contract.algo.ts:200
    // const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 32
    // smart_contracts/arc58/dao/contract.algo.ts:162-165
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getExecutions>({
    //   appId: this.wallet.value,
    //   args: [[lease]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:163
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:163
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:164
    // args: [[lease]]
    dig 1
    len
    pushint 32 // 32
    ==
    assert // invalid size
    pushbytes 0x0001
    uncover 2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:162-165
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getExecutions>({
    //   appId: this.wallet.value,
    //   args: [[lease]]
    // }).returnValue[0]
    pushbytes 0x41bdc680 // method "arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:167
    // return info.groups.length > 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16
    // smart_contracts/arc58/dao/contract.algo.ts:201
    // assert(this.executionExists(executionKey), ERR_EXECUTION_KEY_NOT_FOUND)
    assert // Execution key not found
    // smart_contracts/arc58/dao/contract.algo.ts:202
    // break
    b validateActions_while_top@1

validateActions_after_if_else@25:
    // smart_contracts/arc58/dao/contract.algo.ts:204
    // case ProposalActionTypeRemovePlugin: {
    frame_dig 0
    bytec 7 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:204-208
    // case ProposalActionTypeRemovePlugin: {
    //   const { plugin, caller, escrow } = decodeArc4<ProposalRemovePlugin>(actions[i].data)
    //   assert(this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_DOES_NOT_EXIST)
    //   break
    // }
    bz validateActions_after_if_else@29
    // smart_contracts/arc58/dao/contract.algo.ts:205
    // const { plugin, caller, escrow } = decodeArc4<ProposalRemovePlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    dig 1
    extract 2 8
    uncover 2
    extract 10 32
    dig 2
    pushint 40 // 40
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:206
    // assert(this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_DOES_NOT_EXIST)
    cover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 43 // 0x002a
    concat
    swap
    concat
    callsub pluginExists
    pop
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:207
    // break
    b validateActions_while_top@1

validateActions_after_if_else@29:
    // smart_contracts/arc58/dao/contract.algo.ts:209
    // case ProposalActionTypeRemoveNamedPlugin: {
    frame_dig 0
    bytec 38 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:209-213
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   const { name } = decodeArc4<ProposalRemoveNamedPlugin>(actions[i].data)
    //   assert(this.namedPluginExists(name), ERR_PLUGIN_DOES_NOT_EXIST)
    //   break
    // }
    bz validateActions_after_if_else@33
    // smart_contracts/arc58/dao/contract.algo.ts:210
    // const { name } = decodeArc4<ProposalRemoveNamedPlugin>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 42 // 42
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:211
    // assert(this.namedPluginExists(name), ERR_PLUGIN_DOES_NOT_EXIST)
    callsub namedPluginExists
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:212
    // break
    b validateActions_while_top@1

validateActions_after_if_else@33:
    // smart_contracts/arc58/dao/contract.algo.ts:214
    // case ProposalActionTypeAddAllowances: {
    frame_dig 0
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:214-226
    // case ProposalActionTypeAddAllowances: {
    //   const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(actions[i].data)
    //   assert(allowances.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    // 
    //   let assets: uint64[] = []
    //   for (let i: uint64 = 0; i < allowances.length; i++) {
    //     assets.push(allowances[i].asset)
    //   }
    // 
    //   const { anyExist } = this.allowanceCheck(escrow, assets)
    //   assert(!anyExist, ERR_ALLOWANCE_ALREADY_EXISTS)
    //   break
    // }
    bz validateActions_after_if_else@40
    // smart_contracts/arc58/dao/contract.algo.ts:215
    // const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    frame_bury 5
    dig 1
    len
    substring3
    dup
    frame_bury 3
    // smart_contracts/arc58/dao/contract.algo.ts:216
    // assert(allowances.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 8
    assert // Allowance list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:218
    // let assets: uint64[] = []
    bytec 37 // 0x0000
    frame_bury 4
    // smart_contracts/arc58/dao/contract.algo.ts:219
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    intc_0 // 0
    frame_bury 9

validateActions_while_top@37:
    // smart_contracts/arc58/dao/contract.algo.ts:219
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    frame_dig 9
    frame_dig 8
    <
    bz validateActions_after_while@39
    // smart_contracts/arc58/dao/contract.algo.ts:220
    // assets.push(allowances[i].asset)
    frame_dig 3
    extract 2 0
    frame_dig 9
    dup
    cover 2
    pushint 34 // 34
    *
    pushint 34 // 34
    extract3 // on error: index access is out of bounds
    extract 0 8
    frame_dig 4
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 4
    // smart_contracts/arc58/dao/contract.algo.ts:219
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    intc_1 // 1
    +
    frame_bury 9
    b validateActions_while_top@37

validateActions_after_while@39:
    // smart_contracts/arc58/dao/contract.algo.ts:223
    // const { anyExist } = this.allowanceCheck(escrow, assets)
    frame_dig 5
    frame_dig 4
    callsub allowanceCheck
    pop
    pushint 16 // 16
    getbit
    // smart_contracts/arc58/dao/contract.algo.ts:224
    // assert(!anyExist, ERR_ALLOWANCE_ALREADY_EXISTS)
    !
    assert // allowance already exists
    // smart_contracts/arc58/dao/contract.algo.ts:225
    // break
    b validateActions_while_top@1

validateActions_after_if_else@40:
    // smart_contracts/arc58/dao/contract.algo.ts:227
    // case ProposalActionTypeRemoveAllowances: {
    frame_dig 0
    bytec 39 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:227-233
    // case ProposalActionTypeRemoveAllowances: {
    //   const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(actions[i].data)
    //   assert(assets.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    //   const { allExist } = this.allowanceCheck(escrow, assets)
    //   assert(allExist, ERR_ALLOWANCE_DOES_NOT_EXIST)
    //   break
    // }
    bz validateActions_after_if_else@44
    // smart_contracts/arc58/dao/contract.algo.ts:228
    // const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:229
    // assert(assets.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    dup
    intc_0 // 0
    extract_uint16
    assert // Allowance list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:230
    // const { allExist } = this.allowanceCheck(escrow, assets)
    callsub allowanceCheck
    pop
    pushint 17 // 17
    getbit
    // smart_contracts/arc58/dao/contract.algo.ts:231
    // assert(allExist, ERR_ALLOWANCE_DOES_NOT_EXIST)
    assert // allowance does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:232
    // break
    b validateActions_while_top@1

validateActions_after_if_else@44:
    // smart_contracts/arc58/dao/contract.algo.ts:234
    // case ProposalActionTypeNewEscrow: {
    frame_dig 0
    bytec 40 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:234-238
    // case ProposalActionTypeNewEscrow: {
    //   const { escrow } = decodeArc4<ProposalNewEscrow>(actions[i].data)
    //   assert(!this.escrowExists(escrow), ERR_ESCROW_ALREADY_EXISTS)
    //   break
    // }
    bz validateActions_after_if_else@48
    // smart_contracts/arc58/dao/contract.algo.ts:235
    // const { escrow } = decodeArc4<ProposalNewEscrow>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:236
    // assert(!this.escrowExists(escrow), ERR_ESCROW_ALREADY_EXISTS)
    callsub escrowExists
    !
    assert // Escrow already exists
    // smart_contracts/arc58/dao/contract.algo.ts:237
    // break
    b validateActions_while_top@1

validateActions_after_if_else@48:
    // smart_contracts/arc58/dao/contract.algo.ts:239
    // case ProposalActionTypeToggleEscrowLock: {
    frame_dig 0
    bytec 41 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:239-243
    // case ProposalActionTypeToggleEscrowLock: {
    //   const { escrow } = decodeArc4<ProposalToggleEscrowLock>(actions[i].data)
    //   assert(this.escrowExists(escrow), ERR_ESCROW_DOES_NOT_EXIST)
    //   break
    // }
    bz validateActions_after_if_else@52
    // smart_contracts/arc58/dao/contract.algo.ts:240
    // const { escrow } = decodeArc4<ProposalToggleEscrowLock>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:241
    // assert(this.escrowExists(escrow), ERR_ESCROW_DOES_NOT_EXIST)
    callsub escrowExists
    assert // Escrow does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:242
    // break
    b validateActions_while_top@1

validateActions_after_if_else@52:
    // smart_contracts/arc58/dao/contract.algo.ts:244
    // case ProposalActionTypeUpdateFields: {
    frame_dig 0
    bytec 42 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:244-318
    // case ProposalActionTypeUpdateFields: {
    //   const { field, value } = decodeArc4<ProposalUpdateField>(actions[i].data)
    //   switch (field) {
    //     case AkitaDAOGlobalStateKeysContentPolicy: {
    //       assert(value.length === 36, ERR_INVALID_CID)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //       assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    //       assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //       assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    //       assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    //       assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysAkitaAppList: {
    //       decodeArc4<AkitaAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysPluginAppList: {
    //       decodeArc4<PluginAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysOtherAppList: {
    //       decodeArc4<OtherAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysWalletFees: {
    //       decodeArc4<WalletFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSocialFees: {
    //       decodeArc4<SocialFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysStakingFees: {
    //       decodeArc4<StakingFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //       decodeArc4<SubscriptionFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysNFTFees: {
    //       decodeArc4<NFTFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSwapFees: {
    //       decodeArc4<SwapFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysAkitaAssets: {
    //       decodeArc4<AkitaAssets>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings:
    //     case AkitaDAOGlobalStateKeysAddPluginProposalSettings:
    //     case AkitaDAOGlobalStateKeysRemovePluginProposalSettings:
    //     case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings:
    //     case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings:
    //     case AkitaDAOGlobalStateKeysNewEscrowProposalSettings:
    //     case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //       const settings = decodeArc4<ProposalSettings>(value)
    //       this.validateSettings(settings)
    //       break
    //     }
    //     default: {
    //       assert(false, 'Unknown field in update fields proposal action')
    //     }
    //   }
    //   break
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:245
    // const { field, value } = decodeArc4<ProposalUpdateField>(actions[i].data)
    frame_dig 1
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dup
    cover 3
    frame_bury 6
    dig 1
    len
    substring3
    extract 2 0
    frame_bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:247
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    bytec 23 // "content_policy"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:247-250
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    //   assert(value.length === 36, ERR_INVALID_CID)
    //   break
    // }
    bz validateActions_after_if_else@59
    // smart_contracts/arc58/dao/contract.algo.ts:248
    // assert(value.length === 36, ERR_INVALID_CID)
    frame_dig 7
    len
    pushint 36 // 36
    ==
    assert // Invalid CID
    // smart_contracts/arc58/dao/contract.algo.ts:249
    // break
    b validateActions_while_top@1

validateActions_after_if_else@59:
    // smart_contracts/arc58/dao/contract.algo.ts:251
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    frame_dig 6
    bytec 14 // "proposal_action_limit"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:251-255
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //   assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    //   assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    //   break
    // }
    bz validateActions_after_if_else@63
    // smart_contracts/arc58/dao/contract.algo.ts:252
    // assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    frame_dig 7
    dup
    len
    intc_3 // 8
    ==
    assert // Invalid proposal action limit
    // smart_contracts/arc58/dao/contract.algo.ts:253
    // assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    btoi
    assert // Action limit must be greater than zero
    // smart_contracts/arc58/dao/contract.algo.ts:254
    // break
    b validateActions_while_top@1

validateActions_after_if_else@63:
    // smart_contracts/arc58/dao/contract.algo.ts:256
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    frame_dig 6
    bytec 24 // "min_rewards_impact"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:256-261
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //   assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    //   assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    //   assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    //   break
    // }
    bz validateActions_after_if_else@67
    // smart_contracts/arc58/dao/contract.algo.ts:257
    // assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    frame_dig 7
    dup
    len
    intc_3 // 8
    ==
    assert // Invalid minimum rewards impact
    // smart_contracts/arc58/dao/contract.algo.ts:258
    // assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    btoi
    dup
    assert // Minimum rewards impact must be greater than zero
    // smart_contracts/arc58/dao/contract.algo.ts:259
    // assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    intc 5 // 1000
    <=
    assert // Minimum rewards impact must be less than or equal to 1000
    // smart_contracts/arc58/dao/contract.algo.ts:260
    // break
    b validateActions_while_top@1

validateActions_after_if_else@67:
    // smart_contracts/arc58/dao/contract.algo.ts:262
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    frame_dig 6
    bytec 8 // "akita_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:262-265
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    //   decodeArc4<AkitaAppList>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:266
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    frame_dig 6
    bytec 25 // "plugn_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:266-269
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    //   decodeArc4<PluginAppList>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:270
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    frame_dig 6
    bytec 5 // "other_al"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:270-273
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    //   decodeArc4<OtherAppList>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:274
    // case AkitaDAOGlobalStateKeysWalletFees: {
    frame_dig 6
    bytec 26 // "wallet_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:274-277
    // case AkitaDAOGlobalStateKeysWalletFees: {
    //   decodeArc4<WalletFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:278
    // case AkitaDAOGlobalStateKeysSocialFees: {
    frame_dig 6
    bytec 27 // "social_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:278-281
    // case AkitaDAOGlobalStateKeysSocialFees: {
    //   decodeArc4<SocialFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:282
    // case AkitaDAOGlobalStateKeysStakingFees: {
    frame_dig 6
    bytec 28 // "staking_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:282-285
    // case AkitaDAOGlobalStateKeysStakingFees: {
    //   decodeArc4<StakingFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:286
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    frame_dig 6
    bytec 29 // "subscription_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:286-289
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //   decodeArc4<SubscriptionFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:290
    // case AkitaDAOGlobalStateKeysNFTFees: {
    frame_dig 6
    bytec 30 // "nft_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:290-293
    // case AkitaDAOGlobalStateKeysNFTFees: {
    //   decodeArc4<NFTFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:294
    // case AkitaDAOGlobalStateKeysSwapFees: {
    frame_dig 6
    bytec 31 // "swap_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:294-297
    // case AkitaDAOGlobalStateKeysSwapFees: {
    //   decodeArc4<SwapFees>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:298
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    frame_dig 6
    bytec 10 // "akita_assets"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:298-301
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    //   decodeArc4<AkitaAssets>(value)
    //   break
    // }
    bnz validateActions_while_top@1
    // smart_contracts/arc58/dao/contract.algo.ts:302
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings:
    frame_dig 6
    bytec 15 // "upgrade_app_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:303
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings:
    frame_dig 6
    bytec 16 // "add_plugin_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:304
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings:
    frame_dig 6
    bytec 17 // "remove_plugin_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:305
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings:
    frame_dig 6
    bytec 18 // "add_allowance_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:306
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings:
    frame_dig 6
    bytec 19 // "remove_allowance_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:307
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings:
    frame_dig 6
    bytec 20 // "new_escrow_ps"
    ==
    bnz validateActions_block@127
    // smart_contracts/arc58/dao/contract.algo.ts:308
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    frame_dig 6
    bytec 21 // "update_fields_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:308-312
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //   const settings = decodeArc4<ProposalSettings>(value)
    //   this.validateSettings(settings)
    //   break
    // }
    assert // Unknown field in update fields proposal action

validateActions_block@127:
    // smart_contracts/arc58/dao/contract.algo.ts:310
    // this.validateSettings(settings)
    frame_dig 7
    callsub validateSettings
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:311
    // break
    b validateActions_while_top@1

validateActions_after_while@137:
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.validEditOrSubmit(proposalID: uint64) -> uint64:
validEditOrSubmit:
    // smart_contracts/arc58/dao/contract.algo.ts:326
    // private validEditOrSubmit(proposalID: uint64): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:327
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    frame_dig -1
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:327
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:328
    // const { status, creator } = this.proposals(proposalID).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    swap
    pushints 61 32 // 61, 32
    box_extract
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:329
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "other_al"
    // smart_contracts/arc58/dao/contract.algo.ts:329
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:332
    // status === ProposalStatusDraft &&
    bytec_3 // 0x00
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:332-333
    // status === ProposalStatusDraft &&
    // origin === creator
    bz validEditOrSubmit_bool_false@3
    // smart_contracts/arc58/dao/contract.algo.ts:333
    // origin === creator
    frame_dig 1
    frame_dig 0
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:332-333
    // status === ProposalStatusDraft &&
    // origin === creator
    bz validEditOrSubmit_bool_false@3
    intc_1 // 1

validEditOrSubmit_bool_merge@4:
    // smart_contracts/arc58/dao/contract.algo.ts:331-334
    // return (
    //   status === ProposalStatusDraft &&
    //   origin === creator
    // )
    frame_bury 0
    retsub

validEditOrSubmit_bool_false@3:
    intc_0 // 0
    b validEditOrSubmit_bool_merge@4


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.validateSettings(settings: bytes) -> bytes:
validateSettings:
    // smart_contracts/arc58/dao/contract.algo.ts:337
    // private validateSettings(settings: ProposalSettings): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:338
    // assert(settings.approval > 1_000, ERR_INVALID_MIN_APPROVAL) // 1%
    frame_dig -1
    pushint 32 // 32
    extract_uint64
    dup
    intc 5 // 1000
    >
    assert // Invalid minimum approval percentage
    // smart_contracts/arc58/dao/contract.algo.ts:339
    // assert(settings.approval <= 100_000, ERR_INVALID_MAX_APPROVAL) // 100%
    intc 4 // 100000
    <=
    assert // Invalid maximum approval percentage
    // smart_contracts/arc58/dao/contract.algo.ts:341
    // assert(settings.participation > 1_000) // 1%
    frame_dig -1
    pushint 24 // 24
    extract_uint64
    dup
    intc 5 // 1000
    >
    assert
    // smart_contracts/arc58/dao/contract.algo.ts:342
    // assert(settings.participation <= 100_000, ERR_INVALID_MAX_PARTICIPATION) // 100%
    intc 4 // 100000
    <=
    assert // Invalid maximum participation percentage
    // smart_contracts/arc58/dao/contract.algo.ts:344
    // assert(settings.duration > 0, ERR_INVALID_DURATION)
    frame_dig -1
    pushint 16 // 16
    extract_uint64
    assert // Invalid duration
    // smart_contracts/arc58/dao/contract.algo.ts:346
    // assert(settings.power > 0, ERR_INVALID_MIN_POWER)
    frame_dig -1
    intc_3 // 8
    extract_uint64
    dup
    assert // Invalid minimum power
    // smart_contracts/arc58/dao/contract.algo.ts:347
    // assert(settings.power <= 1_000, ERR_INVALID_MAX_POWER)
    intc 5 // 1000
    <=
    assert // Invalid maximum power
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.createOrUpdateProposal(id: uint64, cid: bytes, actions: bytes, origin: bytes, feesPaid: uint64, powerRequired: uint64) -> uint64, bytes:
createOrUpdateProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:350-357
    // private createOrUpdateProposal(
    //   id: uint64,
    //   cid: CID,
    //   actions: ProposalAction[],
    //   origin: Account,
    //   feesPaid: uint64,
    //   powerRequired: uint64
    // ): uint64 {
    proto 6 2
    // smart_contracts/arc58/dao/contract.algo.ts:359
    // assert(actions.length > 0, ERR_EMPTY_ACTION_LIST)
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dup
    assert // Action list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:360
    // assert(actions.length <= this.proposalActionLimit.value, ERR_TOO_MANY_ACTIONS)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 14 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:360
    // assert(actions.length <= this.proposalActionLimit.value, ERR_TOO_MANY_ACTIONS)
    app_global_get_ex
    assert // check GlobalState exists
    <=
    assert // Too many actions in the proposal
    // smart_contracts/arc58/dao/contract.algo.ts:362
    // if (this.initialized.value === false) {
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:26
    // initialized = GlobalState<boolean>({ initialValue: false, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 9 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:362
    // if (this.initialized.value === false) {
    app_global_get_ex
    assert // check GlobalState exists
    bnz createOrUpdateProposal_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:363
    // assert(Txn.sender === Global.creatorAddress, ERR_FORBIDDEN)
    txn Sender
    global CreatorAddress
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:365
    // id = this.newProposalID()
    callsub newProposalID
    frame_bury -6
    // smart_contracts/arc58/dao/contract.algo.ts:375
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/arc58/dao/contract.algo.ts:377
    // created: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/dao/contract.algo.ts:371
    // approvals: 0,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:367-380
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    itob
    frame_dig -5
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:368
    // status: ProposalStatusApproved,
    bytec 7 // 0x28
    // smart_contracts/arc58/dao/contract.algo.ts:367-380
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    frame_dig -5
    concat
    bytec 49 // 0x000000000000000000000000000000000000000000000000
    concat
    uncover 3
    concat
    swap
    concat
    swap
    itob
    concat
    frame_dig -2
    itob
    concat
    bytec 50 // 0x0077
    concat
    frame_dig -4
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:367
    // this.proposals(id).value = {
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:367-380
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:382
    // return id
    frame_dig -6
    frame_dig -4
    retsub

createOrUpdateProposal_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:386
    // this.akitaAppList.value.staking,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:386
    // this.akitaAppList.value.staking,
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:388
    // this.akitaAssets.value.bones
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 10 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:388
    // this.akitaAssets.value.bones
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:385-389
    // const userPower = getStakingPower(
    //   this.akitaAppList.value.staking,
    //   origin,
    //   this.akitaAssets.value.bones
    // )
    frame_dig -3
    swap
    callsub getStakingPower
    // smart_contracts/arc58/dao/contract.algo.ts:391
    // assert(userPower >= powerRequired, ERR_INSUFFICIENT_PROPOSAL_THRESHOLD)
    frame_dig -1
    >=
    assert // Insufficient proposal threshold
    // smart_contracts/arc58/dao/contract.algo.ts:394
    // if (id === 0) {
    frame_dig -6
    bnz createOrUpdateProposal_else_body@4
    // smart_contracts/arc58/dao/contract.algo.ts:395
    // id = this.newProposalID()
    callsub newProposalID
    frame_bury -6
    // smart_contracts/arc58/dao/contract.algo.ts:396
    // created = Global.latestTimestamp
    global LatestTimestamp

createOrUpdateProposal_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:405
    // approvals: 0,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:401-414
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    itob
    frame_dig -5
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:402
    // status: ProposalStatusDraft,
    bytec_3 // 0x00
    // smart_contracts/arc58/dao/contract.algo.ts:401-414
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    frame_dig -5
    concat
    bytec 49 // 0x000000000000000000000000000000000000000000000000
    concat
    frame_dig -3
    concat
    swap
    concat
    swap
    itob
    concat
    frame_dig -2
    itob
    concat
    bytec 50 // 0x0077
    concat
    frame_dig -4
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:401
    // this.proposals(id).value = {
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:401-414
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:416
    // return id
    frame_dig -6
    frame_dig -4
    retsub

createOrUpdateProposal_else_body@4:
    // smart_contracts/arc58/dao/contract.algo.ts:398
    // created = this.proposals(id).value.created
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:398
    // created = this.proposals(id).value.created
    pushint 101 // 101
    intc_3 // 8
    box_extract
    btoi
    b createOrUpdateProposal_after_if_else@5


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings(type: bytes, data: bytes) -> bytes:
getProposalSettings:
    // smart_contracts/arc58/dao/contract.algo.ts:419
    // private getProposalSettings(type: ProposalActionType, data: bytes): ProposalSettings {
    proto 2 1
    // smart_contracts/arc58/dao/contract.algo.ts:421
    // case ProposalActionTypeUpgradeApp: {
    frame_dig -2
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:421-423
    // case ProposalActionTypeUpgradeApp: {
    //   return this.upgradeAppProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@4
    // smart_contracts/arc58/dao/contract.algo.ts:422
    // return this.upgradeAppProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:60
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:422
    // return this.upgradeAppProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@4:
    // smart_contracts/arc58/dao/contract.algo.ts:424
    // case ProposalActionTypeAddPlugin:
    frame_dig -2
    bytec 6 // 0x14
    ==
    bnz getProposalSettings_block@9
    // smart_contracts/arc58/dao/contract.algo.ts:425
    // case ProposalActionTypeAddNamedPlugin: {
    frame_dig -2
    bytec 33 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:425-427
    // case ProposalActionTypeAddNamedPlugin: {
    //   return this.addPluginProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@11

getProposalSettings_block@9:
    // smart_contracts/arc58/dao/contract.algo.ts:426
    // return this.addPluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:426
    // return this.addPluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@11:
    // smart_contracts/arc58/dao/contract.algo.ts:428
    // case ProposalActionTypeExecutePlugin: {
    frame_dig -2
    bytec 13 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:428-432
    // case ProposalActionTypeExecutePlugin: {
    //   const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(data)
    //   assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    //   return this.plugins({ plugin, escrow }).value
    // }
    bz getProposalSettings_after_if_else@15
    // smart_contracts/arc58/dao/contract.algo.ts:429
    // const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(data)
    frame_dig -1
    extract 0 8
    frame_dig -1
    intc_3 // 8
    extract_uint16
    frame_dig -1
    pushint 42 // 42
    extract_uint16
    frame_dig -1
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:430
    // assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 44 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:83
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 45 // "p"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:430
    // assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:431
    // return this.plugins({ plugin, escrow }).value
    box_get
    pop
    retsub

getProposalSettings_after_if_else@15:
    // smart_contracts/arc58/dao/contract.algo.ts:433
    // case ProposalActionTypeRemoveExecutePlugin: {
    frame_dig -2
    bytec 36 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:433-435
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   return this.removeExecutePluginProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@19
    // smart_contracts/arc58/dao/contract.algo.ts:434
    // return this.removeExecutePluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:66
    // removeExecutePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveExecutePluginProposalSettings })
    bytec 47 // "remove_execute_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:434
    // return this.removeExecutePluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@19:
    // smart_contracts/arc58/dao/contract.algo.ts:436
    // case ProposalActionTypeRemovePlugin:
    frame_dig -2
    bytec 7 // 0x28
    ==
    bnz getProposalSettings_block@24
    // smart_contracts/arc58/dao/contract.algo.ts:437
    // case ProposalActionTypeRemoveNamedPlugin: {
    frame_dig -2
    bytec 38 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:437-439
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   return this.removePluginProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@26

getProposalSettings_block@24:
    // smart_contracts/arc58/dao/contract.algo.ts:438
    // return this.removePluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:64
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:438
    // return this.removePluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@26:
    // smart_contracts/arc58/dao/contract.algo.ts:440
    // case ProposalActionTypeAddAllowances: {
    frame_dig -2
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:440-442
    // case ProposalActionTypeAddAllowances: {
    //   return this.addAllowancesProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@30
    // smart_contracts/arc58/dao/contract.algo.ts:441
    // return this.addAllowancesProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:441
    // return this.addAllowancesProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@30:
    // smart_contracts/arc58/dao/contract.algo.ts:443
    // case ProposalActionTypeRemoveAllowances: {
    frame_dig -2
    bytec 39 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:443-445
    // case ProposalActionTypeRemoveAllowances: {
    //   return this.removeAllowancesProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@34
    // smart_contracts/arc58/dao/contract.algo.ts:444
    // return this.removeAllowancesProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:444
    // return this.removeAllowancesProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@34:
    // smart_contracts/arc58/dao/contract.algo.ts:446
    // case ProposalActionTypeNewEscrow: {
    frame_dig -2
    bytec 40 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:446-448
    // case ProposalActionTypeNewEscrow: {
    //   return this.newEscrowProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@38
    // smart_contracts/arc58/dao/contract.algo.ts:447
    // return this.newEscrowProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:447
    // return this.newEscrowProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@38:
    // smart_contracts/arc58/dao/contract.algo.ts:449
    // case ProposalActionTypeToggleEscrowLock: {
    frame_dig -2
    bytec 41 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:449-451
    // case ProposalActionTypeToggleEscrowLock: {
    //   return this.toggleEscrowLockProposalSettings.value
    // }
    bz getProposalSettings_after_if_else@42
    // smart_contracts/arc58/dao/contract.algo.ts:450
    // return this.toggleEscrowLockProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:74
    // toggleEscrowLockProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysToggleEscrowLockProposalSettings })
    pushbytes "toggle_escrow_lock_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:450
    // return this.toggleEscrowLockProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub

getProposalSettings_after_if_else@42:
    // smart_contracts/arc58/dao/contract.algo.ts:452
    // case ProposalActionTypeUpdateFields: {
    frame_dig -2
    bytec 42 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:452-454
    // case ProposalActionTypeUpdateFields: {
    //   return this.updateFieldsProposalSettings.value
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:453
    // return this.updateFieldsProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:453
    // return this.updateFieldsProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.addPlugin(data: bytes) -> bytes:
addPlugin:
    // smart_contracts/arc58/dao/contract.algo.ts:461
    // private addPlugin(data: ProposalAddNamedPlugin): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:480
    // } = clone(data);
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    pushint 42 // 42
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 2 8
    swap
    frame_dig -1
    extract 10 32
    swap
    frame_dig -1
    pushint 61 // 61
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 44 1
    swap
    frame_dig -1
    extract 45 8
    swap
    frame_dig -1
    extract 53 8
    swap
    frame_dig -1
    pushint 104 // 104
    extract_uint16
    frame_dig -1
    cover 2
    substring3
    frame_dig -1
    pushint 504 // 504
    getbit
    frame_dig -1
    pushint 505 // 505
    getbit
    dup
    frame_dig -1
    pushint 506 // 506
    getbit
    swap
    frame_dig -1
    extract 64 8
    swap
    frame_dig -1
    extract 72 8
    swap
    frame_dig -1
    extract 80 8
    swap
    frame_dig -1
    extract 88 8
    swap
    frame_dig -1
    extract 96 8
    swap
    frame_dig -1
    pushint 106 // 106
    extract_uint16
    frame_dig -1
    len
    frame_dig -1
    cover 2
    substring3
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:482
    // if (useExecutionKey) {
    bz addPlugin_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:483-489
    // this.plugins({ plugin, escrow }).value = {
    //   fee,
    //   power,
    //   duration,
    //   participation,
    //   approval
    // }
    frame_dig 13
    frame_dig 14
    concat
    frame_dig 15
    concat
    frame_dig 16
    concat
    frame_dig 17
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:483
    // this.plugins({ plugin, escrow }).value = {
    frame_dig 5
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_dig 2
    bytec 44 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:83
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 45 // "p"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:483-489
    // this.plugins({ plugin, escrow }).value = {
    //   fee,
    //   power,
    //   duration,
    //   participation,
    //   approval
    // }
    swap
    box_put

addPlugin_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:492
    // if (name !== '') {
    frame_dig 1
    bytec_2 // ""
    !=
    bz addPlugin_else_body@5
    // smart_contracts/arc58/dao/contract.algo.ts:493-509
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:494
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:494
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:505
    // useRounds,
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 10
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:506
    // useExecutionKey,
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 11
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:507
    // defaultToEscrow
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:493-509
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    pushbytes 0x38f591ea // method "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    // smart_contracts/arc58/dao/contract.algo.ts:500
    // false,
    bytec_3 // 0x00
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationArgs
    frame_dig 8
    itxn_field ApplicationArgs
    frame_dig 9
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/arc58/dao/contract.algo.ts:493-509
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

addPlugin_after_if_else@7:
    // smart_contracts/arc58/dao/contract.algo.ts:529
    // if (escrow !== '' && allowances.length > 0) {
    frame_dig 5
    bytec_2 // ""
    !=
    bz addPlugin_after_if_else@10
    frame_dig 18
    intc_0 // 0
    extract_uint16
    bz addPlugin_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:530
    // this.addAllowances(escrow, allowances)
    frame_dig 5
    frame_dig 18
    callsub addAllowances
    pop

addPlugin_after_if_else@10:
    frame_dig -1
    frame_bury 0
    retsub

addPlugin_else_body@5:
    // smart_contracts/arc58/dao/contract.algo.ts:511-526
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:512
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:512
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:522
    // useRounds,
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 10
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:523
    // useExecutionKey,
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 11
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:524
    // defaultToEscrow
    bytec_3 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:511-526
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    pushbytes 0xb3c80df9 // method "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool)void"
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    // smart_contracts/arc58/dao/contract.algo.ts:517
    // false,
    bytec_3 // 0x00
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationArgs
    frame_dig 8
    itxn_field ApplicationArgs
    frame_dig 9
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/arc58/dao/contract.algo.ts:511-526
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     defaultToEscrow
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b addPlugin_after_if_else@7


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.addAllowances(escrow: bytes, allowances: bytes) -> bytes:
addAllowances:
    // smart_contracts/arc58/dao/contract.algo.ts:534
    // private addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    proto 2 1
    // smart_contracts/arc58/dao/contract.algo.ts:535-538
    // abiCall<typeof AbstractedAccount.prototype.arc58_addAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, allowances]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:536
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:536
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:537
    // args: [escrow, allowances]
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:535-538
    // abiCall<typeof AbstractedAccount.prototype.arc58_addAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, allowances]
    // })
    pushbytes 0xbf4d7c57 // method "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.removePlugin(data: bytes) -> bytes:
removePlugin:
    // smart_contracts/arc58/dao/contract.algo.ts:548
    // private removePlugin(data: ProposalRemoveNamedPlugin): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:549
    // const { name, plugin, caller, escrow } = data
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    pushint 42 // 42
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 2 8
    dup
    uncover 2
    frame_dig -1
    extract 10 32
    cover 2
    frame_dig -1
    len
    frame_dig -1
    cover 2
    substring3
    dup
    cover 2
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:551
    // if (this.plugins({ plugin, escrow }).exists) {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 44 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:83
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 45 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:551
    // if (this.plugins({ plugin, escrow }).exists) {
    box_len
    bury 1
    bz removePlugin_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:552
    // this.plugins({ plugin, escrow }).delete()
    frame_dig 5
    box_del
    pop

removePlugin_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:555
    // if (name !== '') {
    frame_dig 1
    bytec_2 // ""
    !=
    bz removePlugin_after_if_else@5
    // smart_contracts/arc58/dao/contract.algo.ts:556-559
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [name]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:557
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:557
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:556-559
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [name]
    // })
    pushbytes 0xe350b9d4 // method "arc58_removeNamedPlugin(string)void"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:560
    // return
    frame_dig -1
    frame_bury 0
    retsub

removePlugin_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:563-566
    // abiCall<typeof AbstractedAccount.prototype.arc58_removePlugin>({
    //   appId: this.wallet.value,
    //   args: [plugin, caller, escrow]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:564
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:564
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:563-566
    // abiCall<typeof AbstractedAccount.prototype.arc58_removePlugin>({
    //   appId: this.wallet.value,
    //   args: [plugin, caller, escrow]
    // })
    pushbytes 0xeef448fd // method "arc58_removePlugin(uint64,address,string)void"
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newExecution(key: bytes, groups: bytes, firstValid: uint64, lastValid: uint64) -> bytes:
newExecution:
    // smart_contracts/arc58/dao/contract.algo.ts:684
    // private newExecution(key: bytes<32>, groups: bytes<32>[], firstValid: uint64, lastValid: uint64): void {
    proto 4 1
    // smart_contracts/arc58/dao/contract.algo.ts:685-688
    // abiCall<typeof AbstractedAccount.prototype.arc58_addExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key, groups, firstValid, lastValid]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:686
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_1 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:686
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:687
    // args: [key, groups, firstValid, lastValid]
    frame_dig -4
    len
    pushint 32 // 32
    ==
    assert // invalid size
    frame_dig -2
    itob
    frame_dig -1
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:685-688
    // abiCall<typeof AbstractedAccount.prototype.arc58_addExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key, groups, firstValid, lastValid]
    // })
    pushbytes 0x5cebed43 // method "arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -3
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newProposalID() -> uint64:
newProposalID:
    // smart_contracts/arc58/dao/contract.algo.ts:699
    // const id = this.proposalID.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 35 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:699
    // const id = this.proposalID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:700
    // this.proposalID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 35 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:700
    // this.proposalID.value += 1
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:701
    // return id
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost() -> uint64:
smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1196
    // const { wallet: appId } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 8 // "akita_al"
    // smart_contracts/arc58/dao/contract.algo.ts:1196
    // const { wallet: appId } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    pushint 88 // 88
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1197
    // return abiCall<typeof AbstractedAccountFactory.prototype.cost>({ appId }).returnValue
    itxn_begin
    pushbytes 0x9b67fa6d // method "cost()uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost(actions: bytes) -> bytes, bytes:
smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1200-1201
    // @abimethod({ readonly: true })
    // proposalCost(actions: ProposalAction[]): { totalFee: uint64, powerRequired: uint64 } {
    proto 1 2
    intc_0 // 0
    bytec_2 // ""
    dupn 4
    // smart_contracts/arc58/dao/contract.algo.ts:97
    // let totalActionDataLength: uint64 = 0;
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:98
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dup

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@19:
    // smart_contracts/arc58/dao/contract.algo.ts:98
    // for (let i: uint64 = 0; i < actions.length; i++) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 1
    frame_dig 7
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@21
    // smart_contracts/arc58/dao/contract.algo.ts:99
    // totalActionDataLength += (MinDAOProposalActionMbr + actions[i].data.length)
    frame_dig -1
    extract 2 0
    frame_dig 7
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 7
    frame_dig 1
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    len
    pushint 5 // 5
    +
    frame_dig 6
    +
    frame_bury 6
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@19

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@21:
    // smart_contracts/arc58/dao/contract.algo.ts:102
    // return MinDAOProposalMBR + (BoxCostPerByte * totalActionDataLength)
    pushint 400 // 400
    frame_dig 6
    *
    pushint 54500 // 54500
    +
    frame_bury 2
    // smart_contracts/arc58/dao/contract.algo.ts:1203
    // let totalFee: uint64 = 0
    intc_0 // 0
    frame_bury 5
    // smart_contracts/arc58/dao/contract.algo.ts:1204
    // let powerRequired: uint64 = 0
    intc_0 // 0
    frame_bury 4
    // smart_contracts/arc58/dao/contract.algo.ts:1205
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3:
    // smart_contracts/arc58/dao/contract.algo.ts:1205
    // for (let i: uint64 = 0; i < actions.length; i++) {
    frame_dig 7
    frame_dig 1
    <
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@13
    // smart_contracts/arc58/dao/contract.algo.ts:1207
    // const { type, data } = actions[i]
    frame_dig -1
    extract 2 0
    frame_dig 7
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 7
    frame_dig 1
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    extract 0 1
    dup
    cover 2
    frame_bury 0
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1209
    // const { fee, power } = this.getProposalSettings(type, data)
    dig 1
    swap
    callsub getProposalSettings
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    frame_bury 3
    // smart_contracts/arc58/dao/contract.algo.ts:1211
    // totalFee += fee
    frame_dig 5
    +
    frame_bury 5
    // smart_contracts/arc58/dao/contract.algo.ts:1213
    // if (type === ProposalActionTypeUpgradeApp) {
    bytec 12 // 0x0a
    ==
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@6
    // smart_contracts/arc58/dao/contract.algo.ts:1214
    // minFee += DAOExecutionMBR
    frame_dig 2
    pushint 22100 // 22100
    +
    frame_bury 2

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1219
    // if (power > powerRequired) {
    frame_dig 3
    frame_dig 4
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3
    frame_dig 3
    frame_bury 4
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1215
    // } else if (type === ProposalActionTypeAddPlugin || type === ProposalActionTypeAddNamedPlugin) {
    frame_dig 0
    bytec 6 // 0x14
    ==
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_if_body@8
    frame_dig 0
    bytec 33 // 0x15
    ==
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_if_body@8:
    // smart_contracts/arc58/dao/contract.algo.ts:1216
    // minFee += this.pluginsMbr(String(op.bzero(24)))
    frame_dig 2
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // return MinDAOPluginMBR + (BoxCostPerByte * Bytes(escrow).length)
    pushint 33300 // 33300
    // smart_contracts/arc58/dao/contract.algo.ts:1216
    // minFee += this.pluginsMbr(String(op.bzero(24)))
    +
    frame_bury 2
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@13:
    // smart_contracts/arc58/dao/contract.algo.ts:1224
    // if (totalFee < minFee) {
    frame_dig 5
    frame_dig 2
    <
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@15
    frame_dig 2
    frame_bury 5

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@15:
    // smart_contracts/arc58/dao/contract.algo.ts:1228
    // return { totalFee, powerRequired }
    frame_dig 5
    itob
    frame_dig 4
    itob
    concat
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade(lease: bytes, appBeingUpgraded: uint64) -> uint64:
smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade:
    // smart_contracts/arc58/dao/contract.algo.ts:1259-1260
    // @abimethod({ readonly: true })
    // isValidUpgrade(lease: bytes<32>, appBeingUpgraded: uint64): boolean {
    proto 2 1
    intc_0 // 0
    dupn 4
    bytec_2 // ""
    dupn 5
    // smart_contracts/arc58/dao/contract.algo.ts:89
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    bytec 32 // "x"
    frame_dig -2
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:1261
    // if (!this.executions(lease).exists) {
    box_len
    bury 1
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:1262
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:1265
    // const { proposalID, index } = this.executions(lease).value
    frame_dig 11
    box_get
    assert // Box must have value
    dup
    extract 0 8
    swap
    intc_3 // 8
    extract_uint64
    frame_bury 9
    // smart_contracts/arc58/dao/contract.algo.ts:85
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/arc58/dao/contract.algo.ts:1267
    // if (!this.proposals(proposalID).exists) {
    box_len
    bury 1
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@4
    // smart_contracts/arc58/dao/contract.algo.ts:1268
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@4:
    // smart_contracts/arc58/dao/contract.algo.ts:1271
    // const { status } = this.proposals(proposalID).value
    frame_dig 0
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    frame_bury 3
    // smart_contracts/arc58/dao/contract.algo.ts:1272
    // const { type, data } = this.proposals(proposalID).value.actions[index]
    dup
    box_get
    pop
    swap
    dup
    pushint 119 // 119
    intc_2 // 2
    box_extract
    btoi
    frame_dig 9
    dup
    uncover 2
    <
    assert // index out of bounds
    intc_2 // 2
    dig 1
    *
    pushint 121 // 121
    +
    dig 2
    swap
    intc_2 // 2
    box_extract
    btoi
    pushint 121 // 121
    +
    uncover 2
    swap
    intc_1 // 1
    box_extract
    frame_bury 4
    dig 1
    pushint 117 // 117
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 2
    intc_2 // 2
    *
    dig 2
    swap
    extract_uint16
    uncover 3
    intc_1 // 1
    +
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1274
    // const { app, executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(data)
    dig 1
    intc_2 // 2
    extract_uint64
    frame_bury 5
    dig 1
    extract 10 32
    frame_bury 1
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    frame_bury 2
    dup
    pushint 44 // 44
    extract_uint64
    frame_bury 6
    pushint 52 // 52
    extract_uint64
    frame_bury 10
    // smart_contracts/arc58/dao/contract.algo.ts:1275
    // let foundGroup = false;
    intc_0 // 0
    frame_bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:1276
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    intc_0 // 0
    frame_bury 8

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_while_top@5:
    // smart_contracts/arc58/dao/contract.algo.ts:1276
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    frame_dig 2
    intc_0 // 0
    extract_uint16
    frame_dig 8
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_while@9
    // smart_contracts/arc58/dao/contract.algo.ts:1277
    // if (groups[i] === Global.groupId) {
    frame_dig 2
    extract 2 0
    frame_dig 8
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    global GroupID
    ==
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // foundGroup = true;
    intc_1 // 1
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_if_else@8:
    // smart_contracts/arc58/dao/contract.algo.ts:1276
    // for (let i: uint64 = 0; i < groups.length; i += 1) {
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 8
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_while_top@5

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_after_while@9:
    // smart_contracts/arc58/dao/contract.algo.ts:1283
    // status === ProposalStatusExecuted &&
    frame_dig 3
    bytec 11 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1284
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    // smart_contracts/arc58/dao/contract.algo.ts:1284
    // type === ProposalActionTypeUpgradeApp &&
    frame_dig 4
    bytec 12 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1284
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    // smart_contracts/arc58/dao/contract.algo.ts:1285
    // app === appBeingUpgraded &&
    frame_dig 5
    frame_dig -1
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1285
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    // app === appBeingUpgraded &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    // smart_contracts/arc58/dao/contract.algo.ts:1286
    // Txn.lease === executionKey &&
    txn Lease
    frame_dig 1
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1286
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    // app === appBeingUpgraded &&
    // Txn.lease === executionKey &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    // smart_contracts/arc58/dao/contract.algo.ts:1287
    // Global.round >= firstValid &&
    global Round
    frame_dig 6
    >=
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1287
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    // app === appBeingUpgraded &&
    // Txn.lease === executionKey &&
    // Global.round >= firstValid &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    // smart_contracts/arc58/dao/contract.algo.ts:1288
    // Global.round <= lastValid &&
    global Round
    frame_dig 10
    <=
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1288
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    // app === appBeingUpgraded &&
    // Txn.lease === executionKey &&
    // Global.round >= firstValid &&
    // Global.round <= lastValid &&
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16
    intc_1 // 1

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_merge@17:
    // smart_contracts/arc58/dao/contract.algo.ts:1283-1289
    // status === ProposalStatusExecuted &&
    // type === ProposalActionTypeUpgradeApp &&
    // app === appBeingUpgraded &&
    // Txn.lease === executionKey &&
    // Global.round >= firstValid &&
    // Global.round <= lastValid &&
    // foundGroup
    frame_dig 7
    &&
    // smart_contracts/arc58/dao/contract.algo.ts:1282-1290
    // return (
    //   status === ProposalStatusExecuted &&
    //   type === ProposalActionTypeUpgradeApp &&
    //   app === appBeingUpgraded &&
    //   Txn.lease === executionKey &&
    //   Global.round >= firstValid &&
    //   Global.round <= lastValid &&
    //   foundGroup
    // )
    frame_bury 0
    retsub

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_false@16:
    intc_0 // 0
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.isValidUpgrade_bool_merge@17
