#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 2 100000 1000 1000000
    bytecblock 0x00 0x151f7c75 "wallet" "" "l" "oal" 0x14 "initialized" 0x28 "aal" 0x1e "akita_assets" 0x32 "proposal_action_limit" "pal" "upgrade_app_ps" "add_plugin_ps" "remove_plugin_ps" "add_allowance_ps" "remove_allowance_ps" "new_escrow_ps" "update_fields_ps" 0x0a "version" "content_policy" "min_rewards_impact" "sal" "wallet_fees" "social_fees" "staking_fees" "subscription_fees" "nft_fees" "swap_fees" "revenue_splits" 0x02 0x15 0x00010002 "proposal_id" 0x002a 0x1f 0x29 0x0000 0x3c 0x46 0x47 0x50 0x000a "p" 0x000000000000016d00000000000f4240 "remove_execute_plugin_ps" "toggle_escrow_lock_ps" 0x89a76826 0x000000000000000000000000000000000000000000000000 0x0077
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    bytec_0 // 0x00
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 23 // "version"
    bytec_3 // ""
    app_global_put

main_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:24-25
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    pushbytes 0xea9180dd // method "update(string)void"
    txna ApplicationArgs 0
    match main_update_route@4

main_switch_case_next@5:
    // smart_contracts/arc58/dao/contract.algo.ts:24-25
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@25
    pushbytess 0xd9bacd94 0x53c47566 0xfd2c93cd 0x0198fe3b 0xfe20c269 0xcb37e668 0x28f80154 0x103a6b88 0xa4b236b6 0x62ce9b5b 0xf1ff28aa 0x49013b5f 0x9699d108 0x8c564768 0x1f9f8b20 0xdbbec6d2 0x854dede0 // method "setup(string)uint64", method "partiallyInitialize()void", method "initialize()void", method "newProposal(pay,byte[36],(uint8,byte[])[])uint64", method "editProposal(uint64,byte[36],(uint8,byte[])[])void", method "editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void", method "deleteProposal(uint64)void", method "submitProposal(uint64)void", method "voteProposal(pay,uint64,uint8)void", method "finalizeProposal(uint64)void", method "executeProposal(uint64)void", method "deleteProposalVotes(uint64,address[])void", method "setupCost()uint64", method "proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])", method "mustGetExecution(byte[32])(uint64,uint64)", method "opUp()void"
    txna ApplicationArgs 0
    match setup partiallyInitialize initialize newProposal editProposal editProposalWithPayment deleteProposal submitProposal voteProposal finalizeProposal executeProposal deleteProposalVotes setupCost proposalCost getProposal mustGetExecution main_opUp_route@23
    err

main_opUp_route@23:
    // smart_contracts/arc58/dao/contract.algo.ts:1338
    // opUp(): void { }
    intc_1 // 1
    return

main_create_NoOp@25:
    // smart_contracts/arc58/dao/contract.algo.ts:24-25
    // @contract({ stateTotals: { globalBytes: AkitaDAONumGlobalBytes, globalUints: AkitaDAONumGlobalUints } })
    // export class AkitaDAO extends Contract {
    pushbytes 0x0eb0b97b // method "create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@4:
    // smart_contracts/arc58/dao/contract.algo.ts:920
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/utils/functions.ts::wideRatio(numerators: bytes, denominators: bytes) -> uint64:
wideRatio:
    // smart_contracts/utils/functions.ts:113
    // export function wideRatio(numerators: [uint64, uint64], denominators: [uint64, uint64]): uint64 {
    proto 2 1
    // smart_contracts/utils/functions.ts:114
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    frame_dig -1
    intc_0 // 0
    extract_uint64
    dup
    bz wideRatio_bool_false@3
    frame_dig -1
    intc_2 // 8
    extract_uint64
    bz wideRatio_bool_false@3
    intc_1 // 1

wideRatio_bool_merge@4:
    // smart_contracts/utils/functions.ts:114
    // assert(denominators[0] > 0 && denominators[1] > 0, ERR_INVALID_PERCENTAGE)
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:115
    // const [overflow, result] = op.divmodw(...op.mulw(...numerators), ...op.mulw(...denominators))
    frame_dig -2
    intc_0 // 0
    extract_uint64
    frame_dig -2
    intc_2 // 8
    extract_uint64
    mulw
    frame_dig -1
    intc_2 // 8
    extract_uint64
    frame_dig 0
    mulw
    divmodw
    popn 2
    swap
    // smart_contracts/utils/functions.ts:116
    // assert(overflow === 0, ERR_INVALID_PERCENTAGE)
    !
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:117
    // return result
    swap
    retsub

wideRatio_bool_false@3:
    intc_0 // 0
    b wideRatio_bool_merge@4


// smart_contracts/utils/functions.ts::getOrigin(escrowFactory: uint64, address: bytes) -> bytes:
getOrigin:
    // smart_contracts/utils/functions.ts:194
    // export function getOrigin(escrowFactory: uint64, address: Account): Account {
    proto 2 1
    bytec_3 // ""
    // smart_contracts/utils/functions.ts:182-185
    // const data = abiCall<typeof EscrowFactory.prototype.get>({
    //   appId: escrowFactory,
    //   args: [address]
    // }).returnValue
    itxn_begin
    pushbytes 0x3c1a6f33 // method "get(address)byte[]"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    extract 6 0
    dup
    // smart_contracts/utils/functions.ts:187
    // if (Bytes(data).length === 0 || Bytes(data).length !== 8) {
    len
    dup
    bz getOrigin_if_body@7
    frame_dig 2
    intc_2 // 8
    !=
    bz getOrigin_after_if_else@8

getOrigin_if_body@7:
    // smart_contracts/utils/functions.ts:188
    // return 0
    intc_0 // 0
    frame_bury 0

getOrigin_after_inlined_smart_contracts/utils/functions.ts::getWalletID@9:
    // smart_contracts/utils/functions.ts:197
    // if (wallet === 0) {
    frame_dig 0
    bnz getOrigin_after_if_else@2
    // smart_contracts/utils/functions.ts:198
    // return Txn.sender
    txn Sender
    frame_bury 0
    retsub

getOrigin_after_if_else@2:
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    frame_dig 0
    // smart_contracts/utils/functions.ts:163
    // Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    pushbytes "controlled_address"
    // smart_contracts/utils/functions.ts:161-164
    // const [controlledAccountBytes] = op.AppGlobal.getExBytes(
    //   walletID,
    //   Bytes(AbstractAccountGlobalStateKeysControlledAddress)
    // )
    app_global_get_ex
    pop
    // smart_contracts/utils/functions.ts:201
    // return getOriginAccount(Application(wallet))
    frame_bury 0
    retsub

getOrigin_after_if_else@8:
    // smart_contracts/utils/functions.ts:191
    // return btoi(data)
    frame_dig 1
    btoi
    frame_bury 0
    // smart_contracts/utils/functions.ts:195
    // const wallet = getWalletID(escrowFactory, address)
    b getOrigin_after_inlined_smart_contracts/utils/functions.ts::getWalletID@9


// smart_contracts/utils/functions.ts::getStakingPower(stakingApp: uint64, user: bytes, asset: uint64) -> uint64:
getStakingPower:
    // smart_contracts/utils/functions.ts:455
    // export function getStakingPower(stakingApp: uint64, user: Account, asset: uint64): uint64 {
    proto 3 1
    bytec_3 // ""
    // smart_contracts/utils/functions.ts:456-465
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    itxn_begin
    // smart_contracts/utils/functions.ts:460-463
    // {
    //   asset,
    //   type: STAKING_TYPE_LOCK,
    // },
    frame_dig -1
    itob
    // smart_contracts/utils/functions.ts:462
    // type: STAKING_TYPE_LOCK,
    bytec 8 // 0x28
    // smart_contracts/utils/functions.ts:460-463
    // {
    //   asset,
    //   type: STAKING_TYPE_LOCK,
    // },
    concat
    // smart_contracts/utils/functions.ts:456-465
    // const info = abiCall<typeof Staking.prototype.getInfo>({
    //   appId: stakingApp,
    //   args: [
    //     user,
    //     {
    //       asset,
    //       type: STAKING_TYPE_LOCK,
    //     },
    //   ],
    // }).returnValue
    pushbytes 0xc9068809 // method "getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 24 // 24
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64)
    pushint 20 // 20
    // smart_contracts/utils/functions.ts:467
    // if (info.expiration <= Global.latestTimestamp) {
    extract_uint64
    dup
    global LatestTimestamp
    <=
    bz getStakingPower_after_if_else@3
    // smart_contracts/utils/functions.ts:468
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getStakingPower_after_if_else@3:
    // smart_contracts/utils/functions.ts:471
    // const remainingTime: uint64 = info.expiration - Global.latestTimestamp
    frame_dig 2
    global LatestTimestamp
    -
    dup
    frame_bury 0
    // smart_contracts/utils/functions.ts:473
    // if (remainingTime < ONE_WEEK) {
    pushint 604800 // 604800
    <
    bz getStakingPower_after_if_else@5
    // smart_contracts/utils/functions.ts:474
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getStakingPower_after_if_else@5:
    // smart_contracts/utils/functions.ts:477
    // const remainingDays: uint64 = remainingTime / ONE_DAY
    frame_dig 0
    pushint 86400 // 86400
    /
    // smart_contracts/utils/functions.ts:478
    // return op.divw(...op.mulw(wideRatio([info.amount, 1_000_000], [ONE_YEAR_IN_DAYS, 1_000_000]), remainingDays), 1_000_000)
    frame_dig 1
    extract 4 8
    intc 6 // 1000000
    itob
    concat
    dup
    bytec 48 // 0x000000000000016d00000000000f4240
    callsub wideRatio
    dig 2
    mulw
    pop
    cover 2
    bytec 48 // 0x000000000000016d00000000000f4240
    callsub wideRatio
    mulw
    bury 1
    intc 6 // 1000000
    divw
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.create[routing]() -> void:
create:
    // smart_contracts/arc58/dao/contract.algo.ts:763
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    pushint 200 // 200
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
    txna ApplicationArgs 6
    dup
    len
    pushint 264 // 264
    ==
    assert // invalid number of bytes for (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
    txna ApplicationArgs 7
    dup
    len
    pushint 360 // 360
    ==
    assert // invalid number of bytes for ((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64))
    txna ApplicationArgs 8
    // smart_contracts/arc58/dao/contract.algo.ts:784
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 23 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:784
    // assert(this.version.value === '', ERR_ALREADY_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    bytec_3 // ""
    ==
    assert // Already initialized
    // smart_contracts/arc58/dao/contract.algo.ts:785
    // assert(version !== '', ERR_VERSION_CANNOT_BE_EMPTY)
    dig 7
    bytec_3 // ""
    !=
    assert // Version cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 23 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:787
    // this.version.value = version
    uncover 8
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:36
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 13 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:788
    // this.proposalActionLimit.value = 5
    pushint 5 // 5
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:789
    // this.akitaAssets.value = { akta, bones: 0 }
    uncover 6
    itob
    intc_0 // 0
    itob
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 11 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:789
    // this.akitaAssets.value = { akta, bones: 0 }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // contentPolicy = GlobalState<CID>({ key: AkitaDAOGlobalStateKeysContentPolicy })
    bytec 24 // "content_policy"
    // smart_contracts/arc58/dao/contract.algo.ts:790
    // this.contentPolicy.value = contentPolicy
    uncover 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:40
    // minRewardsImpact = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysMinRewardsImpact })
    bytec 25 // "min_rewards_impact"
    // smart_contracts/arc58/dao/contract.algo.ts:791
    // this.minRewardsImpact.value = minRewardsImpact
    uncover 5
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:794
    // staking: apps.staking,
    dig 3
    extract 0 8
    // smart_contracts/arc58/dao/contract.algo.ts:795
    // rewards: apps.rewards,
    dig 4
    extract 8 8
    // smart_contracts/arc58/dao/contract.algo.ts:796
    // pool: apps.pool,
    dig 5
    extract 16 8
    // smart_contracts/arc58/dao/contract.algo.ts:797
    // prizeBox: apps.prizeBox,
    dig 6
    extract 24 8
    // smart_contracts/arc58/dao/contract.algo.ts:798
    // subscriptions: apps.subscriptions,
    dig 7
    extract 32 8
    // smart_contracts/arc58/dao/contract.algo.ts:799
    // gate: apps.gate,
    dig 8
    extract 40 8
    // smart_contracts/arc58/dao/contract.algo.ts:800
    // auction: apps.auction,
    dig 9
    extract 48 8
    // smart_contracts/arc58/dao/contract.algo.ts:801
    // hyperSwap: apps.hyperSwap,
    dig 10
    extract 56 8
    // smart_contracts/arc58/dao/contract.algo.ts:802
    // raffle: apps.raffle,
    dig 11
    extract 64 8
    // smart_contracts/arc58/dao/contract.algo.ts:803
    // metaMerkles: apps.metaMerkles,
    dig 12
    extract 72 8
    // smart_contracts/arc58/dao/contract.algo.ts:804
    // marketplace: apps.marketplace,
    dig 13
    extract 80 8
    // smart_contracts/arc58/dao/contract.algo.ts:805
    // wallet: apps.wallet,
    dig 14
    extract 176 8
    // smart_contracts/arc58/dao/contract.algo.ts:793-806
    // this.akitaAppList.value = {
    //   staking: apps.staking,
    //   rewards: apps.rewards,
    //   pool: apps.pool,
    //   prizeBox: apps.prizeBox,
    //   subscriptions: apps.subscriptions,
    //   gate: apps.gate,
    //   auction: apps.auction,
    //   hyperSwap: apps.hyperSwap,
    //   raffle: apps.raffle,
    //   metaMerkles: apps.metaMerkles,
    //   marketplace: apps.marketplace,
    //   wallet: apps.wallet,
    // }
    uncover 11
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:793-806
    // this.akitaAppList.value = {
    //   staking: apps.staking,
    //   rewards: apps.rewards,
    //   pool: apps.pool,
    //   prizeBox: apps.prizeBox,
    //   subscriptions: apps.subscriptions,
    //   gate: apps.gate,
    //   auction: apps.auction,
    //   hyperSwap: apps.hyperSwap,
    //   raffle: apps.raffle,
    //   metaMerkles: apps.metaMerkles,
    //   marketplace: apps.marketplace,
    //   wallet: apps.wallet,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:809
    // social: apps.social,
    dig 3
    extract 120 8
    // smart_contracts/arc58/dao/contract.algo.ts:810
    // graph: apps.graph,
    dig 4
    extract 128 8
    // smart_contracts/arc58/dao/contract.algo.ts:811
    // impact: apps.impact,
    dig 5
    extract 136 8
    // smart_contracts/arc58/dao/contract.algo.ts:812
    // moderation: apps.moderation
    dig 6
    extract 144 8
    // smart_contracts/arc58/dao/contract.algo.ts:808-813
    // this.akitaSocialAppList.value = {
    //   social: apps.social,
    //   graph: apps.graph,
    //   impact: apps.impact,
    //   moderation: apps.moderation
    // }
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:44
    // akitaSocialAppList = GlobalState<AkitaSocialAppList>({ key: AkitaDAOGlobalStateKeysAkitaSocialAppList })
    bytec 26 // "sal"
    // smart_contracts/arc58/dao/contract.algo.ts:808-813
    // this.akitaSocialAppList.value = {
    //   social: apps.social,
    //   graph: apps.graph,
    //   impact: apps.impact,
    //   moderation: apps.moderation
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:816
    // optin: apps.optin,
    dig 3
    extract 96 8
    // smart_contracts/arc58/dao/contract.algo.ts:817
    // revenueManager: apps.revenueManager,
    dig 4
    extract 104 8
    // smart_contracts/arc58/dao/contract.algo.ts:818
    // update: apps.update
    dig 5
    extract 112 8
    // smart_contracts/arc58/dao/contract.algo.ts:815-819
    // this.pluginAppList.value = {
    //   optin: apps.optin,
    //   revenueManager: apps.revenueManager,
    //   update: apps.update
    // }
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:46
    // pluginAppList = GlobalState<PluginAppList>({ key: AkitaDAOGlobalStateKeysPluginAppList })
    bytec 14 // "pal"
    // smart_contracts/arc58/dao/contract.algo.ts:815-819
    // this.pluginAppList.value = {
    //   optin: apps.optin,
    //   revenueManager: apps.revenueManager,
    //   update: apps.update
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:822
    // vrfBeacon: apps.vrfBeacon,
    dig 3
    extract 152 8
    // smart_contracts/arc58/dao/contract.algo.ts:823
    // nfdRegistry: apps.nfdRegistry,
    dig 4
    extract 160 8
    // smart_contracts/arc58/dao/contract.algo.ts:824
    // assetInbox: apps.assetInbox,
    dig 5
    extract 168 8
    // smart_contracts/arc58/dao/contract.algo.ts:825
    // escrow: apps.escrow,
    dig 6
    extract 184 8
    // smart_contracts/arc58/dao/contract.algo.ts:826
    // akitaNfd: apps.akitaNfd,
    dig 7
    extract 88 8
    // smart_contracts/arc58/dao/contract.algo.ts:827
    // poll: apps.poll
    uncover 8
    extract 192 8
    // smart_contracts/arc58/dao/contract.algo.ts:821-828
    // this.otherAppList.value = {
    //   vrfBeacon: apps.vrfBeacon,
    //   nfdRegistry: apps.nfdRegistry,
    //   assetInbox: apps.assetInbox,
    //   escrow: apps.escrow,
    //   akitaNfd: apps.akitaNfd,
    //   poll: apps.poll
    // }
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:821-828
    // this.otherAppList.value = {
    //   vrfBeacon: apps.vrfBeacon,
    //   nfdRegistry: apps.nfdRegistry,
    //   assetInbox: apps.assetInbox,
    //   escrow: apps.escrow,
    //   akitaNfd: apps.akitaNfd,
    //   poll: apps.poll
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:831
    // createFee: fees.walletCreateFee,
    dig 2
    extract 0 8
    // smart_contracts/arc58/dao/contract.algo.ts:832
    // referrerPercentage: fees.walletReferrerPercentage
    dig 3
    extract 8 8
    // smart_contracts/arc58/dao/contract.algo.ts:830-833
    // this.walletFees.value = {
    //   createFee: fees.walletCreateFee,
    //   referrerPercentage: fees.walletReferrerPercentage
    // }
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:50
    // walletFees = GlobalState<WalletFees>({ key: AkitaDAOGlobalStateKeysWalletFees })
    bytec 27 // "wallet_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:830-833
    // this.walletFees.value = {
    //   createFee: fees.walletCreateFee,
    //   referrerPercentage: fees.walletReferrerPercentage
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:836
    // postFee: fees.postFee,
    dig 2
    extract 16 8
    // smart_contracts/arc58/dao/contract.algo.ts:837
    // reactFee: fees.reactFee,
    dig 3
    extract 24 8
    // smart_contracts/arc58/dao/contract.algo.ts:838
    // impactTaxMin: fees.impactTaxMin,
    dig 4
    extract 32 8
    // smart_contracts/arc58/dao/contract.algo.ts:839
    // impactTaxMax: fees.impactTaxMax,
    dig 5
    extract 40 8
    // smart_contracts/arc58/dao/contract.algo.ts:835-840
    // this.socialFees.value = {
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // }
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:52
    // socialFees = GlobalState<SocialFees>({ key: AkitaDAOGlobalStateKeysSocialFees })
    bytec 28 // "social_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:835-840
    // this.socialFees.value = {
    //   postFee: fees.postFee,
    //   reactFee: fees.reactFee,
    //   impactTaxMin: fees.impactTaxMin,
    //   impactTaxMax: fees.impactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:843
    // creationFee: fees.poolCreationFee,
    dig 2
    extract 48 8
    // smart_contracts/arc58/dao/contract.algo.ts:844
    // impactTaxMin: fees.poolImpactTaxMin,
    dig 3
    extract 56 8
    // smart_contracts/arc58/dao/contract.algo.ts:845
    // impactTaxMax: fees.poolImpactTaxMax
    dig 4
    extract 64 8
    // smart_contracts/arc58/dao/contract.algo.ts:842-846
    // this.stakingFees.value = {
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // }
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:54
    // stakingFees = GlobalState<StakingFees>({ key: AkitaDAOGlobalStateKeysStakingFees })
    bytec 29 // "staking_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:842-846
    // this.stakingFees.value = {
    //   creationFee: fees.poolCreationFee,
    //   impactTaxMin: fees.poolImpactTaxMin,
    //   impactTaxMax: fees.poolImpactTaxMax
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:849
    // serviceCreationFee: fees.subscriptionServiceCreationFee,
    dig 2
    extract 72 8
    // smart_contracts/arc58/dao/contract.algo.ts:850
    // paymentPercentage: fees.subscriptionPaymentPercentage,
    dig 3
    extract 80 8
    // smart_contracts/arc58/dao/contract.algo.ts:851
    // triggerPercentage: fees.subscriptionTriggerPercentage,
    dig 4
    extract 88 8
    // smart_contracts/arc58/dao/contract.algo.ts:848-852
    // this.subscriptionFees.value = {
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // }
    cover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // subscriptionFees = GlobalState<SubscriptionFees>({ key: AkitaDAOGlobalStateKeysSubscriptionFees })
    bytec 30 // "subscription_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:848-852
    // this.subscriptionFees.value = {
    //   serviceCreationFee: fees.subscriptionServiceCreationFee,
    //   paymentPercentage: fees.subscriptionPaymentPercentage,
    //   triggerPercentage: fees.subscriptionTriggerPercentage,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:855
    // marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    dig 2
    extract 96 8
    // smart_contracts/arc58/dao/contract.algo.ts:856
    // marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    dig 3
    extract 104 8
    // smart_contracts/arc58/dao/contract.algo.ts:857
    // marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    dig 4
    extract 112 8
    // smart_contracts/arc58/dao/contract.algo.ts:858
    // marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    dig 5
    extract 120 8
    // smart_contracts/arc58/dao/contract.algo.ts:859
    // shuffleSalePercentage: fees.shuffleSalePercentage,
    dig 6
    extract 128 8
    // smart_contracts/arc58/dao/contract.algo.ts:860
    // omnigemSaleFee: fees.omnigemSaleFee,
    dig 7
    extract 136 8
    // smart_contracts/arc58/dao/contract.algo.ts:861
    // auctionCreationFee: fees.auctionCreationFee,
    dig 8
    extract 144 8
    // smart_contracts/arc58/dao/contract.algo.ts:862
    // auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    dig 9
    extract 152 8
    // smart_contracts/arc58/dao/contract.algo.ts:863
    // auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    dig 10
    extract 160 8
    // smart_contracts/arc58/dao/contract.algo.ts:864
    // auctionComposablePercentage: fees.auctionComposablePercentage,
    dig 11
    extract 168 8
    // smart_contracts/arc58/dao/contract.algo.ts:865
    // auctionRafflePercentage: fees.auctionRafflePercentage,
    dig 12
    extract 176 8
    // smart_contracts/arc58/dao/contract.algo.ts:866
    // raffleCreationFee: fees.raffleCreationFee,
    dig 13
    extract 184 8
    // smart_contracts/arc58/dao/contract.algo.ts:867
    // raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    dig 14
    extract 192 8
    // smart_contracts/arc58/dao/contract.algo.ts:868
    // raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    dig 15
    extract 200 8
    // smart_contracts/arc58/dao/contract.algo.ts:869
    // raffleComposablePercentage: fees.raffleComposablePercentage,
    dig 16
    extract 208 8
    // smart_contracts/arc58/dao/contract.algo.ts:854-870
    // this.nftFees.value = {
    //   marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    //   marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   shuffleSalePercentage: fees.shuffleSalePercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // }
    uncover 14
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:58
    // nftFees = GlobalState<NFTFees>({ key: AkitaDAOGlobalStateKeysNFTFees })
    bytec 31 // "nft_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:854-870
    // this.nftFees.value = {
    //   marketplaceSalePercentageMin: fees.marketplaceSalePercentageMin,
    //   marketplaceSalePercentageMax: fees.marketplaceSalePercentageMax,
    //   marketplaceComposablePercentage: fees.marketplaceComposablePercentage,
    //   marketplaceRoyaltyDefaultPercentage: fees.marketplaceRoyaltyDefaultPercentage,
    //   shuffleSalePercentage: fees.shuffleSalePercentage,
    //   omnigemSaleFee: fees.omnigemSaleFee,
    //   auctionCreationFee: fees.auctionCreationFee,
    //   auctionSaleImpactTaxMin: fees.auctionSaleImpactTaxMin,
    //   auctionSaleImpactTaxMax: fees.auctionSaleImpactTaxMax,
    //   auctionComposablePercentage: fees.auctionComposablePercentage,
    //   auctionRafflePercentage: fees.auctionRafflePercentage,
    //   raffleCreationFee: fees.raffleCreationFee,
    //   raffleSaleImpactTaxMin: fees.raffleSaleImpactTaxMin,
    //   raffleSaleImpactTaxMax: fees.raffleSaleImpactTaxMax,
    //   raffleComposablePercentage: fees.raffleComposablePercentage,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:873
    // impactTaxMin: fees.swapFeeImpactTaxMin,
    dig 2
    extract 216 8
    // smart_contracts/arc58/dao/contract.algo.ts:874
    // impactTaxMax: fees.swapFeeImpactTaxMax,
    uncover 3
    extract 224 8
    // smart_contracts/arc58/dao/contract.algo.ts:872-875
    // this.swapFees.value = {
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // }
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:60
    // swapFees = GlobalState<SwapFees>({ key: AkitaDAOGlobalStateKeysSwapFees })
    bytec 32 // "swap_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:872-875
    // this.swapFees.value = {
    //   impactTaxMin: fees.swapFeeImpactTaxMin,
    //   impactTaxMax: fees.swapFeeImpactTaxMax,
    // }
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:877
    // this.upgradeAppProposalSettings.value = clone(proposalSettings.upgradeApp)
    dig 1
    extract 0 40
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:877
    // this.upgradeAppProposalSettings.value = clone(proposalSettings.upgradeApp)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:878
    // this.addPluginProposalSettings.value = clone(proposalSettings.addPlugin)
    dig 1
    extract 40 40
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:878
    // this.addPluginProposalSettings.value = clone(proposalSettings.addPlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:879
    // this.removeExecutePluginProposalSettings.value = clone(proposalSettings.removeExecutePlugin)
    dig 1
    extract 80 40
    // smart_contracts/arc58/dao/contract.algo.ts:74
    // removeExecutePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveExecutePluginProposalSettings })
    bytec 49 // "remove_execute_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:879
    // this.removeExecutePluginProposalSettings.value = clone(proposalSettings.removeExecutePlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:880
    // this.removePluginProposalSettings.value = clone(proposalSettings.removePlugin)
    dig 1
    extract 120 40
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:880
    // this.removePluginProposalSettings.value = clone(proposalSettings.removePlugin)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:881
    // this.addAllowancesProposalSettings.value = clone(proposalSettings.addAllowance)
    dig 1
    extract 160 40
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:881
    // this.addAllowancesProposalSettings.value = clone(proposalSettings.addAllowance)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:882
    // this.removeAllowancesProposalSettings.value = clone(proposalSettings.removeAllowance)
    dig 1
    extract 200 40
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:882
    // this.removeAllowancesProposalSettings.value = clone(proposalSettings.removeAllowance)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:883
    // this.newEscrowProposalSettings.value = clone(proposalSettings.newEscrow)
    dig 1
    extract 240 40
    // smart_contracts/arc58/dao/contract.algo.ts:80
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:883
    // this.newEscrowProposalSettings.value = clone(proposalSettings.newEscrow)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:884
    // this.toggleEscrowLockProposalSettings.value = clone(proposalSettings.toggleEscrowLock)
    dig 1
    pushints 280 40 // 280, 40
    extract3
    // smart_contracts/arc58/dao/contract.algo.ts:82
    // toggleEscrowLockProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysToggleEscrowLockProposalSettings })
    bytec 50 // "toggle_escrow_lock_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:884
    // this.toggleEscrowLockProposalSettings.value = clone(proposalSettings.toggleEscrowLock)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:885
    // this.updateFieldsProposalSettings.value = clone(proposalSettings.updateFields)
    swap
    pushints 320 40 // 320, 40
    extract3
    // smart_contracts/arc58/dao/contract.algo.ts:84
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:885
    // this.updateFieldsProposalSettings.value = clone(proposalSettings.updateFields)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:64
    // revenueSplits = GlobalState<Split[]>({ key: AkitaDAOGlobalStateKeysRevenueSplits })
    bytec 33 // "revenue_splits"
    // smart_contracts/arc58/dao/contract.algo.ts:887
    // this.revenueSplits.value = clone(revenueSplits)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:86
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 37 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:889
    // this.proposalID.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:763
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.update[routing]() -> void:
update:
    // smart_contracts/arc58/dao/contract.algo.ts:920
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:922
    // assert(Txn.sender === this.wallet.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:922
    // assert(Txn.sender === this.wallet.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/arc58/dao/contract.algo.ts:923
    // const updatePlugin = this.pluginAppList.value.update
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:46
    // pluginAppList = GlobalState<PluginAppList>({ key: AkitaDAOGlobalStateKeysPluginAppList })
    bytec 14 // "pal"
    // smart_contracts/arc58/dao/contract.algo.ts:923
    // const updatePlugin = this.pluginAppList.value.update
    app_global_get_ex
    assert // check GlobalState exists
    pushint 16 // 16
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:924
    // assert(Global.callerApplicationId === updatePlugin, ERR_INVALID_UPGRADE)
    global CallerApplicationID
    ==
    assert // Invalid upgrade
    // smart_contracts/arc58/dao/contract.algo.ts:32
    // version = GlobalState<string>({ initialValue: '', key: GlobalStateKeyVersion })
    bytec 23 // "version"
    // smart_contracts/arc58/dao/contract.algo.ts:925
    // this.version.value = newVersion
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:920
    // @abimethod({ allowActions: ['UpdateApplication'] })
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setup[routing]() -> void:
setup:
    // smart_contracts/arc58/dao/contract.algo.ts:929
    // setup(nickname: string): uint64 {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/arc58/dao/contract.algo.ts:930
    // assert(!this.wallet.hasValue, ERR_WALLET_ALREADY_SETUP)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:930
    // assert(!this.wallet.hasValue, ERR_WALLET_ALREADY_SETUP)
    app_global_get_ex
    bury 1
    !
    assert // Wallet already setup
    // smart_contracts/arc58/dao/contract.algo.ts:932
    // const { wallet: appId } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:932
    // const { wallet: appId } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    pushint 88 // 88
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:934
    // const cost = this.setupCost()
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost
    // smart_contracts/arc58/dao/contract.algo.ts:936-948
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:940
    // receiver: Application(appId).address,
    dig 1
    app_params_get AppAddress
    assert // application exists
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/arc58/dao/contract.algo.ts:939-942
    // itxn.payment({
    //   receiver: Application(appId).address,
    //   amount: cost,
    // }),
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/arc58/dao/contract.algo.ts:936-948
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    itxn_next
    // smart_contracts/arc58/dao/contract.algo.ts:943
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/arc58/dao/contract.algo.ts:944
    // Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:946
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/arc58/dao/contract.algo.ts:936-948
    // const walletID = abiCall<typeof AbstractedAccountFactory.prototype.newAccount>({
    //   appId,
    //   args: [
    //     itxn.payment({
    //       receiver: Application(appId).address,
    //       amount: cost,
    //     }),
    //     Global.zeroAddress,
    //     Global.currentApplicationAddress,
    //     nickname,
    //     Global.zeroAddress,
    //   ]
    // }).returnValue
    pushbytes 0x37485541 // method "newAccount(pay,address,address,string,address)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    gitxn 1 LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    dup
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:950
    // this.wallet.value = Application(walletID)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:929
    // setup(nickname: string): uint64 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.partiallyInitialize[routing]() -> void:
partiallyInitialize:
    // smart_contracts/arc58/dao/contract.algo.ts:956
    // assert(Txn.sender === Global.creatorAddress, ERR_FORBIDDEN)
    txn Sender
    global CreatorAddress
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:957
    // this.state.value = DaoStatePartiallyInitialized
    pushbytes 0x01
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:955
    // partiallyInitialize(): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.initialize[routing]() -> void:
initialize:
    // smart_contracts/arc58/dao/contract.algo.ts:961
    // assert(Txn.sender === Global.creatorAddress, ERR_FORBIDDEN)
    txn Sender
    global CreatorAddress
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:962
    // this.state.value = DaoStateFullyInitialized
    bytec 34 // 0x02
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:960
    // initialize(): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newProposal[routing]() -> void:
newProposal:
    intc_0 // 0
    dupn 15
    bytec_3 // ""
    dupn 3
    // smart_contracts/arc58/dao/contract.algo.ts:967
    // newProposal(payment: gtxn.PaymentTxn, cid: CID, actions: ProposalAction[]): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 2
    // smart_contracts/arc58/dao/contract.algo.ts:968
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:968
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:969
    // const { total, power } = this.proposalCost(actions)
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    swap
    dup
    intc_0 // 0
    extract_uint64
    swap
    pushint 24 // 24
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:971
    // let fee: uint64 = 0
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:973
    // this.state.value === DaoStateFullyInitialized ||
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:973
    // this.state.value === DaoStateFullyInitialized ||
    app_global_get_ex
    assert // check GlobalState exists
    bytec 34 // 0x02
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:973-974
    // this.state.value === DaoStateFullyInitialized ||
    // (this.state.value === DaoStatePartiallyInitialized && Txn.sender !== Global.creatorAddress)
    bnz newProposal_if_body@4
    // smart_contracts/arc58/dao/contract.algo.ts:974
    // (this.state.value === DaoStatePartiallyInitialized && Txn.sender !== Global.creatorAddress)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:974
    // (this.state.value === DaoStatePartiallyInitialized && Txn.sender !== Global.creatorAddress)
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes 0x01
    ==
    bz newProposal_after_if_else@5
    txn Sender
    global CreatorAddress
    !=
    bz newProposal_after_if_else@5

newProposal_if_body@4:
    dig 2
    bury 1

newProposal_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:979-986
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: fee
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 6
    dup
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:982
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:979-986
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: fee
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    dig 2
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:179
    // assert(actions.length > 0, ERR_EMPTY_ACTION_LIST)
    dig 3
    intc_0 // 0
    extract_uint16
    dup
    bury 12
    assert // Action list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:181
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0
    bury 9

newProposal_while_top@7:
    // smart_contracts/arc58/dao/contract.algo.ts:181
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dig 8
    dig 11
    <
    bz newProposal_after_while@68
    // smart_contracts/arc58/dao/contract.algo.ts:182
    // switch (actions[i].type) {
    dig 3
    extract 2 0
    dig 9
    dup
    cover 2
    intc_3 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    bury 12
    dig 13
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_3 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    bury 21
    extract 0 1
    dup
    bury 25
    // smart_contracts/arc58/dao/contract.algo.ts:183
    // case ProposalActionTypeUpgradeApp: {
    bytec 22 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:183-191
    // case ProposalActionTypeUpgradeApp: {
    //   // UpgradeApp actions are validated later during execution
    //   // They need execution key and wallet build validation
    //   const { groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(actions[i].data)
    //   assert(groups.length > 0, 'Upgrade app action must have at least one group')
    //   assert(firstValid > 0, 'First valid round must be greater than zero')
    //   assert(lastValid > firstValid, 'Last valid round must be greater than first valid')
    //   break
    // }
    bz newProposal_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:186
    // const { groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    dig 1
    pushint 44 // 44
    extract_uint64
    uncover 2
    pushint 52 // 52
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:187
    // assert(groups.length > 0, 'Upgrade app action must have at least one group')
    uncover 2
    intc_0 // 0
    extract_uint16
    assert // Upgrade app action must have at least one group
    // smart_contracts/arc58/dao/contract.algo.ts:188
    // assert(firstValid > 0, 'First valid round must be greater than zero')
    dig 1
    assert // First valid round must be greater than zero
    // smart_contracts/arc58/dao/contract.algo.ts:189
    // assert(lastValid > firstValid, 'Last valid round must be greater than first valid')
    <
    assert // Last valid round must be greater than first valid
    // smart_contracts/arc58/dao/contract.algo.ts:190
    // break
    b newProposal_while_top@7

newProposal_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:192
    // case ProposalActionTypeAddPlugin: {
    dig 23
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:192-199
    // case ProposalActionTypeAddPlugin: {
    //   const { plugin, caller, escrow, fee, power, duration, participation, approval, useExecutionKey } = decodeArc4<ProposalAddPlugin>(actions[i].data)
    //   if (useExecutionKey) {
    //     this.validateSettings({ fee, power, duration, participation, approval })
    //   }
    //   assert(!this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_ALREADY_EXISTS)
    //   break;
    // }
    bz newProposal_after_if_else@14
    // smart_contracts/arc58/dao/contract.algo.ts:193
    // const { plugin, caller, escrow, fee, power, duration, participation, approval, useExecutionKey } = decodeArc4<ProposalAddPlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    dig 1
    extract 2 8
    bury 25
    dig 1
    extract 10 32
    bury 18
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    pushint 59 // 59
    extract_uint16
    dig 2
    cover 2
    substring3
    extract 2 0
    bury 17
    dig 1
    extract 64 8
    bury 24
    dig 1
    extract 72 8
    bury 23
    dig 1
    extract 80 8
    bury 29
    dig 1
    extract 88 8
    bury 28
    swap
    extract 96 8
    bury 26
    pushint 489 // 489
    getbit
    // smart_contracts/arc58/dao/contract.algo.ts:194
    // if (useExecutionKey) {
    bz newProposal_after_if_else@13
    // smart_contracts/arc58/dao/contract.algo.ts:195
    // this.validateSettings({ fee, power, duration, participation, approval })
    dig 21
    dig 21
    concat
    dig 27
    concat
    dig 26
    concat
    dig 25
    concat
    callsub validateSettings
    pop

newProposal_after_if_else@13:
    // smart_contracts/arc58/dao/contract.algo.ts:197
    // assert(!this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_ALREADY_EXISTS)
    dig 22
    dig 16
    concat
    dig 15
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 38 // 0x002a
    concat
    swap
    concat
    callsub pluginExists
    pop
    !
    assert // Plugin already exists
    // smart_contracts/arc58/dao/contract.algo.ts:198
    // break;
    b newProposal_while_top@7

newProposal_after_if_else@14:
    // smart_contracts/arc58/dao/contract.algo.ts:200
    // case ProposalActionTypeAddNamedPlugin: {
    dig 23
    bytec 35 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:200-204
    // case ProposalActionTypeAddNamedPlugin: {
    //   const { name } = decodeArc4<ProposalAddNamedPlugin>(actions[i].data)
    //   assert(!this.namedPluginExists(name), ERR_PLUGIN_ALREADY_EXISTS)
    //   break
    // }
    bz newProposal_after_if_else@16
    // smart_contracts/arc58/dao/contract.algo.ts:201
    // const { name } = decodeArc4<ProposalAddNamedPlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 42 // 42
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:202
    // assert(!this.namedPluginExists(name), ERR_PLUGIN_ALREADY_EXISTS)
    callsub namedPluginExists
    !
    assert // Plugin already exists
    // smart_contracts/arc58/dao/contract.algo.ts:203
    // break
    b newProposal_while_top@7

newProposal_after_if_else@16:
    // smart_contracts/arc58/dao/contract.algo.ts:205
    // case ProposalActionTypeExecutePlugin: {
    dig 23
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:205-213
    // case ProposalActionTypeExecutePlugin: {
    //   const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(actions[i].data)
    //   const pluginInfo = this.getPlugin({ plugin, caller: Global.zeroAddress, escrow })
    //   assert(pluginInfo.start !== 0, ERR_PLUGIN_DOES_NOT_EXIST)
    //   assert(pluginInfo.useExecutionKey, ERR_NOT_EXECUTABLE_PLUGIN)
    //   const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    //   assert(pluginInfo.lastValid > epochRef, ERR_PLUGIN_EXPIRED)
    //   break
    // }
    bz newProposal_after_if_else@21
    // smart_contracts/arc58/dao/contract.algo.ts:206
    // const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    swap
    extract 2 8
    dig 1
    intc_2 // 8
    extract_uint16
    dig 2
    pushint 42 // 42
    extract_uint16
    uncover 3
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:207
    // const pluginInfo = this.getPlugin({ plugin, caller: Global.zeroAddress, escrow })
    global ZeroAddress
    uncover 2
    swap
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 38 // 0x002a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:123-126
    // return abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:124
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:124
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:125
    // args: [[key]]
    bytec 36 // 0x00010002
    uncover 2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:123-126
    // return abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    bytec 51 // method "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:208
    // assert(pluginInfo.start !== 0, ERR_PLUGIN_DOES_NOT_EXIST)
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_3 // 2
    extract_uint16
    uncover 2
    select
    substring3
    dup
    bury 20
    dup
    pushint 36 // 36
    extract_uint64
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:209
    // assert(pluginInfo.useExecutionKey, ERR_NOT_EXECUTABLE_PLUGIN)
    dup
    pushint 218 // 218
    getbit
    assert // Plugin is not executable
    // smart_contracts/arc58/dao/contract.algo.ts:210
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    pushint 217 // 217
    getbit
    bz newProposal_ternary_false@19
    global Round

newProposal_ternary_merge@20:
    // smart_contracts/arc58/dao/contract.algo.ts:211
    // assert(pluginInfo.lastValid > epochRef, ERR_PLUGIN_EXPIRED)
    dig 19
    pushint 9 // 9
    extract_uint64
    <
    assert // Plugin has expired
    // smart_contracts/arc58/dao/contract.algo.ts:212
    // break
    b newProposal_while_top@7

newProposal_ternary_false@19:
    // smart_contracts/arc58/dao/contract.algo.ts:210
    // const epochRef = pluginInfo.useRounds ? Global.round : Global.latestTimestamp
    global LatestTimestamp
    b newProposal_ternary_merge@20

newProposal_after_if_else@21:
    // smart_contracts/arc58/dao/contract.algo.ts:214
    // case ProposalActionTypeRemoveExecutePlugin: {
    dig 23
    bytec 39 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:214-218
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(actions[i].data)
    //   assert(this.executionExists(executionKey), ERR_EXECUTION_KEY_NOT_FOUND)
    //   break
    // }
    bz newProposal_after_if_else@23
    // smart_contracts/arc58/dao/contract.algo.ts:215
    // const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 32
    // smart_contracts/arc58/dao/contract.algo.ts:170-173
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getExecutions>({
    //   appId: this.wallet.value,
    //   args: [[lease]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:171
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:171
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:172
    // args: [[lease]]
    dig 1
    len
    pushint 32 // 32
    ==
    assert // invalid size
    pushbytes 0x0001
    uncover 2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:170-173
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getExecutions>({
    //   appId: this.wallet.value,
    //   args: [[lease]]
    // }).returnValue[0]
    pushbytes 0x41bdc680 // method "arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:175
    // return info.groups.length > 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_3 // 2
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16
    // smart_contracts/arc58/dao/contract.algo.ts:216
    // assert(this.executionExists(executionKey), ERR_EXECUTION_KEY_NOT_FOUND)
    assert // Execution key not found
    // smart_contracts/arc58/dao/contract.algo.ts:217
    // break
    b newProposal_while_top@7

newProposal_after_if_else@23:
    // smart_contracts/arc58/dao/contract.algo.ts:219
    // case ProposalActionTypeRemovePlugin: {
    dig 23
    bytec 8 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:219-223
    // case ProposalActionTypeRemovePlugin: {
    //   const { plugin, caller, escrow } = decodeArc4<ProposalRemovePlugin>(actions[i].data)
    //   assert(this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_DOES_NOT_EXIST)
    //   break
    // }
    bz newProposal_after_if_else@25
    // smart_contracts/arc58/dao/contract.algo.ts:220
    // const { plugin, caller, escrow } = decodeArc4<ProposalRemovePlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    dig 1
    extract 2 8
    uncover 2
    extract 10 32
    dig 2
    pushint 40 // 40
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:221
    // assert(this.pluginExists({ plugin, caller, escrow }), ERR_PLUGIN_DOES_NOT_EXIST)
    cover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    bytec 38 // 0x002a
    concat
    swap
    concat
    callsub pluginExists
    pop
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:222
    // break
    b newProposal_while_top@7

newProposal_after_if_else@25:
    // smart_contracts/arc58/dao/contract.algo.ts:224
    // case ProposalActionTypeRemoveNamedPlugin: {
    dig 23
    bytec 40 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:224-228
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   const { name } = decodeArc4<ProposalRemoveNamedPlugin>(actions[i].data)
    //   assert(this.namedPluginExists(name), ERR_PLUGIN_DOES_NOT_EXIST)
    //   break
    // }
    bz newProposal_after_if_else@27
    // smart_contracts/arc58/dao/contract.algo.ts:225
    // const { name } = decodeArc4<ProposalRemoveNamedPlugin>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 42 // 42
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:226
    // assert(this.namedPluginExists(name), ERR_PLUGIN_DOES_NOT_EXIST)
    callsub namedPluginExists
    assert // Plugin does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:227
    // break
    b newProposal_while_top@7

newProposal_after_if_else@27:
    // smart_contracts/arc58/dao/contract.algo.ts:229
    // case ProposalActionTypeAddAllowances: {
    dig 23
    bytec 12 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:229-241
    // case ProposalActionTypeAddAllowances: {
    //   const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(actions[i].data)
    //   assert(allowances.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    // 
    //   let assets: uint64[] = []
    //   for (let i: uint64 = 0; i < allowances.length; i++) {
    //     assets.push(allowances[i].asset)
    //   }
    // 
    //   const { anyExist } = this.allowanceCheck(escrow, assets)
    //   assert(!anyExist, ERR_ALLOWANCE_ALREADY_EXISTS)
    //   break
    // }
    bz newProposal_after_if_else@32
    // smart_contracts/arc58/dao/contract.algo.ts:230
    // const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    bury 16
    dig 1
    len
    substring3
    dup
    bury 19
    // smart_contracts/arc58/dao/contract.algo.ts:231
    // assert(allowances.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    intc_0 // 0
    extract_uint16
    dup
    bury 11
    assert // Allowance list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:233
    // let assets: uint64[] = []
    bytec 41 // 0x0000
    bury 17
    // smart_contracts/arc58/dao/contract.algo.ts:234
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    intc_0 // 0
    bury 8

newProposal_while_top@29:
    // smart_contracts/arc58/dao/contract.algo.ts:234
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    dig 7
    dig 10
    <
    bz newProposal_after_while@31
    // smart_contracts/arc58/dao/contract.algo.ts:235
    // assets.push(allowances[i].asset)
    dig 17
    extract 2 0
    dig 8
    dup
    cover 2
    pushint 34 // 34
    *
    pushint 34 // 34
    extract3 // on error: index access is out of bounds
    extract 0 8
    dig 18
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 18
    // smart_contracts/arc58/dao/contract.algo.ts:234
    // for (let i: uint64 = 0; i < allowances.length; i++) {
    intc_1 // 1
    +
    bury 8
    b newProposal_while_top@29

newProposal_after_while@31:
    // smart_contracts/arc58/dao/contract.algo.ts:238
    // const { anyExist } = this.allowanceCheck(escrow, assets)
    dig 13
    dig 17
    callsub allowanceCheck
    pop
    pushint 16 // 16
    getbit
    // smart_contracts/arc58/dao/contract.algo.ts:239
    // assert(!anyExist, ERR_ALLOWANCE_ALREADY_EXISTS)
    !
    assert // allowance already exists
    // smart_contracts/arc58/dao/contract.algo.ts:240
    // break
    b newProposal_while_top@7

newProposal_after_if_else@32:
    // smart_contracts/arc58/dao/contract.algo.ts:242
    // case ProposalActionTypeRemoveAllowances: {
    dig 23
    bytec 42 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:242-248
    // case ProposalActionTypeRemoveAllowances: {
    //   const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(actions[i].data)
    //   assert(assets.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    //   const { allExist } = this.allowanceCheck(escrow, assets)
    //   assert(allExist, ERR_ALLOWANCE_DOES_NOT_EXIST)
    //   break
    // }
    bz newProposal_after_if_else@34
    // smart_contracts/arc58/dao/contract.algo.ts:243
    // const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:244
    // assert(assets.length > 0, ERR_ALLOWANCE_LIST_EMPTY)
    dup
    intc_0 // 0
    extract_uint16
    assert // Allowance list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:245
    // const { allExist } = this.allowanceCheck(escrow, assets)
    callsub allowanceCheck
    pop
    pushint 17 // 17
    getbit
    // smart_contracts/arc58/dao/contract.algo.ts:246
    // assert(allExist, ERR_ALLOWANCE_DOES_NOT_EXIST)
    assert // allowance does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:247
    // break
    b newProposal_while_top@7

newProposal_after_if_else@34:
    // smart_contracts/arc58/dao/contract.algo.ts:249
    // case ProposalActionTypeNewEscrow: {
    dig 23
    bytec 43 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:249-253
    // case ProposalActionTypeNewEscrow: {
    //   const { escrow } = decodeArc4<ProposalNewEscrow>(actions[i].data)
    //   assert(!this.escrowExists(escrow), ERR_ESCROW_ALREADY_EXISTS)
    //   break
    // }
    bz newProposal_after_if_else@36
    // smart_contracts/arc58/dao/contract.algo.ts:250
    // const { escrow } = decodeArc4<ProposalNewEscrow>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:251
    // assert(!this.escrowExists(escrow), ERR_ESCROW_ALREADY_EXISTS)
    callsub escrowExists
    !
    assert // Escrow already exists
    // smart_contracts/arc58/dao/contract.algo.ts:252
    // break
    b newProposal_while_top@7

newProposal_after_if_else@36:
    // smart_contracts/arc58/dao/contract.algo.ts:254
    // case ProposalActionTypeToggleEscrowLock: {
    dig 23
    bytec 44 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:254-258
    // case ProposalActionTypeToggleEscrowLock: {
    //   const { escrow } = decodeArc4<ProposalToggleEscrowLock>(actions[i].data)
    //   assert(this.escrowExists(escrow), ERR_ESCROW_DOES_NOT_EXIST)
    //   break
    // }
    bz newProposal_after_if_else@38
    // smart_contracts/arc58/dao/contract.algo.ts:255
    // const { escrow } = decodeArc4<ProposalToggleEscrowLock>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:256
    // assert(this.escrowExists(escrow), ERR_ESCROW_DOES_NOT_EXIST)
    callsub escrowExists
    assert // Escrow does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:257
    // break
    b newProposal_while_top@7

newProposal_after_if_else@38:
    // smart_contracts/arc58/dao/contract.algo.ts:259
    // case ProposalActionTypeUpdateFields: {
    dig 23
    bytec 45 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:259-341
    // case ProposalActionTypeUpdateFields: {
    //   const { field, value } = decodeArc4<ProposalUpdateField>(actions[i].data)
    //   switch (field) {
    //     case AkitaDAOGlobalStateKeysContentPolicy: {
    //       assert(value.length === 36, ERR_INVALID_CID)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //       assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    //       assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //       assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    //       assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    //       assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysAkitaAppList: {
    //       decodeArc4<AkitaAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysAkitaSocialAppList: {
    //       decodeArc4<AkitaSocialAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysPluginAppList: {
    //       decodeArc4<PluginAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysOtherAppList: {
    //       decodeArc4<OtherAppList>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysWalletFees: {
    //       decodeArc4<WalletFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSocialFees: {
    //       decodeArc4<SocialFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysStakingFees: {
    //       decodeArc4<StakingFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //       decodeArc4<SubscriptionFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysNFTFees: {
    //       decodeArc4<NFTFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysSwapFees: {
    //       decodeArc4<SwapFees>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysAkitaAssets: {
    //       decodeArc4<AkitaAssets>(value)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings:
    //     case AkitaDAOGlobalStateKeysAddPluginProposalSettings:
    //     case AkitaDAOGlobalStateKeysRemovePluginProposalSettings:
    //     case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings:
    //     case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings:
    //     case AkitaDAOGlobalStateKeysNewEscrowProposalSettings:
    //     case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //       const settings = decodeArc4<ProposalSettings>(value)
    //       this.validateSettings(settings)
    //       break
    //     }
    //     case AkitaDAOGlobalStateKeysRevenueSplits: {
    //       decodeArc4<Split[]>(value)
    //       break
    //     }
    //     default: {
    //       assert(false, 'Unknown field in update fields proposal action')
    //     }
    //   }
    //   break
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:260
    // const { field, value } = decodeArc4<ProposalUpdateField>(actions[i].data)
    dig 19
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dup
    cover 3
    bury 16
    dig 1
    len
    substring3
    extract 2 0
    bury 13
    // smart_contracts/arc58/dao/contract.algo.ts:262
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    bytec 24 // "content_policy"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:262-265
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    //   assert(value.length === 36, ERR_INVALID_CID)
    //   break
    // }
    bz newProposal_after_if_else@41
    // smart_contracts/arc58/dao/contract.algo.ts:263
    // assert(value.length === 36, ERR_INVALID_CID)
    dig 11
    len
    pushint 36 // 36
    ==
    assert // Invalid CID
    // smart_contracts/arc58/dao/contract.algo.ts:264
    // break
    b newProposal_while_top@7

newProposal_after_if_else@41:
    // smart_contracts/arc58/dao/contract.algo.ts:266
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    dig 12
    bytec 13 // "proposal_action_limit"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:266-270
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //   assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    //   assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    //   break
    // }
    bz newProposal_after_if_else@43
    // smart_contracts/arc58/dao/contract.algo.ts:267
    // assert(value.length === 8, ERR_INVALID_PROPOSAL_ACTION_LIMIT)
    dig 11
    dup
    len
    intc_2 // 8
    ==
    assert // Invalid proposal action limit
    // smart_contracts/arc58/dao/contract.algo.ts:268
    // assert(btoi(value) > 0, ERR_ACTION_LIMIT_MUST_BE_GREATER_THAN_ZERO)
    btoi
    assert // Action limit must be greater than zero
    // smart_contracts/arc58/dao/contract.algo.ts:269
    // break
    b newProposal_while_top@7

newProposal_after_if_else@43:
    // smart_contracts/arc58/dao/contract.algo.ts:271
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    dig 12
    bytec 25 // "min_rewards_impact"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:271-276
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //   assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    //   assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    //   assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    //   break
    // }
    bz newProposal_after_if_else@45
    // smart_contracts/arc58/dao/contract.algo.ts:272
    // assert(value.length === 8, ERR_INVALID_MINIMUM_REWARDS_IMPACT)
    dig 11
    dup
    len
    intc_2 // 8
    ==
    assert // Invalid minimum rewards impact
    // smart_contracts/arc58/dao/contract.algo.ts:273
    // assert(btoi(value) > 0, ERR_MIN_REWARDS_IMPACT_MUST_BE_GREATER_THAN_ZERO)
    btoi
    dup
    assert // Minimum rewards impact must be greater than zero
    // smart_contracts/arc58/dao/contract.algo.ts:274
    // assert(btoi(value) <= 1000, ERR_MIN_REWARDS_IMPACT_MUST_BE_LESS_THAN_OR_EQUAL_TO_1000s)
    intc 5 // 1000
    <=
    assert // Minimum rewards impact must be less than or equal to 1000
    // smart_contracts/arc58/dao/contract.algo.ts:275
    // break
    b newProposal_while_top@7

newProposal_after_if_else@45:
    // smart_contracts/arc58/dao/contract.algo.ts:277
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    dig 12
    bytec 9 // "aal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:277-280
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    //   decodeArc4<AkitaAppList>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:281
    // case AkitaDAOGlobalStateKeysAkitaSocialAppList: {
    dig 12
    bytec 26 // "sal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:281-284
    // case AkitaDAOGlobalStateKeysAkitaSocialAppList: {
    //   decodeArc4<AkitaSocialAppList>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:285
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    dig 12
    bytec 14 // "pal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:285-288
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    //   decodeArc4<PluginAppList>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:289
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    dig 12
    bytec 5 // "oal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:289-292
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    //   decodeArc4<OtherAppList>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:293
    // case AkitaDAOGlobalStateKeysWalletFees: {
    dig 12
    bytec 27 // "wallet_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:293-296
    // case AkitaDAOGlobalStateKeysWalletFees: {
    //   decodeArc4<WalletFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:297
    // case AkitaDAOGlobalStateKeysSocialFees: {
    dig 12
    bytec 28 // "social_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:297-300
    // case AkitaDAOGlobalStateKeysSocialFees: {
    //   decodeArc4<SocialFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:301
    // case AkitaDAOGlobalStateKeysStakingFees: {
    dig 12
    bytec 29 // "staking_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:301-304
    // case AkitaDAOGlobalStateKeysStakingFees: {
    //   decodeArc4<StakingFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:305
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    dig 12
    bytec 30 // "subscription_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:305-308
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //   decodeArc4<SubscriptionFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:309
    // case AkitaDAOGlobalStateKeysNFTFees: {
    dig 12
    bytec 31 // "nft_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:309-312
    // case AkitaDAOGlobalStateKeysNFTFees: {
    //   decodeArc4<NFTFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:313
    // case AkitaDAOGlobalStateKeysSwapFees: {
    dig 12
    bytec 32 // "swap_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:313-316
    // case AkitaDAOGlobalStateKeysSwapFees: {
    //   decodeArc4<SwapFees>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:317
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    dig 12
    bytec 11 // "akita_assets"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:317-320
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    //   decodeArc4<AkitaAssets>(value)
    //   break
    // }
    bnz newProposal_while_top@7
    // smart_contracts/arc58/dao/contract.algo.ts:321
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings:
    dig 12
    bytec 15 // "upgrade_app_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:322
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings:
    dig 12
    bytec 16 // "add_plugin_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:323
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings:
    dig 12
    bytec 17 // "remove_plugin_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:324
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings:
    dig 12
    bytec 18 // "add_allowance_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:325
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings:
    dig 12
    bytec 19 // "remove_allowance_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:326
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings:
    dig 12
    bytec 20 // "new_escrow_ps"
    ==
    bnz newProposal_block@63
    // smart_contracts/arc58/dao/contract.algo.ts:327
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    dig 12
    bytec 21 // "update_fields_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:327-331
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //   const settings = decodeArc4<ProposalSettings>(value)
    //   this.validateSettings(settings)
    //   break
    // }
    bz newProposal_after_if_else@64

newProposal_block@63:
    // smart_contracts/arc58/dao/contract.algo.ts:329
    // this.validateSettings(settings)
    dig 11
    callsub validateSettings
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:330
    // break
    b newProposal_while_top@7

newProposal_after_if_else@64:
    // smart_contracts/arc58/dao/contract.algo.ts:332
    // case AkitaDAOGlobalStateKeysRevenueSplits: {
    dig 12
    bytec 33 // "revenue_splits"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:332-335
    // case AkitaDAOGlobalStateKeysRevenueSplits: {
    //   decodeArc4<Split[]>(value)
    //   break
    // }
    assert // Unknown field in update fields proposal action
    b newProposal_while_top@7

newProposal_after_while@68:
    // smart_contracts/arc58/dao/contract.algo.ts:990
    // return this.createOrUpdateProposal(0, cid, actions, origin, fee, power)
    intc_0 // 0
    dig 6
    dig 5
    dig 7
    dig 4
    dig 6
    callsub createOrUpdateProposal
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:967
    // newProposal(payment: gtxn.PaymentTxn, cid: CID, actions: ProposalAction[]): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.editProposal[routing]() -> void:
editProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:993
    // editProposal(id: uint64, cid: CID, actions: ProposalAction[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 3
    // smart_contracts/arc58/dao/contract.algo.ts:994
    // assert(this.validEditOrSubmit(id), ERR_INVALID_PROPOSAL_STATE)
    dig 2
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:996
    // const { feesPaid } = this.proposals(id).value
    dig 2
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:996
    // const { feesPaid } = this.proposals(id).value
    pushint 109 // 109
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:997
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:997
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:998
    // const { total, power } = this.proposalCost(actions)
    uncover 2
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    dig 1
    intc_0 // 0
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1000
    // assert(total <= feesPaid, ERR_PAYMENT_REQUIRED)
    dig 1
    uncover 5
    <=
    assert // Payment required
    // smart_contracts/arc58/dao/contract.algo.ts:1002
    // this.createOrUpdateProposal(id, cid, actions, origin, total, power)
    uncover 5
    uncover 5
    uncover 4
    uncover 5
    uncover 5
    uncover 5
    callsub createOrUpdateProposal
    popn 2
    // smart_contracts/arc58/dao/contract.algo.ts:993
    // editProposal(id: uint64, cid: CID, actions: ProposalAction[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.editProposalWithPayment[routing]() -> void:
editProposalWithPayment:
    // smart_contracts/arc58/dao/contract.algo.ts:1005
    // editProposalWithPayment(payment: gtxn.PaymentTxn, id: uint64, cid: CID, actions: ProposalAction[]): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 36 // 36
    ==
    assert // invalid number of bytes for uint8[36]
    txna ApplicationArgs 3
    // smart_contracts/arc58/dao/contract.algo.ts:1006
    // assert(this.validEditOrSubmit(id), ERR_INVALID_PROPOSAL_STATE)
    dig 2
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1008
    // const { feesPaid } = this.proposals(id).value
    dig 2
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1008
    // const { feesPaid } = this.proposals(id).value
    pushint 109 // 109
    intc_2 // 8
    box_extract
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1009
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:1009
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:1010
    // const { total, power } = this.proposalCost(actions)
    uncover 2
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    dig 1
    intc_0 // 0
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1012
    // assert(total > feesPaid, ERR_PAYMENT_NOT_REQUIRED)
    dig 1
    dig 5
    >
    assert // Payment not required
    // smart_contracts/arc58/dao/contract.algo.ts:1014-1021
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 7
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:1017
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:1014-1021
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 8
    gtxns Amount
    // smart_contracts/arc58/dao/contract.algo.ts:1018
    // amount: total - feesPaid
    dig 3
    uncover 7
    -
    // smart_contracts/arc58/dao/contract.algo.ts:1014-1021
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: total - feesPaid
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:1023
    // this.createOrUpdateProposal(id, cid, actions, origin, total, power)
    uncover 5
    uncover 5
    uncover 4
    uncover 5
    uncover 5
    uncover 5
    callsub createOrUpdateProposal
    popn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1005
    // editProposalWithPayment(payment: gtxn.PaymentTxn, id: uint64, cid: CID, actions: ProposalAction[]): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.deleteProposal[routing]() -> void:
deleteProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:1026
    // deleteProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1027
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1027
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1029
    // const { status, creator } = this.proposals(proposalID).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    dup
    uncover 2
    pushints 61 32 // 61, 32
    box_extract
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:1031
    // status === ProposalStatusDraft ||
    bytec_0 // 0x00
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1031-1032
    // status === ProposalStatusDraft ||
    // status === ProposalStatusExecuted,
    bnz deleteProposal_bool_true@3
    // smart_contracts/arc58/dao/contract.algo.ts:1032
    // status === ProposalStatusExecuted,
    dig 1
    bytec 12 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1031-1032
    // status === ProposalStatusDraft ||
    // status === ProposalStatusExecuted,
    bz deleteProposal_bool_false@4

deleteProposal_bool_true@3:
    intc_1 // 1

deleteProposal_bool_merge@5:
    // smart_contracts/arc58/dao/contract.algo.ts:1030-1034
    // assert(
    //   status === ProposalStatusDraft ||
    //   status === ProposalStatusExecuted,
    //   ERR_INVALID_PROPOSAL_STATE
    // )
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1036
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:1036
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    // smart_contracts/arc58/dao/contract.algo.ts:1037
    // assert(origin === creator, ERR_INCORRECT_SENDER)
    dig 1
    ==
    assert // Incorrect sender
    // smart_contracts/arc58/dao/contract.algo.ts:1039
    // this.proposals(proposalID).delete()
    dig 2
    box_del
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1026
    // deleteProposal(proposalID: uint64): void {
    intc_1 // 1
    return

deleteProposal_bool_false@4:
    intc_0 // 0
    b deleteProposal_bool_merge@5


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.submitProposal[routing]() -> void:
submitProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:1042
    // submitProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1043
    // assert(this.validEditOrSubmit(proposalID), ERR_INVALID_PROPOSAL_STATE)
    dup
    callsub validEditOrSubmit
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1045
    // this.proposals(proposalID).value.votingTs = Global.latestTimestamp
    global LatestTimestamp
    swap
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1045
    // this.proposals(proposalID).value.votingTs = Global.latestTimestamp
    swap
    itob
    dig 1
    pushint 93 // 93
    uncover 2
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:1046
    // this.proposals(proposalID).value.status = ProposalStatusVoting
    intc_0 // 0
    bytec 6 // 0x14
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:1042
    // submitProposal(proposalID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.voteProposal[routing]() -> void:
voteProposal:
    intc_0 // 0
    bytec_3 // ""
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:1049
    // voteProposal(mbrPayment: gtxn.PaymentTxn, proposalID: uint64, vote: ProposalVoteType): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 3
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for uint8
    // smart_contracts/arc58/dao/contract.algo.ts:1050
    // assert(this.state.value !== DaoStateDraft, ERR_DAO_NOT_INITIALIZED)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:1050
    // assert(this.state.value !== DaoStateDraft, ERR_DAO_NOT_INITIALIZED)
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // 0x00
    !=
    assert // DAO is not initialized
    // smart_contracts/arc58/dao/contract.algo.ts:1051
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    dig 1
    concat
    dup
    cover 3
    // smart_contracts/arc58/dao/contract.algo.ts:1051
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1053-1060
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 2
    gtxns Receiver
    // smart_contracts/arc58/dao/contract.algo.ts:1056
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/arc58/dao/contract.algo.ts:1053-1060
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 3
    gtxns Amount
    // smart_contracts/arc58/dao/contract.algo.ts:1057
    // amount: DAOProposalVotesMBR,
    pushint 22500 // 22500
    // smart_contracts/arc58/dao/contract.algo.ts:1053-1060
    // assertMatch(
    //   mbrPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: DAOProposalVotesMBR,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/arc58/dao/contract.algo.ts:1062
    // const { status } = this.proposals(proposalID).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    // smart_contracts/arc58/dao/contract.algo.ts:1063
    // assert(status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATE)
    bytec 6 // 0x14
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1065
    // const voter = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:1065
    // const voter = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    dup
    cover 3
    // smart_contracts/arc58/dao/contract.algo.ts:1066
    // const proposal = clone(this.proposals(proposalID).value)
    swap
    box_get
    swap
    cover 3
    assert // Box must have value
    // smart_contracts/arc58/dao/contract.algo.ts:1068
    // if (this.proposalVotes({ proposalID, voter }).exists) {
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:95
    // proposalVotes = BoxMap<ProposalVoteKey, ProposalVoteInfo>({ keyPrefix: AkitaDAOBoxPrefixProposalVotes })
    pushbytes "v"
    swap
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:1068
    // if (this.proposalVotes({ proposalID, voter }).exists) {
    box_len
    bury 1
    bz voteProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:1069
    // const { type, power: previousPower } = this.proposalVotes({ proposalID, voter }).value
    dup
    box_get
    assert // Box must have value
    dup
    extract 0 1
    dup
    cover 2
    bury 10
    intc_1 // 1
    extract_uint64
    bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:1072
    // case ProposalVoteTypeApprove: {
    bytec 22 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1072-1075
    // case ProposalVoteTypeApprove: {
    //   proposal.votes.approvals -= previousPower
    //   break;
    // }
    bz voteProposal_after_if_else@6
    // smart_contracts/arc58/dao/contract.algo.ts:1073
    // proposal.votes.approvals -= previousPower
    dig 3
    pushints 37 24 // 37, 24
    box_extract
    intc_0 // 0
    extract_uint64
    dig 6
    -
    itob
    dig 2
    dup
    cover 2
    extract 37 24
    swap
    replace2 0
    replace2 37
    bury 2

voteProposal_after_if_else@18:
    // smart_contracts/arc58/dao/contract.algo.ts:1090
    // const power = this.getGovernancePower(voter)
    dig 2
    callsub getGovernancePower
    dup
    bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1093
    // assert(power > 0, ERR_FORBIDDEN)
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:1096
    // case ProposalVoteTypeApprove: {
    dig 4
    bytec 22 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1096-1099
    // case ProposalVoteTypeApprove: {
    //   proposal.votes.approvals += power
    //   break;
    // }
    bz voteProposal_after_if_else@22
    // smart_contracts/arc58/dao/contract.algo.ts:1097
    // proposal.votes.approvals += power
    dig 1
    dup
    extract 37 24
    dup
    intc_0 // 0
    extract_uint64
    dig 9
    +
    itob
    replace2 0
    replace2 37
    bury 2

voteProposal_block@33:
    // smart_contracts/arc58/dao/contract.algo.ts:1114
    // this.proposals(proposalID).value = clone(proposal)
    dig 3
    dup
    box_del
    pop
    dig 2
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:1115
    // this.proposalVotes({ proposalID, voter }).value = { type: vote, power }
    dig 6
    itob
    dig 5
    swap
    concat
    dig 1
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:1049
    // voteProposal(mbrPayment: gtxn.PaymentTxn, proposalID: uint64, vote: ProposalVoteType): void {
    intc_1 // 1
    return

voteProposal_after_if_else@22:
    // smart_contracts/arc58/dao/contract.algo.ts:1100
    // case ProposalVoteTypeReject: {
    dig 4
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1100-1103
    // case ProposalVoteTypeReject: {
    //   proposal.votes.rejections += power
    //   break;
    // }
    bz voteProposal_after_if_else@26
    // smart_contracts/arc58/dao/contract.algo.ts:1101
    // proposal.votes.rejections += power
    dig 1
    dup
    extract 37 24
    dup
    intc_2 // 8
    extract_uint64
    dig 9
    +
    itob
    replace2 8
    replace2 37
    bury 2
    // smart_contracts/arc58/dao/contract.algo.ts:1102
    // break;
    b voteProposal_block@33

voteProposal_after_if_else@26:
    // smart_contracts/arc58/dao/contract.algo.ts:1104
    // case ProposalVoteTypeAbstain: {
    dig 4
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1104-1107
    // case ProposalVoteTypeAbstain: {
    //   proposal.votes.abstains += power
    //   break;
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:1105
    // proposal.votes.abstains += power
    dig 1
    dup
    extract 37 24
    dup
    pushint 16 // 16
    extract_uint64
    dig 9
    +
    itob
    replace2 16
    replace2 37
    bury 2
    // smart_contracts/arc58/dao/contract.algo.ts:1106
    // break;
    b voteProposal_block@33

voteProposal_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1076
    // case ProposalVoteTypeReject: {
    dig 7
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1076-1079
    // case ProposalVoteTypeReject: {
    //   proposal.votes.rejections -= previousPower
    //   break;
    // }
    bz voteProposal_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:1077
    // proposal.votes.rejections -= previousPower
    dig 3
    pushints 37 24 // 37, 24
    box_extract
    intc_2 // 8
    extract_uint64
    dig 6
    -
    itob
    dig 2
    dup
    cover 2
    extract 37 24
    swap
    replace2 8
    replace2 37
    bury 2
    // smart_contracts/arc58/dao/contract.algo.ts:1078
    // break;
    b voteProposal_after_if_else@18

voteProposal_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1080
    // case ProposalVoteTypeAbstain: {
    dig 7
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1080-1083
    // case ProposalVoteTypeAbstain: {
    //   proposal.votes.abstains -= previousPower
    //   break;
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:1081
    // proposal.votes.abstains -= previousPower
    dig 3
    pushints 37 24 // 37, 24
    box_extract
    pushint 16 // 16
    extract_uint64
    dig 6
    -
    itob
    dig 2
    dup
    cover 2
    extract 37 24
    swap
    replace2 16
    replace2 37
    bury 2
    // smart_contracts/arc58/dao/contract.algo.ts:1082
    // break;
    b voteProposal_after_if_else@18


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.finalizeProposal[routing]() -> void:
finalizeProposal:
    bytec_3 // ""
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:1118
    // finalizeProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1119
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1119
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1121
    // const { status, creator, votes: { approvals, rejections, abstains }, votingTs, actions } = clone(this.proposals(proposalID).value)
    dup
    box_get
    pop
    swap
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    dig 1
    pushints 61 32 // 61, 32
    box_extract
    dig 2
    pushints 37 24 // 37, 24
    box_extract
    dup
    intc_0 // 0
    extract_uint64
    cover 5
    dup
    intc_2 // 8
    extract_uint64
    cover 5
    pushint 16 // 16
    extract_uint64
    cover 4
    uncover 2
    pushint 93 // 93
    intc_2 // 8
    box_extract
    btoi
    cover 3
    dig 2
    pushint 117 // 117
    extract_uint16
    dig 3
    len
    uncover 4
    cover 2
    substring3
    cover 2
    // smart_contracts/arc58/dao/contract.algo.ts:1123
    // assert(Txn.sender === creator, ERR_INCORRECT_SENDER)
    txn Sender
    ==
    assert // Incorrect sender
    // smart_contracts/arc58/dao/contract.algo.ts:1124
    // assert(status === ProposalStatusVoting, ERR_INVALID_PROPOSAL_STATE)
    bytec 6 // 0x14
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1127
    // const { akta, bones } = this.akitaAssets.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 11 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:1127
    // const { akta, bones } = this.akitaAssets.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dup
    uncover 2
    intc_2 // 8
    extract_uint64
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:1128
    // let locked: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:1129
    // if (akta > 0 && bones > 0) {
    bz finalizeProposal_after_if_else@5
    dig 1
    bz finalizeProposal_after_if_else@5
    // smart_contracts/arc58/dao/contract.algo.ts:1130-1135
    // const totals = abiCall<typeof Staking.prototype.getTotals>({
    //   appId: this.akitaAppList.value.staking,
    //   args: [
    //     [akta, bones]
    //   ]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:1131
    // appId: this.akitaAppList.value.staking,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:1131
    // appId: this.akitaAppList.value.staking,
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1133
    // [akta, bones]
    dig 3
    itob
    pushbytes 0x0002
    swap
    concat
    dig 3
    itob
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1130-1135
    // const totals = abiCall<typeof Staking.prototype.getTotals>({
    //   appId: this.akitaAppList.value.staking,
    //   args: [
    //     [akta, bones]
    //   ]
    // }).returnValue
    pushbytes 0x6be8cee6 // method "getTotals(uint64[])(uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 16 // 16
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64)[])
    // smart_contracts/arc58/dao/contract.algo.ts:1137
    // const lockedAkta = totals[0].locked
    dup
    extract 6 16
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1138
    // const lockedBones = totals[1].locked
    swap
    extract 22 16
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1139
    // locked = lockedAkta < lockedBones ? lockedAkta : lockedBones
    dup2
    <
    swap
    cover 2
    select
    bury 1

finalizeProposal_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:1142
    // const totalVotes: uint64 = approvals + rejections + abstains
    dig 7
    dig 7
    dup
    cover 2
    +
    dup
    bury 13
    dig 7
    +
    bury 11
    // smart_contracts/arc58/dao/contract.algo.ts:1146
    // if (rejections > 0) {
    bz finalizeProposal_else_body@7
    // smart_contracts/utils/functions.ts:109
    // assert(a < b, ERR_INVALID_PERCENTAGE_OF_ARGS)
    dig 7
    dup
    dig 12
    dup
    cover 3
    <
    assert // Invalid percentage of args
    // smart_contracts/utils/functions.ts:110
    // return op.divw(...op.mulw(a, DIVISOR), b)
    intc 4 // 100000
    mulw
    uncover 2
    divw

finalizeProposal_after_if_else@8:
    // smart_contracts/arc58/dao/contract.algo.ts:1152
    // const { duration, participation, approval } = this.proposalCost(actions)
    dig 4
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    pop
    dup
    pushint 32 // 32
    extract_uint64
    dig 1
    pushint 40 // 40
    extract_uint64
    uncover 2
    pushint 48 // 48
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1154
    // assert(Global.latestTimestamp > (votingTs + duration), ERR_VOTING_DURATION_NOT_MET)
    global LatestTimestamp
    dig 9
    uncover 4
    +
    >
    assert // Voting duration not met
    // smart_contracts/utils/functions.ts:104
    // assert(p <= DIVISOR, ERR_INVALID_PERCENTAGE)
    dig 1
    intc 4 // 100000
    <=
    assert // Invalid percentage
    // smart_contracts/utils/functions.ts:105
    // return op.divw(...op.mulw(a, p), DIVISOR)
    dig 3
    uncover 2
    mulw
    intc 4 // 100000
    divw
    // smart_contracts/arc58/dao/contract.algo.ts:1156
    // assert(totalVotes >= participationThreshold, ERR_VOTING_PARTICIPATION_NOT_MET)
    dig 12
    <=
    assert // Voting participation not met
    // smart_contracts/arc58/dao/contract.algo.ts:1158
    // if (approvalPercentage >= approval) {
    >=
    bz finalizeProposal_else_body@10
    // smart_contracts/arc58/dao/contract.algo.ts:1159
    // this.proposals(proposalID).value.status = ProposalStatusApproved
    dig 8
    intc_0 // 0
    bytec 8 // 0x28
    box_replace

finalizeProposal_after_if_else@11:
    // smart_contracts/arc58/dao/contract.algo.ts:1118
    // finalizeProposal(proposalID: uint64): void {
    intc_1 // 1
    return

finalizeProposal_else_body@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1161
    // this.proposals(proposalID).value.status = ProposalStatusRejected
    dig 8
    intc_0 // 0
    bytec 10 // 0x1e
    box_replace
    b finalizeProposal_after_if_else@11

finalizeProposal_else_body@7:
    // smart_contracts/arc58/dao/contract.algo.ts:1149
    // approvalPercentage = ONE_HUNDRED_PERCENT
    intc 4 // 100000
    b finalizeProposal_after_if_else@8


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.executeProposal[routing]() -> void:
executeProposal:
    intc_0 // 0
    dupn 4
    bytec_3 // ""
    // smart_contracts/arc58/dao/contract.algo.ts:1165
    // executeProposal(proposalID: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1166
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1166
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1168
    // const { status, actions } = clone(this.proposals(proposalID).value)
    dup
    box_get
    pop
    swap
    intc_0 // 0
    intc_1 // 1
    box_extract
    // smart_contracts/arc58/dao/contract.algo.ts:1170
    // assert(status === ProposalStatusApproved, ERR_INVALID_PROPOSAL_STATE)
    bytec 8 // 0x28
    ==
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1172
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0

executeProposal_while_top@2:
    // smart_contracts/arc58/dao/contract.algo.ts:1172
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dig 2
    pushint 119 // 119
    intc_3 // 2
    box_extract
    btoi
    dig 1
    >
    bz executeProposal_after_while@52
    // smart_contracts/arc58/dao/contract.algo.ts:1174
    // const { type, data } = actions[i]
    dig 2
    dup
    pushint 119 // 119
    intc_3 // 2
    box_extract
    btoi
    dig 2
    dup
    uncover 2
    <
    assert // index out of bounds
    intc_3 // 2
    dig 1
    *
    pushint 121 // 121
    +
    dig 2
    swap
    intc_3 // 2
    box_extract
    btoi
    pushint 121 // 121
    +
    uncover 2
    swap
    intc_1 // 1
    box_extract
    dup
    cover 2
    bury 9
    dig 3
    dup
    pushint 117 // 117
    extract_uint16
    dig 1
    len
    substring3
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 2
    intc_3 // 2
    *
    dig 2
    swap
    extract_uint16
    uncover 3
    intc_1 // 1
    +
    dup
    bury 10
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_3 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    bury 12
    extract 2 0
    bury 10
    // smart_contracts/arc58/dao/contract.algo.ts:1177
    // case ProposalActionTypeUpgradeApp:
    bytec 22 // 0x0a
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1177-1182
    // case ProposalActionTypeUpgradeApp:
    //   const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(data)
    //   // track the proposal that created the execution by lease so they can be verified without explicit proposal id being provided
    //   this.executions(executionKey).value = { proposalID, index: i }
    //   this.newExecution(executionKey, groups, firstValid, lastValid)
    //   break
    bz executeProposal_after_if_else@6
    // smart_contracts/arc58/dao/contract.algo.ts:1178
    // const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalUpgradeApp>(data)
    dig 9
    dup
    extract 10 32
    dig 10
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    dig 2
    pushint 44 // 44
    extract_uint64
    uncover 3
    pushint 52 // 52
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1180
    // this.executions(executionKey).value = { proposalID, index: i }
    dig 4
    itob
    dig 8
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:97
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    pushbytes "x"
    dig 5
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1180
    // this.executions(executionKey).value = { proposalID, index: i }
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:1181
    // this.newExecution(executionKey, groups, firstValid, lastValid)
    callsub newExecution
    pop

executeProposal_block@51:
    dig 4
    bury 1
    b executeProposal_while_top@2

executeProposal_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1183
    // case ProposalActionTypeExecutePlugin: {
    dig 6
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1183-1187
    // case ProposalActionTypeExecutePlugin: {
    //   const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalExecutePlugin>(data)
    //   this.newExecution(executionKey, groups, firstValid, lastValid)
    //   break
    // }
    bz executeProposal_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:1184
    // const { executionKey, groups, firstValid, lastValid } = decodeArc4<ProposalExecutePlugin>(data)
    dig 9
    dup
    extract 12 32
    dig 10
    dup
    pushint 42 // 42
    extract_uint16
    dig 1
    len
    substring3
    dig 2
    pushint 46 // 46
    extract_uint64
    uncover 3
    pushint 54 // 54
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1185
    // this.newExecution(executionKey, groups, firstValid, lastValid)
    callsub newExecution
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1186
    // break
    b executeProposal_block@51

executeProposal_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1188
    // case ProposalActionTypeRemoveExecutePlugin: {
    dig 6
    bytec 39 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1188-1192
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(data)
    //   this.removeExecution(executionKey)
    //   break
    // }
    bz executeProposal_after_if_else@14
    // smart_contracts/arc58/dao/contract.algo.ts:1189
    // const { executionKey } = decodeArc4<ProposalRemoveExecutePlugin>(data)
    dig 9
    extract 2 32
    // smart_contracts/arc58/dao/contract.algo.ts:749-752
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:750
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:750
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:751
    // args: [key]
    dig 1
    len
    pushint 32 // 32
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:749-752
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key]
    // })
    pushbytes 0xd58685af // method "arc58_removeExecutionKey(byte[32])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:1191
    // break
    b executeProposal_block@51

executeProposal_after_if_else@14:
    // smart_contracts/arc58/dao/contract.algo.ts:1193
    // case ProposalActionTypeAddPlugin: {
    dig 6
    bytec 6 // 0x14
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1193-1196
    // case ProposalActionTypeAddPlugin: {
    //   this.addPlugin({ name: '', ...decodeArc4<ProposalAddPlugin>(data) })
    //   break
    // }
    bz executeProposal_after_if_else@18
    // smart_contracts/arc58/dao/contract.algo.ts:1194
    // this.addPlugin({ name: '', ...decodeArc4<ProposalAddPlugin>(data) })
    dig 9
    dup
    extract 2 8
    dig 1
    extract 10 32
    dig 11
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    pushint 59 // 59
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 5
    extract 44 1
    dig 6
    extract 45 8
    dig 7
    extract 53 8
    dig 5
    pushint 102 // 102
    extract_uint16
    dig 6
    uncover 6
    dig 2
    substring3
    dig 6
    pushint 488 // 488
    getbit
    dig 7
    pushint 489 // 489
    getbit
    dig 8
    pushint 490 // 490
    getbit
    dig 9
    pushint 491 // 491
    getbit
    dig 13
    extract 64 8
    dig 14
    extract 72 8
    dig 15
    extract 80 8
    dig 16
    extract 88 8
    uncover 17
    extract 96 8
    dig 15
    pushint 104 // 104
    extract_uint16
    dig 16
    uncover 12
    dig 2
    substring3
    extract 2 0
    dig 16
    len
    uncover 17
    uncover 3
    uncover 2
    substring3
    pushbytes 0x006c
    uncover 18
    concat
    uncover 17
    concat
    dig 16
    len
    itob
    extract 6 2
    uncover 17
    concat
    swap
    pushbytes 0x006e
    concat
    dig 1
    len
    pushint 110 // 110
    +
    swap
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    dig 1
    itob
    extract 6 2
    concat
    dig 14
    len
    uncover 2
    +
    bytec_0 // 0x00
    intc_0 // 0
    uncover 15
    setbit
    intc_1 // 1
    uncover 14
    setbit
    intc_3 // 2
    uncover 13
    setbit
    pushint 3 // 3
    uncover 12
    setbit
    uncover 2
    swap
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    dig 4
    len
    itob
    extract 6 2
    uncover 5
    concat
    dig 2
    itob
    extract 6 2
    uncover 2
    swap
    concat
    dig 1
    len
    uncover 3
    +
    itob
    extract 6 2
    concat
    bytec 41 // 0x0000
    concat
    uncover 2
    concat
    uncover 3
    concat
    swap
    concat
    swap
    concat
    callsub addPlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1195
    // break
    b executeProposal_block@51

executeProposal_after_if_else@18:
    // smart_contracts/arc58/dao/contract.algo.ts:1197
    // case ProposalActionTypeAddNamedPlugin: {
    dig 6
    bytec 35 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1197-1200
    // case ProposalActionTypeAddNamedPlugin: {
    //   this.addPlugin(decodeArc4<ProposalAddNamedPlugin>(data))
    //   break
    // }
    bz executeProposal_after_if_else@22
    // smart_contracts/arc58/dao/contract.algo.ts:1198
    // this.addPlugin(decodeArc4<ProposalAddNamedPlugin>(data))
    dig 8
    callsub addPlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1199
    // break
    b executeProposal_block@51

executeProposal_after_if_else@22:
    // smart_contracts/arc58/dao/contract.algo.ts:1201
    // case ProposalActionTypeRemovePlugin: {
    dig 6
    bytec 8 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1201-1204
    // case ProposalActionTypeRemovePlugin: {
    //   this.removePlugin({ name: '', ...decodeArc4<ProposalRemovePlugin>(data) })
    //   break
    // }
    bz executeProposal_after_if_else@26
    // smart_contracts/arc58/dao/contract.algo.ts:1202
    // this.removePlugin({ name: '', ...decodeArc4<ProposalRemovePlugin>(data) })
    dig 9
    dup
    extract 2 8
    swap
    extract 10 32
    dig 10
    dup
    pushint 40 // 40
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    pushbytes 0x002c
    uncover 3
    concat
    uncover 2
    concat
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    swap
    pushbytes 0x002e0000
    concat
    swap
    concat
    callsub removePlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1203
    // break
    b executeProposal_block@51

executeProposal_after_if_else@26:
    // smart_contracts/arc58/dao/contract.algo.ts:1205
    // case ProposalActionTypeRemoveNamedPlugin: {
    dig 6
    bytec 40 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1205-1208
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   this.removePlugin(decodeArc4<ProposalRemoveNamedPlugin>(data))
    //   break
    // }
    bz executeProposal_after_if_else@30
    // smart_contracts/arc58/dao/contract.algo.ts:1206
    // this.removePlugin(decodeArc4<ProposalRemoveNamedPlugin>(data))
    dig 8
    callsub removePlugin
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1207
    // break
    b executeProposal_block@51

executeProposal_after_if_else@30:
    // smart_contracts/arc58/dao/contract.algo.ts:1209
    // case ProposalActionTypeAddAllowances: {
    dig 6
    bytec 12 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1209-1213
    // case ProposalActionTypeAddAllowances: {
    //   const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(data)
    //   this.addAllowances(escrow, allowances)
    //   break
    // }
    bz executeProposal_after_if_else@34
    // smart_contracts/arc58/dao/contract.algo.ts:1210
    // const { escrow, allowances } = decodeArc4<ProposalAddAllowances>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:1211
    // this.addAllowances(escrow, allowances)
    callsub addAllowances
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1212
    // break
    b executeProposal_block@51

executeProposal_after_if_else@34:
    // smart_contracts/arc58/dao/contract.algo.ts:1214
    // case ProposalActionTypeRemoveAllowances: {
    dig 6
    bytec 42 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1214-1218
    // case ProposalActionTypeRemoveAllowances: {
    //   const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(data)
    //   this.removeAllowances(escrow, assets)
    //   break
    // }
    bz executeProposal_after_if_else@38
    // smart_contracts/arc58/dao/contract.algo.ts:1215
    // const { escrow, assets } = decodeArc4<ProposalRemoveAllowances>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    dig 2
    len
    uncover 3
    uncover 3
    uncover 2
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:589-592
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:590
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:590
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:589-592
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // })
    pushbytes 0xd5dd382b // method "arc58_removeAllowances(string,uint64[])void"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:1217
    // break
    b executeProposal_block@51

executeProposal_after_if_else@38:
    // smart_contracts/arc58/dao/contract.algo.ts:1219
    // case ProposalActionTypeNewEscrow: {
    dig 6
    bytec 43 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1219-1223
    // case ProposalActionTypeNewEscrow: {
    //   const { escrow } = decodeArc4<ProposalNewEscrow>(data)
    //   this.newEscrow(escrow)
    //   break
    // }
    bz executeProposal_after_if_else@42
    // smart_contracts/arc58/dao/contract.algo.ts:1220
    // const { escrow } = decodeArc4<ProposalNewEscrow>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:617-620
    // return abiCall<typeof AbstractedAccount.prototype.arc58_newEscrow>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:618
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:618
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:617-620
    // return abiCall<typeof AbstractedAccount.prototype.arc58_newEscrow>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    pushbytes 0x0a8cb2c2 // method "arc58_newEscrow(string)uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1222
    // break
    b executeProposal_block@51

executeProposal_after_if_else@42:
    // smart_contracts/arc58/dao/contract.algo.ts:1224
    // case ProposalActionTypeToggleEscrowLock: {
    dig 6
    bytec 44 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1224-1228
    // case ProposalActionTypeToggleEscrowLock: {
    //   const { escrow } = decodeArc4<ProposalToggleEscrowLock>(data)
    //   this.toggleEscrowLock(escrow)
    //   break
    // }
    bz executeProposal_after_if_else@46
    // smart_contracts/arc58/dao/contract.algo.ts:1225
    // const { escrow } = decodeArc4<ProposalToggleEscrowLock>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/arc58/dao/contract.algo.ts:624-627
    // return abiCall<typeof AbstractedAccount.prototype.arc58_toggleEscrowLock>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:625
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:625
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:624-627
    // return abiCall<typeof AbstractedAccount.prototype.arc58_toggleEscrowLock>({
    //   appId: this.wallet.value,
    //   args: [escrow]
    // }).returnValue
    pushbytes 0x25b713ca // method "arc58_toggleEscrowLock(string)(uint64,bool)"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    len
    pushint 9 // 9
    ==
    assert // invalid number of bytes for (uint64,bool1)
    // smart_contracts/arc58/dao/contract.algo.ts:1227
    // break
    b executeProposal_block@51

executeProposal_after_if_else@46:
    // smart_contracts/arc58/dao/contract.algo.ts:1229
    // case ProposalActionTypeUpdateFields: {
    dig 6
    bytec 45 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1229-1233
    // case ProposalActionTypeUpdateFields: {
    //   const { field, value } = decodeArc4<ProposalUpdateField>(data)
    //   this.updateField(field, value)
    //   break
    // }
    bz executeProposal_block@51
    // smart_contracts/arc58/dao/contract.algo.ts:1230
    // const { field, value } = decodeArc4<ProposalUpdateField>(data)
    dig 8
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_3 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    extract 2 0
    dup
    cover 3
    bury 11
    dig 1
    len
    substring3
    extract 2 0
    bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:632
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    bytec 24 // "content_policy"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:632-635
    // case AkitaDAOGlobalStateKeysContentPolicy: {
    //   this.contentPolicy.value = value.toFixed({ length: 36 })
    //   break
    // }
    bz executeProposal_after_if_else@55
    // smart_contracts/arc58/dao/contract.algo.ts:633
    // this.contentPolicy.value = value.toFixed({ length: 36 })
    dig 5
    dup
    len
    pushint 36 // 36
    ==
    assert // Length must be 36
    // smart_contracts/arc58/dao/contract.algo.ts:38
    // contentPolicy = GlobalState<CID>({ key: AkitaDAOGlobalStateKeysContentPolicy })
    bytec 24 // "content_policy"
    // smart_contracts/arc58/dao/contract.algo.ts:633
    // this.contentPolicy.value = value.toFixed({ length: 36 })
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:634
    // break
    b executeProposal_block@51

executeProposal_after_if_else@55:
    // smart_contracts/arc58/dao/contract.algo.ts:636
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    dig 7
    bytec 13 // "proposal_action_limit"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:636-639
    // case AkitaDAOGlobalStateKeysProposalActionLimit: {
    //   this.proposalActionLimit.value = btoi(value)
    //   break
    // }
    bz executeProposal_after_if_else@57
    // smart_contracts/arc58/dao/contract.algo.ts:637
    // this.proposalActionLimit.value = btoi(value)
    dig 5
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:36
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 13 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:637
    // this.proposalActionLimit.value = btoi(value)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:638
    // break
    b executeProposal_block@51

executeProposal_after_if_else@57:
    // smart_contracts/arc58/dao/contract.algo.ts:640
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    dig 7
    bytec 25 // "min_rewards_impact"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:640-643
    // case AkitaDAOGlobalStateKeysMinRewardsImpact: {
    //   this.minRewardsImpact.value = btoi(value)
    //   break
    // }
    bz executeProposal_after_if_else@59
    // smart_contracts/arc58/dao/contract.algo.ts:641
    // this.minRewardsImpact.value = btoi(value)
    dig 5
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:40
    // minRewardsImpact = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysMinRewardsImpact })
    bytec 25 // "min_rewards_impact"
    // smart_contracts/arc58/dao/contract.algo.ts:641
    // this.minRewardsImpact.value = btoi(value)
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:642
    // break
    b executeProposal_block@51

executeProposal_after_if_else@59:
    // smart_contracts/arc58/dao/contract.algo.ts:644
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    dig 7
    bytec 9 // "aal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:644-648
    // case AkitaDAOGlobalStateKeysAkitaAppList: {
    //   const akitaAppList = decodeArc4<AkitaAppList>(value)
    //   this.akitaAppList.value = clone(akitaAppList)
    //   break
    // }
    bz executeProposal_after_if_else@61
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:646
    // this.akitaAppList.value = clone(akitaAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:647
    // break
    b executeProposal_block@51

executeProposal_after_if_else@61:
    // smart_contracts/arc58/dao/contract.algo.ts:649
    // case AkitaDAOGlobalStateKeysAkitaSocialAppList: {
    dig 7
    bytec 26 // "sal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:649-653
    // case AkitaDAOGlobalStateKeysAkitaSocialAppList: {
    //   const akitaSocialAppList = decodeArc4<AkitaSocialAppList>(value)
    //   this.akitaSocialAppList.value = clone(akitaSocialAppList)
    //   break
    // }
    bz executeProposal_after_if_else@63
    // smart_contracts/arc58/dao/contract.algo.ts:44
    // akitaSocialAppList = GlobalState<AkitaSocialAppList>({ key: AkitaDAOGlobalStateKeysAkitaSocialAppList })
    bytec 26 // "sal"
    // smart_contracts/arc58/dao/contract.algo.ts:651
    // this.akitaSocialAppList.value = clone(akitaSocialAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:652
    // break
    b executeProposal_block@51

executeProposal_after_if_else@63:
    // smart_contracts/arc58/dao/contract.algo.ts:654
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    dig 7
    bytec 14 // "pal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:654-658
    // case AkitaDAOGlobalStateKeysPluginAppList: {
    //   const pluginAppList = decodeArc4<PluginAppList>(value)
    //   this.pluginAppList.value = clone(pluginAppList)
    //   break
    // }
    bz executeProposal_after_if_else@65
    // smart_contracts/arc58/dao/contract.algo.ts:46
    // pluginAppList = GlobalState<PluginAppList>({ key: AkitaDAOGlobalStateKeysPluginAppList })
    bytec 14 // "pal"
    // smart_contracts/arc58/dao/contract.algo.ts:656
    // this.pluginAppList.value = clone(pluginAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:657
    // break
    b executeProposal_block@51

executeProposal_after_if_else@65:
    // smart_contracts/arc58/dao/contract.algo.ts:659
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    dig 7
    bytec 5 // "oal"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:659-663
    // case AkitaDAOGlobalStateKeysOtherAppList: {
    //   const otherAppList = decodeArc4<OtherAppList>(value)
    //   this.otherAppList.value = clone(otherAppList)
    //   break
    // }
    bz executeProposal_after_if_else@67
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:661
    // this.otherAppList.value = clone(otherAppList)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:662
    // break
    b executeProposal_block@51

executeProposal_after_if_else@67:
    // smart_contracts/arc58/dao/contract.algo.ts:664
    // case AkitaDAOGlobalStateKeysWalletFees: {
    dig 7
    bytec 27 // "wallet_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:664-668
    // case AkitaDAOGlobalStateKeysWalletFees: {
    //   const walletFees = decodeArc4<WalletFees>(value)
    //   this.walletFees.value = clone(walletFees)
    //   break
    // }
    bz executeProposal_after_if_else@69
    // smart_contracts/arc58/dao/contract.algo.ts:50
    // walletFees = GlobalState<WalletFees>({ key: AkitaDAOGlobalStateKeysWalletFees })
    bytec 27 // "wallet_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:666
    // this.walletFees.value = clone(walletFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:667
    // break
    b executeProposal_block@51

executeProposal_after_if_else@69:
    // smart_contracts/arc58/dao/contract.algo.ts:669
    // case AkitaDAOGlobalStateKeysSocialFees: {
    dig 7
    bytec 28 // "social_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:669-673
    // case AkitaDAOGlobalStateKeysSocialFees: {
    //   const socialFees = decodeArc4<SocialFees>(value)
    //   this.socialFees.value = clone(socialFees)
    //   break
    // }
    bz executeProposal_after_if_else@71
    // smart_contracts/arc58/dao/contract.algo.ts:52
    // socialFees = GlobalState<SocialFees>({ key: AkitaDAOGlobalStateKeysSocialFees })
    bytec 28 // "social_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:671
    // this.socialFees.value = clone(socialFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:672
    // break
    b executeProposal_block@51

executeProposal_after_if_else@71:
    // smart_contracts/arc58/dao/contract.algo.ts:674
    // case AkitaDAOGlobalStateKeysStakingFees: {
    dig 7
    bytec 29 // "staking_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:674-678
    // case AkitaDAOGlobalStateKeysStakingFees: {
    //   const stakingFees = decodeArc4<StakingFees>(value)
    //   this.stakingFees.value = clone(stakingFees)
    //   break
    // }
    bz executeProposal_after_if_else@73
    // smart_contracts/arc58/dao/contract.algo.ts:54
    // stakingFees = GlobalState<StakingFees>({ key: AkitaDAOGlobalStateKeysStakingFees })
    bytec 29 // "staking_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:676
    // this.stakingFees.value = clone(stakingFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:677
    // break
    b executeProposal_block@51

executeProposal_after_if_else@73:
    // smart_contracts/arc58/dao/contract.algo.ts:679
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    dig 7
    bytec 30 // "subscription_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:679-683
    // case AkitaDAOGlobalStateKeysSubscriptionFees: {
    //   const subscriptionFees = decodeArc4<SubscriptionFees>(value)
    //   this.subscriptionFees.value = clone(subscriptionFees)
    //   break
    // }
    bz executeProposal_after_if_else@75
    // smart_contracts/arc58/dao/contract.algo.ts:56
    // subscriptionFees = GlobalState<SubscriptionFees>({ key: AkitaDAOGlobalStateKeysSubscriptionFees })
    bytec 30 // "subscription_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:681
    // this.subscriptionFees.value = clone(subscriptionFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:682
    // break
    b executeProposal_block@51

executeProposal_after_if_else@75:
    // smart_contracts/arc58/dao/contract.algo.ts:684
    // case AkitaDAOGlobalStateKeysNFTFees: {
    dig 7
    bytec 31 // "nft_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:684-688
    // case AkitaDAOGlobalStateKeysNFTFees: {
    //   const nftFees = decodeArc4<NFTFees>(value)
    //   this.nftFees.value = clone(nftFees)
    //   break
    // }
    bz executeProposal_after_if_else@77
    // smart_contracts/arc58/dao/contract.algo.ts:58
    // nftFees = GlobalState<NFTFees>({ key: AkitaDAOGlobalStateKeysNFTFees })
    bytec 31 // "nft_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:686
    // this.nftFees.value = clone(nftFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:687
    // break
    b executeProposal_block@51

executeProposal_after_if_else@77:
    // smart_contracts/arc58/dao/contract.algo.ts:689
    // case AkitaDAOGlobalStateKeysSwapFees: {
    dig 7
    bytec 32 // "swap_fees"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:689-693
    // case AkitaDAOGlobalStateKeysSwapFees: {
    //   const swapFees = decodeArc4<SwapFees>(value)
    //   this.swapFees.value = clone(swapFees)
    //   break
    // }
    bz executeProposal_after_if_else@79
    // smart_contracts/arc58/dao/contract.algo.ts:60
    // swapFees = GlobalState<SwapFees>({ key: AkitaDAOGlobalStateKeysSwapFees })
    bytec 32 // "swap_fees"
    // smart_contracts/arc58/dao/contract.algo.ts:691
    // this.swapFees.value = clone(swapFees)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:692
    // break
    b executeProposal_block@51

executeProposal_after_if_else@79:
    // smart_contracts/arc58/dao/contract.algo.ts:694
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    dig 7
    bytec 11 // "akita_assets"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:694-697
    // case AkitaDAOGlobalStateKeysAkitaAssets: {
    //   this.akitaAssets.value = decodeArc4<AkitaAssets>(value)
    //   break
    // }
    bz executeProposal_after_if_else@81
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 11 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:695
    // this.akitaAssets.value = decodeArc4<AkitaAssets>(value)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:696
    // break
    b executeProposal_block@51

executeProposal_after_if_else@81:
    // smart_contracts/arc58/dao/contract.algo.ts:698
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings: {
    dig 7
    bytec 15 // "upgrade_app_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:698-702
    // case AkitaDAOGlobalStateKeysUpgradeAppProposalSettings: {
    //   const upgradeAppSettings = decodeArc4<ProposalSettings>(value)
    //   this.upgradeAppProposalSettings.value = clone(upgradeAppSettings)
    //   break
    // }
    bz executeProposal_after_if_else@83
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:700
    // this.upgradeAppProposalSettings.value = clone(upgradeAppSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:701
    // break
    b executeProposal_block@51

executeProposal_after_if_else@83:
    // smart_contracts/arc58/dao/contract.algo.ts:703
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings: {
    dig 7
    bytec 16 // "add_plugin_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:703-707
    // case AkitaDAOGlobalStateKeysAddPluginProposalSettings: {
    //   const addPluginSettings = decodeArc4<ProposalSettings>(value)
    //   this.addPluginProposalSettings.value = clone(addPluginSettings)
    //   break
    // }
    bz executeProposal_after_if_else@85
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:705
    // this.addPluginProposalSettings.value = clone(addPluginSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:706
    // break
    b executeProposal_block@51

executeProposal_after_if_else@85:
    // smart_contracts/arc58/dao/contract.algo.ts:708
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings: {
    dig 7
    bytec 17 // "remove_plugin_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:708-712
    // case AkitaDAOGlobalStateKeysRemovePluginProposalSettings: {
    //   const removePluginSettings = decodeArc4<ProposalSettings>(value)
    //   this.removePluginProposalSettings.value = clone(removePluginSettings)
    //   break
    // }
    bz executeProposal_after_if_else@87
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:710
    // this.removePluginProposalSettings.value = clone(removePluginSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:711
    // break
    b executeProposal_block@51

executeProposal_after_if_else@87:
    // smart_contracts/arc58/dao/contract.algo.ts:713
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings: {
    dig 7
    bytec 18 // "add_allowance_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:713-717
    // case AkitaDAOGlobalStateKeysAddAllowancesProposalSettings: {
    //   const addAllowanceSettings = decodeArc4<ProposalSettings>(value)
    //   this.addAllowancesProposalSettings.value = clone(addAllowanceSettings)
    //   break
    // }
    bz executeProposal_after_if_else@89
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:715
    // this.addAllowancesProposalSettings.value = clone(addAllowanceSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:716
    // break
    b executeProposal_block@51

executeProposal_after_if_else@89:
    // smart_contracts/arc58/dao/contract.algo.ts:718
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings: {
    dig 7
    bytec 19 // "remove_allowance_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:718-722
    // case AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings: {
    //   const removeAllowanceSettings = decodeArc4<ProposalSettings>(value)
    //   this.removeAllowancesProposalSettings.value = clone(removeAllowanceSettings)
    //   break
    // }
    bz executeProposal_after_if_else@91
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:720
    // this.removeAllowancesProposalSettings.value = clone(removeAllowanceSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:721
    // break
    b executeProposal_block@51

executeProposal_after_if_else@91:
    // smart_contracts/arc58/dao/contract.algo.ts:723
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings: {
    dig 7
    bytec 20 // "new_escrow_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:723-727
    // case AkitaDAOGlobalStateKeysNewEscrowProposalSettings: {
    //   const newEscrowSettings = decodeArc4<ProposalSettings>(value)
    //   this.newEscrowProposalSettings.value = clone(newEscrowSettings)
    //   break
    // }
    bz executeProposal_after_if_else@93
    // smart_contracts/arc58/dao/contract.algo.ts:80
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:725
    // this.newEscrowProposalSettings.value = clone(newEscrowSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:726
    // break
    b executeProposal_block@51

executeProposal_after_if_else@93:
    // smart_contracts/arc58/dao/contract.algo.ts:728
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    dig 7
    bytec 21 // "update_fields_ps"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:728-732
    // case AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings: {
    //   const updateFieldsSettings = decodeArc4<ProposalSettings>(value)
    //   this.updateFieldsProposalSettings.value = clone(updateFieldsSettings)
    //   break
    // }
    bz executeProposal_after_if_else@95
    // smart_contracts/arc58/dao/contract.algo.ts:84
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:730
    // this.updateFieldsProposalSettings.value = clone(updateFieldsSettings)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:731
    // break
    b executeProposal_block@51

executeProposal_after_if_else@95:
    // smart_contracts/arc58/dao/contract.algo.ts:733
    // case AkitaDAOGlobalStateKeysRevenueSplits: {
    dig 7
    bytec 33 // "revenue_splits"
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:733-737
    // case AkitaDAOGlobalStateKeysRevenueSplits: {
    //   const revenueSplits = decodeArc4<Split[]>(value)
    //   this.revenueSplits.value = clone(revenueSplits)
    //   break
    // }
    bz executeProposal_block@51
    // smart_contracts/arc58/dao/contract.algo.ts:64
    // revenueSplits = GlobalState<Split[]>({ key: AkitaDAOGlobalStateKeysRevenueSplits })
    bytec 33 // "revenue_splits"
    // smart_contracts/arc58/dao/contract.algo.ts:735
    // this.revenueSplits.value = clone(revenueSplits)
    dig 6
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:736
    // break
    b executeProposal_block@51

executeProposal_after_while@52:
    // smart_contracts/arc58/dao/contract.algo.ts:1237
    // this.proposals(proposalID).value.status = ProposalStatusExecuted
    dig 2
    intc_0 // 0
    bytec 12 // 0x32
    box_replace
    // smart_contracts/arc58/dao/contract.algo.ts:1165
    // executeProposal(proposalID: uint64): void {
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.deleteProposalVotes[routing]() -> void:
deleteProposalVotes:
    bytec_3 // ""
    // smart_contracts/arc58/dao/contract.algo.ts:1240
    // deleteProposalVotes(proposalID: uint64, voters: Account[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 3
    pushint 32 // 32
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    // smart_contracts/arc58/dao/contract.algo.ts:1241
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:1241
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1243
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 8 // 0x28
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1243-1244
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    bnz deleteProposalVotes_bool_true@4
    // smart_contracts/arc58/dao/contract.algo.ts:1244
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1243-1244
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    bnz deleteProposalVotes_bool_true@4
    // smart_contracts/arc58/dao/contract.algo.ts:1245
    // this.proposals(proposalID).value.status === ProposalStatusExecuted,
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    bytec 12 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:1243-1245
    // this.proposals(proposalID).value.status === ProposalStatusApproved ||
    // this.proposals(proposalID).value.status === ProposalStatusRejected ||
    // this.proposals(proposalID).value.status === ProposalStatusExecuted,
    bz deleteProposalVotes_bool_false@5

deleteProposalVotes_bool_true@4:
    intc_1 // 1

deleteProposalVotes_bool_merge@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1242-1247
    // assert(
    //   this.proposals(proposalID).value.status === ProposalStatusApproved ||
    //   this.proposals(proposalID).value.status === ProposalStatusRejected ||
    //   this.proposals(proposalID).value.status === ProposalStatusExecuted,
    //   ERR_INVALID_PROPOSAL_STATE
    // )
    assert // invalid proposal state
    // smart_contracts/arc58/dao/contract.algo.ts:1249
    // for (let i: uint64 = 0; i < voters.length; i++) {
    intc_0 // 0
    bury 5

deleteProposalVotes_while_top@7:
    // smart_contracts/arc58/dao/contract.algo.ts:1249
    // for (let i: uint64 = 0; i < voters.length; i++) {
    dig 4
    dig 3
    <
    bz deleteProposalVotes_after_while@9
    // smart_contracts/arc58/dao/contract.algo.ts:1250
    // assert(this.proposalVotes({ proposalID, voter: voters[i] }).exists, ERR_PROPOSAL_VOTE_NOT_FOUND)
    dig 3
    extract 2 0
    dig 5
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    dig 3
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:95
    // proposalVotes = BoxMap<ProposalVoteKey, ProposalVoteInfo>({ keyPrefix: AkitaDAOBoxPrefixProposalVotes })
    pushbytes "v"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1250
    // assert(this.proposalVotes({ proposalID, voter: voters[i] }).exists, ERR_PROPOSAL_VOTE_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Proposal Vote not found
    // smart_contracts/arc58/dao/contract.algo.ts:1251
    // this.proposalVotes({ proposalID, voter: voters[i] }).delete()
    box_del
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1249
    // for (let i: uint64 = 0; i < voters.length; i++) {
    intc_1 // 1
    +
    bury 5
    b deleteProposalVotes_while_top@7

deleteProposalVotes_after_while@9:
    // smart_contracts/arc58/dao/contract.algo.ts:1240
    // deleteProposalVotes(proposalID: uint64, voters: Account[]): void {
    intc_1 // 1
    return

deleteProposalVotes_bool_false@5:
    intc_0 // 0
    b deleteProposalVotes_bool_merge@6


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost[routing]() -> void:
setupCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1255
    // @abimethod({ readonly: true })
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost[routing]() -> void:
proposalCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1261
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    callsub smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost
    pop
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposal[routing]() -> void:
getProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:1326
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/arc58/dao/contract.algo.ts:1328
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1328
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:1329
    // return this.proposals(proposalID).value
    box_get
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1326
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.mustGetExecution[routing]() -> void:
mustGetExecution:
    // smart_contracts/arc58/dao/contract.algo.ts:1332
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/arc58/dao/contract.algo.ts:97
    // executions = BoxMap<bytes<32>, ExecutionMetadata>({ keyPrefix: AbstractAccountBoxPrefixExecutions })
    pushbytes "x"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:1334
    // assert(this.executions(lease).exists, ERR_EXECUTION_KEY_NOT_FOUND)
    dup
    box_len
    bury 1
    assert // Execution key not found
    // smart_contracts/arc58/dao/contract.algo.ts:1335
    // return this.executions(lease).value
    box_get
    pop
    // smart_contracts/arc58/dao/contract.algo.ts:1332
    // @abimethod({ readonly: true })
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.pluginExists(key: bytes) -> uint64, bytes:
pluginExists:
    // smart_contracts/arc58/dao/contract.algo.ts:113
    // private pluginExists(key: PluginKey): boolean {
    proto 1 2
    // smart_contracts/arc58/dao/contract.algo.ts:114-117
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:115
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:115
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:116
    // args: [[key]]
    bytec 36 // 0x00010002
    frame_dig -1
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:114-117
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getPlugins>({
    //   appId: this.wallet.value,
    //   args: [[key]]
    // }).returnValue[0]
    bytec 51 // method "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:119
    // return info.start !== 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_3 // 2
    extract_uint16
    uncover 2
    select
    substring3
    pushint 36 // 36
    extract_uint64
    intc_0 // 0
    !=
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.namedPluginExists(name: bytes) -> uint64:
namedPluginExists:
    // smart_contracts/arc58/dao/contract.algo.ts:129
    // private namedPluginExists(name: string): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:130-133
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getNamedPlugins>({
    //   appId: this.wallet.value,
    //   args: [[name]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:131
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:131
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:132
    // args: [[name]]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 36 // 0x00010002
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:130-133
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getNamedPlugins>({
    //   appId: this.wallet.value,
    //   args: [[name]]
    // }).returnValue[0]
    pushbytes 0x05794d7d // method "arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/arc58/dao/contract.algo.ts:135
    // return info.start !== 0
    swap
    extract 6 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    extract_uint16
    swap
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_3 // 2
    extract_uint16
    uncover 2
    select
    substring3
    pushint 36 // 36
    extract_uint64
    intc_0 // 0
    !=
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.escrowExists(escrow: bytes) -> uint64:
escrowExists:
    // smart_contracts/arc58/dao/contract.algo.ts:138
    // private escrowExists(escrow: string): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:139-142
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId: this.wallet.value,
    //   args: [[escrow]]
    // }).returnValue[0]
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:140
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:140
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:141
    // args: [[escrow]]
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 36 // 0x00010002
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:139-142
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getEscrows>({
    //   appId: this.wallet.value,
    //   args: [[escrow]]
    // }).returnValue[0]
    pushbytes 0xa2403ddf // method "arc58_getEscrows(string[])(uint64,bool)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1)[])
    // smart_contracts/arc58/dao/contract.algo.ts:144
    // return info.id !== 0
    extract 6 9
    intc_0 // 0
    extract_uint64
    intc_0 // 0
    !=
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.allowanceCheck(escrow: bytes, assets: bytes) -> bytes, bytes:
allowanceCheck:
    // smart_contracts/arc58/dao/contract.algo.ts:147
    // private allowanceCheck(escrow: string, assets: uint64[]): { existences: boolean[], anyExist: boolean, allExist: boolean } {
    proto 2 2
    intc_0 // 0
    dup
    bytec_3 // ""
    dupn 6
    // smart_contracts/arc58/dao/contract.algo.ts:148-151
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // }).returnValue
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:149
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:149
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:150
    // args: [escrow, assets]
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:148-151
    // const info = abiCall<typeof AbstractedAccount.prototype.arc58_getAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, assets]
    // }).returnValue
    pushbytes 0x02fe4515 // method "arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    pushint 50 // 50
    *
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool1)[])
    // smart_contracts/arc58/dao/contract.algo.ts:153
    // let existences: boolean[] = []
    bytec 41 // 0x0000
    // smart_contracts/arc58/dao/contract.algo.ts:154
    // let anyExist: boolean = false
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:155
    // let allExist: boolean = true
    intc_1 // 1
    // smart_contracts/arc58/dao/contract.algo.ts:156
    // for (let i: uint64 = 0; i < info.length; i++) {
    intc_0 // 0

allowanceCheck_while_top@2:
    // smart_contracts/arc58/dao/contract.algo.ts:156
    // for (let i: uint64 = 0; i < info.length; i++) {
    frame_dig 14
    frame_dig 10
    <
    bz allowanceCheck_after_while@7
    // smart_contracts/arc58/dao/contract.algo.ts:157
    // const exists = info[i].start !== 0
    frame_dig 9
    extract 6 0
    frame_dig 14
    pushint 50 // 50
    *
    pushint 50 // 50
    extract3 // on error: index access is out of bounds
    pushint 41 // 41
    extract_uint64
    dup
    frame_bury 6
    intc_0 // 0
    !=
    // smart_contracts/arc58/dao/contract.algo.ts:158
    // existences.push(exists)
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    frame_bury 0
    frame_dig 11
    dup
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:158
    // existences.push(exists)
    intc_1 // 1
    +
    dup
    itob
    extract 6 0
    uncover 3
    swap
    replace2 0
    frame_bury 1
    swap
    pushint 7 // 7
    +
    intc_2 // 8
    /
    dup
    frame_bury 3
    swap
    pushint 7 // 7
    +
    intc_2 // 8
    /
    dup
    frame_bury 5
    <
    bz allowanceCheck_after_if_else@10
    frame_dig 5
    frame_dig 3
    -
    bzero
    frame_dig 1
    swap
    concat
    frame_bury 1

allowanceCheck_after_if_else@10:
    intc_0 // 0
    frame_bury 4
    frame_dig 2
    pushint 16 // 16
    +
    dup
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:158
    // existences.push(exists)
    intc_1 // 1
    +
    frame_bury 7

allowanceCheck_while_top@11:
    frame_dig 8
    frame_dig 7
    <
    bz allowanceCheck_after_while@13
    frame_dig 0
    frame_dig 4
    dup
    cover 2
    getbit
    frame_dig 1
    frame_dig 8
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 1
    intc_1 // 1
    +
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:158
    // existences.push(exists)
    intc_2 // 8
    +
    frame_bury 4
    b allowanceCheck_while_top@11

allowanceCheck_after_while@13:
    // smart_contracts/arc58/dao/contract.algo.ts:159
    // if (exists) {
    frame_dig 6
    bz allowanceCheck_else_body@5
    // smart_contracts/arc58/dao/contract.algo.ts:160
    // anyExist = true
    intc_1 // 1
    frame_bury 12

allowanceCheck_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:156
    // for (let i: uint64 = 0; i < info.length; i++) {
    frame_dig 14
    intc_1 // 1
    +
    frame_bury 14
    frame_dig 1
    frame_bury 11
    b allowanceCheck_while_top@2

allowanceCheck_else_body@5:
    // smart_contracts/arc58/dao/contract.algo.ts:162
    // allExist = false
    intc_0 // 0
    frame_bury 13
    b allowanceCheck_after_if_else@6

allowanceCheck_after_while@7:
    // smart_contracts/arc58/dao/contract.algo.ts:166
    // return { existences, anyExist, allExist }
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    intc_1 // 1
    frame_dig 13
    setbit
    pushbytes 0x0003
    swap
    concat
    frame_dig 11
    concat
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.validEditOrSubmit(proposalID: uint64) -> uint64:
validEditOrSubmit:
    // smart_contracts/arc58/dao/contract.algo.ts:349
    // private validEditOrSubmit(proposalID: uint64): boolean {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:350
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    frame_dig -1
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:350
    // assert(this.proposals(proposalID).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:351
    // const { status, creator } = this.proposals(proposalID).value
    dup
    intc_0 // 0
    intc_1 // 1
    box_extract
    swap
    pushints 61 32 // 61, 32
    box_extract
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:352
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:48
    // otherAppList = GlobalState<OtherAppList>({ key: AkitaDAOGlobalStateKeysOtherAppList })
    bytec 5 // "oal"
    // smart_contracts/arc58/dao/contract.algo.ts:352
    // const origin = getOrigin(this.otherAppList.value.escrow, Txn.sender)
    app_global_get_ex
    assert // check GlobalState exists
    pushint 24 // 24
    extract_uint64
    txn Sender
    callsub getOrigin
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:355
    // status === ProposalStatusDraft &&
    bytec_0 // 0x00
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:355-356
    // status === ProposalStatusDraft &&
    // origin === creator
    bz validEditOrSubmit_bool_false@3
    // smart_contracts/arc58/dao/contract.algo.ts:356
    // origin === creator
    frame_dig 1
    frame_dig 0
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:355-356
    // status === ProposalStatusDraft &&
    // origin === creator
    bz validEditOrSubmit_bool_false@3
    intc_1 // 1

validEditOrSubmit_bool_merge@4:
    // smart_contracts/arc58/dao/contract.algo.ts:354-357
    // return (
    //   status === ProposalStatusDraft &&
    //   origin === creator
    // )
    frame_bury 0
    retsub

validEditOrSubmit_bool_false@3:
    intc_0 // 0
    b validEditOrSubmit_bool_merge@4


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.validateSettings(settings: bytes) -> bytes:
validateSettings:
    // smart_contracts/arc58/dao/contract.algo.ts:360
    // private validateSettings(settings: ProposalSettings): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:361
    // assert(settings.approval > 1_000, ERR_INVALID_MIN_APPROVAL) // 1%
    frame_dig -1
    pushint 32 // 32
    extract_uint64
    dup
    intc 5 // 1000
    >
    assert // Invalid minimum approval percentage
    // smart_contracts/arc58/dao/contract.algo.ts:362
    // assert(settings.approval <= 100_000, ERR_INVALID_MAX_APPROVAL) // 100%
    intc 4 // 100000
    <=
    assert // Invalid maximum approval percentage
    // smart_contracts/arc58/dao/contract.algo.ts:364
    // assert(settings.participation > 1_000) // 1%
    frame_dig -1
    pushint 24 // 24
    extract_uint64
    dup
    intc 5 // 1000
    >
    assert
    // smart_contracts/arc58/dao/contract.algo.ts:365
    // assert(settings.participation <= 100_000, ERR_INVALID_MAX_PARTICIPATION) // 100%
    intc 4 // 100000
    <=
    assert // Invalid maximum participation percentage
    // smart_contracts/arc58/dao/contract.algo.ts:367
    // assert(settings.duration > 0, ERR_INVALID_DURATION)
    frame_dig -1
    pushint 16 // 16
    extract_uint64
    assert // Invalid duration
    // smart_contracts/arc58/dao/contract.algo.ts:369
    // assert(settings.power > 0, ERR_INVALID_MIN_POWER)
    frame_dig -1
    intc_2 // 8
    extract_uint64
    dup
    assert // Invalid minimum power
    // smart_contracts/arc58/dao/contract.algo.ts:370
    // assert(settings.power <= 1_000, ERR_INVALID_MAX_POWER)
    intc 5 // 1000
    <=
    assert // Invalid maximum power
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getGovernancePower(account: bytes) -> uint64:
getGovernancePower:
    // smart_contracts/arc58/dao/contract.algo.ts:373
    // private getGovernancePower(account: Account): uint64 {
    proto 1 1
    bytec_3 // ""
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:374
    // const { staking } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:374
    // const { staking } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:375
    // const { akta, bones } = this.akitaAssets.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:62
    // akitaAssets = GlobalState<AkitaAssets>({ key: AkitaDAOGlobalStateKeysAkitaAssets })
    bytec 11 // "akita_assets"
    // smart_contracts/arc58/dao/contract.algo.ts:375
    // const { akta, bones } = this.akitaAssets.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    intc_0 // 0
    extract_uint64
    dup
    uncover 2
    intc_2 // 8
    extract_uint64
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:377
    // if (akta === 0 || bones === 0) {
    bz getGovernancePower_if_body@2
    frame_dig 4
    bnz getGovernancePower_after_if_else@3

getGovernancePower_if_body@2:
    // smart_contracts/arc58/dao/contract.algo.ts:378
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getGovernancePower_after_if_else@3:
    // smart_contracts/arc58/dao/contract.algo.ts:381
    // const aktaPower = getStakingPower(staking, account, akta)
    frame_dig 2
    dup
    frame_dig -1
    frame_dig 3
    callsub getStakingPower
    dup
    cover 2
    frame_bury 0
    // smart_contracts/arc58/dao/contract.algo.ts:382
    // const bonesPower = getStakingPower(staking, account, bones)
    frame_dig -1
    frame_dig 4
    callsub getStakingPower
    frame_bury 1
    // smart_contracts/arc58/dao/contract.algo.ts:384
    // if (aktaPower === 0 || bonesPower === 0) {
    bz getGovernancePower_if_body@5
    frame_dig 1
    bnz getGovernancePower_after_if_else@6

getGovernancePower_if_body@5:
    // smart_contracts/arc58/dao/contract.algo.ts:385
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

getGovernancePower_after_if_else@6:
    // smart_contracts/arc58/dao/contract.algo.ts:389
    // if (aktaPower < bonesPower) {
    frame_dig 0
    frame_dig 1
    <
    bz getGovernancePower_after_if_else@8
    // smart_contracts/arc58/dao/contract.algo.ts:390
    // return aktaPower
    retsub

getGovernancePower_after_if_else@8:
    // smart_contracts/arc58/dao/contract.algo.ts:393
    // return bonesPower
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.createOrUpdateProposal(id: uint64, cid: bytes, actions: bytes, origin: bytes, feesPaid: uint64, powerRequired: uint64) -> uint64, bytes:
createOrUpdateProposal:
    // smart_contracts/arc58/dao/contract.algo.ts:396-403
    // private createOrUpdateProposal(
    //   id: uint64,
    //   cid: CID,
    //   actions: ProposalAction[],
    //   origin: Account,
    //   feesPaid: uint64,
    //   powerRequired: uint64
    // ): uint64 {
    proto 6 2
    // smart_contracts/arc58/dao/contract.algo.ts:405
    // assert(actions.length > 0, ERR_EMPTY_ACTION_LIST)
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dup
    assert // Action list cannot be empty
    // smart_contracts/arc58/dao/contract.algo.ts:406
    // assert(actions.length <= this.proposalActionLimit.value, ERR_TOO_MANY_ACTIONS)
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:36
    // proposalActionLimit = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalActionLimit })
    bytec 13 // "proposal_action_limit"
    // smart_contracts/arc58/dao/contract.algo.ts:406
    // assert(actions.length <= this.proposalActionLimit.value, ERR_TOO_MANY_ACTIONS)
    app_global_get_ex
    assert // check GlobalState exists
    <=
    assert // Too many actions in the proposal
    // smart_contracts/arc58/dao/contract.algo.ts:408
    // if (this.state.value !== DaoStateFullyInitialized) {
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:408
    // if (this.state.value !== DaoStateFullyInitialized) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 34 // 0x02
    !=
    bz createOrUpdateProposal_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:409
    // assert(Txn.sender === Global.creatorAddress, ERR_FORBIDDEN)
    txn Sender
    global CreatorAddress
    ==
    assert // only the creator wallet can delete a spending account
    // smart_contracts/arc58/dao/contract.algo.ts:411
    // id = this.newProposalID()
    callsub newProposalID
    frame_bury -6
    // smart_contracts/arc58/dao/contract.algo.ts:421
    // creator: Txn.sender,
    txn Sender
    // smart_contracts/arc58/dao/contract.algo.ts:423
    // created: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/arc58/dao/contract.algo.ts:417
    // approvals: 0,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:413-426
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    itob
    frame_dig -5
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:414
    // status: ProposalStatusApproved,
    bytec 8 // 0x28
    // smart_contracts/arc58/dao/contract.algo.ts:413-426
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    frame_dig -5
    concat
    bytec 52 // 0x000000000000000000000000000000000000000000000000
    concat
    uncover 3
    concat
    swap
    concat
    swap
    itob
    concat
    frame_dig -2
    itob
    concat
    bytec 53 // 0x0077
    concat
    frame_dig -4
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:413
    // this.proposals(id).value = {
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:413-426
    // this.proposals(id).value = {
    //   status: ProposalStatusApproved,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: Txn.sender,
    //   votingTs: 0,
    //   created: Global.latestTimestamp,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:428
    // return id
    frame_dig -6
    frame_dig -4
    retsub

createOrUpdateProposal_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:431
    // const userPower = this.getGovernancePower(origin)
    frame_dig -3
    callsub getGovernancePower
    // smart_contracts/arc58/dao/contract.algo.ts:433
    // assert(userPower >= powerRequired, ERR_INSUFFICIENT_PROPOSAL_THRESHOLD)
    frame_dig -1
    >=
    assert // Insufficient proposal threshold
    // smart_contracts/arc58/dao/contract.algo.ts:436
    // if (id === 0) {
    frame_dig -6
    bnz createOrUpdateProposal_else_body@4
    // smart_contracts/arc58/dao/contract.algo.ts:437
    // id = this.newProposalID()
    callsub newProposalID
    frame_bury -6
    // smart_contracts/arc58/dao/contract.algo.ts:438
    // created = Global.latestTimestamp
    global LatestTimestamp

createOrUpdateProposal_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:447
    // approvals: 0,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:443-456
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    itob
    frame_dig -5
    len
    pushint 36 // 36
    ==
    assert // invalid size
    // smart_contracts/arc58/dao/contract.algo.ts:444
    // status: ProposalStatusDraft,
    bytec_0 // 0x00
    // smart_contracts/arc58/dao/contract.algo.ts:443-456
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    frame_dig -5
    concat
    bytec 52 // 0x000000000000000000000000000000000000000000000000
    concat
    frame_dig -3
    concat
    swap
    concat
    swap
    itob
    concat
    frame_dig -2
    itob
    concat
    bytec 53 // 0x0077
    concat
    frame_dig -4
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:443
    // this.proposals(id).value = {
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:443-456
    // this.proposals(id).value = {
    //   status: ProposalStatusDraft,
    //   cid,
    //   votes: {
    //     approvals: 0,
    //     rejections: 0,
    //     abstains: 0,
    //   },
    //   creator: origin,
    //   votingTs: 0,
    //   created,
    //   feesPaid,
    //   actions: clone(actions)
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/arc58/dao/contract.algo.ts:458
    // return id
    frame_dig -6
    frame_dig -4
    retsub

createOrUpdateProposal_else_body@4:
    // smart_contracts/arc58/dao/contract.algo.ts:440
    // created = this.proposals(id).value.created
    frame_dig -6
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:93
    // proposals = BoxMap<uint64, ProposalDetails>({ keyPrefix: AkitaDAOBoxPrefixProposals })
    bytec 4 // "l"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:440
    // created = this.proposals(id).value.created
    pushint 101 // 101
    intc_2 // 8
    box_extract
    btoi
    b createOrUpdateProposal_after_if_else@5


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.addPlugin(data: bytes) -> bytes:
addPlugin:
    // smart_contracts/arc58/dao/contract.algo.ts:503
    // private addPlugin(data: ProposalAddNamedPlugin): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:523
    // } = clone(data);
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    pushint 42 // 42
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 2 8
    swap
    frame_dig -1
    extract 10 32
    swap
    frame_dig -1
    pushint 61 // 61
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 44 1
    swap
    frame_dig -1
    extract 45 8
    swap
    frame_dig -1
    extract 53 8
    swap
    frame_dig -1
    pushint 104 // 104
    extract_uint16
    frame_dig -1
    cover 2
    substring3
    frame_dig -1
    pushint 504 // 504
    getbit
    frame_dig -1
    pushint 505 // 505
    getbit
    dup
    frame_dig -1
    pushint 506 // 506
    getbit
    swap
    frame_dig -1
    pushint 507 // 507
    getbit
    swap
    frame_dig -1
    extract 64 8
    swap
    frame_dig -1
    extract 72 8
    swap
    frame_dig -1
    extract 80 8
    swap
    frame_dig -1
    extract 88 8
    swap
    frame_dig -1
    extract 96 8
    swap
    frame_dig -1
    pushint 106 // 106
    extract_uint16
    frame_dig -1
    len
    frame_dig -1
    cover 2
    substring3
    swap
    // smart_contracts/arc58/dao/contract.algo.ts:525
    // if (useExecutionKey) {
    bz addPlugin_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:526-532
    // this.plugins({ plugin, escrow }).value = {
    //   fee,
    //   power,
    //   duration,
    //   participation,
    //   approval
    // }
    frame_dig 14
    frame_dig 15
    concat
    frame_dig 16
    concat
    frame_dig 17
    concat
    frame_dig 18
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:526
    // this.plugins({ plugin, escrow }).value = {
    frame_dig 5
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_dig 2
    bytec 46 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:91
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 47 // "p"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:526-532
    // this.plugins({ plugin, escrow }).value = {
    //   fee,
    //   power,
    //   duration,
    //   participation,
    //   approval
    // }
    swap
    box_put

addPlugin_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:535
    // if (name !== '') {
    frame_dig 1
    bytec_3 // ""
    !=
    bz addPlugin_else_body@5
    // smart_contracts/arc58/dao/contract.algo.ts:536-554
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:537
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:537
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:548
    // useRounds,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 10
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:549
    // useExecutionKey,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 11
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:550
    // coverFees,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:552
    // defaultToEscrow
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 13
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:536-554
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    pushbytes 0x572fd1ea // method "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    // smart_contracts/arc58/dao/contract.algo.ts:543
    // false,
    bytec_0 // 0x00
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationArgs
    frame_dig 8
    itxn_field ApplicationArgs
    frame_dig 9
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    bytec_0 // 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/arc58/dao/contract.algo.ts:536-554
    // abiCall<typeof AbstractedAccount.prototype.arc58_addNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     name,
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

addPlugin_after_if_else@7:
    // smart_contracts/arc58/dao/contract.algo.ts:576
    // if (escrow !== '' && allowances.length > 0) {
    frame_dig 5
    bytec_3 // ""
    !=
    bz addPlugin_after_if_else@10
    frame_dig 19
    intc_0 // 0
    extract_uint16
    bz addPlugin_after_if_else@10
    // smart_contracts/arc58/dao/contract.algo.ts:577
    // this.addAllowances(escrow, allowances)
    frame_dig 5
    frame_dig 19
    callsub addAllowances
    pop

addPlugin_after_if_else@10:
    frame_dig -1
    frame_bury 0
    retsub

addPlugin_else_body@5:
    // smart_contracts/arc58/dao/contract.algo.ts:556-573
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:557
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:557
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:567
    // useRounds,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 10
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:568
    // useExecutionKey,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 11
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:569
    // coverFees,
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 12
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:571
    // defaultToEscrow
    bytec_0 // 0x00
    intc_0 // 0
    frame_dig 13
    setbit
    // smart_contracts/arc58/dao/contract.algo.ts:556-573
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    pushbytes 0x5672462e // method "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void"
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    // smart_contracts/arc58/dao/contract.algo.ts:562
    // false,
    bytec_0 // 0x00
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationArgs
    frame_dig 7
    itxn_field ApplicationArgs
    frame_dig 8
    itxn_field ApplicationArgs
    frame_dig 9
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    bytec_0 // 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/arc58/dao/contract.algo.ts:556-573
    // abiCall<typeof AbstractedAccount.prototype.arc58_addPlugin>({
    //   appId: this.wallet.value,
    //   args: [
    //     plugin,
    //     caller,
    //     escrow,
    //     false,
    //     delegationType,
    //     lastValid,
    //     cooldown,
    //     methods,
    //     useRounds,
    //     useExecutionKey,
    //     coverFees,
    //     false,
    //     defaultToEscrow
    //   ]
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b addPlugin_after_if_else@7


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.addAllowances(escrow: bytes, allowances: bytes) -> bytes:
addAllowances:
    // smart_contracts/arc58/dao/contract.algo.ts:581
    // private addAllowances(escrow: string, allowances: AddAllowanceInfo[]): void {
    proto 2 1
    // smart_contracts/arc58/dao/contract.algo.ts:582-585
    // abiCall<typeof AbstractedAccount.prototype.arc58_addAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, allowances]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:583
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:583
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:584
    // args: [escrow, allowances]
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:582-585
    // abiCall<typeof AbstractedAccount.prototype.arc58_addAllowances>({
    //   appId: this.wallet.value,
    //   args: [escrow, allowances]
    // })
    pushbytes 0xbf4d7c57 // method "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -1
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.removePlugin(data: bytes) -> bytes:
removePlugin:
    // smart_contracts/arc58/dao/contract.algo.ts:595
    // private removePlugin(data: ProposalRemoveNamedPlugin): void {
    proto 1 1
    // smart_contracts/arc58/dao/contract.algo.ts:596
    // const { name, plugin, caller, escrow } = data
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig -1
    pushint 42 // 42
    extract_uint16
    frame_dig -1
    uncover 2
    dig 2
    substring3
    dup
    cover 2
    extract 2 0
    swap
    frame_dig -1
    extract 2 8
    dup
    uncover 2
    frame_dig -1
    extract 10 32
    cover 2
    frame_dig -1
    len
    frame_dig -1
    cover 2
    substring3
    dup
    cover 2
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:598
    // if (this.plugins({ plugin, escrow }).exists) {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 46 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:91
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 47 // "p"
    swap
    concat
    dup
    // smart_contracts/arc58/dao/contract.algo.ts:598
    // if (this.plugins({ plugin, escrow }).exists) {
    box_len
    bury 1
    bz removePlugin_after_if_else@2
    // smart_contracts/arc58/dao/contract.algo.ts:599
    // this.plugins({ plugin, escrow }).delete()
    frame_dig 5
    box_del
    pop

removePlugin_after_if_else@2:
    // smart_contracts/arc58/dao/contract.algo.ts:602
    // if (name !== '') {
    frame_dig 1
    bytec_3 // ""
    !=
    bz removePlugin_after_if_else@5
    // smart_contracts/arc58/dao/contract.algo.ts:603-606
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [name]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:604
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:604
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:603-606
    // abiCall<typeof AbstractedAccount.prototype.arc58_removeNamedPlugin>({
    //   appId: this.wallet.value,
    //   args: [name]
    // })
    pushbytes 0xe350b9d4 // method "arc58_removeNamedPlugin(string)void"
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/arc58/dao/contract.algo.ts:607
    // return
    frame_dig -1
    frame_bury 0
    retsub

removePlugin_after_if_else@5:
    // smart_contracts/arc58/dao/contract.algo.ts:610-613
    // abiCall<typeof AbstractedAccount.prototype.arc58_removePlugin>({
    //   appId: this.wallet.value,
    //   args: [plugin, caller, escrow]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:611
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:611
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:610-613
    // abiCall<typeof AbstractedAccount.prototype.arc58_removePlugin>({
    //   appId: this.wallet.value,
    //   args: [plugin, caller, escrow]
    // })
    pushbytes 0xeef448fd // method "arc58_removePlugin(uint64,address,string)void"
    itxn_field ApplicationArgs
    frame_dig 2
    itxn_field ApplicationArgs
    frame_dig 3
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newExecution(key: bytes, groups: bytes, firstValid: uint64, lastValid: uint64) -> bytes:
newExecution:
    // smart_contracts/arc58/dao/contract.algo.ts:741
    // private newExecution(key: bytes<32>, groups: bytes<32>[], firstValid: uint64, lastValid: uint64): void {
    proto 4 1
    // smart_contracts/arc58/dao/contract.algo.ts:742-745
    // abiCall<typeof AbstractedAccount.prototype.arc58_addExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key, groups, firstValid, lastValid]
    // })
    itxn_begin
    // smart_contracts/arc58/dao/contract.algo.ts:743
    // appId: this.wallet.value,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:34
    // wallet = GlobalState<Application>({ key: AkitaDAOGlobalStateKeysWallet })
    bytec_2 // "wallet"
    // smart_contracts/arc58/dao/contract.algo.ts:743
    // appId: this.wallet.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:744
    // args: [key, groups, firstValid, lastValid]
    frame_dig -4
    len
    pushint 32 // 32
    ==
    assert // invalid size
    frame_dig -2
    itob
    frame_dig -1
    itob
    // smart_contracts/arc58/dao/contract.algo.ts:742-745
    // abiCall<typeof AbstractedAccount.prototype.arc58_addExecutionKey>({
    //   appId: this.wallet.value,
    //   args: [key, groups, firstValid, lastValid]
    // })
    pushbytes 0x5cebed43 // method "arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_dig -3
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.newProposalID() -> uint64:
newProposalID:
    // smart_contracts/arc58/dao/contract.algo.ts:756
    // const id = this.proposalID.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:86
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 37 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:756
    // const id = this.proposalID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/arc58/dao/contract.algo.ts:757
    // this.proposalID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/arc58/dao/contract.algo.ts:86
    // proposalID = GlobalState<uint64>({ key: AkitaDAOGlobalStateKeysProposalID })
    bytec 37 // "proposal_id"
    // smart_contracts/arc58/dao/contract.algo.ts:757
    // this.proposalID.value += 1
    swap
    app_global_put
    // smart_contracts/arc58/dao/contract.algo.ts:758
    // return id
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost() -> uint64:
smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.setupCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1257
    // const { wallet: appId } = this.akitaAppList.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:42
    // akitaAppList = GlobalState<AkitaAppList>({ key: AkitaDAOGlobalStateKeysAkitaAppList })
    bytec 9 // "aal"
    // smart_contracts/arc58/dao/contract.algo.ts:1257
    // const { wallet: appId } = this.akitaAppList.value
    app_global_get_ex
    assert // check GlobalState exists
    pushint 88 // 88
    extract_uint64
    // smart_contracts/arc58/dao/contract.algo.ts:1258
    // return abiCall<typeof AbstractedAccountFactory.prototype.cost>({ appId }).returnValue
    itxn_begin
    pushbytes 0x9b67fa6d // method "cost()uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_1 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    retsub


// smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost(actions: bytes) -> bytes, bytes:
smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost:
    // smart_contracts/arc58/dao/contract.algo.ts:1261-1262
    // @abimethod({ readonly: true })
    // proposalCost(actions: ProposalAction[]): ProposalCostInfo {
    proto 1 2
    intc_0 // 0
    dupn 9
    bytec_3 // ""
    dupn 2
    // smart_contracts/arc58/dao/contract.algo.ts:105
    // let totalActionDataLength: uint64 = 0;
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:106
    // for (let i: uint64 = 0; i < actions.length; i++) {
    dup

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@53:
    // smart_contracts/arc58/dao/contract.algo.ts:106
    // for (let i: uint64 = 0; i < actions.length; i++) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 10
    frame_dig 14
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@55
    // smart_contracts/arc58/dao/contract.algo.ts:107
    // totalActionDataLength += (MinDAOProposalActionMbr + actions[i].data.length)
    frame_dig -1
    extract 2 0
    frame_dig 14
    dup
    cover 2
    intc_3 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 14
    frame_dig 10
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_3 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    extract 2 0
    len
    pushint 7 // 7
    +
    frame_dig 13
    +
    frame_bury 13
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@53

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@55:
    // smart_contracts/arc58/dao/contract.algo.ts:110
    // return MinDAOProposalMBR + (BoxCostPerByte * totalActionDataLength)
    pushint 400 // 400
    frame_dig 13
    *
    pushint 54500 // 54500
    +
    frame_bury 11
    // smart_contracts/arc58/dao/contract.algo.ts:1265
    // total: 0,
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:1264-1272
    // let info: ProposalCostInfo = {
    //   total: 0,
    //   mbr: 0,
    //   fee: 0,
    //   power: 0,
    //   duration: 0,
    //   participation: 0,
    //   approval: 0
    // }
    itob
    frame_bury 5
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    frame_bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:1274
    // for (let i: uint64 = 0; i < actions.length; i++) {
    intc_0 // 0
    frame_bury 14

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3:
    // smart_contracts/arc58/dao/contract.algo.ts:1274
    // for (let i: uint64 = 0; i < actions.length; i++) {
    frame_dig 14
    frame_dig 10
    <
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@19
    // smart_contracts/arc58/dao/contract.algo.ts:1276
    // const { type, data } = actions[i]
    frame_dig -1
    extract 2 0
    frame_dig 14
    dup
    cover 2
    intc_3 // 2
    *
    dig 1
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    dup
    frame_bury 14
    frame_dig 10
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_3 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    extract 0 1
    dup
    cover 2
    frame_bury 9
    dup
    intc_1 // 1
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 4
    extract 2 0
    frame_bury 6
    // smart_contracts/arc58/dao/contract.algo.ts:463
    // case ProposalActionTypeUpgradeApp: {
    bytec 22 // 0x0a
    ==
    dup
    frame_bury 12
    // smart_contracts/arc58/dao/contract.algo.ts:463-465
    // case ProposalActionTypeUpgradeApp: {
    //   return this.upgradeAppProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@30
    // smart_contracts/arc58/dao/contract.algo.ts:464
    // return this.upgradeAppProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:68
    // upgradeAppProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpgradeAppProposalSettings })
    bytec 15 // "upgrade_app_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:464
    // return this.upgradeAppProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51:
    // smart_contracts/arc58/dao/contract.algo.ts:1280
    // info.total += settings.fee
    frame_dig 7
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 8
    intc_0 // 0
    extract_uint64
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1281
    // info.fee += settings.fee
    dup
    pushint 16 // 16
    extract_uint64
    uncover 2
    +
    itob
    replace2 16
    frame_bury 7
    // smart_contracts/arc58/dao/contract.algo.ts:1283
    // if (type === ProposalActionTypeUpgradeApp) {
    frame_dig 12
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@6
    // smart_contracts/arc58/dao/contract.algo.ts:1284
    // mbr += DAOExecutionMBR
    frame_dig 11
    pushint 22100 // 22100
    +
    frame_bury 11

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10:
    // smart_contracts/arc58/dao/contract.algo.ts:1289
    // if (settings.power > info.power) {
    frame_dig 8
    dup
    extract 8 8
    frame_bury 3
    intc_2 // 8
    extract_uint64
    frame_dig 7
    pushint 24 // 24
    extract_uint64
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@12
    // smart_contracts/arc58/dao/contract.algo.ts:1290
    // info.power = settings.power
    frame_dig 7
    frame_dig 3
    replace2 24
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@12:
    // smart_contracts/arc58/dao/contract.algo.ts:1293
    // if (settings.duration > info.duration) {
    frame_dig 8
    dup
    extract 16 8
    frame_bury 0
    pushint 16 // 16
    extract_uint64
    frame_dig 7
    pushint 32 // 32
    extract_uint64
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@14
    // smart_contracts/arc58/dao/contract.algo.ts:1294
    // info.duration = settings.duration
    frame_dig 7
    frame_dig 0
    replace2 32
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@14:
    // smart_contracts/arc58/dao/contract.algo.ts:1297
    // if (settings.participation > info.participation) {
    frame_dig 8
    dup
    extract 24 8
    frame_bury 1
    pushint 24 // 24
    extract_uint64
    frame_dig 7
    pushint 40 // 40
    extract_uint64
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@16
    // smart_contracts/arc58/dao/contract.algo.ts:1298
    // info.participation = settings.participation
    frame_dig 7
    frame_dig 1
    replace2 40
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@16:
    // smart_contracts/arc58/dao/contract.algo.ts:1301
    // if (settings.approval > info.approval) {
    frame_dig 8
    dup
    extract 32 8
    frame_bury 2
    pushint 32 // 32
    extract_uint64
    frame_dig 7
    pushint 48 // 48
    extract_uint64
    >
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3
    // smart_contracts/arc58/dao/contract.algo.ts:1302
    // info.approval = settings.approval
    frame_dig 7
    frame_dig 2
    replace2 48
    frame_bury 7
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_while_top@3

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@6:
    // smart_contracts/arc58/dao/contract.algo.ts:1285
    // } else if (type === ProposalActionTypeAddPlugin || type === ProposalActionTypeAddNamedPlugin) {
    frame_dig 9
    bytec 6 // 0x14
    ==
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_if_body@8
    frame_dig 9
    bytec 35 // 0x15
    ==
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_if_body@8:
    // smart_contracts/arc58/dao/contract.algo.ts:1286
    // mbr += this.pluginsMbr(String(op.bzero(24)))
    frame_dig 11
    // smart_contracts/arc58/dao/contract.algo.ts:101
    // return MinDAOPluginMBR + (BoxCostPerByte * Bytes(escrow).length)
    pushint 33300 // 33300
    // smart_contracts/arc58/dao/contract.algo.ts:1286
    // mbr += this.pluginsMbr(String(op.bzero(24)))
    +
    frame_bury 11
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@10

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@30:
    // smart_contracts/arc58/dao/contract.algo.ts:466
    // case ProposalActionTypeAddPlugin:
    frame_dig 9
    bytec 6 // 0x14
    ==
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_block@32
    // smart_contracts/arc58/dao/contract.algo.ts:467
    // case ProposalActionTypeAddNamedPlugin: {
    frame_dig 9
    bytec 35 // 0x15
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:467-469
    // case ProposalActionTypeAddNamedPlugin: {
    //   return this.addPluginProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@33

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_block@32:
    // smart_contracts/arc58/dao/contract.algo.ts:468
    // return this.addPluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:70
    // addPluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddPluginProposalSettings })
    bytec 16 // "add_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:468
    // return this.addPluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@33:
    // smart_contracts/arc58/dao/contract.algo.ts:470
    // case ProposalActionTypeExecutePlugin: {
    frame_dig 9
    bytec 10 // 0x1e
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:470-474
    // case ProposalActionTypeExecutePlugin: {
    //   const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(data)
    //   assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    //   return this.plugins({ plugin, escrow }).value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@35
    // smart_contracts/arc58/dao/contract.algo.ts:471
    // const { plugin, escrow } = decodeArc4<ProposalExecutePlugin>(data)
    frame_dig 4
    extract 2 8
    frame_dig 6
    dup
    intc_2 // 8
    extract_uint16
    dig 1
    pushint 42 // 42
    extract_uint16
    substring3
    extract 2 0
    // smart_contracts/arc58/dao/contract.algo.ts:472
    // assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 46 // 0x000a
    concat
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:91
    // plugins = BoxMap<DAOPluginKey, ProposalSettings>({ keyPrefix: AbstractAccountBoxPrefixPlugins })
    bytec 47 // "p"
    swap
    concat
    // smart_contracts/arc58/dao/contract.algo.ts:472
    // assert(this.plugins({ plugin, escrow }).exists, ERR_PROPOSAL_DOES_NOT_EXIST)
    dup
    box_len
    bury 1
    assert // Proposal does not exist
    // smart_contracts/arc58/dao/contract.algo.ts:473
    // return this.plugins({ plugin, escrow }).value
    box_get
    pop
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@35:
    // smart_contracts/arc58/dao/contract.algo.ts:475
    // case ProposalActionTypeRemoveExecutePlugin: {
    frame_dig 9
    bytec 39 // 0x1f
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:475-477
    // case ProposalActionTypeRemoveExecutePlugin: {
    //   return this.removeExecutePluginProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@37
    // smart_contracts/arc58/dao/contract.algo.ts:476
    // return this.removeExecutePluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:74
    // removeExecutePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveExecutePluginProposalSettings })
    bytec 49 // "remove_execute_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:476
    // return this.removeExecutePluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@37:
    // smart_contracts/arc58/dao/contract.algo.ts:478
    // case ProposalActionTypeRemovePlugin:
    frame_dig 9
    bytec 8 // 0x28
    ==
    bnz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_block@39
    // smart_contracts/arc58/dao/contract.algo.ts:479
    // case ProposalActionTypeRemoveNamedPlugin: {
    frame_dig 9
    bytec 40 // 0x29
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:479-481
    // case ProposalActionTypeRemoveNamedPlugin: {
    //   return this.removePluginProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@40

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_block@39:
    // smart_contracts/arc58/dao/contract.algo.ts:480
    // return this.removePluginProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:72
    // removePluginProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemovePluginProposalSettings })
    bytec 17 // "remove_plugin_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:480
    // return this.removePluginProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@40:
    // smart_contracts/arc58/dao/contract.algo.ts:482
    // case ProposalActionTypeAddAllowances: {
    frame_dig 9
    bytec 12 // 0x32
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:482-484
    // case ProposalActionTypeAddAllowances: {
    //   return this.addAllowancesProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@42
    // smart_contracts/arc58/dao/contract.algo.ts:483
    // return this.addAllowancesProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:76
    // addAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysAddAllowancesProposalSettings })
    bytec 18 // "add_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:483
    // return this.addAllowancesProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@42:
    // smart_contracts/arc58/dao/contract.algo.ts:485
    // case ProposalActionTypeRemoveAllowances: {
    frame_dig 9
    bytec 42 // 0x3c
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:485-487
    // case ProposalActionTypeRemoveAllowances: {
    //   return this.removeAllowancesProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@44
    // smart_contracts/arc58/dao/contract.algo.ts:486
    // return this.removeAllowancesProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:78
    // removeAllowancesProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysRemoveAllowancesProposalSettings })
    bytec 19 // "remove_allowance_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:486
    // return this.removeAllowancesProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@44:
    // smart_contracts/arc58/dao/contract.algo.ts:488
    // case ProposalActionTypeNewEscrow: {
    frame_dig 9
    bytec 43 // 0x46
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:488-490
    // case ProposalActionTypeNewEscrow: {
    //   return this.newEscrowProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@46
    // smart_contracts/arc58/dao/contract.algo.ts:489
    // return this.newEscrowProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:80
    // newEscrowProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysNewEscrowProposalSettings })
    bytec 20 // "new_escrow_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:489
    // return this.newEscrowProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@46:
    // smart_contracts/arc58/dao/contract.algo.ts:491
    // case ProposalActionTypeToggleEscrowLock: {
    frame_dig 9
    bytec 44 // 0x47
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:491-493
    // case ProposalActionTypeToggleEscrowLock: {
    //   return this.toggleEscrowLockProposalSettings.value
    // }
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@48
    // smart_contracts/arc58/dao/contract.algo.ts:492
    // return this.toggleEscrowLockProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:82
    // toggleEscrowLockProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysToggleEscrowLockProposalSettings })
    bytec 50 // "toggle_escrow_lock_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:492
    // return this.toggleEscrowLockProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@48:
    // smart_contracts/arc58/dao/contract.algo.ts:494
    // case ProposalActionTypeUpdateFields: {
    frame_dig 9
    bytec 45 // 0x50
    ==
    // smart_contracts/arc58/dao/contract.algo.ts:494-496
    // case ProposalActionTypeUpdateFields: {
    //   return this.updateFieldsProposalSettings.value
    // }
    assert // Invalid proposal action
    // smart_contracts/arc58/dao/contract.algo.ts:495
    // return this.updateFieldsProposalSettings.value
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:84
    // updateFieldsProposalSettings = GlobalState<ProposalSettings>({ key: AkitaDAOGlobalStateKeysUpdateFieldsProposalSettings })
    bytec 21 // "update_fields_ps"
    // smart_contracts/arc58/dao/contract.algo.ts:495
    // return this.updateFieldsProposalSettings.value
    app_global_get_ex
    assert // check GlobalState exists
    frame_bury 8
    // smart_contracts/arc58/dao/contract.algo.ts:1278
    // const settings = this.getProposalSettings(type, data)
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_inlined_smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.getProposalSettings@51

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_while@19:
    // smart_contracts/arc58/dao/contract.algo.ts:1309
    // if (info.total < mbr) {
    frame_dig 7
    intc_0 // 0
    extract_uint64
    frame_dig 11
    <
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@21
    // smart_contracts/arc58/dao/contract.algo.ts:1310
    // info.total = mbr
    frame_dig 11
    itob
    frame_dig 7
    dig 1
    replace2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1311
    // info.mbr = mbr
    swap
    replace2 8
    // smart_contracts/arc58/dao/contract.algo.ts:1312
    // info.fee = 0
    frame_dig 5
    replace2 16
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@22:
    // smart_contracts/arc58/dao/contract.algo.ts:1318
    // if (this.state.value !== DaoStateFullyInitialized && Txn.sender === Global.creatorAddress) {
    intc_0 // 0
    // smart_contracts/arc58/dao/contract.algo.ts:30
    // state = GlobalState<DaoState>({ initialValue: DaoStateDraft, key: AkitaDAOGlobalStateKeysInitialized })
    bytec 7 // "initialized"
    // smart_contracts/arc58/dao/contract.algo.ts:1318
    // if (this.state.value !== DaoStateFullyInitialized && Txn.sender === Global.creatorAddress) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec 34 // 0x02
    !=
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@25
    txn Sender
    global CreatorAddress
    ==
    bz smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@25
    // smart_contracts/arc58/dao/contract.algo.ts:1319
    // info.total = 0
    frame_dig 7
    frame_dig 5
    dup
    cover 2
    replace2 0
    // smart_contracts/arc58/dao/contract.algo.ts:1320
    // info.fee = 0
    swap
    replace2 16
    frame_bury 7

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@25:
    // smart_contracts/arc58/dao/contract.algo.ts:1323
    // return info
    frame_dig 7
    frame_dig -1
    frame_bury 1
    frame_bury 0
    retsub

smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_else_body@21:
    // smart_contracts/arc58/dao/contract.algo.ts:1314
    // info.mbr = mbr
    frame_dig 11
    dup
    itob
    frame_dig 7
    swap
    replace2 8
    // smart_contracts/arc58/dao/contract.algo.ts:1315
    // info.fee = info.total - mbr
    dup
    intc_0 // 0
    extract_uint64
    uncover 2
    -
    itob
    replace2 16
    frame_bury 7
    b smart_contracts/arc58/dao/contract.algo.ts::AkitaDAO.proposalCost_after_if_else@22
