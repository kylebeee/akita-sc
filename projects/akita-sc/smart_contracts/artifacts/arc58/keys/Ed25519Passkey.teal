#pragma version 11
#pragma typetrack false

// smart_contracts/arc58/keys/ed25519_passkey.algo.ts::program() -> uint64:
main:
    bytecblock TMPL_PK
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:13
    // const sig = op.arg(4).toFixed({ length: 64 })
    arg 4
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:11
    // const cdTwo = op.arg(2)
    arg_2
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:9
    // const authData = op.arg(0)
    arg_0
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:10
    // const cdOne = op.arg(1)
    arg_1
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:11
    // const cdTwo = op.arg(2)
    arg_2
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:12
    // const cdThree = op.arg(3)
    arg_3
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:13
    // const sig = op.arg(4).toFixed({ length: 64 })
    arg 4
    len
    pushint 64 // 64
    ==
    assert // Length must be 64
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:15
    // const h = sha256(authData.concat(sha256(cdOne.concat(cdTwo).concat(cdThree))))
    cover 2
    concat
    swap
    concat
    sha256
    concat
    sha256
    swap
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:17
    // if (Global.groupSize > 1) {
    global GroupSize
    pushint 1 // 1
    >
    bz main_else_body@2
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:18
    // assert(Global.groupId === base64Decode(op.Base64.URLEncoding, cdTwo))
    global GroupID
    swap
    base64_decode URLEncoding
    ==
    assert

main_after_if_else@3:
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:23
    // return ed25519verify(h, sig, PK)
    dup
    dig 2
    bytec_0 // TMPL_PK
    ed25519verify
    return

main_else_body@2:
    // smart_contracts/arc58/keys/ed25519_passkey.algo.ts:20
    // assert(Txn.txId === base64Decode(op.Base64.URLEncoding, cdTwo))
    txn TxID
    swap
    base64_decode URLEncoding
    ==
    assert
    b main_after_if_else@3
