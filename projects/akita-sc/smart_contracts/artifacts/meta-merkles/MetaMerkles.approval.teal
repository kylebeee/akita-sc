#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 32 400
    bytecblock "" 0x0014 "d" 0x151f7c75 0x0022 "r" "types_id" 0x00066c2e74797065 0x068101
    // smart_contracts/meta-merkles/contract.algo.ts:87
    // export class MetaMerkles extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@16
    pushbytess 0xa24c067c 0xdf287a7d 0xc6d3d704 0x42fc7202 0x06d38904 0x2bf3cc5a 0x50c36e41 0x0cf1b9cf 0x1ff7c74c 0x39c17ded 0x72b25981 0x7683cd25 // method "addRoot(pay,string,byte[32],uint64)void", method "deleteRoot(string)void", method "updateRoot(string,byte[32])void", method "addData(pay,string,string,string)void", method "deleteData(string,string)void", method "verify(address,string,byte[32],byte[32][],uint64)bool", method "read(address,string,string)string", method "verifiedRead(address,string,byte[32],byte[32][],uint64,string)string", method "verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string", method "addType(pay,string,uint8[])void", method "rootCosts(string)uint64", method "dataCosts(string,string,string)uint64"
    txna ApplicationArgs 0
    match addRoot deleteRoot updateRoot addData deleteData verify read verifiedRead verifiedMustRead addType rootCosts dataCosts
    err

main_create_NoOp@16:
    // smart_contracts/meta-merkles/contract.algo.ts:87
    // export class MetaMerkles extends Contract {
    pushbytes 0x4c5c61ba // method "create()void"
    txna ApplicationArgs 0
    match main_create_route@17
    err

main_create_route@17:
    // smart_contracts/meta-merkles/contract.algo.ts:95
    // typesID = GlobalState<uint64>({ key: MetaMerklesGlobalStateKeyTypesID })
    bytec 6 // "types_id"
    // smart_contracts/meta-merkles/contract.algo.ts:140
    // this.typesID.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/meta-merkles/contract.algo.ts:138
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return


// smart_contracts/utils/types/base.ts::bytes16(v: bytes) -> bytes:
bytes16:
    // smart_contracts/utils/types/base.ts:7
    // export function bytes16(v: bytes) {
    proto 1 1
    // smart_contracts/utils/types/base.ts:8
    // return v.slice(0, 16).toFixed({ length: 16 })
    frame_dig -1
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 16 // 16
    dig 2
    >=
    pushint 16 // 16
    uncover 3
    uncover 2
    select
    frame_dig -1
    cover 2
    substring3
    dup
    len
    pushint 16 // 16
    ==
    assert // Length must be 16
    retsub


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.addRoot[routing]() -> void:
addRoot:
    // smart_contracts/meta-merkles/contract.algo.ts:155-160
    // addRoot(
    //   payment: gtxn.PaymentTxn,
    //   name: string,
    //   root: bytes<32>,
    //   type: uint64
    // ): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/meta-merkles/contract.algo.ts:161
    // assert(Bytes(name).length <= 31, 'Cannot add root with name longer than 31 bytes')
    dig 2
    len
    dup
    pushint 31 // 31
    <=
    assert // Cannot add root with name longer than 31 bytes
    // smart_contracts/meta-merkles/contract.algo.ts:162
    // assert(this.types(type).exists, ERR_NO_TREE_TYPE)
    swap
    itob
    // smart_contracts/meta-merkles/contract.algo.ts:100
    // types = BoxMap<uint64, TypesValue>({ keyPrefix: MetaMerklesBoxPrefixTypes })
    pushbytes "t"
    dig 1
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:162
    // assert(this.types(type).exists, ERR_NO_TREE_TYPE)
    box_len
    bury 1
    assert // tree type does not exist
    // smart_contracts/meta-merkles/contract.algo.ts:164
    // const truncatedAddress = bytes16(Txn.sender.bytes)
    txn Sender
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:166
    // const rootKey: RootKey = { address: Txn.sender, name }
    txn Sender
    uncover 3
    itob
    extract 6 2
    dig 5
    concat
    swap
    bytec 4 // 0x0022
    concat
    dig 1
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:167
    // const typeKey: DataKey = { address: truncatedAddress, name, key: treeTypeKey }
    dig 2
    len
    pushint 16 // 16
    ==
    assert // invalid size
    uncover 2
    bytec_1 // 0x0014
    concat
    dig 2
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    concat
    bytec 7 // 0x00066c2e74797065
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:102
    // roots = BoxMap<RootKey, bytes<32>>({ keyPrefix: MetaMerklesBoxPrefixRoots })
    bytec 5 // "r"
    uncover 2
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:169
    // assert(!this.roots(rootKey).exists, ERR_NAME_TAKEN)
    dup
    box_len
    bury 1
    !
    assert // this name is already in use
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    uncover 2
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:170
    // assert(!this.data(typeKey).exists, ERR_TREE_TYPE_KEY_ALREADY_EXISTS)
    dup
    box_len
    bury 1
    !
    assert // tree type key already exists for this root
    // smart_contracts/meta-merkles/contract.algo.ts:172-179
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.rootCosts(name),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 5
    gtxns Receiver
    // smart_contracts/meta-merkles/contract.algo.ts:175
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/meta-merkles/contract.algo.ts:172-179
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.rootCosts(name),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 6
    gtxns Amount
    // smart_contracts/meta-merkles/contract.algo.ts:176
    // amount: this.rootCosts(name),
    uncover 6
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts
    // smart_contracts/meta-merkles/contract.algo.ts:172-179
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: this.rootCosts(name),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/meta-merkles/contract.algo.ts:181
    // this.roots(rootKey).value = root
    swap
    uncover 3
    box_put
    // smart_contracts/meta-merkles/contract.algo.ts:182
    // this.data(typeKey).value = String(itob(type))
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/meta-merkles/contract.algo.ts:155-160
    // addRoot(
    //   payment: gtxn.PaymentTxn,
    //   name: string,
    //   root: bytes<32>,
    //   type: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.deleteRoot[routing]() -> void:
deleteRoot:
    // smart_contracts/meta-merkles/contract.algo.ts:190
    // deleteRoot(name: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/meta-merkles/contract.algo.ts:191
    // const truncatedAddress = bytes16(Txn.sender.bytes)
    txn Sender
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:193
    // const rootKey: RootKey = { address: Txn.sender, name }
    txn Sender
    dig 2
    len
    itob
    extract 6 2
    dig 3
    concat
    swap
    bytec 4 // 0x0022
    concat
    dig 1
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:194
    // const typeKey: DataKey = { address: truncatedAddress, name, key: treeTypeKey }
    dig 2
    len
    pushint 16 // 16
    ==
    assert // invalid size
    uncover 2
    bytec_1 // 0x0014
    concat
    dig 2
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    concat
    bytec 7 // 0x00066c2e74797065
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:102
    // roots = BoxMap<RootKey, bytes<32>>({ keyPrefix: MetaMerklesBoxPrefixRoots })
    bytec 5 // "r"
    uncover 2
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:196
    // assert(this.roots(rootKey).exists, ERR_NO_NAME)
    dup
    box_len
    bury 1
    assert // a root with this name does not exist
    // smart_contracts/meta-merkles/contract.algo.ts:198
    // this.roots(rootKey).delete()
    box_del
    pop
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:199
    // this.data(typeKey).delete()
    box_del
    pop
    // smart_contracts/meta-merkles/contract.algo.ts:202-207
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.rootCosts(name),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/meta-merkles/contract.algo.ts:204
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/meta-merkles/contract.algo.ts:205
    // amount: this.rootCosts(name),
    swap
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/meta-merkles/contract.algo.ts:202-206
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.rootCosts(name),
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/meta-merkles/contract.algo.ts:202-207
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: this.rootCosts(name),
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/meta-merkles/contract.algo.ts:190
    // deleteRoot(name: string): void {
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.updateRoot[routing]() -> void:
updateRoot:
    // smart_contracts/meta-merkles/contract.algo.ts:216
    // updateRoot(name: string, newRoot: bytes<32>): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/meta-merkles/contract.algo.ts:217
    // const key: RootKey = { address: Txn.sender, name }
    txn Sender
    dig 2
    len
    itob
    extract 6 2
    uncover 3
    concat
    swap
    bytec 4 // 0x0022
    concat
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:102
    // roots = BoxMap<RootKey, bytes<32>>({ keyPrefix: MetaMerklesBoxPrefixRoots })
    bytec 5 // "r"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:218
    // assert(this.roots(key).exists, ERR_NO_NAME)
    dup
    box_len
    bury 1
    assert // a root with this name does not exist
    // smart_contracts/meta-merkles/contract.algo.ts:219
    // this.roots(key).value = newRoot
    swap
    box_put
    // smart_contracts/meta-merkles/contract.algo.ts:216
    // updateRoot(name: string, newRoot: bytes<32>): void {
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.addData[routing]() -> void:
addData:
    // smart_contracts/meta-merkles/contract.algo.ts:231
    // addData(payment: gtxn.PaymentTxn, name: string, key: string, value: string): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 2
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 3
    // smart_contracts/meta-merkles/contract.algo.ts:232
    // const rootKey: RootKey = { address: Txn.sender, name }
    txn Sender
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    dup
    cover 4
    swap
    bytec 4 // 0x0022
    concat
    swap
    concat
    cover 2
    // smart_contracts/meta-merkles/contract.algo.ts:235
    // assert(keyBytes.length <= maxDataKeyLength, ERR_KEY_TOO_LONG)
    swap
    len
    dup
    cover 2
    dup
    pushint 15 // 15
    <=
    assert // max key length is 32 bytes
    // smart_contracts/meta-merkles/contract.algo.ts:236
    // assert(Bytes(value).length <= maxDataLength, ERR_DATA_TOO_LONG)
    swap
    len
    pushint 1024 // 1024
    <=
    assert // max data length is 1024 bytes
    // smart_contracts/meta-merkles/contract.algo.ts:238
    // keyBytes.length < 2 || !(keyBytes.slice(0, 2) === Bytes(reservedDataKeyPrefix)),
    intc_2 // 2
    <
    bnz addData_bool_true@3
    intc_0 // 0
    dig 1
    dup
    cover 2
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 2
    dig 2
    >=
    intc_2 // 2
    uncover 3
    uncover 2
    select
    dig 6
    cover 2
    substring3
    pushbytes "l."
    ==
    bnz addData_bool_false@4

addData_bool_true@3:
    intc_1 // 1

addData_bool_merge@5:
    // smart_contracts/meta-merkles/contract.algo.ts:237-240
    // assert(
    //   keyBytes.length < 2 || !(keyBytes.slice(0, 2) === Bytes(reservedDataKeyPrefix)),
    //   ERR_RESERVED_KEY_PREFIX
    // )
    assert // l. is reserved for internals
    // smart_contracts/meta-merkles/contract.algo.ts:102
    // roots = BoxMap<RootKey, bytes<32>>({ keyPrefix: MetaMerklesBoxPrefixRoots })
    bytec 5 // "r"
    dig 2
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:241
    // assert(this.roots(rootKey).exists, ERR_NO_ROOT_FOR_DATA)
    box_len
    bury 1
    assert // there must be a root to associate the data to
    // smart_contracts/meta-merkles/contract.algo.ts:243
    // const costs = this.mbr('', '', name, key, value)
    bytec_0 // ""
    dup
    dig 7
    dig 7
    dup
    cover 4
    dig 8
    dup
    cover 6
    callsub mbr
    // smart_contracts/meta-merkles/contract.algo.ts:245-252
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.data,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 9
    dup
    gtxns Receiver
    // smart_contracts/meta-merkles/contract.algo.ts:248
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/meta-merkles/contract.algo.ts:245-252
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.data,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    swap
    gtxns Amount
    // smart_contracts/meta-merkles/contract.algo.ts:249
    // amount: costs.data,
    uncover 2
    pushint 16 // 16
    extract_uint64
    // smart_contracts/meta-merkles/contract.algo.ts:245-252
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: costs.data,
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/meta-merkles/contract.algo.ts:254
    // const truncatedAddress = bytes16(Txn.sender.bytes)
    txn Sender
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:255
    // const dataKey: DataKey = { address: truncatedAddress, name, key }
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    bytec_1 // 0x0014
    concat
    dig 5
    dup
    cover 2
    len
    pushint 20 // 20
    +
    dig 5
    itob
    extract 6 2
    uncover 4
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:257
    // this.data(dataKey).value = value
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/meta-merkles/contract.algo.ts:231
    // addData(payment: gtxn.PaymentTxn, name: string, key: string, value: string): void {
    intc_1 // 1
    return

addData_bool_false@4:
    intc_0 // 0
    b addData_bool_merge@5


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.deleteData[routing]() -> void:
deleteData:
    // smart_contracts/meta-merkles/contract.algo.ts:266
    // deleteData(name: string, key: string): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/meta-merkles/contract.algo.ts:267
    // const truncatedAddress = bytes16(Txn.sender.bytes)
    txn Sender
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:268
    // const dataKey: DataKey = { address: truncatedAddress, name, key }
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    dig 2
    len
    itob
    extract 6 2
    dig 3
    concat
    swap
    bytec_1 // 0x0014
    concat
    dig 1
    len
    pushint 20 // 20
    +
    dig 3
    len
    itob
    extract 6 2
    dig 4
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:270
    // assert(this.data(dataKey).exists, ERR_NO_DATA)
    dup
    box_len
    bury 1
    assert // data does not exist
    // smart_contracts/meta-merkles/contract.algo.ts:272
    // this.data(dataKey).delete()
    dup
    box_del
    pop
    // smart_contracts/meta-merkles/contract.algo.ts:274
    // const costs = this.mbr('', '', name, key, this.data(dataKey).value)
    box_get
    assert // Box must have value
    bytec_0 // ""
    dup
    cover 4
    cover 4
    callsub mbr
    // smart_contracts/meta-merkles/contract.algo.ts:276-281
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: costs.data,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/meta-merkles/contract.algo.ts:278
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/meta-merkles/contract.algo.ts:279
    // amount: costs.data,
    swap
    pushint 16 // 16
    extract_uint64
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/meta-merkles/contract.algo.ts:276-280
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: costs.data,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/meta-merkles/contract.algo.ts:276-281
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: costs.data,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/meta-merkles/contract.algo.ts:266
    // deleteData(name: string, key: string): void {
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify[routing]() -> void:
verify:
    // smart_contracts/meta-merkles/contract.algo.ts:295
    // verify(address: Account, name: string, leaf: Leaf, proof: Proof, type: uint64): boolean {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    txna ApplicationArgs 5
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify
    pop
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read[routing]() -> void:
read:
    // smart_contracts/meta-merkles/contract.algo.ts:328
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verifiedRead[routing]() -> void:
verifiedRead:
    // smart_contracts/meta-merkles/contract.algo.ts:353
    // verifiedRead(address: Account, name: string, leaf: Leaf, proof: Proof, type: uint64, key: string): string {
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 2
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    txna ApplicationArgs 5
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    cover 5
    // smart_contracts/meta-merkles/contract.algo.ts:354
    // const verified = this.verify(address, name, leaf, proof, type)
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify
    pop
    // smart_contracts/meta-merkles/contract.algo.ts:355
    // if (!verified) {
    bnz verifiedRead_after_if_else@3
    // smart_contracts/meta-merkles/contract.algo.ts:356
    // return ''
    bytec_0 // ""

verifiedRead_after_inlined_smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verifiedRead@4:
    // smart_contracts/meta-merkles/contract.algo.ts:353
    // verifiedRead(address: Account, name: string, leaf: Leaf, proof: Proof, type: uint64, key: string): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

verifiedRead_after_if_else@3:
    // smart_contracts/meta-merkles/contract.algo.ts:358
    // return this.read(address, name, key)
    dig 2
    dig 2
    dig 2
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read
    // smart_contracts/meta-merkles/contract.algo.ts:353
    // verifiedRead(address: Account, name: string, leaf: Leaf, proof: Proof, type: uint64, key: string): string {
    b verifiedRead_after_inlined_smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verifiedRead@4


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verifiedMustRead[routing]() -> void:
verifiedMustRead:
    // smart_contracts/meta-merkles/contract.algo.ts:380-387
    // verifiedMustRead(
    //   address: Account,
    //   name: string,
    //   leaf: Leaf,
    //   proof: Proof,
    //   type: uint64,
    //   key: string
    // ): string {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 32
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint8[32][])
    txna ApplicationArgs 5
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/meta-merkles/contract.algo.ts:388
    // assert(this.verify(address, name, leaf, proof, type), ERR_FAILED_TO_VERIFY_INCLUSION)
    dig 5
    dig 5
    uncover 5
    uncover 5
    uncover 5
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify
    pop
    assert // failed to verify inclusion
    // smart_contracts/meta-merkles/contract.algo.ts:389
    // return this.read(address, name, key)
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read
    // smart_contracts/meta-merkles/contract.algo.ts:380-387
    // verifiedMustRead(
    //   address: Account,
    //   name: string,
    //   leaf: Leaf,
    //   proof: Proof,
    //   type: uint64,
    //   key: string
    // ): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.addType[routing]() -> void:
addType:
    intc_0 // 0
    // smart_contracts/meta-merkles/contract.algo.ts:392
    // addType(payment: gtxn.PaymentTxn, description: string, schemaList: SchemaList): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    dup
    cover 2
    txna ApplicationArgs 2
    dup
    cover 3
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 4
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint8[])
    // smart_contracts/meta-merkles/contract.algo.ts:393
    // assert(payment.receiver === Global.currentApplicationAddress, ERR_INVALID_PAYMENT_RECEIVER)
    dig 1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Invalid payment receiver
    // smart_contracts/meta-merkles/contract.algo.ts:394
    // assert(payment.amount === 100_000_000, ERR_INVALID_PAYMENT_AMOUNT)
    swap
    gtxns Amount
    pushint 100000000 // 100000000
    ==
    assert // Invalid payment amount
    // smart_contracts/meta-merkles/contract.algo.ts:395
    // assert(Bytes(description).length <= 800, ERR_DATA_TOO_LONG)
    len
    dup
    pushint 800 // 800
    <=
    assert // max data length is 1024 bytes
    // smart_contracts/meta-merkles/contract.algo.ts:397
    // let schema: string = ''
    bytec_0 // ""
    // smart_contracts/meta-merkles/contract.algo.ts:398
    // for (let i: uint64 = 0; i < schemaList.length; i += 1) {
    intc_0 // 0

addType_while_top@2:
    // smart_contracts/meta-merkles/contract.algo.ts:398
    // for (let i: uint64 = 0; i < schemaList.length; i += 1) {
    dup
    dig 4
    <
    bz addType_after_while@59
    // smart_contracts/meta-merkles/contract.algo.ts:399
    // switch (schemaList[i]) {
    dig 4
    extract 2 0
    dig 1
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    dup
    bury 8
    // smart_contracts/meta-merkles/contract.algo.ts:400
    // case SchemaPartUint8:
    pushbytes 0x0a
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:400-402
    // case SchemaPartUint8:
    //   schema += SchemaPartUint8String
    //   break
    bz addType_after_if_else@6
    // smart_contracts/meta-merkles/contract.algo.ts:401
    // schema += SchemaPartUint8String
    dig 1
    pushbytes "uint8"
    concat
    bury 2

addType_block@55:
    // smart_contracts/meta-merkles/contract.algo.ts:453
    // if (schemaList.length > 0 && i !== schemaList.length - 1) {
    dig 3
    bz addType_after_if_else@58
    dig 3
    intc_1 // 1
    -
    dig 1
    !=
    bz addType_after_if_else@58
    // smart_contracts/meta-merkles/contract.algo.ts:454
    // schema += ','
    dig 1
    pushbytes ","
    concat
    bury 2

addType_after_if_else@58:
    // smart_contracts/meta-merkles/contract.algo.ts:398
    // for (let i: uint64 = 0; i < schemaList.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b addType_while_top@2

addType_after_if_else@6:
    // smart_contracts/meta-merkles/contract.algo.ts:403
    // case SchemaPartUint16:
    dig 6
    pushbytes 0x0b
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:403-405
    // case SchemaPartUint16:
    //   schema += SchemaPartUint16String
    //   break
    bz addType_after_if_else@9
    // smart_contracts/meta-merkles/contract.algo.ts:404
    // schema += SchemaPartUint16String
    dig 1
    pushbytes "uint16"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:405
    // break
    b addType_block@55

addType_after_if_else@9:
    // smart_contracts/meta-merkles/contract.algo.ts:406
    // case SchemaPartUint32:
    dig 6
    pushbytes 0x0c
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:406-408
    // case SchemaPartUint32:
    //   schema += SchemaPartUint32String
    //   break
    bz addType_after_if_else@12
    // smart_contracts/meta-merkles/contract.algo.ts:407
    // schema += SchemaPartUint32String
    dig 1
    pushbytes "uint32"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:408
    // break
    b addType_block@55

addType_after_if_else@12:
    // smart_contracts/meta-merkles/contract.algo.ts:409
    // case SchemaPartUint64:
    dig 6
    pushbytes 0x0d
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:409-411
    // case SchemaPartUint64:
    //   schema += SchemaPartUint64String
    //   break
    bz addType_after_if_else@15
    // smart_contracts/meta-merkles/contract.algo.ts:410
    // schema += SchemaPartUint64String
    dig 1
    pushbytes "uint64"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:411
    // break
    b addType_block@55

addType_after_if_else@15:
    // smart_contracts/meta-merkles/contract.algo.ts:412
    // case SchemaPartUint128:
    dig 6
    pushbytes 0x0e
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:412-414
    // case SchemaPartUint128:
    //   schema += SchemaPartUint128String
    //   break
    bz addType_after_if_else@18
    // smart_contracts/meta-merkles/contract.algo.ts:413
    // schema += SchemaPartUint128String
    dig 1
    pushbytes "uint128"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:414
    // break
    b addType_block@55

addType_after_if_else@18:
    // smart_contracts/meta-merkles/contract.algo.ts:415
    // case SchemaPartUint256:
    dig 6
    pushbytes 0x0f
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:415-417
    // case SchemaPartUint256:
    //   schema += SchemaPartUint256String
    //   break
    bz addType_after_if_else@21
    // smart_contracts/meta-merkles/contract.algo.ts:416
    // schema += SchemaPartUint256String
    dig 1
    pushbytes "uint256"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:417
    // break
    b addType_block@55

addType_after_if_else@21:
    // smart_contracts/meta-merkles/contract.algo.ts:418
    // case SchemaPartUint512:
    dig 6
    pushbytes 0x10
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:418-420
    // case SchemaPartUint512:
    //   schema += SchemaPartUint512String
    //   break
    bz addType_after_if_else@24
    // smart_contracts/meta-merkles/contract.algo.ts:419
    // schema += SchemaPartUint512String
    dig 1
    pushbytes "uint512"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:420
    // break
    b addType_block@55

addType_after_if_else@24:
    // smart_contracts/meta-merkles/contract.algo.ts:421
    // case SchemaPartBytes4:
    dig 6
    pushbytes 0x14
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:421-423
    // case SchemaPartBytes4:
    //   schema += SchemaPartBytes4String
    //   break
    bz addType_after_if_else@27
    // smart_contracts/meta-merkles/contract.algo.ts:422
    // schema += SchemaPartBytes4String
    dig 1
    pushbytes "bytes4"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:423
    // break
    b addType_block@55

addType_after_if_else@27:
    // smart_contracts/meta-merkles/contract.algo.ts:424
    // case SchemaPartBytes8:
    dig 6
    pushbytes 0x15
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:424-426
    // case SchemaPartBytes8:
    //   schema += SchemaPartBytes8String
    //   break
    bz addType_after_if_else@30
    // smart_contracts/meta-merkles/contract.algo.ts:425
    // schema += SchemaPartBytes8String
    dig 1
    pushbytes "bytes8"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:426
    // break
    b addType_block@55

addType_after_if_else@30:
    // smart_contracts/meta-merkles/contract.algo.ts:427
    // case SchemaPartBytes16:
    dig 6
    pushbytes 0x16
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:427-429
    // case SchemaPartBytes16:
    //   schema += SchemaPartBytes16String
    //   break
    bz addType_after_if_else@33
    // smart_contracts/meta-merkles/contract.algo.ts:428
    // schema += SchemaPartBytes16String
    dig 1
    pushbytes "bytes16"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:429
    // break
    b addType_block@55

addType_after_if_else@33:
    // smart_contracts/meta-merkles/contract.algo.ts:430
    // case SchemaPartBytes32:
    dig 6
    pushbytes 0x17
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:430-432
    // case SchemaPartBytes32:
    //   schema += SchemaPartBytes32String
    //   break
    bz addType_after_if_else@36
    // smart_contracts/meta-merkles/contract.algo.ts:431
    // schema += SchemaPartBytes32String
    dig 1
    pushbytes "bytes32"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:432
    // break
    b addType_block@55

addType_after_if_else@36:
    // smart_contracts/meta-merkles/contract.algo.ts:433
    // case SchemaPartBytes64:
    dig 6
    pushbytes 0x18
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:433-435
    // case SchemaPartBytes64:
    //   schema += SchemaPartBytes64String
    //   break
    bz addType_after_if_else@39
    // smart_contracts/meta-merkles/contract.algo.ts:434
    // schema += SchemaPartBytes64String
    dig 1
    pushbytes "bytes64"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:435
    // break
    b addType_block@55

addType_after_if_else@39:
    // smart_contracts/meta-merkles/contract.algo.ts:436
    // case SchemaPartBytes128:
    dig 6
    pushbytes 0x19
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:436-438
    // case SchemaPartBytes128:
    //   schema += SchemaPartBytes128String
    //   break
    bz addType_after_if_else@42
    // smart_contracts/meta-merkles/contract.algo.ts:437
    // schema += SchemaPartBytes128String
    dig 1
    pushbytes "bytes128"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:438
    // break
    b addType_block@55

addType_after_if_else@42:
    // smart_contracts/meta-merkles/contract.algo.ts:439
    // case SchemaPartBytes256:
    dig 6
    pushbytes 0x1a
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:439-441
    // case SchemaPartBytes256:
    //   schema += SchemaPartBytes256String
    //   break
    bz addType_after_if_else@45
    // smart_contracts/meta-merkles/contract.algo.ts:440
    // schema += SchemaPartBytes256String
    dig 1
    pushbytes "bytes256"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:441
    // break
    b addType_block@55

addType_after_if_else@45:
    // smart_contracts/meta-merkles/contract.algo.ts:442
    // case SchemaPartBytes512:
    dig 6
    pushbytes 0x1b
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:442-444
    // case SchemaPartBytes512:
    //   schema += SchemaPartBytes512String
    //   break
    bz addType_after_if_else@48
    // smart_contracts/meta-merkles/contract.algo.ts:443
    // schema += SchemaPartBytes512String
    dig 1
    pushbytes "bytes512"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:444
    // break
    b addType_block@55

addType_after_if_else@48:
    // smart_contracts/meta-merkles/contract.algo.ts:445
    // case SchemaPartString:
    dig 6
    pushbytes 0x1e
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:445-447
    // case SchemaPartString:
    //   schema += SchemaPartStringString
    //   break
    bz addType_after_if_else@51
    // smart_contracts/meta-merkles/contract.algo.ts:446
    // schema += SchemaPartStringString
    dig 1
    pushbytes "string"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:447
    // break
    b addType_block@55

addType_after_if_else@51:
    // smart_contracts/meta-merkles/contract.algo.ts:448
    // case SchemaPartAddress:
    dig 6
    pushbytes 0x28
    ==
    // smart_contracts/meta-merkles/contract.algo.ts:448-450
    // case SchemaPartAddress:
    //   schema += SchemaPartAddressString
    //   break
    bz addType_block@55
    // smart_contracts/meta-merkles/contract.algo.ts:449
    // schema += SchemaPartAddressString
    dig 1
    pushbytes "address"
    concat
    bury 2
    // smart_contracts/meta-merkles/contract.algo.ts:450
    // break
    b addType_block@55

addType_after_while@59:
    // smart_contracts/meta-merkles/contract.algo.ts:124
    // const id = this.typesID.value
    intc_0 // 0
    // smart_contracts/meta-merkles/contract.algo.ts:95
    // typesID = GlobalState<uint64>({ key: MetaMerklesGlobalStateKeyTypesID })
    bytec 6 // "types_id"
    // smart_contracts/meta-merkles/contract.algo.ts:124
    // const id = this.typesID.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/meta-merkles/contract.algo.ts:125
    // this.typesID.value += 1
    dup
    intc_1 // 1
    +
    // smart_contracts/meta-merkles/contract.algo.ts:95
    // typesID = GlobalState<uint64>({ key: MetaMerklesGlobalStateKeyTypesID })
    bytec 6 // "types_id"
    // smart_contracts/meta-merkles/contract.algo.ts:125
    // this.typesID.value += 1
    swap
    app_global_put
    // smart_contracts/meta-merkles/contract.algo.ts:460-463
    // this.types(id).value = {
    //   description: description,
    //   schema,
    // }
    dig 2
    dup
    len
    itob
    extract 6 2
    swap
    concat
    dup
    len
    pushint 4 // 4
    +
    dig 5
    itob
    extract 6 2
    dig 9
    concat
    swap
    itob
    extract 6 2
    pushbytes 0x0004
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:460
    // this.types(id).value = {
    swap
    itob
    // smart_contracts/meta-merkles/contract.algo.ts:100
    // types = BoxMap<uint64, TypesValue>({ keyPrefix: MetaMerklesBoxPrefixTypes })
    pushbytes "t"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:460-463
    // this.types(id).value = {
    //   description: description,
    //   schema,
    // }
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/meta-merkles/contract.algo.ts:392
    // addType(payment: gtxn.PaymentTxn, description: string, schemaList: SchemaList): void {
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts[routing]() -> void:
rootCosts:
    // smart_contracts/meta-merkles/contract.algo.ts:468
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    callsub smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.dataCosts[routing]() -> void:
dataCosts:
    // smart_contracts/meta-merkles/contract.algo.ts:474
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    // smart_contracts/meta-merkles/contract.algo.ts:476
    // const costs = this.mbr('', '', name.native, key.native, value.native)
    uncover 2
    extract 2 0
    uncover 2
    extract 2 0
    uncover 2
    extract 2 0
    bytec_0 // ""
    dup
    cover 4
    cover 4
    callsub mbr
    // smart_contracts/meta-merkles/contract.algo.ts:477
    // return costs.data
    extract 16 8
    // smart_contracts/meta-merkles/contract.algo.ts:474
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.mbr(typeDescription: bytes, schema: bytes, rootName: bytes, dataKey: bytes, dataValue: bytes) -> bytes:
mbr:
    // smart_contracts/meta-merkles/contract.algo.ts:109-115
    // private mbr(
    //   typeDescription: string,
    //   schema: string,
    //   rootName: string,
    //   dataKey: string,
    //   dataValue: string
    // ): MetaMerklesMBRData {
    proto 5 1
    // smart_contracts/meta-merkles/contract.algo.ts:117
    // types: MinTypesMBR + (BoxCostPerByte * Bytes(typeDescription).length + Bytes(schema).length),
    frame_dig -5
    len
    intc 4 // 400
    *
    frame_dig -4
    len
    +
    pushint 9300 // 9300
    +
    // smart_contracts/meta-merkles/contract.algo.ts:118
    // roots: MinRootsMBR + (BoxCostPerByte * Bytes(rootName).length),
    frame_dig -3
    len
    intc 4 // 400
    dig 1
    *
    pushint 30100 // 30100
    +
    // smart_contracts/meta-merkles/contract.algo.ts:119
    // data: MinDataMBR + (BoxCostPerByte * (Bytes(rootName).length + Bytes(dataKey).length + Bytes(dataValue).length)),
    frame_dig -2
    len
    uncover 2
    +
    frame_dig -1
    len
    +
    intc 4 // 400
    *
    pushint 12500 // 12500
    +
    // smart_contracts/meta-merkles/contract.algo.ts:116-120
    // return {
    //   types: MinTypesMBR + (BoxCostPerByte * Bytes(typeDescription).length + Bytes(schema).length),
    //   roots: MinRootsMBR + (BoxCostPerByte * Bytes(rootName).length),
    //   data: MinDataMBR + (BoxCostPerByte * (Bytes(rootName).length + Bytes(dataKey).length + Bytes(dataValue).length)),
    // }
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    retsub


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify(address: bytes, name: bytes, leaf: bytes, proof: bytes, type: uint64) -> uint64, bytes:
smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify:
    // smart_contracts/meta-merkles/contract.algo.ts:295
    // verify(address: Account, name: string, leaf: Leaf, proof: Proof, type: uint64): boolean {
    proto 5 2
    intc_0 // 0
    dup
    bytec_0 // ""
    dupn 3
    // smart_contracts/meta-merkles/contract.algo.ts:296
    // const truncatedAddress = bytes16(address.bytes)
    frame_dig -5
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:298
    // const rootKey: RootKey = { address, name }
    frame_dig -4
    len
    itob
    extract 6 2
    frame_dig -4
    concat
    frame_dig -5
    bytec 4 // 0x0022
    concat
    dig 1
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:299
    // const typeKey: DataKey = { address: truncatedAddress, name, key: treeTypeKey }
    dig 2
    len
    pushint 16 // 16
    ==
    assert // invalid size
    uncover 2
    bytec_1 // 0x0014
    concat
    dig 2
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    concat
    bytec 7 // 0x00066c2e74797065
    concat
    swap
    // smart_contracts/meta-merkles/contract.algo.ts:102
    // roots = BoxMap<RootKey, bytes<32>>({ keyPrefix: MetaMerklesBoxPrefixRoots })
    bytec 5 // "r"
    swap
    concat
    dup
    // smart_contracts/meta-merkles/contract.algo.ts:301
    // if (!this.roots(rootKey).exists || !this.data(typeKey).exists) {
    box_len
    bury 1
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_if_body@2
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    frame_dig 6
    concat
    dup
    frame_bury 0
    // smart_contracts/meta-merkles/contract.algo.ts:301
    // if (!this.roots(rootKey).exists || !this.data(typeKey).exists) {
    box_len
    bury 1
    bnz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@3

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_if_body@2:
    // smart_contracts/meta-merkles/contract.algo.ts:302
    // return false
    intc_0 // 0
    frame_dig -2
    frame_bury 1
    frame_bury 0
    retsub

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@3:
    // smart_contracts/meta-merkles/contract.algo.ts:305
    // const treeType = btoi(Bytes(this.data(typeKey).value))
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    frame_bury 5
    // smart_contracts/meta-merkles/contract.algo.ts:306
    // if (type !== MerkleTreeTypeUnspecified && treeType !== type) {
    frame_dig -1
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@6
    frame_dig 5
    frame_dig -1
    !=
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@6
    // smart_contracts/meta-merkles/contract.algo.ts:307
    // return false
    intc_0 // 0
    frame_dig -2
    frame_bury 1
    frame_bury 0
    retsub

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@6:
    // smart_contracts/meta-merkles/contract.algo.ts:310
    // ensureBudget(proof.length * 50)
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    pushint 50 // 50
    *
    pushint 10 // 10
    +
    frame_bury 4

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_while_top@15:
    frame_dig 4
    global OpcodeBudget
    >
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_while@20
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 8 // 0x068101
    itxn_field ApprovalProgram
    bytec 8 // 0x068101
    itxn_field ClearStateProgram
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_while_top@15

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_while@20:
    // smart_contracts/meta-merkles/contract.algo.ts:313
    // for (let i: uint64 = 0; i < proof.length; i += 1) {
    intc_0 // 0
    frame_bury 3
    frame_dig -3
    frame_bury 1

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_while_top@7:
    // smart_contracts/meta-merkles/contract.algo.ts:313
    // for (let i: uint64 = 0; i < proof.length; i += 1) {
    frame_dig 3
    frame_dig 2
    <
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_while@9
    // smart_contracts/meta-merkles/contract.algo.ts:314
    // hash = this.hash(proof[i], hash)
    frame_dig -2
    extract 2 0
    frame_dig 3
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    dup
    // smart_contracts/meta-merkles/contract.algo.ts:130
    // if (BigUint(a) > BigUint(b)) {
    frame_dig 1
    b>
    bz smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@12
    // smart_contracts/meta-merkles/contract.algo.ts:131
    // return sha256(b.concat(a))
    frame_dig 1
    swap
    concat
    sha256
    frame_bury 1

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_inlined_smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.hash@13:
    // smart_contracts/meta-merkles/contract.algo.ts:313
    // for (let i: uint64 = 0; i < proof.length; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_while_top@7

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_if_else@12:
    // smart_contracts/meta-merkles/contract.algo.ts:133
    // return sha256(a.concat(b))
    frame_dig 1
    concat
    sha256
    frame_bury 1
    // smart_contracts/meta-merkles/contract.algo.ts:314
    // hash = this.hash(proof[i], hash)
    b smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_inlined_smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.hash@13

smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.verify_after_while@9:
    // smart_contracts/meta-merkles/contract.algo.ts:317
    // return hash === this.roots(rootKey).value
    frame_dig 7
    box_get
    assert // Box must have value
    frame_dig 1
    ==
    frame_dig -2
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read(address: bytes, name: bytes, key: bytes) -> bytes:
smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.read:
    // smart_contracts/meta-merkles/contract.algo.ts:328-329
    // @abimethod({ readonly: true })
    // read(address: Account, name: string, key: string): string {
    proto 3 1
    // smart_contracts/meta-merkles/contract.algo.ts:330
    // const truncatedAddress = bytes16(address.bytes)
    frame_dig -3
    callsub bytes16
    // smart_contracts/meta-merkles/contract.algo.ts:331
    // return this.data({ address: truncatedAddress, name, key }).value
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid size
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    swap
    bytec_1 // 0x0014
    concat
    dig 1
    len
    pushint 20 // 20
    +
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    swap
    itob
    extract 6 2
    uncover 2
    swap
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:104
    // data = BoxMap<DataKey, string>({ keyPrefix: MetaMerklesBoxPrefixData })
    bytec_2 // "d"
    swap
    concat
    // smart_contracts/meta-merkles/contract.algo.ts:331
    // return this.data({ address: truncatedAddress, name, key }).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts(name: bytes) -> uint64:
smart_contracts/meta-merkles/contract.algo.ts::MetaMerkles.rootCosts:
    // smart_contracts/meta-merkles/contract.algo.ts:468-469
    // @abimethod({ readonly: true })
    // rootCosts(name: string): uint64 {
    proto 1 1
    // smart_contracts/meta-merkles/contract.algo.ts:470
    // const costs = this.mbr('', '', name, treeTypeKey, String(itob(0)))
    intc_0 // 0
    itob
    bytec_0 // ""
    dup
    frame_dig -1
    pushbytes "l.type"
    uncover 4
    callsub mbr
    // smart_contracts/meta-merkles/contract.algo.ts:471
    // return costs.roots + costs.data
    dup
    pushint 8 // 8
    extract_uint64
    swap
    pushint 16 // 16
    extract_uint64
    +
    retsub
