#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 4
    bytecblock "akita_dao" "child_contract_version"
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txn NumAppArgs
    bz main_after_if_else@12
    pushbytess 0x20df3a54 0xa0e81872 0x3decb140 0xc385cfae 0x33e92c94 0x1ead20a9 // method "create(string)void", method "update()void", method "mint(pay,address)uint64", method "updateApplication(string,string)void", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match main_create_route@3 main_update_route@4 main_mint_route@5 main_updateApplication_route@6 main_updateAkitaDAO_route@7 main_updateAkitaDAOEscrow_route@8

main_after_if_else@12:
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    intc_1 // 0
    return

main_updateAkitaDAOEscrow_route@8:
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    callsub updateAkitaDAOEscrow
    intc_0 // 1
    return

main_updateAkitaDAO_route@7:
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_0 // 1
    return

main_updateApplication_route@6:
    // smart_contracts/utils/base-contracts/factory.ts:79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_2 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:79
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_0 // 1
    return

main_mint_route@5:
    // smart_contracts/prize-box/factory.algo.ts:34
    // mint(payment: gtxn.PaymentTxn, owner: Address): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/prize-box/factory.algo.ts:34
    // mint(payment: gtxn.PaymentTxn, owner: Address): uint64 {
    callsub mint
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_route@4:
    // smart_contracts/prize-box/factory.algo.ts:27
    // @abimethod({ allowActions: 'UpdateApplication' })
    txn OnCompletion
    intc_2 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main_create_route@3:
    // smart_contracts/prize-box/factory.algo.ts:22
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/prize-box/factory.algo.ts:18
    // export class PrizeBoxFactory extends FactoryContract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/prize-box/factory.algo.ts:22
    // @abimethod({ onCreate: 'require' })
    callsub create
    intc_0 // 1
    return


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.create(version: bytes) -> void:
create:
    // smart_contracts/prize-box/factory.algo.ts:22-23
    // @abimethod({ onCreate: 'require' })
    // create(version: string): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:19
    // export const BaseFactoryGlobalStateKeyChildContractVersion = 'child_contract_version'
    bytec_1 // "child_contract_version"
    // smart_contracts/prize-box/factory.algo.ts:24
    // this.childContractVersion.value = version
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.update() -> void:
update:
    // smart_contracts/prize-box/factory.algo.ts:29
    // assert(Txn.sender === Global.creatorAddress, 'Only the creator can update the application')
    txn Sender
    global CreatorAddress
    ==
    assert // Only the creator can update the application
    retsub


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.mint(payment: uint64, owner: bytes) -> uint64:
mint:
    // smart_contracts/prize-box/factory.algo.ts:34
    // mint(payment: gtxn.PaymentTxn, owner: Address): uint64 {
    proto 2 1
    // smart_contracts/prize-box/factory.algo.ts:38-50
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       AccountMinimumBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    frame_dig -2
    gtxns Receiver
    // smart_contracts/prize-box/factory.algo.ts:41
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/prize-box/factory.algo.ts:38-50
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       AccountMinimumBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz mint_bool_false@3
    frame_dig -2
    gtxns Amount
    // smart_contracts/prize-box/factory.algo.ts:43-46
    // MIN_PROGRAM_PAGES +
    // (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    // (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    // AccountMinimumBalance
    pushint 278500 // 278500
    // smart_contracts/prize-box/factory.algo.ts:38-50
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       AccountMinimumBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    bz mint_bool_false@3
    intc_0 // 1

mint_bool_merge@4:
    // smart_contracts/prize-box/factory.algo.ts:38-50
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       AccountMinimumBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    assert // Invalid payment
    // smart_contracts/prize-box/factory.algo.ts:52-56
    // const prizeBoxApp = prizeBox.call
    //   .create({
    //     args: [owner],
    //     fee,
    //   })
    itxn_begin
    pushbytes 0xcc694eaa // method "create(address)void"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    // smart_contracts/prize-box/factory.algo.ts:36
    // const prizeBox = compileArc4(PrizeBox)
    intc_0 // 1
    itxn_field GlobalNumByteSlice
    intc_0 // 1
    itxn_field GlobalNumUint
    pushbytes base64(CoEBQw==)
    itxn_field ClearStateProgramPages
    pushbytes base64(CiAEAAEEECYCBW93bmVyC29wdGluX2NvdW50MRtBACqCBQTMaU6qBCSHwywEPqEYMgSt+SrkBEQgD702GgCOBQBIADoAIAARAAIiQzEZFEQxGEQ2GgGIAMIjQzEZFEQxGEQ2GgGIAKMjQzEZFEQxGEQxFiMJSTgQIxJENhoBF4gARyNDMRmBBRJEMRhEiAAdI0MxGRREMRgURDYaAYgAAiNDigEAKIv/ZykiZ4kxACIoZURMSwESRCIpZUQURLGyCSOyECKyAbOJigIAMQAiKGVEEkSL/jgHMgoSQQApi/44CDIQEkEAHyNEsTIKi/+yESKyErIUJLIQIrIBsyIpZUQjCClMZ4kiQv/eigEAMQAiKGVEEkQoi/9niYoBAIAAMQAiKGVEEkQii/8iWYsBDUEAfIv/VwIAiwElCyVYSSJbSYwAQQBSMgqLAHAAREyBCFtJTgISQQApIillRCMJKUxnsSIoZURJshWyFLISiwCyESSyECKyAbOLASMIjAFC/6exIihlRLIUshKLALIRJLIQIrIBs0L/4LGBCFsiKGVEsgeyCCOyECKyAbNC/8qJ)
    itxn_field ApprovalProgramPages
    // smart_contracts/prize-box/factory.algo.ts:52-56
    // const prizeBoxApp = prizeBox.call
    //   .create({
    //     args: [owner],
    //     fee,
    //   })
    intc_1 // 0
    itxn_field OnCompletion
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/prize-box/factory.algo.ts:52-56
    // const prizeBoxApp = prizeBox.call
    //   .create({
    //     args: [owner],
    //     fee,
    //   })
    itxn_submit
    // smart_contracts/prize-box/factory.algo.ts:58
    // .createdApp
    gitxn 0 CreatedApplicationID
    // smart_contracts/prize-box/factory.algo.ts:60-66
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: AccountMinimumBalance,
    //     fee,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/prize-box/factory.algo.ts:62
    // receiver: prizeBoxApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/utils/constants.ts:11
    // export const AccountMinimumBalance: uint64 = 100_000
    pushint 100000 // 100000
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/prize-box/factory.algo.ts:60-65
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: AccountMinimumBalance,
    //     fee,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/utils/constants.ts:4
    // export const fee: uint64 = 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/prize-box/factory.algo.ts:60-66
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: AccountMinimumBalance,
    //     fee,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/prize-box/factory.algo.ts:68
    // return prizeBoxApp.id
    retsub

mint_bool_false@3:
    intc_1 // 0
    b mint_bool_merge@4


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateApplication(newVersion: bytes, newChildVersion: bytes) -> void:
updateApplication:
    // smart_contracts/utils/base-contracts/factory.ts:79-80
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(newVersion: string, newChildVersion: string): void {
    proto 2 0
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_1 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:3
    // export const GlobalStateKeyVersion = 'version'
    pushbytes "version"
    // smart_contracts/utils/base-contracts/factory.ts:82
    // this.version.value = newVersion
    frame_dig -2
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:19
    // export const BaseFactoryGlobalStateKeyChildContractVersion = 'child_contract_version'
    bytec_1 // "child_contract_version"
    // smart_contracts/utils/base-contracts/factory.ts:83
    // this.childContractVersion.value = newChildVersion
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:88
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:89
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_1 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:89
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:90
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAOEscrow(app: uint64) -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/factory.ts:93
    // updateAkitaDAOEscrow(app: uint64): void {
    proto 1 0
    // smart_contracts/utils/base-contracts/factory.ts:94
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // smart_contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_1 // 0
    bytec_0 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/utils/base-contracts/factory.ts:94
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/constants.ts:2
    // export const GlobalStateKeyAkitaEscrow = 'akita_escrow'
    pushbytes "akita_escrow"
    // smart_contracts/utils/base-contracts/factory.ts:95
    // this.akitaDAOEscrow.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
