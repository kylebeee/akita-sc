#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 8
    bytecblock "akita_dao"
    // smart_contracts/prize-box/factory.algo.ts:17
    // export class PrizeBoxFactory extends FactoryContract {
    pushbytes 0xa0e81872 // method "update()void"
    txna ApplicationArgs 0
    match main_update_route@2

main_switch_case_next@3:
    // smart_contracts/prize-box/factory.algo.ts:17
    // export class PrizeBoxFactory extends FactoryContract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@9
    pushbytess 0x3decb140 0x33e92c94 0x1ead20a9 // method "mint(pay,address)uint64", method "updateAkitaDAO(uint64)void", method "updateAkitaDAOEscrow(uint64)void"
    txna ApplicationArgs 0
    match mint updateAkitaDAO updateAkitaDAOEscrow
    err

main_create_NoOp@9:
    // smart_contracts/prize-box/factory.algo.ts:17
    // export class PrizeBoxFactory extends FactoryContract {
    pushbytes 0x20df3a54 // method "create(string)void"
    txna ApplicationArgs 0
    match create
    err

main_update_route@2:
    // smart_contracts/prize-box/factory.algo.ts:26
    // @abimethod({ allowActions: 'UpdateApplication' })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be UpdateApplication && can only call when not creating
    b update


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.create[routing]() -> void:
create:
    // smart_contracts/prize-box/factory.algo.ts:21
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    // smart_contracts/utils/base-contracts/factory.ts:38
    // childContractVersion = GlobalState<string>({ key: BaseFactoryGlobalStateKeyChildContractVersion })
    pushbytes "child_contract_version"
    // smart_contracts/prize-box/factory.algo.ts:23
    // this.childContractVersion.value = version
    swap
    app_global_put
    // smart_contracts/prize-box/factory.algo.ts:21
    // @abimethod({ onCreate: 'require' })
    intc_0 // 1
    return


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.update[routing]() -> void:
update:
    // smart_contracts/prize-box/factory.algo.ts:28
    // assert(Txn.sender === Global.creatorAddress, 'Only the creator can update the application')
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/prize-box/factory.algo.ts:26
    // @abimethod({ allowActions: 'UpdateApplication' })
    return // on error: Only the creator can update the application


// smart_contracts/prize-box/factory.algo.ts::PrizeBoxFactory.mint[routing]() -> void:
mint:
    // smart_contracts/prize-box/factory.algo.ts:33
    // mint(payment: gtxn.PaymentTxn, owner: Address): uint64 {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/prize-box/factory.algo.ts:37-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       Global.minBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    dig 1
    gtxns Receiver
    // smart_contracts/prize-box/factory.algo.ts:40
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/prize-box/factory.algo.ts:37-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       Global.minBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    uncover 2
    gtxns Amount
    // smart_contracts/prize-box/factory.algo.ts:42-44
    // MIN_PROGRAM_PAGES +
    // (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    // (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    pushint 178500 // 178500
    // smart_contracts/prize-box/factory.algo.ts:45
    // Global.minBalance
    global MinBalance
    // smart_contracts/prize-box/factory.algo.ts:42-45
    // MIN_PROGRAM_PAGES +
    // (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    // (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    // Global.minBalance
    +
    // smart_contracts/prize-box/factory.algo.ts:37-49
    // assertMatch(
    //   payment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: (
    //       MIN_PROGRAM_PAGES +
    //       (GLOBAL_STATE_KEY_UINT_COST * prizeBox.globalUints) +
    //       (GLOBAL_STATE_KEY_BYTES_COST * prizeBox.globalBytes) +
    //       Global.minBalance
    //     ),
    //   },
    //   ERR_INVALID_PAYMENT
    // )
    ==
    &&
    assert // Invalid payment
    // smart_contracts/prize-box/factory.algo.ts:51-54
    // const prizeBoxApp = prizeBox.call
    //   .create({
    //     args: [owner],
    //   })
    itxn_begin
    pushbytes 0xcc694eaa // method "create(address)void"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    // smart_contracts/prize-box/factory.algo.ts:35
    // const prizeBox = compileArc4(PrizeBox)
    intc_0 // 1
    itxn_field GlobalNumByteSlice
    intc_0 // 1
    itxn_field GlobalNumUint
    pushbytes base64(CoEBQw==)
    itxn_field ClearStateProgramPages
    pushbytes base64(CiAEAAEIBCYCBW93bmVyC29wdGluX2NvdW50gAQkh8MsNhoAjgEANDEZFEQxGEEAHYIDBD6hGDIErfkq5AREIA+9NhoAjgMASQCRAKcAgATMaU6qNhoAjgEADQAxGYEFEjEYEERCABE2GgFJFYEgEkQoTGcpImcjQzEAIihlRExLARJEIillRBREsbIJI7IQIrIBsyNDMRYjCUk4ECMSRDYaAUkVJBJEFzEAIihlRBJESwE4BzIKEk8COAgyEBIQRLEyCkyyESKyErIUJbIQIrIBsyIpZUQjCClMZyNDNhoBSRWBIBJEMQAiKGVEEkQoTGcjQ4AANhoBRwIiWUlOAoEQC4ECCEwVEkQxACIoZUQSRCJJSwIMQQB7SwJXAgBLAYEQC4EQWEkiW0lFBkEAUDIKSwVwAERMJFtJTgISQQAoIillRCMJKUxnsSIoZURJshWyFLISSwOyESWyECKyAbNJIwhFAUL/qrEiKGVEshSyEksDshElshAisgGzQv/hsSRbIihlRLIHsggjshAisgGzQv/MI0M=)
    itxn_field ApprovalProgramPages
    // smart_contracts/prize-box/factory.algo.ts:51-54
    // const prizeBoxApp = prizeBox.call
    //   .create({
    //     args: [owner],
    //   })
    intc_1 // 0
    itxn_field OnCompletion
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/prize-box/factory.algo.ts:56
    // .createdApp
    gitxn 0 CreatedApplicationID
    // smart_contracts/prize-box/factory.algo.ts:58-63
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: Global.minBalance,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/prize-box/factory.algo.ts:60
    // receiver: prizeBoxApp.address,
    dup
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/prize-box/factory.algo.ts:61
    // amount: Global.minBalance,
    global MinBalance
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/prize-box/factory.algo.ts:58-62
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: Global.minBalance,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/prize-box/factory.algo.ts:58-63
    // itxn
    //   .payment({
    //     receiver: prizeBoxApp.address,
    //     amount: Global.minBalance,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/prize-box/factory.algo.ts:33
    // mint(payment: gtxn.PaymentTxn, owner: Address): uint64 {
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAO[routing]() -> void:
updateAkitaDAO:
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_1 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:81
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:82
    // this.akitaDAO.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:80
    // updateAkitaDAO(app: uint64): void {
    intc_0 // 1
    return


// smart_contracts/utils/base-contracts/factory.ts::FactoryContract.updateAkitaDAOEscrow[routing]() -> void:
updateAkitaDAOEscrow:
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    intc_1 // 0
    // smart_contracts/utils/base-contracts/factory.ts:34
    // akitaDAO = GlobalState<Application>({ key: GlobalStateKeyAkitaDAO })
    bytec_0 // "akita_dao"
    // smart_contracts/utils/base-contracts/factory.ts:86
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // smart_contracts/utils/base-contracts/factory.ts:36
    // akitaDAOEscrow = GlobalState<Application>({ key: GlobalStateKeyAkitaEscrow })
    pushbytes "akita_escrow"
    // smart_contracts/utils/base-contracts/factory.ts:87
    // this.akitaDAOEscrow.value = Application(app)
    swap
    app_global_put
    // smart_contracts/utils/base-contracts/factory.ts:85
    // updateAkitaDAOEscrow(app: uint64): void {
    intc_0 // 1
    return
