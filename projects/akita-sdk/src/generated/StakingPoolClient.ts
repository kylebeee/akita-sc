/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"StakingPool","structs":{"ObjectC3416591":[{"name":"valid","type":"bool"},{"name":"balance","type":"uint64"}],"RootKey":[{"name":"address","type":"address"},{"name":"name","type":"string"}],"EntryData":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"},{"name":"quantity","type":"uint64"},{"name":"gateArgs","type":"byte[][]"},{"name":"disqualified","type":"bool"}],"EntryKey":[{"name":"address","type":"address"},{"name":"asset","type":"uint64"}],"RaffleCursor":[{"name":"ticket","type":"uint64"},{"name":"stake","type":"uint64"},{"name":"disbursed","type":"uint64"}],"Reward":[{"name":"asset","type":"uint64"},{"name":"distribution","type":"uint8"},{"name":"rate","type":"uint64"},{"name":"expiration","type":"uint64"},{"name":"interval","type":"uint64"},{"name":"qualifiedStakers","type":"uint64"},{"name":"qualifiedStake","type":"uint64"},{"name":"winnerCount","type":"uint64"},{"name":"winningTickets","type":"uint64[]"},{"name":"raffleCursor","type":"RaffleCursor"},{"name":"vrfFailureCount","type":"uint64"},{"name":"phase","type":"uint8"},{"name":"disbursementCursor","type":"uint64"},{"name":"activeDisbursementId","type":"uint64"},{"name":"activeDisbursementRoundStart","type":"uint64"},{"name":"lastDisbursementTimestamp","type":"uint64"}],"StakingPoolMBRData":[{"name":"entries","type":"uint64"},{"name":"uniques","type":"uint64"},{"name":"entriesByAddress","type":"uint64"},{"name":"rewards","type":"uint64"},{"name":"disbursements","type":"uint64"}],"StakingPoolState":[{"name":"status","type":"uint8"},{"name":"title","type":"string"},{"name":"type","type":"uint8"},{"name":"signupTimestamp","type":"uint64"},{"name":"startTimestamp","type":"uint64"},{"name":"allowLateSignups","type":"bool"},{"name":"endTimestamp","type":"uint64"},{"name":"maxEntries","type":"uint64"},{"name":"entryCount","type":"uint64"},{"name":"rewardCount","type":"uint64"},{"name":"totalStaked","type":"uint64"},{"name":"stakeKey","type":"RootKey"},{"name":"minimumStakeAmount","type":"uint64"},{"name":"gateId","type":"uint64"},{"name":"creator","type":"address"}],"FunderInfo":[{"name":"account","type":"address"},{"name":"amount","type":"uint64"}]},"methods":[{"name":"create","args":[{"type":"string","name":"title"},{"type":"uint8","name":"type"},{"type":"address","name":"creator"},{"type":"(address,uint64)","struct":"FunderInfo","name":"funder"},{"type":"address","name":"marketplace"},{"type":"(address,string)","struct":"RootKey","name":"stakeKey"},{"type":"uint64","name":"minimumStakeAmount"},{"type":"uint64","name":"gateID"},{"type":"uint64","name":"maxEntries"},{"type":"uint64","name":"akitaDAO"},{"type":"uint64","name":"akitaDAOEscrow"}],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"init","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"delete","args":[{"type":"address","name":"caller"}],"returns":{"type":"void"},"actions":{"create":[],"call":["DeleteApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"optIn","args":[{"type":"pay","name":"payment","desc":"The payment transaction"},{"type":"uint64","name":"asset","desc":"The asset to be opted into"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in","events":[],"recommendations":{}},{"name":"addReward","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"addRewardAsa","args":[{"type":"pay","name":"payment"},{"type":"axfer","name":"assetXfer"},{"type":"(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)","struct":"Reward","name":"reward"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalize","args":[{"type":"uint64","name":"signupTimestamp"},{"type":"uint64","name":"startTimestamp"},{"type":"uint64","name":"endTimestamp"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"enter","args":[{"type":"pay","name":"payment"},{"type":"(uint64,uint64,byte[32][])[]","name":"entries"},{"type":"byte[][]","name":"args"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"startDisbursement","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"raffle","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"disburseRewards","args":[{"type":"uint64","name":"rewardID"},{"type":"uint64","name":"iterationAmount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalizeDistribution","args":[{"type":"uint64","name":"rewardID"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"check","args":[{"type":"address","name":"address"},{"type":"uint64","name":"asset"}],"returns":{"type":"(bool,uint64)","struct":"ObjectC3416591"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"signUpsOpen","args":[],"returns":{"type":"bool","desc":"a boolean of whether sign ups are open"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isLive","args":[],"returns":{"type":"bool","desc":"a boolean of whether the pool is live"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"isEntered","args":[{"type":"address","name":"address"}],"returns":{"type":"bool","desc":"a boolean indicating if the address has entered the staking pool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getState","args":[],"returns":{"type":"(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)","struct":"StakingPoolState"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"updateAkitaDAOEscrow","args":[{"type":"uint64","name":"app"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"update","args":[{"type":"string","name":"newVersion"}],"returns":{"type":"void"},"actions":{"create":[],"call":["UpdateApplication"]},"readonly":false,"events":[],"recommendations":{}},{"name":"updateAkitaDAO","args":[{"type":"uint64","name":"akitaDAO"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"opUp","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"mbr","args":[{"type":"uint64","name":"winningTickets"}],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","struct":"StakingPoolMBRData","desc":"the mbr created for each boxmap entry"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":16,"bytes":9},"local":{"ints":0,"bytes":0}},"keys":{"global":{"status":{"keyType":"AVMString","valueType":"uint8","key":"c3RhdHVz","desc":"the status the pool is in"},"title":{"keyType":"AVMString","valueType":"AVMString","key":"dGl0bGU=","desc":"title of the staking pool"},"type":{"keyType":"AVMString","valueType":"uint8","key":"dHlwZQ==","desc":"the method of staking to be used for the pool"},"signupTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c2lnbnVwX3RpbWVzdGFtcA==","desc":"the timestamp when sign ups for the pool are allowed"},"allowLateSignups":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWxsb3dfbGF0ZV9zaWdudXBz","desc":"whether signups are allowed after the staking pool begins"},"startTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"c3RhcnRfdGltZXN0YW1w","desc":"the timestamp when the pool starts"},"endTimestamp":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW5kX3RpbWVzdGFtcA==","desc":"the timestamp when the pool ends"},"maxEntries":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWF4X2VudHJpZXM=","desc":"the maximum entries allowed for the pool"},"entryID":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZW50cnlfY291bnQ=","desc":"the number of entries in a pool"},"rewardID":{"keyType":"AVMString","valueType":"AVMUint64","key":"cmV3YXJkX2NvdW50","desc":"the number of rewards for the pool"},"totalStaked":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxfc3Rha2Vk","desc":"the total amount staked in the pool"},"stakeKey":{"keyType":"AVMString","valueType":"RootKey","key":"c3Rha2Vfa2V5","desc":"the name for the meta merkle asset group to validate staking\nstake key can be empty if distribution !== DistributionTypePercentage"},"minimumStakeAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWluaW11bV9zdGFrZV9hbW91bnQ=","desc":"minimum stake amount"},"gateID":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9pZA==","desc":"the gate id of the pool"},"gateSize":{"keyType":"AVMString","valueType":"AVMUint64","key":"Z2F0ZV9zaXpl","desc":"the size of the gate were using"},"creator":{"keyType":"AVMString","valueType":"address","key":"Y3JlYXRvcg==","desc":"the address of the creator of the staking pool"},"marketplace":{"keyType":"AVMString","valueType":"address","key":"bWFya2V0cGxhY2U=","desc":"marketplace is pool creation side marketplace"},"marketplaceRoyalties":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWFya2V0cGxhY2Vfcm95YWx0aWVz","desc":"the amount the marketplaces will get for the sale"},"akitaRoyalty":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eQ==","desc":"the akita royalty for the pool"},"akitaRoyaltyAmount":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfcm95YWx0eV9hbW91bnQ=","desc":"the amount of royalties that were paid in a disbursement"},"salt":{"keyType":"AVMString","valueType":"AVMBytes","key":"c2FsdA==","desc":"salt for randomness"},"akitaDAOEscrow":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZXNjcm93","desc":"the app ID for the akita DAO escrow to use"},"version":{"keyType":"AVMString","valueType":"AVMString","key":"dmVyc2lvbg==","desc":"the current version of the contract"},"akitaDAO":{"keyType":"AVMString","valueType":"AVMUint64","key":"YWtpdGFfZGFv","desc":"the app ID of the Akita DAO"},"funder":{"keyType":"AVMString","valueType":"FunderInfo","key":"ZnVuZGVy"}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"entries":{"keyType":"uint64","valueType":"EntryData","desc":"indexed entries for efficient iteration","prefix":"ZQ=="},"uniques":{"keyType":"address","valueType":"uint64","desc":"the number of unique asset entries by address","prefix":"dQ=="},"entriesByAddress":{"keyType":"EntryKey","valueType":"uint64","desc":"the entries in the pool","prefix":"YQ=="},"rewards":{"keyType":"uint64","valueType":"Reward","desc":"the rewards for this staking pool","prefix":"cg=="},"disbursements":{"keyType":"uint64","valueType":"AVMBytes","desc":"the disbursements this pool as created & finalized","prefix":"ZA=="}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[2819,4683,6279],"errorMessage":"Box must have value"},{"pc":[703,796,1073,1191,1445,2166,2280,2592,3064,5287,5386,5916],"errorMessage":"Bytes has valid prefix"},{"pc":[3221],"errorMessage":"DAO not opted in to the asset"},{"pc":[4574],"errorMessage":"Disbursement not ready for finalization"},{"pc":[1465],"errorMessage":"Escrow does not exist"},{"pc":[1303,5604],"errorMessage":"Forbidden"},{"pc":[5045],"errorMessage":"Invalid app upgrade"},{"pc":[5836],"errorMessage":"Invalid disbursement phase"},{"pc":[1341,1983,5739],"errorMessage":"Invalid payment"},{"pc":[3175,3254,3440,3614],"errorMessage":"Invalid percentage"},{"pc":[3429],"errorMessage":"Invalid percentage of args"},{"pc":[5172],"errorMessage":"Invalid pool type for check"},{"pc":[1673],"errorMessage":"Invalid transfer"},{"pc":[5711],"errorMessage":"Max entries cannot be greater than rate"},{"pc":[5610],"errorMessage":"Must be an Algo asset"},{"pc":[3635,3867,4115],"errorMessage":"Not enough funds"},{"pc":[2732],"errorMessage":"Not ready to disburse"},{"pc":[609],"errorMessage":"OnCompletion must be DeleteApplication && can only call when not creating"},{"pc":[426],"errorMessage":"OnCompletion must be NoOp"},{"pc":[597],"errorMessage":"OnCompletion must be UpdateApplication && can only call when not creating"},{"pc":[4993,5034,5082],"errorMessage":"Only the Akita DAO can call this function"},{"pc":[5679],"errorMessage":"Rate must be greater than winner count"},{"pc":[5717],"errorMessage":"Rate must be greater than zero"},{"pc":[5637],"errorMessage":"Stake key required"},{"pc":[5846],"errorMessage":"Winning tickets already exist"},{"pc":[1475],"errorMessage":"Wrong escrow for this operation"},{"pc":[1534,2517,4991,5030,5080,5472,5524,5541],"errorMessage":"application exists"},{"pc":[1227],"errorMessage":"call must come from factory"},{"pc":[992,1026,1031,1137,1145,1157,1232,1239,1251,1301,1365,1470,1716,1723,1742,1777,1873,1902,1917,1924,1933,1988,2073,2088,2179,2190,2225,2299,2445,2472,2781,2789,2866,2892,2917,2934,2993,3016,3123,3170,3249,3339,3347,3357,3518,3603,3609,3642,3650,3772,3858,3874,3882,4002,4106,4122,4130,4578,4698,4710,4721,4730,4796,4801,4806,4811,4816,4821,4826,4831,4835,4842,4861,4866,4871,4876,4881,4984,5022,5073,5154,5164,5230,5241,5338,5422,5446,5602,5615,5692,5700,5744,5871,6323,6335,6346,6355],"errorMessage":"check GlobalState exists"},{"pc":[2467],"errorMessage":"distribution window is not open"},{"pc":[2174],"errorMessage":"failed to verify stake requirements"},{"pc":[1782],"errorMessage":"if the starting round is zero, the signup round must be zero and allowLateSignups must be true"},{"pc":[2044],"errorMessage":"index access is out of bounds"},{"pc":[5292],"errorMessage":"invalid number of bytes for (bool1,uint64)"},{"pc":[1458],"errorMessage":"invalid number of bytes for (len+(uint64,bool1)[])"},{"pc":[713,5926],"errorMessage":"invalid number of bytes for (len+uint8[])"},{"pc":[823,5013],"errorMessage":"invalid number of bytes for (len+utf8[])"},{"pc":[2285,5391],"errorMessage":"invalid number of bytes for (uint64,uint64,uint64)"},{"pc":[852],"errorMessage":"invalid number of bytes for (uint8[32],uint64)"},{"pc":[801,2171],"errorMessage":"invalid number of bytes for bool8"},{"pc":[872,881,890,899,908,1078,1196,1293,1687,1697,1707,2387,2597,2659,2680,2690,3069,4544,4673,4977,5066,5095],"errorMessage":"invalid number of bytes for uint64"},{"pc":[834],"errorMessage":"invalid number of bytes for uint8"},{"pc":[843,861,1221,4665,4772],"errorMessage":"invalid number of bytes for uint8[32]"},{"pc":[3458,3716,3951,4281,6220],"errorMessage":"max array length exceeded"},{"pc":[1234],"errorMessage":"only the creator can delete the pool"},{"pc":[1718],"errorMessage":"only the creator can finalize the pool"},{"pc":[1132],"errorMessage":"only the factory can init the pool"},{"pc":[5435],"errorMessage":"overflow"},{"pc":[1938],"errorMessage":"pool has reached maximum entries"},{"pc":[5426],"errorMessage":"pool staking type is not set"},{"pc":[2075],"errorMessage":"quantity is less than minimum stake amount"},{"pc":[2403,2703,4555,5802],"errorMessage":"reward does not exist"},{"pc":[2437],"errorMessage":"reward is already in a disbursement phase"},{"pc":[1803],"errorMessage":"the ending round must be zero or after the starting round + 10"},{"pc":[1868,2392],"errorMessage":"the pool is not live"},{"pc":[1257],"errorMessage":"the pool must be in draft or ended"},{"pc":[1726],"errorMessage":"the pool must be in draft state to finalize"},{"pc":[1747],"errorMessage":"the signup round must be zero and late sign ups allowed or in the future"},{"pc":[1762],"errorMessage":"the starting round must be zero or in the future"},{"pc":[1647],"errorMessage":"transaction type is axfer"},{"pc":[1285,1616,1636,1858],"errorMessage":"transaction type is pay"},{"pc":[4028],"errorMessage":"unknown reward rate type"},{"pc":[2295],"errorMessage":"user does not have enough staked"},{"pc":[2220],"errorMessage":"user does not have min balance"},{"pc":[1913],"errorMessage":"user does not meet gate requirements"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggOTIgMTAwMDAwIDYzNjQxMzYyMjM4NDY3OTMwMDUgNDAwIDE0NDI2OTUwNDA4ODg5NjM0MDcgMTQ0MjY5NTA0MDg4ODk2MzQwOSA0Mjk0OTY3Mjk1IDE4NDQ2NzQ0MDczNzA5NTUxNjE1CiAgICBieXRlY2Jsb2NrIDB4MTUxZjdjNzUgImVudHJ5X2NvdW50IiAiYWtpdGFfZGFvIiAweDAwICJha2l0YV9hbCIgInR5cGUiIDB4MDAwMCAweDBhICJnYXRlX2lkIiAic3RhdHVzIiAiY3JlYXRvciIgMHgxNCAiZSIgMHgxZSAibWF4X2VudHJpZXMiIDB4ODAgImVuZF90aW1lc3RhbXAiICJ3YWxsZXQiICJzdGFydF90aW1lc3RhbXAiICJyIiAiYWtpdGFfcm95YWx0eV9hbW91bnQiICJzdGFrZV9rZXkiICJha2l0YV9yb3lhbHR5IiAiYWxsb3dfbGF0ZV9zaWdudXBzIiAidGl0bGUiICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIgImFraXRhX2VzY3JvdyIgInNpZ251cF90aW1lc3RhbXAiICJyZXdhcmRfY291bnQiICJvdGhlcl9hbCIgInNhbHQiICJwbHVnbl9hbCIgMHhjOTA2ODgwOSAiY29udHJvbGxlZF9hZGRyZXNzIiAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNC0xMDgKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VTdGFraW5nUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QsCiAgICAvLyAgIENoaWxkQ29udHJhY3QKICAgIC8vICkgewogICAgcHVzaGJ5dGVzcyAweGFiOGIyMTNhIDB4ZWE5MTgwZGQgLy8gbWV0aG9kICJkZWxldGUoYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJ1cGRhdGUoc3RyaW5nKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2RlbGV0ZV9yb3V0ZUA0IG1haW5fdXBkYXRlX3JvdXRlQDUKCm1haW5fc3dpdGNoX2Nhc2VfbmV4dEA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNC0xMDgKICAgIC8vIGV4cG9ydCBjbGFzcyBTdGFraW5nUG9vbCBleHRlbmRzIGNsYXNzZXMoCiAgICAvLyAgIEJhc2VTdGFraW5nUG9vbCwKICAgIC8vICAgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QsCiAgICAvLyAgIENoaWxkQ29udHJhY3QKICAgIC8vICkgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDI4CiAgICBwdXNoYnl0ZXNzIDB4ODNmMTQ3NDggMHgzOTRlYWViMiAweDY0NWE3YmNjIDB4MGYyZmMzMTIgMHgxODFlODI5MSAweDY4NTU4YzcwIDB4YTk0MThkMzcgMHhmYzY5OWNiMyAweDZlNzZiMmNhIDB4Y2RiMGFjNmEgMHhiMjIzZDM1ZCAweDU5MmVlMzQxIDB4OGZhNGExNjAgMHhlMzM3NzM0MiAweDcxNzA0NjQ5IDB4MWVhZDIwYTkgMHgzM2U5MmM5NCAweDg1NGRlZGUwIDB4YTRiM2U3ODkgLy8gbWV0aG9kICJpbml0KCl2b2lkIiwgbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiLCBtZXRob2QgImFkZFJld2FyZChwYXksKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjRbXSwodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpKXZvaWQiLCBtZXRob2QgImFkZFJld2FyZEFzYShwYXksYXhmZXIsKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjRbXSwodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpKXZvaWQiLCBtZXRob2QgImZpbmFsaXplKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImVudGVyKHBheSwodWludDY0LHVpbnQ2NCxieXRlWzMyXVtdKVtdLGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgInN0YXJ0RGlzYnVyc2VtZW50KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJyYWZmbGUodWludDY0KXZvaWQiLCBtZXRob2QgImRpc2J1cnNlUmV3YXJkcyh1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImZpbmFsaXplRGlzdHJpYnV0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjaGVjayhhZGRyZXNzLHVpbnQ2NCkoYm9vbCx1aW50NjQpIiwgbWV0aG9kICJzaWduVXBzT3BlbigpYm9vbCIsIG1ldGhvZCAiaXNMaXZlKClib29sIiwgbWV0aG9kICJpc0VudGVyZWQoYWRkcmVzcylib29sIiwgbWV0aG9kICJnZXRTdGF0ZSgpKHVpbnQ4LHN0cmluZyx1aW50OCx1aW50NjQsdWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCwoYWRkcmVzcyxzdHJpbmcpLHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPRXNjcm93KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBTyh1aW50NjQpdm9pZCIsIG1ldGhvZCAib3BVcCgpdm9pZCIsIG1ldGhvZCAibWJyKHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBpbml0IG9wdEluIGFkZFJld2FyZCBhZGRSZXdhcmRBc2EgZmluYWxpemUgZW50ZXIgc3RhcnREaXNidXJzZW1lbnQgcmFmZmxlIGRpc2J1cnNlUmV3YXJkcyBmaW5hbGl6ZURpc3RyaWJ1dGlvbiBjaGVjayBzaWduVXBzT3BlbiBpc0xpdmUgaXNFbnRlcmVkIGdldFN0YXRlIHVwZGF0ZUFraXRhREFPRXNjcm93IHVwZGF0ZUFraXRhREFPIG1haW5fb3BVcF9yb3V0ZUAyNSBtYnIKICAgIGVycgoKbWFpbl9vcFVwX3JvdXRlQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDIKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMjg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0LTEwOAogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmdQb29sIGV4dGVuZHMgY2xhc3NlcygKICAgIC8vICAgQmFzZVN0YWtpbmdQb29sLAogICAgLy8gICBBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdCwKICAgIC8vICAgQ2hpbGRDb250cmFjdAogICAgLy8gKSB7CiAgICBwdXNoYnl0ZXMgMHg3NzdlYzNlNSAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDgsYWRkcmVzcywoYWRkcmVzcyx1aW50NjQpLGFkZHJlc3MsKGFkZHJlc3Msc3RyaW5nKSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKbWFpbl91cGRhdGVfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ3CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIFVwZGF0ZUFwcGxpY2F0aW9uICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgdXBkYXRlCgptYWluX2RlbGV0ZV9yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwMgogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgRGVsZXRlQXBwbGljYXRpb24gJiYgY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgYiBkZWxldGUKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjpfX3BjZzMyT3V0cHV0KHN0YXRlOiB1aW50NjQpIC0+IHVpbnQ2NDoKX19wY2czMk91dHB1dDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjMKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBfX3BjZzMyT3V0cHV0KHN0YXRlOiBQQ0czMlNUQVRFKTogdWludDY0IHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoyNAogICAgLy8gY29uc3QgeG9yc2hpZnRlZCA9IF9fbWFza1RvVWludDMyKG9wLnNocihvcC5zaHIoc3RhdGUsIDE4KSBeIHN0YXRlLCAyNykpCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgMTggLy8gMTgKICAgIHNocgogICAgZnJhbWVfZGlnIC0xCiAgICBeCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBzaHIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTMKICAgIC8vIHJldHVybiB2YWx1ZSAmIChvcC5zaGwoMSwgMzIpIC0gMSkKICAgIGludGMgOSAvLyA0Mjk0OTY3Mjk1CiAgICAmCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI1CiAgICAvLyBjb25zdCByb3QgPSBvcC5zaHIoc3RhdGUsIDU5KQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBzaHIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjYKICAgIC8vIHJldHVybiBvcC5zaHIoeG9yc2hpZnRlZCwgcm90KSB8IF9fbWFza1RvVWludDMyKG9wLnNobCh4b3JzaGlmdGVkLCBfX3VpbnQ2NFR3b3Mocm90KSAmIDMxKSkKICAgIGR1cDIKICAgIHNocgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyh+dmFsdWUsIDEpCiAgICBzd2FwCiAgICB+CiAgICBpbnRjXzEgLy8gMQogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjI2CiAgICAvLyByZXR1cm4gb3Auc2hyKHhvcnNoaWZ0ZWQsIHJvdCkgfCBfX21hc2tUb1VpbnQzMihvcC5zaGwoeG9yc2hpZnRlZCwgX191aW50NjRUd29zKHJvdCkgJiAzMSkpCiAgICBwdXNoaW50IDMxIC8vIDMxCiAgICAmCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIHNobAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxMwogICAgLy8gcmV0dXJuIHZhbHVlICYgKG9wLnNobCgxLCAzMikgLSAxKQogICAgaW50YyA5IC8vIDQyOTQ5NjcyOTUKICAgICYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MjYKICAgIC8vIHJldHVybiBvcC5zaHIoeG9yc2hpZnRlZCwgcm90KSB8IF9fbWFza1RvVWludDMyKG9wLnNobCh4b3JzaGlmdGVkLCBfX3VpbnQ2NFR3b3Mocm90KSAmIDMxKSkKICAgIHwKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdldFdhbGxldElEVXNpbmdBa2l0YURBTyhha2l0YURBTzogdWludDY0LCBhZGRyZXNzOiBieXRlcykgLT4gdWludDY0OgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2NAogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIGdldFdhbGxldElEVXNpbmdBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24sIGFkZHJlc3M6IEFjY291bnQpOiBBcHBsaWNhdGlvbiB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDgKICAgIC8vIGNvbnN0IFtvdGhlckFwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNPdGhlckFwcExpc3QpKQogICAgZnJhbWVfZGlnIC0yCiAgICBieXRlYyAyOSAvLyAib3RoZXJfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUzCiAgICAvLyByZXR1cm4gZ2V0T3RoZXJBcHBMaXN0KGFraXRhREFPKS5lc2Nyb3cKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE3MC0xNzMKICAgIC8vIGNvbnN0IGRhdGEgPSBhYmlDYWxsPHR5cGVvZiBFc2Nyb3dGYWN0b3J5LnByb3RvdHlwZS5nZXQ+KHsKICAgIC8vICAgYXBwSWQ6IGVzY3Jvd0ZhY3RvcnksCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDNjMWE2ZjMzIC8vIG1ldGhvZCAiZ2V0KGFkZHJlc3MpYnl0ZVtdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgNiAwCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTc1CiAgICAvLyBpZiAoQnl0ZXMoZGF0YSkubGVuZ3RoID09PSAwIHx8IEJ5dGVzKGRhdGEpLmxlbmd0aCAhPT0gOCkgewogICAgbGVuCiAgICBkdXAKICAgIGJ6IGdldFdhbGxldElEVXNpbmdBa2l0YURBT19pZl9ib2R5QDYKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzIgLy8gOAogICAgIT0KICAgIGJ6IGdldFdhbGxldElEVXNpbmdBa2l0YURBT19hZnRlcl9pZl9lbHNlQDcKCmdldFdhbGxldElEVXNpbmdBa2l0YURBT19pZl9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE3NgogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJREA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjYKICAgIC8vIHJldHVybiBBcHBsaWNhdGlvbihnZXRXYWxsZXRJRChlc2Nyb3dGYWN0b3J5LCBhZGRyZXNzKSkKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzkKICAgIC8vIHJldHVybiBidG9pKGRhdGEpCiAgICBmcmFtZV9kaWcgMAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjYKICAgIC8vIHJldHVybiBBcHBsaWNhdGlvbihnZXRXYWxsZXRJRChlc2Nyb3dGYWN0b3J5LCBhZGRyZXNzKSkKICAgIGIgZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6Z2V0V2FsbGV0SURAOAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdhdGVDYWxsKGFraXRhREFPOiB1aW50NjQsIGNhbGxlcjogYnl0ZXMsIGlkOiB1aW50NjQsIGFyZ3M6IGJ5dGVzKSAtPiB1aW50NjQsIGJ5dGVzOgpnYXRlQ2FsbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTkyCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gZ2F0ZUNhbGwoYWtpdGFEQU86IEFwcGxpY2F0aW9uLCBjYWxsZXI6IEFjY291bnQsIGlkOiB1aW50NjQsIGFyZ3M6IEdhdGVBcmdzKTogYm9vbGVhbiB7CiAgICBwcm90byA0IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTkzLTIwMAogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLmNoZWNrPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoYWtpdGFEQU8pLmdhdGUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBjYWxsZXIsCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBmcmFtZV9kaWcgLTQKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxOTQKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QoYWtpdGFEQU8pLmdhdGUsCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxOTcKICAgIC8vIGlkLAogICAgZnJhbWVfZGlnIC0yCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE5My0yMDAKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBHYXRlLnByb3RvdHlwZS5jaGVjaz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5nYXRlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgY2FsbGVyLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MjAwZjc0MjEgLy8gbWV0aG9kICJjaGVjayhhZGRyZXNzLHVpbnQ2NCxieXRlW11bXSlib29sIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjUxCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA0MCAvLyA0MAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ4WzMyXSx1aW50NjQpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDExCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjUKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlID0gUG9vbFN0YXR1c0RyYWZ0CiAgICBieXRlY18zIC8vIDB4MDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBieXRlYyAyNCAvLyAidGl0bGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY2CiAgICAvLyB0aGlzLnRpdGxlLnZhbHVlID0gdGl0bGUKICAgIHVuY292ZXIgMTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjY3CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPSB0eXBlCiAgICB1bmNvdmVyIDEwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjgKICAgIC8vIHRoaXMuY3JlYXRvci52YWx1ZSA9IGNyZWF0b3IKICAgIHVuY292ZXIgOQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9jaGlsZC50czoxMQogICAgLy8gZnVuZGVyID0gR2xvYmFsU3RhdGU8RnVuZGVySW5mbz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5RnVuZGVyIH0pCiAgICBwdXNoYnl0ZXMgImZ1bmRlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NjkKICAgIC8vIHRoaXMuZnVuZGVyLnZhbHVlID0gY2xvbmUoZnVuZGVyKQogICAgdW5jb3ZlciA4CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0OAogICAgLy8gbWFya2V0cGxhY2UgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWFya2V0cGxhY2UgfSkKICAgIHB1c2hieXRlcyAibWFya2V0cGxhY2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjcwCiAgICAvLyB0aGlzLm1hcmtldHBsYWNlLnZhbHVlID0gbWFya2V0cGxhY2UKICAgIHVuY292ZXIgNwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzgKICAgIC8vIHN0YWtlS2V5ID0gR2xvYmFsU3RhdGU8Um9vdEtleT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YWtlS2V5IH0pCiAgICBieXRlYyAyMSAvLyAic3Rha2Vfa2V5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3MgogICAgLy8gdGhpcy5zdGFrZUtleS52YWx1ZSA9IGNsb25lKHN0YWtlS2V5KQogICAgdW5jb3ZlciA2CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MAogICAgLy8gbWluaW11bVN0YWtlQW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWluaW11bVN0YWtlQW1vdW50IH0pCiAgICBieXRlYyAyNSAvLyAibWluaW11bV9zdGFrZV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjczCiAgICAvLyB0aGlzLm1pbmltdW1TdGFrZUFtb3VudC52YWx1ZSA9IG1pbmltdW1TdGFrZUFtb3VudAogICAgdW5jb3ZlciA1CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3NAogICAgLy8gdGhpcy5nYXRlSUQudmFsdWUgPSBnYXRlSUQKICAgIHVuY292ZXIgNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njc1CiAgICAvLyB0aGlzLm1heEVudHJpZXMudmFsdWUgPSBtYXhFbnRyaWVzCiAgICB1bmNvdmVyIDMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU2CiAgICAvLyBzYWx0ID0gR2xvYmFsU3RhdGU8Ynl0ZXM8MzI+Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U2FsdCB9KQogICAgYnl0ZWMgMzAgLy8gInNhbHQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njc3CiAgICAvLyB0aGlzLnNhbHQudmFsdWUgPSBUeG4udHhJZAogICAgdHhuIFR4SUQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NzgKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NTkKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBieXRlYyAyNiAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY3OQogICAgLy8gdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZSA9IGFraXRhREFPRXNjcm93CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4MQogICAgLy8gY29uc3QgZmVlcyA9IGdldFN0YWtpbmdGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjgxCiAgICAvLyBjb25zdCBmZWVzID0gZ2V0U3Rha2luZ0ZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjY3CiAgICAvLyBjb25zdCBbc3Rha2luZ0ZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNTdGFraW5nRmVlcykpCiAgICBkdXAKICAgIHB1c2hieXRlcyAic3Rha2luZ19mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg0CiAgICAvLyBsZXQgaW1wYWN0OiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4NQogICAgLy8gaWYgKGFwcExpc3QuaW1wYWN0ICE9PSAwKSB7CiAgICBwdXNoaW50IDEwNCAvLyAxMDQKICAgIGV4dHJhY3RfdWludDY0CiAgICBieiBjcmVhdGVfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg2CiAgICAvLyBpbXBhY3QgPSBnZXRVc2VySW1wYWN0KHRoaXMuYWtpdGFEQU8udmFsdWUsIHRoaXMuY3JlYXRvci52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2ODYKICAgIC8vIGltcGFjdCA9IGdldFVzZXJJbXBhY3QodGhpcy5ha2l0YURBTy52YWx1ZSwgdGhpcy5jcmVhdG9yLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBjcmVhdG9yID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUNyZWF0b3IgfSkKICAgIGJ5dGVjIDEwIC8vICJjcmVhdG9yIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY4NgogICAgLy8gaW1wYWN0ID0gZ2V0VXNlckltcGFjdCh0aGlzLmFraXRhREFPLnZhbHVlLCB0aGlzLmNyZWF0b3IudmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjAtMTIzCiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxJbXBhY3QucHJvdG90eXBlLmdldFVzZXJJbXBhY3Q+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdChha2l0YURBTykuaW1wYWN0LAogICAgLy8gICBhcmdzOiBbYWNjb3VudF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBzd2FwCiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTIxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5pbXBhY3QsCiAgICBwdXNoaW50IDEwNCAvLyAxMDQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEyMC0xMjMKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbEltcGFjdC5wcm90b3R5cGUuZ2V0VXNlckltcGFjdD4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5pbXBhY3QsCiAgICAvLyAgIGFyZ3M6IFthY2NvdW50XQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGQ1NzRiYjEwIC8vIG1ldGhvZCAiZ2V0VXNlckltcGFjdChhZGRyZXNzKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBidXJ5IDEKCmNyZWF0ZV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg4CiAgICAvLyB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSA9IGltcGFjdFJhbmdlKGltcGFjdCwgZmVlcy5pbXBhY3RUYXhNaW4sIGZlZXMuaW1wYWN0VGF4TWF4KQogICAgZGlnIDEKICAgIGR1cAogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDQKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTE1CiAgICAvLyBjb25zdCBtaW5JbXBhY3Q6IHVpbnQ2NCA9IChpbXBhY3QgPiAxKSA/IGltcGFjdCAtIDEgOiAxCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICA+CiAgICBieiBjcmVhdGVfdGVybmFyeV9mYWxzZUA2CiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICAtCgpjcmVhdGVfdGVybmFyeV9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMTYKICAgIC8vIHJldHVybiBtYXggLSAoKChtYXggLSBtaW4pICogbWluSW1wYWN0KSAvIElNUEFDVF9ESVZJU09SKQogICAgZGlnIDQKICAgIGR1cAogICAgZGlnIDUKICAgIC0KICAgIHVuY292ZXIgMgogICAgKgogICAgcHVzaGludCAxMDAwIC8vIDEwMDAKICAgIC8KICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTIKICAgIC8vIGFraXRhUm95YWx0eSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eSB9KQogICAgYnl0ZWMgMjIgLy8gImFraXRhX3JveWFsdHkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njg4CiAgICAvLyB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSA9IGltcGFjdFJhbmdlKGltcGFjdCwgZmVlcy5pbXBhY3RUYXhNaW4sIGZlZXMuaW1wYWN0VGF4TWF4KQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2NTEKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpjcmVhdGVfdGVybmFyeV9mYWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMTUKICAgIC8vIGNvbnN0IG1pbkltcGFjdDogdWludDY0ID0gKGltcGFjdCA+IDEpID8gaW1wYWN0IC0gMSA6IDEKICAgIGludGNfMSAvLyAxCiAgICBiIGNyZWF0ZV90ZXJuYXJ5X21lcmdlQDcKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmluaXRbcm91dGluZ10oKSAtPiB2b2lkOgppbml0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5MgogICAgLy8gYXNzZXJ0KEdsb2JhbC5jYWxsZXJBcHBsaWNhdGlvbkFkZHJlc3MgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ29ubHkgdGhlIGZhY3RvcnkgY2FuIGluaXQgdGhlIHBvb2wnKQogICAgZ2xvYmFsIENhbGxlckFwcGxpY2F0aW9uQWRkcmVzcwogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGZhY3RvcnkgY2FuIGluaXQgdGhlIHBvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTQKICAgIC8vIGlmICh0aGlzLmdhdGVJRC52YWx1ZSA+IDApIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGJ5dGVjIDggLy8gImdhdGVfaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk0CiAgICAvLyBpZiAodGhpcy5nYXRlSUQudmFsdWUgPiAwKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnogaW5pdF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTUtNjk4CiAgICAvLyB0aGlzLmdhdGVTaXplLnZhbHVlID0gYWJpQ2FsbDx0eXBlb2YgR2F0ZS5wcm90b3R5cGUuc2l6ZT4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmdhdGUsCiAgICAvLyAgIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlLAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2OTcKICAgIC8vIGFyZ3M6IFt0aGlzLmdhdGVJRC52YWx1ZV0sCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NwogICAgLy8gYXJnczogW3RoaXMuZ2F0ZUlELnZhbHVlXSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Njk1LTY5OAogICAgLy8gdGhpcy5nYXRlU2l6ZS52YWx1ZSA9IGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLnNpemU+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlLAogICAgLy8gICBhcmdzOiBbdGhpcy5nYXRlSUQudmFsdWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGRmNTZiMDFlIC8vIG1ldGhvZCAic2l6ZSh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGdhdGVTaXplID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZVNpemUgfSkKICAgIHB1c2hieXRlcyAiZ2F0ZV9zaXplIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5NS02OTgKICAgIC8vIHRoaXMuZ2F0ZVNpemUudmFsdWUgPSBhYmlDYWxsPHR5cGVvZiBHYXRlLnByb3RvdHlwZS5zaXplPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZSwKICAgIC8vICAgYXJnczogW3RoaXMuZ2F0ZUlELnZhbHVlXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAoKaW5pdF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjkxCiAgICAvLyBpbml0KCkgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZGVsZXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwMgogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ2NhbGwgbXVzdCBjb21lIGZyb20gZmFjdG9yeScpCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gY2FsbCBtdXN0IGNvbWUgZnJvbSBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA1CiAgICAvLyBhc3NlcnQoY2FsbGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsICdvbmx5IHRoZSBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHBvb2wnKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNyZWF0b3IgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5Q3JlYXRvciB9KQogICAgYnl0ZWMgMTAgLy8gImNyZWF0b3IiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA1CiAgICAvLyBhc3NlcnQoY2FsbGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsICdvbmx5IHRoZSBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHBvb2wnKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA2CiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkJykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEzCiAgICAvLyBzdGF0dXMgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YXR1cz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXR1cyB9KQogICAgYnl0ZWMgOSAvLyAic3RhdHVzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwNgogICAgLy8gYXNzZXJ0KHRoaXMuc3RhdHVzLnZhbHVlID09PSBQb29sU3RhdHVzRHJhZnQgfHwgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBvciBlbmRlZCcpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMyAvLyAweDAwCiAgICA9PQogICAgYm56IGRlbGV0ZV9ib29sX3RydWVAMwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjUKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTYgLy8gImVuZF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzA2CiAgICAvLyBhc3NlcnQodGhpcy5zdGF0dXMudmFsdWUgPT09IFBvb2xTdGF0dXNEcmFmdCB8fCBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsICd0aGUgcG9vbCBtdXN0IGJlIGluIGRyYWZ0IG9yIGVuZGVkJykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICBieiBkZWxldGVfYm9vbF9mYWxzZUA0CgpkZWxldGVfYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQoKZGVsZXRlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MDYKICAgIC8vIGFzc2VydCh0aGlzLnN0YXR1cy52YWx1ZSA9PT0gUG9vbFN0YXR1c0RyYWZ0IHx8IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSwgJ3RoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgb3IgZW5kZWQnKQogICAgYXNzZXJ0IC8vIHRoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgb3IgZW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MTAtNzEyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsgY2xvc2VSZW1haW5kZXJUbzogR2xvYmFsLmNyZWF0b3JBZGRyZXNzIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcxMQogICAgLy8gLnBheW1lbnQoeyBjbG9zZVJlbWFpbmRlclRvOiBHbG9iYWwuY3JlYXRvckFkZHJlc3MgfSkKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzEwLTcxMQogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7IGNsb3NlUmVtYWluZGVyVG86IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcxMC03MTIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoeyBjbG9zZVJlbWFpbmRlclRvOiBHbG9iYWwuY3JlYXRvckFkZHJlc3MgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcwMgogICAgLy8gQGFiaW1ldGhvZCh7IGFsbG93QWN0aW9uczogJ0RlbGV0ZUFwcGxpY2F0aW9uJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKZGVsZXRlX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGRlbGV0ZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLm9wdEluW3JvdXRpbmddKCkgLT4gdm9pZDoKb3B0SW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzIyCiAgICAvLyBvcHRJbihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0OiB1aW50NjQpOiB2b2lkIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MjMKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gY3JlYXRvciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlDcmVhdG9yIH0pCiAgICBieXRlYyAxMCAvLyAiY3JlYXRvciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MjMKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmNyZWF0b3IudmFsdWUsIEVSUl9GT1JCSURERU4pCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBGb3JiaWRkZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MjcKICAgIC8vIGNvbnN0IGRhb0VzY3Jvd05lZWRzVG9PcHRJbiA9ICFHbG9iYWwuemVyb0FkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0KSkKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgZGlnIDEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzMxCiAgICAvLyBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MzIKICAgIC8vIGRhb0VzY3Jvd05lZWRzVG9PcHRJbiA/IDQgOiAxCiAgICBpbnRjXzEgLy8gMQogICAgcHVzaGludCA0IC8vIDQKICAgIHVuY292ZXIgMwogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzMxLTczMwogICAgLy8gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogKAogICAgLy8gICBkYW9Fc2Nyb3dOZWVkc1RvT3B0SW4gPyA0IDogMQogICAgLy8gKQogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjczOC03NDUKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBkaWcgMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDEKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzM4LTc0NQogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICB1bmNvdmVyIDMKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0MgogICAgLy8gYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIsCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3MzYKICAgIC8vIGNvbnN0IHJld2FyZHNNQlI6IHVpbnQ2NCA9IHRoaXMucmV3YXJkc01icihXaW5uZXJDb3VudENhcCkgKiAyCiAgICBwdXNoaW50IDgwMDAgLy8gODAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0MgogICAgLy8gYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIsCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzM4LTc0NQogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICAmJgogICAgYXNzZXJ0IC8vIEludmFsaWQgcGF5bWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0Ny03NTMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0OQogICAgLy8gYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzUwCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NDctNzUyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc0Ny03NTMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGJ5dGVjIDE3IC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQzCiAgICAvLyBjb25zdCBbcGx1Z2luQXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1BsdWdpbkFwcExpc3QpKQogICAgZHVwCiAgICBieXRlYyAzMSAvLyAicGx1Z25fYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo3NwogICAgLy8gY29uc3QgeyByZXZlbnVlTWFuYWdlciB9ID0gZ2V0UGx1Z2luQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgZHVwCiAgICBleHRyYWN0IDggOAogICAgc3dhcAogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICB1bmNvdmVyIDIKICAgIGJ5dGVjIDE3IC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo2NC02NwogICAgLy8gY29uc3QgZXNjcm93ID0gYWJpQ2FsbDx0eXBlb2YgQWJzdHJhY3RlZEFjY291bnQucHJvdG90eXBlLmFyYzU4X2dldEVzY3Jvd3M+KHsKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtbbmFtZV1dLAogICAgLy8gfSkucmV0dXJuVmFsdWVbMF0KICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweGEyNDAzZGRmIC8vIG1ldGhvZCAiYXJjNThfZ2V0RXNjcm93cyhzdHJpbmdbXSkodWludDY0LGJvb2wpW10iCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NjYKICAgIC8vIGFyZ3M6IFtbbmFtZV1dLAogICAgcHVzaGJ5dGVzIDB4MDAwMTAwMDIwMDBkNzM3NDYxNmI2OTZlNjc1ZjcwNmY2ZjZjNzMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjY0LTY3CiAgICAvLyBjb25zdCBlc2Nyb3cgPSBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfZ2V0RXNjcm93cz4oewogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW1tuYW1lXV0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZVswXQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgOSAvLyA5CiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50NjQsYm9vbDEpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo2OQogICAgLy8gYXNzZXJ0KGVzY3Jvdy5pZCAhPT0gMCwgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGV4dHJhY3QgNiA5CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYXNzZXJ0IC8vIEVzY3JvdyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODAKICAgIC8vIGFzc2VydChpZCA9PT0gdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5pZCwgRVJSX1dST05HX0VTQ1JPV19GT1JfT1BFUkFUSU9OKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjU5CiAgICAvLyBha2l0YURBT0VzY3JvdyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YUVzY3JvdyB9KQogICAgYnl0ZWMgMjYgLy8gImFraXRhX2VzY3JvdyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjgwCiAgICAvLyBhc3NlcnQoaWQgPT09IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuaWQsIEVSUl9XUk9OR19FU0NST1dfRk9SX09QRVJBVElPTikKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBzd2FwCiAgICBkaWcgMQogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyBlc2Nyb3cgZm9yIHRoaXMgb3BlcmF0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4Mi05MQogICAgLy8gaXR4bkNvbXBvc2UuYmVnaW48dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9yZWtleVRvUGx1Z2luPih7CiAgICAvLyAgIGFwcElkOiB3YWxsZXQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICByZXZlbnVlTWFuYWdlciwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgW10sCiAgICAvLyAgICAgW10KICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHg1ODJmZjM4MiAvLyBtZXRob2QgImFyYzU4X3Jla2V5VG9QbHVnaW4odWludDY0LGJvb2wsc3RyaW5nLHVpbnQ2NFtdLCh1aW50NjQsdWludDY0KVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODYKICAgIC8vIHRydWUsCiAgICBieXRlYyAxNSAvLyAweDgwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6ODcKICAgIC8vIG5hbWUsCiAgICBwdXNoYnl0ZXMgMHgwMDBkNzM3NDYxNmI2OTZlNjc1ZjcwNmY2ZjZjNzMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4OAogICAgLy8gW10sCiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjg5CiAgICAvLyBbXQogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4Mi05MQogICAgLy8gaXR4bkNvbXBvc2UuYmVnaW48dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9yZWtleVRvUGx1Z2luPih7CiAgICAvLyAgIGFwcElkOiB3YWxsZXQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICByZXZlbnVlTWFuYWdlciwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgW10sCiAgICAvLyAgICAgW10KICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5My0xMDQKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFJldmVudWVNYW5hZ2VyUGx1Z2luU3R1Yi5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgYXBwSWQ6IHJldmVudWVNYW5hZ2VyLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgd2FsbGV0LAogICAgLy8gICAgIHRydWUsCiAgICAvLyAgICAgW2Fzc2V0LmlkXSwKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjEwMAogICAgLy8gcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjEwMQogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UsCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5OS0xMDIKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjkzLTEwNAogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgUmV2ZW51ZU1hbmFnZXJQbHVnaW5TdHViLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBhcHBJZDogcmV2ZW51ZU1hbmFnZXIsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICB3YWxsZXQsCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBbYXNzZXQuaWRdLAogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UsCiAgICAvLyAgICAgfSkKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OTYKICAgIC8vIHdhbGxldCwKICAgIGRpZyAxCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5OAogICAgLy8gW2Fzc2V0LmlkXSwKICAgIHVuY292ZXIgMwogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4MDAwMQogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5My0xMDQKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFJldmVudWVNYW5hZ2VyUGx1Z2luU3R1Yi5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgYXBwSWQ6IHJldmVudWVNYW5hZ2VyLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgd2FsbGV0LAogICAgLy8gICAgIHRydWUsCiAgICAvLyAgICAgW2Fzc2V0LmlkXSwKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg2ODM1ZTNiYyAvLyBtZXRob2QgIm9wdEluKHVpbnQ2NCxib29sLHVpbnQ2NFtdLHBheSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo4NgogICAgLy8gdHJ1ZSwKICAgIGJ5dGVjIDE1IC8vIDB4ODAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo5My0xMDQKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFJldmVudWVNYW5hZ2VyUGx1Z2luU3R1Yi5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgYXBwSWQ6IHJldmVudWVNYW5hZ2VyLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgd2FsbGV0LAogICAgLy8gICAgIHRydWUsCiAgICAvLyAgICAgW2Fzc2V0LmlkXSwKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMDYKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF92ZXJpZnlBdXRoQWRkcmVzcz4oeyBhcHBJZDogd2FsbGV0IH0pCiAgICBpdHhuX25leHQKICAgIHB1c2hieXRlcyAweDZjYzNmNjA2IC8vIG1ldGhvZCAiYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3MoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxMTgKICAgIC8vIGl0eG5Db21wb3NlLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjcyMgogICAgLy8gb3B0SW4ocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBhc3NldDogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRbcm91dGluZ10oKSAtPiB2b2lkOgphZGRSZXdhcmQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzYyCiAgICAvLyBhZGRSZXdhcmQocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCByZXdhcmQ6IFJld2FyZCk6IHZvaWQgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkCiAgICBwb3AKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZEFzYVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFkZFJld2FyZEFzYToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODMKICAgIC8vIGFkZFJld2FyZEFzYShwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0WGZlcjogZ3R4bi5Bc3NldFRyYW5zZmVyVHhuLCByZXdhcmQ6IFJld2FyZCk6IHZvaWQgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIGF4ZmVyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzg0LTc5NAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIGFzc2V0WGZlciwKICAgIC8vICAgewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIC8vICAgICBhc3NldEFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW46IDAKICAgIC8vICAgICB9CiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1RSQU5TRkVSCiAgICAvLyApCiAgICBkaWcgMQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4NwogICAgLy8gYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4NC03OTQKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBhc3NldFhmZXIsCiAgICAvLyAgIHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IEFzc2V0KHJld2FyZC5hc3NldCksCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuOiAwCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9UUkFOU0ZFUgogICAgLy8gKQogICAgPT0KICAgIGRpZyAyCiAgICBndHhucyBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODgKICAgIC8vIHhmZXJBc3NldDogQXNzZXQocmV3YXJkLmFzc2V0KSwKICAgIGRpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODQtNzk0CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgYXNzZXRYZmVyLAogICAgLy8gICB7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgeGZlckFzc2V0OiBBc3NldChyZXdhcmQuYXNzZXQpLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbjogMAogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfVFJBTlNGRVIKICAgIC8vICkKICAgID09CiAgICAmJgogICAgdW5jb3ZlciAyCiAgICBndHhucyBBc3NldEFtb3VudAogICAgJiYKICAgIGFzc2VydCAvLyBJbnZhbGlkIHRyYW5zZmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Nzk2CiAgICAvLyB0aGlzLmFkZFJld2FyZChwYXltZW50LCByZXdhcmQpCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODMKICAgIC8vIGFkZFJld2FyZEFzYShwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0WGZlcjogZ3R4bi5Bc3NldFRyYW5zZmVyVHhuLCByZXdhcmQ6IFJld2FyZCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZmluYWxpemVbcm91dGluZ10oKSAtPiB2b2lkOgpmaW5hbGl6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3OTkKICAgIC8vIGZpbmFsaXplKHNpZ251cFRpbWVzdGFtcDogdWludDY0LCBzdGFydFRpbWVzdGFtcDogdWludDY0LCBlbmRUaW1lc3RhbXA6IHVpbnQ2NCkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAwCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCAnb25seSB0aGUgY3JlYXRvciBjYW4gZmluYWxpemUgdGhlIHBvb2wnKQogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNyZWF0b3IgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5Q3JlYXRvciB9KQogICAgYnl0ZWMgMTAgLy8gImNyZWF0b3IiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODAwCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCAnb25seSB0aGUgY3JlYXRvciBjYW4gZmluYWxpemUgdGhlIHBvb2wnKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciBjYW4gZmluYWxpemUgdGhlIHBvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MDEKICAgIC8vIGFzc2VydCh0aGlzLnN0YXR1cy52YWx1ZSA9PT0gUG9vbFN0YXR1c0RyYWZ0LCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBzdGF0ZSB0byBmaW5hbGl6ZScpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExMwogICAgLy8gc3RhdHVzID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGF0dXM+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGF0dXMgfSkKICAgIGJ5dGVjIDkgLy8gInN0YXR1cyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MDEKICAgIC8vIGFzc2VydCh0aGlzLnN0YXR1cy52YWx1ZSA9PT0gUG9vbFN0YXR1c0RyYWZ0LCAndGhlIHBvb2wgbXVzdCBiZSBpbiBkcmFmdCBzdGF0ZSB0byBmaW5hbGl6ZScpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMyAvLyAweDAwCiAgICA9PQogICAgYXNzZXJ0IC8vIHRoZSBwb29sIG11c3QgYmUgaW4gZHJhZnQgc3RhdGUgdG8gZmluYWxpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MDMKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgfHwgKHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUpLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgPgogICAgYm56IGZpbmFsaXplX2Jvb2xfdHJ1ZUA0CiAgICBkaWcgMgogICAgYm56IGZpbmFsaXplX2Jvb2xfZmFsc2VANQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIGFsbG93TGF0ZVNpZ251cHMgPSBHbG9iYWxTdGF0ZTxib29sZWFuPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWxsb3dMYXRlU2lnbnVwcyB9KQogICAgYnl0ZWMgMjMgLy8gImFsbG93X2xhdGVfc2lnbnVwcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MDMKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgfHwgKHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUpLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IGZpbmFsaXplX2Jvb2xfZmFsc2VANQoKZmluYWxpemVfYm9vbF90cnVlQDQ6CiAgICBpbnRjXzEgLy8gMQoKZmluYWxpemVfYm9vbF9tZXJnZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwMi04MDUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgc2lnbnVwVGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCB8fCAoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSksCiAgICAvLyAgICd0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgbGF0ZSBzaWduIHVwcyBhbGxvd2VkIG9yIGluIHRoZSBmdXR1cmUnCiAgICAvLyApCiAgICBhc3NlcnQgLy8gdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGxhdGUgc2lnbiB1cHMgYWxsb3dlZCBvciBpbiB0aGUgZnV0dXJlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODA4LTgwOQogICAgLy8gc3RhcnRUaW1lc3RhbXAgPT09IDAgfHwKICAgIC8vIHN0YXJ0VGltZXN0YW1wID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGRpZyAxCiAgICBieiBmaW5hbGl6ZV9ib29sX3RydWVAOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwOQogICAgLy8gc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgZGlnIDEKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MDgtODA5CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9PT0gMCB8fAogICAgLy8gc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgYnogZmluYWxpemVfYm9vbF9mYWxzZUA5CgpmaW5hbGl6ZV9ib29sX3RydWVAODoKICAgIGludGNfMSAvLyAxCgpmaW5hbGl6ZV9ib29sX21lcmdlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgwNy04MTEKICAgIC8vIGFzc2VydCgKICAgIC8vICAgc3RhcnRUaW1lc3RhbXAgPT09IDAgfHwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXAgPiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgLy8gICAndGhlIHN0YXJ0aW5nIHJvdW5kIG11c3QgYmUgemVybyBvciBpbiB0aGUgZnV0dXJlJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHRoZSBzdGFydGluZyByb3VuZCBtdXN0IGJlIHplcm8gb3IgaW4gdGhlIGZ1dHVyZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxMwogICAgLy8gaWYgKHN0YXJ0VGltZXN0YW1wID09PSAwKSB7CiAgICBkaWcgMQogICAgYm56IGZpbmFsaXplX2FmdGVyX2lmX2Vsc2VAMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MTQKICAgIC8vIGFzc2VydChzaWdudXBUaW1lc3RhbXAgPT09IDAgJiYgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLCAnaWYgdGhlIHN0YXJ0aW5nIHJvdW5kIGlzIHplcm8sIHRoZSBzaWdudXAgcm91bmQgbXVzdCBiZSB6ZXJvIGFuZCBhbGxvd0xhdGVTaWdudXBzIG11c3QgYmUgdHJ1ZScpCiAgICBkaWcgMgogICAgYm56IGZpbmFsaXplX2Jvb2xfZmFsc2VAMTQKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGJ5dGVjIDIzIC8vICJhbGxvd19sYXRlX3NpZ251cHMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODE0CiAgICAvLyBhc3NlcnQoc2lnbnVwVGltZXN0YW1wID09PSAwICYmIHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSwgJ2lmIHRoZSBzdGFydGluZyByb3VuZCBpcyB6ZXJvLCB0aGUgc2lnbnVwIHJvdW5kIG11c3QgYmUgemVybyBhbmQgYWxsb3dMYXRlU2lnbnVwcyBtdXN0IGJlIHRydWUnKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IGZpbmFsaXplX2Jvb2xfZmFsc2VAMTQKICAgIGludGNfMSAvLyAxCgpmaW5hbGl6ZV9ib29sX21lcmdlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgxNAogICAgLy8gYXNzZXJ0KHNpZ251cFRpbWVzdGFtcCA9PT0gMCAmJiB0aGlzLmFsbG93TGF0ZVNpZ251cHMudmFsdWUsICdpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlJykKICAgIGFzc2VydCAvLyBpZiB0aGUgc3RhcnRpbmcgcm91bmQgaXMgemVybywgdGhlIHNpZ251cCByb3VuZCBtdXN0IGJlIHplcm8gYW5kIGFsbG93TGF0ZVNpZ251cHMgbXVzdCBiZSB0cnVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODE1CiAgICAvLyBzdGFydFRpbWVzdGFtcCA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGJ1cnkgMgoKZmluYWxpemVfYWZ0ZXJfaWZfZWxzZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MTkKICAgIC8vIGVuZFRpbWVzdGFtcCA9PT0gMCB8fCBlbmRUaW1lc3RhbXAgPiAoc3RhcnRUaW1lc3RhbXAgKyAxMCksCiAgICBkdXAKICAgIGJ6IGZpbmFsaXplX2Jvb2xfdHJ1ZUAxOAogICAgZGlnIDEKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgICsKICAgIGRpZyAxCiAgICA8CiAgICBieiBmaW5hbGl6ZV9ib29sX2ZhbHNlQDE5CgpmaW5hbGl6ZV9ib29sX3RydWVAMTg6CiAgICBpbnRjXzEgLy8gMQoKZmluYWxpemVfYm9vbF9tZXJnZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MTgtODIxCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIGVuZFRpbWVzdGFtcCA9PT0gMCB8fCBlbmRUaW1lc3RhbXAgPiAoc3RhcnRUaW1lc3RhbXAgKyAxMCksCiAgICAvLyAgICd0aGUgZW5kaW5nIHJvdW5kIG11c3QgYmUgemVybyBvciBhZnRlciB0aGUgc3RhcnRpbmcgcm91bmQgKyAxMCcKICAgIC8vICkKICAgIGFzc2VydCAvLyB0aGUgZW5kaW5nIHJvdW5kIG11c3QgYmUgemVybyBvciBhZnRlciB0aGUgc3RhcnRpbmcgcm91bmQgKyAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gc2lnbnVwVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U2lnbnVwVGltZXN0YW1wIH0pCiAgICBieXRlYyAyNyAvLyAic2lnbnVwX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MjMKICAgIC8vIHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlID0gc2lnbnVwVGltZXN0YW1wCiAgICBkaWcgMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE4IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODI0CiAgICAvLyB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlID0gc3RhcnRUaW1lc3RhbXAKICAgIGRpZyAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gZW5kVGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW5kVGltZXN0YW1wIH0pCiAgICBieXRlYyAxNiAvLyAiZW5kX3RpbWVzdGFtcCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MjUKICAgIC8vIHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID0gZW5kVGltZXN0YW1wCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyA5IC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODI2CiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSA9IFBvb2xTdGF0dXNGaW5hbAogICAgYnl0ZWMgNyAvLyAweDBhCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc5OQogICAgLy8gZmluYWxpemUoc2lnbnVwVGltZXN0YW1wOiB1aW50NjQsIHN0YXJ0VGltZXN0YW1wOiB1aW50NjQsIGVuZFRpbWVzdGFtcDogdWludDY0KSB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpmaW5hbGl6ZV9ib29sX2ZhbHNlQDE5OgogICAgaW50Y18wIC8vIDAKICAgIGIgZmluYWxpemVfYm9vbF9tZXJnZUAyMAoKZmluYWxpemVfYm9vbF9mYWxzZUAxNDoKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VAMTUKCmZpbmFsaXplX2Jvb2xfZmFsc2VAOToKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VAMTAKCmZpbmFsaXplX2Jvb2xfZmFsc2VANToKICAgIGludGNfMCAvLyAwCiAgICBiIGZpbmFsaXplX2Jvb2xfbWVyZ2VANgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZW50ZXJbcm91dGluZ10oKSAtPiB2b2lkOgplbnRlcjoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDMKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODI5CiAgICAvLyBlbnRlcihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGVudHJpZXM6IFN0YWtlRW50cnlbXSwgYXJnczogR2F0ZUFyZ3MpOiB2b2lkIHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzMQogICAgLy8gYXNzZXJ0KHRoaXMuaXNMaXZlKCksICd0aGUgcG9vbCBpcyBub3QgbGl2ZScpCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlCiAgICBhc3NlcnQgLy8gdGhlIHBvb2wgaXMgbm90IGxpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MzMKICAgIC8vIGlmICh0aGlzLmdhdGVJRC52YWx1ZSAhPT0gMCkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MzMKICAgIC8vIGlmICh0aGlzLmdhdGVJRC52YWx1ZSAhPT0gMCkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IGVudGVyX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzNAogICAgLy8gY29uc3Qgd2FsbGV0ID0gZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgVHhuLnNlbmRlcikKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8KICAgIGR1cAogICAgYnVyeSA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzNAogICAgLy8gcmV0dXJuIG9yaWdpbk9yKHdhbGxldElELCBUeG4uc2VuZGVyKQogICAgdHhuIFNlbmRlcgogICAgYnVyeSAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjcKICAgIC8vIGlmICh3YWxsZXRJRC5pZCA9PT0gMCkgewogICAgYm56IGVudGVyX2FmdGVyX2lmX2Vsc2VAMzAKICAgIGRpZyA4CgplbnRlcl9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDMxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzNwogICAgLy8gZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBhcmdzKSwKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGdhdGVJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUdhdGVJRCB9KQogICAgYnl0ZWMgOCAvLyAiZ2F0ZV9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4MzcKICAgIC8vIGdhdGVDYWxsKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCwgb3JpZ2luLCB0aGlzLmdhdGVJRC52YWx1ZSwgYXJncyksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgc3dhcAogICAgY292ZXIgMgogICAgZGlnIDMKICAgIGNhbGxzdWIgZ2F0ZUNhbGwKICAgIGJ1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgzNi04MzkKICAgIC8vIGFzc2VydCgKICAgIC8vICAgZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBhcmdzKSwKICAgIC8vICAgJ3VzZXIgZG9lcyBub3QgbWVldCBnYXRlIHJlcXVpcmVtZW50cycKICAgIC8vICkKICAgIGFzc2VydCAvLyB1c2VyIGRvZXMgbm90IG1lZXQgZ2F0ZSByZXF1aXJlbWVudHMKCmVudGVyX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDMKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDMKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGJ5dGVjIDE0IC8vICJtYXhfZW50cmllcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDMKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIDwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NDMtODQ0CiAgICAvLyAodGhpcy5lbnRyeUlELnZhbHVlICsgMSkgPCB0aGlzLm1heEVudHJpZXMudmFsdWUgfHwKICAgIC8vIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIGJueiBlbnRlcl9ib29sX3RydWVANQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0NAogICAgLy8gdGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODQ0CiAgICAvLyB0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0My04NDQKICAgIC8vICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSA8IHRoaXMubWF4RW50cmllcy52YWx1ZSB8fAogICAgLy8gdGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwLAogICAgYm56IGVudGVyX2Jvb2xfZmFsc2VANgoKZW50ZXJfYm9vbF90cnVlQDU6CiAgICBpbnRjXzEgLy8gMQoKZW50ZXJfYm9vbF9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg0Mi04NDYKICAgIC8vIGFzc2VydCgKICAgIC8vICAgKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpIDwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIHx8CiAgICAvLyAgIHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCwKICAgIC8vICAgJ3Bvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzJwogICAgLy8gKQogICAgYXNzZXJ0IC8vIHBvb2wgaGFzIHJlYWNoZWQgbWF4aW11bSBlbnRyaWVzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODUwCiAgICAvLyBsZXQgdG90YWw6IHVpbnQ2NCA9IGVudHJ5TUJSICogZW50cmllcy5sZW5ndGgKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgYnVyeSA5CiAgICBwdXNoaW50IDUwNjAwIC8vIDUwNjAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyB1bmlxdWVzID0gQm94TWFwPEFjY291bnQsIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xHbG9iYWxTdGF0ZUtleVVuaXF1ZXMgfSkKICAgIHB1c2hieXRlcyAidSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTEKICAgIC8vIGlmICghdGhpcy51bmlxdWVzKFR4bi5zZW5kZXIpLmV4aXN0cykgewogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gdW5pcXVlcyA9IEJveE1hcDxBY2NvdW50LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sR2xvYmFsU3RhdGVLZXlVbmlxdWVzIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NTEKICAgIC8vIGlmICghdGhpcy51bmlxdWVzKFR4bi5zZW5kZXIpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogZW50ZXJfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODUyCiAgICAvLyB0b3RhbCArPSBQb29sVW5pcXVlc01CUgogICAgcHVzaGludCAxODkwMCAvLyAxODkwMAogICAgKwoKZW50ZXJfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1NS04NjIKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdG90YWwsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGRpZyAzCiAgICBkdXAKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODU4CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg1NS04NjIKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBwYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdG90YWwsCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICBzd2FwCiAgICBndHhucyBBbW91bnQKICAgIHVuY292ZXIgMgogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODY0CiAgICAvLyBjb25zdCB7IGFkZHJlc3MsIG5hbWUgfSA9IHRoaXMuc3Rha2VLZXkudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBzdGFrZUtleSA9IEdsb2JhbFN0YXRlPFJvb3RLZXk+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTdGFrZUtleSB9KQogICAgYnl0ZWMgMjEgLy8gInN0YWtlX2tleSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NjQKICAgIC8vIGNvbnN0IHsgYWRkcmVzcywgbmFtZSB9ID0gdGhpcy5zdGFrZUtleS52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICBidXJ5IDEzCiAgICBkdXAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBidXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODY2CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykgewogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgNgoKZW50ZXJfd2hpbGVfdG9wQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg2NgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHsKICAgIGRpZyA1CiAgICBkaWcgOAogICAgPAogICAgYnogZW50ZXJfYWZ0ZXJfd2hpbGVAMjMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NjcKICAgIC8vIGFzc2VydChlbnRyaWVzW2ldLnF1YW50aXR5ID49IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLCAncXVhbnRpdHkgaXMgbGVzcyB0aGFuIG1pbmltdW0gc3Rha2UgYW1vdW50JykKICAgIGRpZyAxCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgcHVzaGludCAyIC8vIDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgdW5jb3ZlciAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZHVwCiAgICBidXJ5IDkKICAgIGRpZyAxMAogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMiAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICBkdXAKICAgIGJ1cnkgMTEKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBidXJ5IDYKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyBtaW5pbXVtU3Rha2VBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNaW5pbXVtU3Rha2VBbW91bnQgfSkKICAgIGJ5dGVjIDI1IC8vICJtaW5pbXVtX3N0YWtlX2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NjcKICAgIC8vIGFzc2VydChlbnRyaWVzW2ldLnF1YW50aXR5ID49IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLCAncXVhbnRpdHkgaXMgbGVzcyB0aGFuIG1pbmltdW0gc3Rha2UgYW1vdW50JykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+PQogICAgYXNzZXJ0IC8vIHF1YW50aXR5IGlzIGxlc3MgdGhhbiBtaW5pbXVtIHN0YWtlIGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg2OQogICAgLy8gaWYgKGFkZHJlc3MgIT09IEdsb2JhbC56ZXJvQWRkcmVzcykgewogICAgZGlnIDExCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODcwLTg3OQogICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhYmlDYWxsPHR5cGVvZiBNZXRhTWVya2xlcy5wcm90b3R5cGUudmVyaWZ5Pih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgc2hhMjU2KHNoYTI1NihpdG9iKGVudHJpZXNbaV0uYXNzZXQpKSksCiAgICAvLyAgICAgZW50cmllc1tpXS5wcm9vZiwKICAgIC8vICAgICBNRVJLTEVfVFJFRV9UWVBFX0FTU0VULAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzEKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODcxCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLm1ldGFNZXJrbGVzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3MQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5tZXRhTWVya2xlcywKICAgIHB1c2hpbnQgNzIgLy8gNzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODc1CiAgICAvLyBzaGEyNTYoc2hhMjU2KGl0b2IoZW50cmllc1tpXS5hc3NldCkpKSwKICAgIGRpZyAxMAogICAgZHVwCiAgICBleHRyYWN0IDAgOAogICAgc2hhMjU2CiAgICBzaGEyNTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4NzYKICAgIC8vIGVudHJpZXNbaV0ucHJvb2YsCiAgICBkaWcgMQogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyCiAgICBsZW4KICAgIHVuY292ZXIgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg3NwogICAgLy8gTUVSS0xFX1RSRUVfVFlQRV9BU1NFVCwKICAgIGludGNfMSAvLyAxCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODcwLTg3OQogICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhYmlDYWxsPHR5cGVvZiBNZXRhTWVya2xlcy5wcm90b3R5cGUudmVyaWZ5Pih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkubWV0YU1lcmtsZXMsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgc2hhMjU2KHNoYTI1NihpdG9iKGVudHJpZXNbaV0uYXNzZXQpKSksCiAgICAvLyAgICAgZW50cmllc1tpXS5wcm9vZiwKICAgIC8vICAgICBNRVJLTEVfVFJFRV9UWVBFX0FTU0VULAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDJiZjNjYzVhIC8vIG1ldGhvZCAidmVyaWZ5KGFkZHJlc3Msc3RyaW5nLGJ5dGVbMzJdLGJ5dGVbMzJdW10sdWludDY0KWJvb2wiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4MQogICAgLy8gYXNzZXJ0KHZlcmlmaWVkLCAnZmFpbGVkIHRvIHZlcmlmeSBzdGFrZSByZXF1aXJlbWVudHMnKQogICAgYXNzZXJ0IC8vIGZhaWxlZCB0byB2ZXJpZnkgc3Rha2UgcmVxdWlyZW1lbnRzCgplbnRlcl9hZnRlcl9pZl9lbHNlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4NgogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQgfHwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODg2CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDcgLy8gMHgwYQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4ODYtODg3CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBibnogZW50ZXJfaWZfYm9keUAxNgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4NwogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4NwogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4ODYtODg3CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCB8fAogICAgLy8gdGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUCiAgICBieiBlbnRlcl9hZnRlcl9pZl9lbHNlQDIxCgplbnRlcl9pZl9ib2R5QDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjg4OQogICAgLy8gY29uc3QgW2JhbGFuY2UsIG9wdGVkSW5dID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShUeG4uc2VuZGVyLCBlbnRyaWVzW2ldLmFzc2V0KQogICAgdHhuIFNlbmRlcgogICAgZGlnIDEwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgc3dhcAogICAgYnVyeSA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODkwCiAgICAvLyBhc3NlcnQob3B0ZWRJbiAmJiBiYWxhbmNlID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgbWluIGJhbGFuY2UnKQogICAgYnogZW50ZXJfYm9vbF9mYWxzZUAxOQogICAgZGlnIDYKICAgIGRpZyA1CiAgICA+PQogICAgYnogZW50ZXJfYm9vbF9mYWxzZUAxOQogICAgaW50Y18xIC8vIDEKCmVudGVyX2Jvb2xfbWVyZ2VAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODkwCiAgICAvLyBhc3NlcnQob3B0ZWRJbiAmJiBiYWxhbmNlID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgbWluIGJhbGFuY2UnKQogICAgYXNzZXJ0IC8vIHVzZXIgZG9lcyBub3QgaGF2ZSBtaW4gYmFsYW5jZQoKZW50ZXJfYWZ0ZXJfaWZfZWxzZUAyMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4OTMtOTAyCiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgfSwKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjgKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4OTYKICAgIC8vIFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk5CiAgICAvLyB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICBjYWxsc3ViIHN0YWtpbmdUeXBlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODk3LTkwMAogICAgLy8gewogICAgLy8gICBhc3NldDogZW50cmllc1tpXS5hc3NldCwKICAgIC8vICAgdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgLy8gfSwKICAgIGRpZyAxMgogICAgZXh0cmFjdCAwIDgKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo4OTMtOTAyCiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIFR4bi5zZW5kZXIsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgICAgICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyAgICAgfSwKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBieXRlYyAzMiAvLyBtZXRob2QgImdldEluZm8oYWRkcmVzcywodWludDY0LHVpbnQ4KSkodWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCAyNCAvLyAyNAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgcHVzaGludCA0IC8vIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MDQKICAgIC8vIGFzc2VydChzdGFrZUluZm8uYW1vdW50ID49IGVudHJpZXNbaV0ucXVhbnRpdHksICd1c2VyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHN0YWtlZCcpCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgPj0KICAgIGFzc2VydCAvLyB1c2VyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHN0YWtlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE3NQogICAgLy8gY29uc3QgaWQgPSB0aGlzLmVudHJ5SUQudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc1CiAgICAvLyBjb25zdCBpZCA9IHRoaXMuZW50cnlJRC52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNzYKICAgIC8vIHRoaXMuZW50cnlJRC52YWx1ZSArPSAxCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc2CiAgICAvLyB0aGlzLmVudHJ5SUQudmFsdWUgKz0gMQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MDgKICAgIC8vIGFkZHJlc3M6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTA3LTkxMwogICAgLy8gdGhpcy5lbnRyaWVzKGVudHJ5SUQpLnZhbHVlID0gewogICAgLy8gICBhZGRyZXNzOiBUeG4uc2VuZGVyLAogICAgLy8gICBhc3NldDogZW50cmllc1tpXS5hc3NldCwKICAgIC8vICAgcXVhbnRpdHk6IGVudHJpZXNbaV0ucXVhbnRpdHksCiAgICAvLyAgIGdhdGVBcmdzOiBjbG9uZShhcmdzKSwKICAgIC8vICAgZGlzcXVhbGlmaWVkOiBmYWxzZQogICAgLy8gfQogICAgZGlnIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwMzMwMAogICAgY29uY2F0CiAgICBkaWcgMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTA3CiAgICAvLyB0aGlzLmVudHJpZXMoZW50cnlJRCkudmFsdWUgPSB7CiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkwNy05MTMKICAgIC8vIHRoaXMuZW50cmllcyhlbnRyeUlEKS52YWx1ZSA9IHsKICAgIC8vICAgYWRkcmVzczogVHhuLnNlbmRlciwKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyAgIHF1YW50aXR5OiBlbnRyaWVzW2ldLnF1YW50aXR5LAogICAgLy8gICBnYXRlQXJnczogY2xvbmUoYXJncyksCiAgICAvLyAgIGRpc3F1YWxpZmllZDogZmFsc2UKICAgIC8vIH0KICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICB1bmNvdmVyIDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MTYKICAgIC8vIGFkZHJlc3M6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTE1LTkxOAogICAgLy8gY29uc3QgYUtleSA9IHsKICAgIC8vICAgYWRkcmVzczogVHhuLnNlbmRlciwKICAgIC8vICAgYXNzZXQ6IGVudHJpZXNbaV0uYXNzZXQsCiAgICAvLyB9CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkyMAogICAgLy8gdGhpcy5lbnRyaWVzQnlBZGRyZXNzKGFLZXkpLnZhbHVlID0gZW50cnlJRAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIHN3YXAKICAgIGV4dHJhY3QgMzIgOAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY1CiAgICAvLyBlbnRyaWVzQnlBZGRyZXNzID0gQm94TWFwPEVudHJ5S2V5LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllc0J5QWRkcmVzcyB9KQogICAgcHVzaGJ5dGVzICJhIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTIwCiAgICAvLyB0aGlzLmVudHJpZXNCeUFkZHJlc3MoYUtleSkudmFsdWUgPSBlbnRyeUlECiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIGVudGVyX3doaWxlX3RvcEAxMAoKZW50ZXJfYm9vbF9mYWxzZUAxOToKICAgIGludGNfMCAvLyAwCiAgICBiIGVudGVyX2Jvb2xfbWVyZ2VAMjAKCmVudGVyX2FmdGVyX3doaWxlQDIzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjgyOQogICAgLy8gZW50ZXIocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBlbnRyaWVzOiBTdGFrZUVudHJ5W10sIGFyZ3M6IEdhdGVBcmdzKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgplbnRlcl9ib29sX2ZhbHNlQDY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBlbnRlcl9ib29sX21lcmdlQDcKCmVudGVyX2FmdGVyX2lmX2Vsc2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE0OS0xNTIKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNTEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgMzMgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTQ5LTE1MgogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTM0CiAgICAvLyByZXR1cm4gb3JpZ2luT3Iod2FsbGV0SUQsIFR4bi5zZW5kZXIpCiAgICBiIGVudGVyX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6b3JpZ2luT3JAMzEKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnN0YXJ0RGlzYnVyc2VtZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKc3RhcnREaXNidXJzZW1lbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTI0CiAgICAvLyBzdGFydERpc2J1cnNlbWVudChyZXdhcmRJRDogdWludDY0KTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkyNQogICAgLy8gYXNzZXJ0KHRoaXMuaXNMaXZlKCksICd0aGUgcG9vbCBpcyBub3QgbGl2ZScpCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlCiAgICBhc3NlcnQgLy8gdGhlIHBvb2wgaXMgbm90IGxpdmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MjYKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDE5IC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MjYKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyByZXdhcmQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MjgKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGludGVydmFsLCBsYXN0RGlzYnVyc2VtZW50VGltZXN0YW1wLCBleHBpcmF0aW9uIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjUgLy8gMjUKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDIKICAgIHB1c2hpbnQgMTE2IC8vIDExNgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBjb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzMAogICAgLy8gYXNzZXJ0KHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZUlkbGUsICdyZXdhcmQgaXMgYWxyZWFkeSBpbiBhIGRpc2J1cnNlbWVudCBwaGFzZScpCiAgICBzd2FwCiAgICBieXRlY18zIC8vIDB4MDAKICAgID09CiAgICBhc3NlcnQgLy8gcmV3YXJkIGlzIGFscmVhZHkgaW4gYSBkaXNidXJzZW1lbnQgcGhhc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MTYKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gKChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJSBpbnRlcnZhbCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE4IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTE2CiAgICAvLyByZXR1cm4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtICgoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICUgaW50ZXJ2YWwpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLQogICAgdW5jb3ZlciAyCiAgICAlCiAgICAtCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MjEKICAgIC8vIHJldHVybiBsYXRlc3RXaW5kb3dTdGFydCAhPT0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAmJiBsYXN0IDwgbGF0ZXN0V2luZG93U3RhcnQKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgICE9CiAgICBieiBzdGFydERpc2J1cnNlbWVudF9ib29sX2ZhbHNlQDQKICAgIGRpZyAyCiAgICBkaWcgMQogICAgPAogICAgYnogc3RhcnREaXNidXJzZW1lbnRfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKc3RhcnREaXNidXJzZW1lbnRfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzMQogICAgLy8gYXNzZXJ0KHRoaXMudmFsaWRXaW5kb3coaW50ZXJ2YWwsIGxhc3REaXNidXJzZW1lbnRUaW1lc3RhbXApLCAnZGlzdHJpYnV0aW9uIHdpbmRvdyBpcyBub3Qgb3BlbicpCiAgICBhc3NlcnQgLy8gZGlzdHJpYnV0aW9uIHdpbmRvdyBpcyBub3Qgb3BlbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzNAogICAgLy8gYCR7dGhpcy50aXRsZS52YWx1ZX0gLSBSZXdhcmRzYCwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyB0aXRsZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRpdGxlIH0pCiAgICBieXRlYyAyNCAvLyAidGl0bGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTM0CiAgICAvLyBgJHt0aGlzLnRpdGxlLnZhbHVlfSAtIFJld2FyZHNgLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAiIC0gUmV3YXJkcyIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzNQogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MzYKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgKyBleHBpcmF0aW9uCiAgICBkdXAKICAgIGRpZyA0CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ4CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQ4CiAgICAvLyBjb25zdCByZXdhcmRzQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkucmV3YXJkcykKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU0OQogICAgLy8gY29uc3QgcmV3YXJkTUJSOiB1aW50NjQgPSBNaW5EaXNidXJzZW1lbnRzTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXModGl0bGUpLmxlbmd0aCkKICAgIGRpZyAzCiAgICBsZW4KICAgIGludGMgNiAvLyA0MDAKICAgIGRpZyAxCiAgICAqCiAgICBwdXNoaW50IDM1MzAwIC8vIDM1MzAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTUyCiAgICAvLyByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NTYtNTY1CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAnJywKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU1MS01NTQKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHJld2FyZE1CUiwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTU2LTU2NQogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZURpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgJycsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYwCiAgICAvLyB0aXRsZSwKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU2MQogICAgLy8gdGltZVRvVW5sb2NrLAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYyCiAgICAvLyBleHBpcmF0aW9uLAogICAgdW5jb3ZlciAzCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTYzCiAgICAvLyAnJywKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTU2LTU2NQogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZURpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgJycsCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MWM5ZWJiZGIgLy8gbWV0aG9kICJjcmVhdGVEaXNidXJzZW1lbnQocGF5LHN0cmluZyx1aW50NjQsdWludDY0LHN0cmluZyl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NjMKICAgIC8vICcnLAogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NTYtNTY1CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlRGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICAnJywKICAgIC8vICAgXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTM5CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlcnMgPSAwCiAgICBkaWcgNQogICAgZHVwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBkaWcgNAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NDAKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2UgPSAwCiAgICBkdXAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGRpZyA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5waGFzZSA9IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24KICAgIGR1cAogICAgcHVzaGludCA5MSAvLyA5MQogICAgYnl0ZWMgNyAvLyAweDBhCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgdW5jb3ZlciA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0MwogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRJRCA9IGRpc2J1cnNlbWVudElECiAgICBkdXAKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgdW5jb3ZlciAzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0NAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5hY3RpdmVEaXNidXJzZW1lbnRSb3VuZFN0YXJ0ID0gR2xvYmFsLnJvdW5kCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIGRpZyAxCiAgICBwdXNoaW50IDEwOCAvLyAxMDgKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NDUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUubGFzdERpc2J1cnNlbWVudFRpbWVzdGFtcCA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIHB1c2hpbnQgMTE2IC8vIDExNgogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5MjQKICAgIC8vIHN0YXJ0RGlzYnVyc2VtZW50KHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnN0YXJ0RGlzYnVyc2VtZW50X2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIHN0YXJ0RGlzYnVyc2VtZW50X2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKcmFmZmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0OAogICAgLy8gcmFmZmxlKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5kaXNidXJzZVJld2FyZHNbcm91dGluZ10oKSAtPiB2b2lkOgpkaXNidXJzZVJld2FyZHM6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA3CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5ODgKICAgIC8vIGRpc2J1cnNlUmV3YXJkcyhyZXdhcmRJRDogdWludDY0LCBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTAKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyByZXdhcmRzID0gQm94TWFwPHVpbnQ2NCwgUmV3YXJkPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeFJld2FyZHMgfSkKICAgIGJ5dGVjIDE5IC8vICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTAKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyByZXdhcmQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTIKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGRpc3RyaWJ1dGlvbiwgd2lubmluZ1RpY2tldHMgfSA9IGNsb25lKHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUpCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTUKICAgIC8vIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZVByZXBhcmF0aW9uIHx8CiAgICBieXRlYyA3IC8vIDB4MGEKICAgID09CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTUtOTk2CiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYm9vbF90cnVlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTYKICAgIC8vIHBoYXNlID09PSBEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24sCiAgICBkaWcgMgogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5OTUtOTk2CiAgICAvLyBwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbiB8fAogICAgLy8gcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ib29sX2ZhbHNlQDQKCmRpc2J1cnNlUmV3YXJkc19ib29sX3RydWVAMzoKICAgIGludGNfMSAvLyAxCgpkaXNidXJzZVJld2FyZHNfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk5NC05OTgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlUHJlcGFyYXRpb24gfHwKICAgIC8vICAgcGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwKICAgIC8vICAgRVJSX05PVF9SRUFEWV9UT19ESVNCVVJTRQogICAgLy8gKQogICAgYXNzZXJ0IC8vIE5vdCByZWFkeSB0byBkaXNidXJzZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMDAKICAgIC8vIGlmIChwaGFzZSA9PT0gRGlzYnVyc2VtZW50UGhhc2VQcmVwYXJhdGlvbikgewogICAgZHVwCiAgICBieiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMTgKICAgIC8vIGNvbnN0IHsgZGlzYnVyc2VtZW50Q3Vyc29yLCBkaXN0cmlidXRpb24sIHJhdGUsIGFzc2V0IH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkaWcgMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIyCiAgICBkdXAKICAgIGludGNfMiAvLyA4CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgNAogICAgZHVwCiAgICBwdXNoaW50IDkgLy8gOQogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDE1CiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDI4CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjE5CiAgICAvLyBsZXQgY291bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDI2CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjIwCiAgICAvLyBsZXQgdG90YWw6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjIyCiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGRpZyA1CiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyMgogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPgogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAOTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjMKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjMKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAyMAogICAgLQogICAgYnVyeSA1CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5MToKICAgIGRpZyAxOQogICAgYnVyeSAxNwoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA5MjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMjYKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZGlnIDE2CiAgICBkaWcgNQogICAgPAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDEwOQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyNwogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGdhdGVBcmdzLCBxdWFudGl0eSB9ID0gY2xvbmUodGhpcy5lbnRyaWVzKGlkKS52YWx1ZSkKICAgIGRpZyAxNgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDM1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI3CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgYWRkcmVzcywgZ2F0ZUFyZ3MsIHF1YW50aXR5IH0gPSBjbG9uZSh0aGlzLmVudHJpZXMoaWQpLnZhbHVlKQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZGlnIDEKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDIKICAgIGludGNfMCAvLyAwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBib3hfZXh0cmFjdAogICAgYnVyeSA0MwogICAgZGlnIDEKICAgIHB1c2hpbnQgNDggLy8gNDgKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgbGVuCiAgICB1bmNvdmVyIDMKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGJ1cnkgMzUKICAgIHN3YXAKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyOAogICAgLy8gaWYgKGRpc3F1YWxpZmllZCkgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19ibG9ja0AxMDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzAKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgPT09IFBPT0xfU1RBS0lOR19UWVBFX05PTkUpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTMwCiAgICAvLyBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMyAvLyAweDAwCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA5NwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzMQogICAgLy8gcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGJhbGFuY2U6IDAgfQogICAgcHVzaGJ5dGVzIDB4ODAwMDAwMDAwMDAwMDAwMDAwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmdldFN0YWtlVmFsdWVAMTAwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzMwogICAgLy8gY29uc3QgeyB2YWxpZCB9ID0gdGhpcy5nZXRTdGFrZVZhbHVlKGlkKQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzNAogICAgLy8gaWYgKCF2YWxpZCkgewogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzOAogICAgLy8gaWYgKHRoaXMuZ2F0ZUlELnZhbHVlICE9PSAwKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzOAogICAgLy8gaWYgKHRoaXMuZ2F0ZUlELnZhbHVlICE9PSAwKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjM5CiAgICAvLyBjb25zdCB3YWxsZXQgPSBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBhZGRyZXNzKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBkaWcgNDAKICAgIGNhbGxzdWIgZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPCiAgICBkdXAKICAgIGJ1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMjcKICAgIC8vIGlmICh3YWxsZXRJRC5pZCA9PT0gMCkgewogICAgYm56IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEyNwogICAgZGlnIDM5CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpvcmlnaW5PckAxMjg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQyCiAgICAvLyBjb25zdCBwYXNzZXMgPSBnYXRlQ2FsbChHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQsIG9yaWdpbiwgdGhpcy5nYXRlSUQudmFsdWUsIGdhdGVBcmdzKQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZ2F0ZUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5R2F0ZUlEIH0pCiAgICBieXRlYyA4IC8vICJnYXRlX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0MgogICAgLy8gY29uc3QgcGFzc2VzID0gZ2F0ZUNhbGwoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBvcmlnaW4sIHRoaXMuZ2F0ZUlELnZhbHVlLCBnYXRlQXJncykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBkaWcgMzUKICAgIGNhbGxzdWIgZ2F0ZUNhbGwKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0MwogICAgLy8gaWYgKCFwYXNzZXMpIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDQKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDQKICAgIC8vIGlmICh0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDcgLy8gMHgwYQogICAgIT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ibG9ja0AxMDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDUKICAgIC8vIHRoaXMuZW50cmllcyhpZCkudmFsdWUuZGlzcXVhbGlmaWVkID0gdHJ1ZQogICAgZGlnIDMzCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGludGNfMSAvLyAxCiAgICBzZXRiaXQKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCgpkaXNidXJzZVJld2FyZHNfYmxvY2tAMTA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyNgogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBkaWcgMTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDE3CiAgICBiIGRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BAOTIKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDEwNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTEKICAgIC8vIGNvdW50ICs9IDEKICAgIGRpZyAyNAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTIKICAgIC8vIHRvdGFsICs9IHF1YW50aXR5CiAgICBkaWcgOAogICAgZGlnIDE0CiAgICArCiAgICBidXJ5IDkKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDEwOAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNDktMTUyCiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTUxCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIGJ5dGVjIDMzIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE0OS0xNTIKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQwCiAgICAvLyBjb25zdCBvcmlnaW4gPSBvcmlnaW5Pcih3YWxsZXQsIGFkZHJlc3MpCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDEyOAoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUA5NzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzIKICAgIC8vIH0gZWxzZSBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTMyCiAgICAvLyB9IGVsc2UgaWYgKHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfSEVBUlRCRUFUKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWMgNyAvLyAweDBhCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAOTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzMKICAgIC8vIGNvbnN0IHsgYWRkcmVzcywgYXNzZXQgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGRpZyAzMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIHN3YXAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNS01MzgKICAgIC8vIGNvbnN0IGF2ZyA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLmdldEhlYXJ0YmVhdEF2ZXJhZ2U+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXQsIHRydWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNS01MzgKICAgIC8vIGNvbnN0IGF2ZyA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLmdldEhlYXJ0YmVhdEF2ZXJhZ2U+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXQsIHRydWVdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGM2ZmQwY2E1IC8vIG1ldGhvZCAiZ2V0SGVhcnRiZWF0QXZlcmFnZShhZGRyZXNzLHVpbnQ2NCxib29sKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUzNwogICAgLy8gYXJnczogW2FkZHJlc3MsIGFzc2V0LCB0cnVlXSwKICAgIGJ5dGVjIDE1IC8vIDB4ODAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MzUtNTM4CiAgICAvLyBjb25zdCBhdmcgPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRIZWFydGJlYXRBdmVyYWdlPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogW2FkZHJlc3MsIGFzc2V0LCB0cnVlXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTQwCiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogYXZnIH0KICAgIGl0b2IKICAgIGJ5dGVjIDE1IC8vIDB4ODAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzMwogICAgLy8gY29uc3QgeyB2YWxpZCB9ID0gdGhpcy5nZXRTdGFrZVZhbHVlKGlkKQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmdldFN0YWtlVmFsdWVAMTAwCgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5OToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1NDMKICAgIC8vIHJldHVybiB0aGlzLmNoZWNrQnlJRChpZCkKICAgIGRpZyAxNgogICAgY2FsbHN1YiBjaGVja0J5SUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMzMKICAgIC8vIGNvbnN0IHsgdmFsaWQgfSA9IHRoaXMuZ2V0U3Rha2VWYWx1ZShpZCkKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5nZXRTdGFrZVZhbHVlQDEwMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDEwOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2VycyArPSBjb3VudAogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCAzMyAvLyAzMwogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMjYKICAgICsKICAgIGl0b2IKICAgIGRpZyAxCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjU2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlICs9IHRvdGFsCiAgICBkdXAKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDEwCiAgICArCiAgICBpdG9iCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gZGlzYnVyc2VtZW50Q3Vyc29yKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gZGlzYnVyc2VtZW50Q3Vyc29yKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIwCiAgICA9PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjAKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucGhhc2UgPSBEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24KICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjIDExIC8vIDB4MTQKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjYxCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDkyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjYzCiAgICAvLyB0aGlzLnBheUFraXRhUm95YWx0eShkaXN0cmlidXRpb24sIHJhdGUsIGFzc2V0LCB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnF1YWxpZmllZFN0YWtlcnMpCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODgKICAgIC8vIGlmIChkaXN0cmlidXRpb24gPT09IERpc3RyaWJ1dGlvblR5cGVGbGF0KSB7CiAgICBkaWcgMQogICAgYnl0ZWMgMTEgLy8gMHgxNAogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTg5CiAgICAvLyBhbW91bnQgPSBjYWxjUGVyY2VudCgocXVhbGlmaWVkU3Rha2VycyAqIHJhdGUpLCB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSkKICAgIGRpZyAxNAogICAgZGlnIDEzCiAgICAqCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gYWtpdGFSb3lhbHR5ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5IH0pCiAgICBieXRlYyAyMiAvLyAiYWtpdGFfcm95YWx0eSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODkKICAgIC8vIGFtb3VudCA9IGNhbGNQZXJjZW50KChxdWFsaWZpZWRTdGFrZXJzICogcmF0ZSksIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTIKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjkzCiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIHApLCBESVZJU09SKQogICAgbXVsdwogICAgaW50YyA0IC8vIDEwMDAwMAogICAgZGl2dwogICAgYnVyeSAyOAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NAogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBieXRlYyAyMCAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTk0CiAgICAvLyB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZSA9IGFtb3VudAogICAgZGlnIDI4CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5NwogICAgLy8gaWYgKGFzc2V0ID09PSAwKSB7CiAgICBkaWcgMjYKICAgIGJueiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDExNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5OC0yMDMKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMDAKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGRpZyAyOAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxOTgtMjAyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxOTgtMjAzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTg4CiAgICAvLyBkaXNidXJzZVJld2FyZHMocmV3YXJkSUQ6IHVpbnQ2NCwgaXRlcmF0aW9uQW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMTE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIwNQogICAgLy8gYXNzZXJ0KEdsb2JhbC56ZXJvQWRkcmVzcy5pc09wdGVkSW4oQXNzZXQoYXNzZXQpKSwgRVJSX0RBT19OT1RfT1BURURfSU4pCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIGRpZyAyNwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIERBTyBub3Qgb3B0ZWQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA3LTIxMwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA5CiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMjgKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIwNy0yMTIKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA3LTIxMwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2Vsc2VfYm9keUAxMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyBhbW91bnQgPSBjYWxjUGVyY2VudChyYXRlLCB0aGlzLmFraXRhUm95YWx0eS52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBha2l0YVJveWFsdHkgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHkgfSkKICAgIGJ5dGVjIDIyIC8vICJha2l0YV9yb3lhbHR5IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gYW1vdW50ID0gY2FsY1BlcmNlbnQocmF0ZSwgdGhpcy5ha2l0YVJveWFsdHkudmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5MgogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGR1cAogICAgaW50YyA0IC8vIDEwMDAwMAogICAgPD0KICAgIGFzc2VydCAvLyBJbnZhbGlkIHBlcmNlbnRhZ2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTMKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBkaWcgMTMKICAgIG11bHcKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIGRpdncKICAgIGJ1cnkgMjgKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTEzCgpkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDExNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjYKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yICs9IGl0ZXJhdGlvbkFtb3VudAogICAgZGlnIDMKICAgIGR1cAogICAgaW50Y18zIC8vIDkyCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyA2CiAgICArCiAgICBpdG9iCiAgICBpbnRjXzMgLy8gOTIKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwNAogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZTogewogICAgZGlnIDEKICAgIGJ5dGVjIDcgLy8gMHgwYQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDA0LTEwMDcKICAgIC8vIGNhc2UgRGlzdHJpYnV0aW9uVHlwZVBlcmNlbnRhZ2U6IHsKICAgIC8vICAgdGhpcy5jcmVhdGVQZXJjZW50YWdlRGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICAvLyAgIGJyZWFrCiAgICAvLyB9CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI3NwogICAgLy8gfSA9IHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUKICAgIGRpZyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMjgKICAgIGR1cAogICAgaW50Y18zIC8vIDkyCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAyMgogICAgZHVwCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAzNAogICAgZHVwCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMTgKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGJ1cnkgMjkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNzkKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZGlnIDUKICAgICsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjc5CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA3OQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MAogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MAogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIwCiAgICAtCiAgICBidXJ5IDUKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDc5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MwogICAgLy8gY29uc3QgYWN0dWFsQW1vdW50OiB1aW50NjQgPSBhbW91bnQgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTQKICAgIC8vIGFraXRhUm95YWx0eUFtb3VudCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eUFtb3VudCB9KQogICAgYnl0ZWMgMjAgLy8gImFraXRhX3JveWFsdHlfYW1vdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MwogICAgLy8gY29uc3QgYWN0dWFsQW1vdW50OiB1aW50NjQgPSBhbW91bnQgLSB0aGlzLmFraXRhUm95YWx0eUFtb3VudC52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAyOAogICAgc3dhcAogICAgLQogICAgYnVyeSAzMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4NAogICAgLy8gbGV0IGFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbltdID0gW10KICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBidXJ5IDM5CiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgYnVyeSAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4NQogICAgLy8gbGV0IHN1bTogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMTEKICAgIGRpZyAxOQogICAgYnVyeSAxNwoKZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA4MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODcKICAgIC8vIGZvciAobGV0IGlkID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpZCA8IGl0ZXJhdGlvbkFtb3VudDsgaWQrKykgewogICAgZGlnIDE2CiAgICBkaWcgNQogICAgPAogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDg1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg4CiAgICAvLyBjb25zdCB7IGRpc3F1YWxpZmllZCwgcXVhbnRpdHksIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGRpZyAxNgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4OAogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIHF1YW50aXR5LCBhZGRyZXNzIH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAxNgogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICBidXJ5IDQxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjg5CiAgICAvLyBpZiAoZGlzcXVhbGlmaWVkKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDg0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk3CiAgICAvLyBhc3NlcnQoYSA8IGIsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0VfT0ZfQVJHUykKICAgIGRpZyAxMwogICAgZHVwCiAgICBkaWcgMTcKICAgIGR1cAogICAgY292ZXIgMwogICAgPAogICAgYXNzZXJ0IC8vIEludmFsaWQgcGVyY2VudGFnZSBvZiBhcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk4CiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIERJVklTT1IpLCBiKQogICAgaW50YyA0IC8vIDEwMDAwMAogICAgbXVsdwogICAgdW5jb3ZlciAyCiAgICBkaXZ3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjkyCiAgICAvLyBhc3NlcnQocCA8PSBESVZJU09SLCBFUlJfSU5WQUxJRF9QRVJDRU5UQUdFKQogICAgZHVwCiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGVyY2VudGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5MwogICAgLy8gcmV0dXJuIG9wLmRpdncoLi4ub3AubXVsdyhhLCBwKSwgRElWSVNPUikKICAgIGRpZyAzMQogICAgbXVsdwogICAgaW50YyA0IC8vIDEwMDAwMAogICAgZGl2dwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI5NAogICAgLy8gYWxsb2NhdGlvbnMucHVzaCh7IGFkZHJlc3MsIGFtb3VudDogaW5kaXZpZHVhbEFtb3VudCB9KQogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgNDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDM2CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgYnVyeSAzNgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI5NQogICAgLy8gc3VtICs9IGluZGl2aWR1YWxBbW91bnQKICAgIGRpZyAxMQogICAgKwogICAgYnVyeSAxMQoKZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDg0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4NwogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBkaWcgMTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDE3CiAgICBiIGRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BAODAKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl93aGlsZUA4NToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOTgKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yICs9IGl0ZXJhdGlvbkFtb3VudAogICAgZGlnIDMKICAgIGR1cAogICAgaW50Y18zIC8vIDkyCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyA2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgICsKICAgIGl0b2IKICAgIGludGNfMyAvLyA5MgogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMDAKICAgIC8vIHRoaXMuY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMoYWN0aXZlRGlzYnVyc2VtZW50SUQsIGFzc2V0LCBhbGxvY2F0aW9ucywgc3VtKQogICAgZGlnIDMyCiAgICBkaWcgMjgKICAgIGRpZyAzNwogICAgZGlnIDE0CiAgICBjYWxsc3ViIGNyZWF0ZVJld2FyZEFsbG9jYXRpb25zCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMDIKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMwMgogICAgLy8gaWYgKHRoaXMuZW50cnlJRC52YWx1ZSA9PT0gKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMjEKICAgIHVuY292ZXIgMgogICAgKwogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzAzCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzA0CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDQwCiAgICBib3hfcmVwbGFjZQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwOAogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlRmxhdDogewogICAgZGlnIDEKICAgIGJ5dGVjIDExIC8vIDB4MTQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAwOC0xMDExCiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVGbGF0OiB7CiAgICAvLyAgIHRoaXMuY3JlYXRlRmxhdERpc2J1cnNlbWVudChyZXdhcmRJRCwgaXRlcmF0aW9uQW1vdW50KQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTUKICAgIC8vIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkaWcgMwogICAgZHVwCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAzMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIyCiAgICBkdXAKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIHVuY292ZXIgMgogICAgaW50Y18wIC8vIDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBidXJ5IDMxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzE3CiAgICAvLyBjb25zdCB0b3RhbDogdWludDY0ID0gKHF1YWxpZmllZFN0YWtlcnMgKiBhbW91bnQpIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIHN3YXAKICAgIGRpZyAxCiAgICAqCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NAogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBieXRlYyAyMCAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzE3CiAgICAvLyBjb25zdCB0b3RhbDogdWludDY0ID0gKHF1YWxpZmllZFN0YWtlcnMgKiBhbW91bnQpIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzE4CiAgICAvLyBjb25zdCBwZXJjZW50YWdlQWtpdGFGZWUgPSBjYWxjUGVyY2VudChhbW91bnQsIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTIKICAgIC8vIGFraXRhUm95YWx0eSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFraXRhUm95YWx0eSB9KQogICAgYnl0ZWMgMjIgLy8gImFraXRhX3JveWFsdHkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzE4CiAgICAvLyBjb25zdCBwZXJjZW50YWdlQWtpdGFGZWUgPSBjYWxjUGVyY2VudChhbW91bnQsIHRoaXMuYWtpdGFSb3lhbHR5LnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTIKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjkzCiAgICAvLyByZXR1cm4gb3AuZGl2dyguLi5vcC5tdWx3KGEsIHApLCBESVZJU09SKQogICAgZGlnIDIKICAgIG11bHcKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMTkKICAgIC8vIGNvbnN0IGFkanVzdGVkQW1vdW50OiB1aW50NjQgPSBhbW91bnQgLSBwZXJjZW50YWdlQWtpdGFGZWUKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgLQogICAgYnVyeSAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyMAogICAgLy8gY29uc3QgW2JhbGFuY2VdID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgYXNzZXQpCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgdW5jb3ZlciAyCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyMgogICAgLy8gYXNzZXJ0KGJhbGFuY2UgPj0gdG90YWwsIEVSUl9OT1RfRU5PVUdIX0ZVTkRTKQogICAgPD0KICAgIGFzc2VydCAvLyBOb3QgZW5vdWdoIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGRpZyA1CiAgICArCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMyNAogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPgogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMjUKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMjUKICAgIC8vIGl0ZXJhdGlvbkFtb3VudCA9IHRoaXMuZW50cnlJRC52YWx1ZSAtIGRpc2J1cnNlbWVudEN1cnNvcgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAyMAogICAgLQogICAgYnVyeSA1CgpkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA2NzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMjgKICAgIC8vIGxldCBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgYnVyeSAzOAogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGJ1cnkgMzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMjkKICAgIC8vIGxldCBzdW06IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDExCiAgICBkaWcgMTkKICAgIGJ1cnkgMTcKCmRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BANjg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzMxCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgZGlnIDUKICAgIDwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl93aGlsZUA3MwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzMgogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGRpZyAxNgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZW50cmllcyA9IEJveE1hcDx1aW50NjQsIEVudHJ5RGF0YT4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhFbnRyaWVzIH0pCiAgICBieXRlYyAxMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMzMgogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MgfSA9IHRoaXMuZW50cmllcyhpZCkudmFsdWUKICAgIGR1cAogICAgcHVzaGludCA1MCAvLyA1MAogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgNDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMzMKICAgIC8vIGlmIChkaXNxdWFsaWZpZWQpIHsKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYmxvY2tANzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMzcKICAgIC8vIGFsbG9jYXRpb25zLnB1c2goeyBhZGRyZXNzLCBhbW91bnQ6IGFkanVzdGVkQW1vdW50IH0pCiAgICBkaWcgMjgKICAgIGR1cAogICAgaXRvYgogICAgZGlnIDQxCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyAzNgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMzYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMzgKICAgIC8vIHN1bSArPSBhZGp1c3RlZEFtb3VudAogICAgZGlnIDExCiAgICArCiAgICBidXJ5IDExCgpkaXNidXJzZVJld2FyZHNfYmxvY2tANzI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzMxCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA2OAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDczOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM0MQogICAgLy8gY29uc3QgbmV3Q3Vyc29yVmFsdWU6IHVpbnQ2NCA9IGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudAogICAgZGlnIDE5CiAgICBkaWcgNQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM0MgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSBuZXdDdXJzb3JWYWx1ZQogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgNQogICAgaW50Y18zIC8vIDkyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQzCiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGRpZyAzMgogICAgZGlnIDI4CiAgICBkaWcgMzcKICAgIGRpZyAxNAogICAgY2FsbHN1YiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQ1CiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSBuZXdDdXJzb3JWYWx1ZSkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNDUKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IG5ld0N1cnNvclZhbHVlKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQ2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzQ3CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDM5CiAgICBib3hfcmVwbGFjZQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAxMgogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlRXZlbjogewogICAgZGlnIDEKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAxMi0xMDE1CiAgICAvLyBjYXNlIERpc3RyaWJ1dGlvblR5cGVFdmVuOiB7CiAgICAvLyAgIHRoaXMuY3JlYXRlRXZlbkRpc2J1cnNlbWVudChyZXdhcmRJRCwgaXRlcmF0aW9uQW1vdW50KQogICAgLy8gICBicmVhawogICAgLy8gfQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNTgKICAgIC8vIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkaWcgMwogICAgZHVwCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAzMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIyCiAgICBkdXAKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAxNwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMzAKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2MAogICAgLy8gY29uc3QgYmFsYW5jZSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2UoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsIGFzc2V0KVswXQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzYxCiAgICAvLyBjb25zdCBhY3R1YWxTdW06IHVpbnQ2NCA9IHN1bSAtIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1NAogICAgLy8gYWtpdGFSb3lhbHR5QW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5QWtpdGFSb3lhbHR5QW1vdW50IH0pCiAgICBieXRlYyAyMCAvLyAiYWtpdGFfcm95YWx0eV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzYxCiAgICAvLyBjb25zdCBhY3R1YWxTdW06IHVpbnQ2NCA9IHN1bSAtIHRoaXMuYWtpdGFSb3lhbHR5QW1vdW50LnZhbHVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICAtCiAgICBkdXAKICAgIGJ1cnkgMzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNjIKICAgIC8vIGFzc2VydChiYWxhbmNlID49IGFjdHVhbFN1bSwgRVJSX05PVF9FTk9VR0hfRlVORFMpCiAgICA+PQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggZnVuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNjQKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgZGlnIDUKICAgICsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzY0CiAgICAvLyBpZiAoKGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudCkgPiB0aGlzLmVudHJ5SUQudmFsdWUpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA1NQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2NQogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2NQogICAgLy8gaXRlcmF0aW9uQW1vdW50ID0gdGhpcy5lbnRyeUlELnZhbHVlIC0gZGlzYnVyc2VtZW50Q3Vyc29yCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIwCiAgICAtCiAgICBidXJ5IDUKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDU1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2OAogICAgLy8gY29uc3QgYW1vdW50OiB1aW50NjQgPSBhY3R1YWxTdW0gLyBxdWFsaWZpZWRTdGFrZXJzCiAgICBkaWcgMjkKICAgIGRpZyAxNQogICAgLwogICAgYnVyeSAyOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM2OQogICAgLy8gbGV0IGFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbltdID0gW10KICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBidXJ5IDM3CiAgICBieXRlYyA2IC8vIDB4MDAwMAogICAgYnVyeSAzNQogICAgZGlnIDE5CiAgICBidXJ5IDE3CgpkaXNidXJzZVJld2FyZHNfd2hpbGVfdG9wQDU2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3MAogICAgLy8gZm9yIChsZXQgaWQgPSBkaXNidXJzZW1lbnRDdXJzb3I7IGlkIDwgaXRlcmF0aW9uQW1vdW50OyBpZCsrKSB7CiAgICBkaWcgMTYKICAgIGRpZyA1CiAgICA8CiAgICBieiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfd2hpbGVANjEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNzEKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzIH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBkaWcgMTYKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjEKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgMTIgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNzEKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzIH0gPSB0aGlzLmVudHJpZXMoaWQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICBidXJ5IDQxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzcyCiAgICAvLyBpZiAoZGlzcXVhbGlmaWVkKSB7CiAgICBibnogZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDYwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzc2CiAgICAvLyBhbGxvY2F0aW9ucy5wdXNoKHsgYWRkcmVzcywgYW1vdW50IH0pCiAgICBkaWcgMjcKICAgIGl0b2IKICAgIGRpZyA0MAogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMzUKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBidXJ5IDM1CgpkaXNidXJzZVJld2FyZHNfYmxvY2tANjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzcwCiAgICAvLyBmb3IgKGxldCBpZCA9IGRpc2J1cnNlbWVudEN1cnNvcjsgaWQgPCBpdGVyYXRpb25BbW91bnQ7IGlkKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEA1NgoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX3doaWxlQDYxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3OQogICAgLy8gY29uc3QgbmV3Q3Vyc29yVmFsdWU6IHVpbnQ2NCA9IGRpc2J1cnNlbWVudEN1cnNvciArIGl0ZXJhdGlvbkFtb3VudAogICAgZGlnIDE5CiAgICBkaWcgNQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM4MAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSBuZXdDdXJzb3JWYWx1ZQogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgNQogICAgaW50Y18zIC8vIDkyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzgxCiAgICAvLyB0aGlzLmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zKGFjdGl2ZURpc2J1cnNlbWVudElELCBhc3NldCwgYWxsb2NhdGlvbnMsIHN1bSkKICAgIGRpZyAzMgogICAgZGlnIDI4CiAgICBkaWcgMzcKICAgIGRpZyAxNAogICAgY2FsbHN1YiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MzgzCiAgICAvLyBpZiAodGhpcy5lbnRyeUlELnZhbHVlID09PSBuZXdDdXJzb3JWYWx1ZSkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozODMKICAgIC8vIGlmICh0aGlzLmVudHJ5SUQudmFsdWUgPT09IG5ld0N1cnNvclZhbHVlKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzg0CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mzg1CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDM4CiAgICBib3hfcmVwbGFjZQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAxNgogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlU2h1ZmZsZTogewogICAgZGlnIDEKICAgIHB1c2hieXRlcyAweDI4CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMTYtMTAyMwogICAgLy8gY2FzZSBEaXN0cmlidXRpb25UeXBlU2h1ZmZsZTogewogICAgLy8gICBpZiAod2lubmluZ1RpY2tldHMubGVuZ3RoID09PSAwKSB7CiAgICAvLyAgICAgdGhpcy5yYWZmbGUocmV3YXJkSUQpCiAgICAvLyAgIH0gZWxzZSB7CiAgICAvLyAgICAgdGhpcy5jcmVhdGVTaHVmZmxlRGlzYnVyc2VtZW50KHJld2FyZElELCBpdGVyYXRpb25BbW91bnQpCiAgICAvLyAgIH0KICAgIC8vICAgYnJlYWsKICAgIC8vIH0KICAgIGFzc2VydCAvLyB1bmtub3duIHJld2FyZCByYXRlIHR5cGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE3CiAgICAvLyBpZiAod2lubmluZ1RpY2tldHMubGVuZ3RoID09PSAwKSB7CiAgICBkaWcgMwogICAgcHVzaGludHMgMTI0IDIgLy8gMTI0LCAyCiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYm56IGRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlAMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDE4CiAgICAvLyB0aGlzLnJhZmZsZShyZXdhcmRJRCkKICAgIGRpZyA1CiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlCiAgICBiIGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMwCgpkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDI0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM5OAogICAgLy8gfSA9IGNsb25lKHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUpCiAgICBkaWcgMwogICAgZHVwCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAzMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIyCiAgICBkdXAKICAgIHB1c2hpbnQgNDkgLy8gNDkKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSA5CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAzMAogICAgcHVzaGludCA5IC8vIDkKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDAwCiAgICAvLyBjb25zdCBiYWxhbmNlID0gQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgYXNzZXQpWzBdCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDEKICAgIC8vIGNvbnN0IGFjdHVhbFN1bTogdWludDY0ID0gc3VtIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBha2l0YVJveWFsdHlBbW91bnQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlBa2l0YVJveWFsdHlBbW91bnQgfSkKICAgIGJ5dGVjIDIwIC8vICJha2l0YV9yb3lhbHR5X2Ftb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDEKICAgIC8vIGNvbnN0IGFjdHVhbFN1bTogdWludDY0ID0gc3VtIC0gdGhpcy5ha2l0YVJveWFsdHlBbW91bnQudmFsdWUKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIGR1cAogICAgYnVyeSAzMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQwMgogICAgLy8gYXNzZXJ0KGJhbGFuY2UgPj0gYWN0dWFsU3VtLCBFUlJfTk9UX0VOT1VHSF9GVU5EUykKICAgID49CiAgICBhc3NlcnQgLy8gTm90IGVub3VnaCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQwNAogICAgLy8gaWYgKChkaXNidXJzZW1lbnRDdXJzb3IgKyBpdGVyYXRpb25BbW91bnQpID4gdGhpcy5lbnRyeUlELnZhbHVlKSB7CiAgICBkaWcgNQogICAgKwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjkKICAgIC8vIGVudHJ5SUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlFbnRyeUNvdW50IH0pCiAgICBieXRlY18xIC8vICJlbnRyeV9jb3VudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MDQKICAgIC8vIGlmICgoZGlzYnVyc2VtZW50Q3Vyc29yICsgaXRlcmF0aW9uQW1vdW50KSA+IHRoaXMuZW50cnlJRC52YWx1ZSkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID4KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDMzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDA1CiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBlbnRyeUlEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5RW50cnlDb3VudCB9KQogICAgYnl0ZWNfMSAvLyAiZW50cnlfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDA1CiAgICAvLyBpdGVyYXRpb25BbW91bnQgPSB0aGlzLmVudHJ5SUQudmFsdWUgLSBkaXNidXJzZW1lbnRDdXJzb3IKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMjAKICAgIC0KICAgIGJ1cnkgNQoKZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDA5CiAgICAvLyBpZiAod2lubmVyQ291bnQgPiAwKSB7CiAgICBkaWcgNgogICAgYm56IGRpc2J1cnNlUmV3YXJkc19pZl9ib2R5QDM0CiAgICBkaWcgMjkKICAgIGJ1cnkgMjgKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDM1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQxMwogICAgLy8gbGV0IHsgc3Rha2UsIHRpY2tldCwgZGlzYnVyc2VkIH0gPSByYWZmbGVDdXJzb3IKICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnRzIDU5IDI0IC8vIDU5LCAyNAogICAgYm94X2V4dHJhY3QKICAgIGR1cAogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGJ1cnkgMTUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgMTQKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDI0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE0CiAgICAvLyBsZXQgY3VycmVudFRpY2tldCA9IHRpY2tldHNbdGlja2V0XQogICAgaW50Y18yIC8vIDgKICAgICoKICAgIHB1c2hpbnQgMTI2IC8vIDEyNgogICAgKwogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE4CiAgICAvLyBsZXQgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10gPSBbXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGJ1cnkgMzcKICAgIGJ5dGVjIDYgLy8gMHgwMDAwCiAgICBidXJ5IDM2CiAgICBidXJ5IDIzCiAgICBkaWcgMTkKICAgIGJ1cnkgMTgKCmRpc2J1cnNlUmV3YXJkc193aGlsZV90b3BAMzY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE5CiAgICAvLyBmb3IgKGxldCBpID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpIDwgaXRlcmF0aW9uQW1vdW50OyBpKyspIHsKICAgIGRpZyAxNwogICAgZGlnIDUKICAgIDwKICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A0OAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyMAogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGFzc2V0LCBxdWFudGl0eSB9ID0gdGhpcy5lbnRyaWVzKGkpLnZhbHVlCiAgICBkaWcgMTcKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjEKICAgIC8vIGVudHJpZXMgPSBCb3hNYXA8dWludDY0LCBFbnRyeURhdGE+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllcyB9KQogICAgYnl0ZWMgMTIgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MjAKICAgIC8vIGNvbnN0IHsgZGlzcXVhbGlmaWVkLCBhZGRyZXNzLCBhc3NldCwgcXVhbnRpdHkgfSA9IHRoaXMuZW50cmllcyhpKS52YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGJ1cnkgMjAKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICBidXJ5IDQxCiAgICBkdXAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAyNwogICAgcHVzaGludCA0MCAvLyA0MAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDIyCiAgICAvLyBjdXJyZW50UmFuZ2VFbmQgPSBjdXJyZW50UmFuZ2VTdGFydCArIHF1YW50aXR5CiAgICBkaWcgMjMKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICArCiAgICBidXJ5IDI1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDIzCiAgICAvLyBpZiAoY3VycmVudFRpY2tldCA+PSBjdXJyZW50UmFuZ2VTdGFydCAmJiBjdXJyZW50VGlja2V0IDw9IGN1cnJlbnRSYW5nZUVuZCkgewogICAgZGlnIDIyCiAgICA8PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDYKICAgIGRpZyAyMQogICAgZGlnIDI0CiAgICA8PQogICAgYnogZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MjQKICAgIC8vIGlmICghZGlzcXVhbGlmaWVkKSB7CiAgICBkaWcgMTgKICAgIGJueiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA0MQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyNQogICAgLy8gYWxsb2NhdGlvbnMucHVzaCh7IGFkZHJlc3MsIGFtb3VudCB9KQogICAgZGlnIDI3CiAgICBpdG9iCiAgICBkaWcgNDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDM1CiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgYnVyeSAzNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyNgogICAgLy8gZGlzYnVyc2VkKysKICAgIGRpZyAyMAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMjEKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQyOQogICAgLy8gaWYgKHRpY2tldCA9PT0gdGlja2V0cy5sZW5ndGggLSAxKSB7CiAgICBkaWcgMwogICAgcHVzaGludHMgMTI0IDIgLy8gMTI0LCAyCiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGRpZyAxMAogICAgPT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQ1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDMxCiAgICAvLyBpZiAod2lubmVyQ291bnQgIT09IGRpc2J1cnNlZCkgewogICAgZGlnIDYKICAgIGRpZyAyMQogICAgIT0KICAgIGJ6IGRpc2J1cnNlUmV3YXJkc19ibG9ja0A0OAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzMgogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBkaWcgMwogICAgZHVwCiAgICBpbnRjXzMgLy8gOTIKICAgIGRpZyAzOAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MzMtNDM3CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnJhZmZsZUN1cnNvciA9IHsKICAgIC8vICAgdGlja2V0OiAwLAogICAgLy8gICBzdGFrZTogMCwKICAgIC8vICAgZGlzYnVyc2VkOiAwLAogICAgLy8gfQogICAgZHVwCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBieXRlYyAzNCAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0MzgKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUud2lubmluZ1RpY2tldHMgPSBbXQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGR1cAogICAgcHVzaGludCA1NyAvLyA1NwogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICBleHRyYWN0MwogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGNvbmNhdAogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzOQogICAgLy8gdGhpcy5jcmVhdGVSZXdhcmRBbGxvY2F0aW9ucyhhY3RpdmVEaXNidXJzZW1lbnRJRCwgYXNzZXQsIGFsbG9jYXRpb25zLCBzdW0pCiAgICBkaWcgMzEKICAgIGRpZyAyNgogICAgZGlnIDM2CiAgICBkaWcgMTMKICAgIGNhbGxzdWIgY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMjAKICAgIC8vIHRoaXMuY3JlYXRlU2h1ZmZsZURpc2J1cnNlbWVudChyZXdhcmRJRCwgaXRlcmF0aW9uQW1vdW50KQogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzMAoKZGlzYnVyc2VSZXdhcmRzX2Jsb2NrQDQ4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1NgogICAgLy8gdGhpcy5jcmVhdGVSZXdhcmRBbGxvY2F0aW9ucyhhY3RpdmVEaXNidXJzZW1lbnRJRCwgYXNzZXQsIGFsbG9jYXRpb25zLCBzdW0pCiAgICBkaWcgMzEKICAgIGRpZyAyNwogICAgZGlnIDM2CiAgICBkaWcgMTMKICAgIGNhbGxzdWIgY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnMKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1OAogICAgLy8gaWYgKHdpbm5lckNvdW50ID09PSBkaXNidXJzZWQpIHsKICAgIGRpZyA2CiAgICBkaWcgMjEKICAgID09CiAgICBieiBkaXNidXJzZVJld2FyZHNfZWxzZV9ib2R5QDUwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDU5CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGRpZyAzCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjIDEzIC8vIDB4MWUKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDYwCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciA9IDAKICAgIGR1cAogICAgaW50Y18zIC8vIDkyCiAgICBkaWcgMzgKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDYxLTQ2NQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5yYWZmbGVDdXJzb3IgPSB7CiAgICAvLyAgIHRpY2tldDogMCwKICAgIC8vICAgc3Rha2U6IDAsCiAgICAvLyAgIGRpc2J1cnNlZDogMCwKICAgIC8vIH0KICAgIGR1cAogICAgcHVzaGludCA1OSAvLyA1OQogICAgYnl0ZWMgMzQgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDY2CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLndpbm5pbmdUaWNrZXRzID0gW10KICAgIGR1cAogICAgYm94X2dldAogICAgcG9wCiAgICBkdXAKICAgIHB1c2hpbnQgNTcgLy8gNTcKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgZXh0cmFjdDMKICAgIGJ5dGVjIDYgLy8gMHgwMDAwCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKCmRpc2J1cnNlUmV3YXJkc19lbHNlX2JvZHlANTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDY4CiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmRpc2J1cnNlbWVudEN1cnNvciArPSBpdGVyYXRpb25BbW91bnQKICAgIGRpZyAzCiAgICBkdXAKICAgIGludGNfMyAvLyA5MgogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgNgogICAgKwogICAgaXRvYgogICAgZGlnIDEKICAgIGludGNfMyAvLyA5MgogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ2OQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5yYWZmbGVDdXJzb3IgPSB7IHRpY2tldCwgc3Rha2UsIGRpc2J1cnNlZCB9CiAgICBkaWcgMTAKICAgIGl0b2IKICAgIGRpZyAxMwogICAgaXRvYgogICAgY29uY2F0CiAgICBkaWcgMjIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgcHVzaGludCA1OSAvLyA1OQogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIGIgZGlzYnVyc2VSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMzAKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQ1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ0NQogICAgLy8gaXRlcmF0aW9uQW1vdW50IC09IGkKICAgIGRpZyA0CiAgICBkaWcgMTgKICAgIC0KICAgIGJ1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ0NgogICAgLy8gdGlja2V0KysKICAgIGRpZyA5CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZHVwCiAgICBidXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDQ3CiAgICAvLyBjdXJyZW50VGlja2V0ID0gdGlja2V0c1t0aWNrZXRdCiAgICBpbnRjXzIgLy8gOAogICAgKgogICAgcHVzaGludCAxMjYgLy8gMTI2CiAgICArCiAgICBkaWcgNAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgYnVyeSAyMwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ0OAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5kaXNidXJzZW1lbnRDdXJzb3IgPSAwCiAgICBpbnRjXzMgLy8gOTIKICAgIGRpZyAzNwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NDkKICAgIC8vIGkgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxOAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1MAogICAgLy8gc3Rha2UgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1MQogICAgLy8gY3VycmVudFJhbmdlRW5kID0gMAogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMjQKCmRpc2J1cnNlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDQ2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ1MwogICAgLy8gY3VycmVudFJhbmdlU3RhcnQgPSBjdXJyZW50UmFuZ2VFbmQgKyAxCiAgICBkaWcgMjMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDE5CiAgICAvLyBmb3IgKGxldCBpID0gZGlzYnVyc2VtZW50Q3Vyc29yOyBpIDwgaXRlcmF0aW9uQW1vdW50OyBpKyspIHsKICAgIGRpZyAxNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTgKICAgIGIgZGlzYnVyc2VSZXdhcmRzX3doaWxlX3RvcEAzNgoKZGlzYnVyc2VSZXdhcmRzX2lmX2JvZHlAMzQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDEwCiAgICAvLyBhbW91bnQgPSBhY3R1YWxTdW0gLyB3aW5uZXJDb3VudAogICAgZGlnIDI5CiAgICBkaWcgNwogICAgLwogICAgYnVyeSAyOAogICAgYiBkaXNidXJzZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAzNQoKZGlzYnVyc2VSZXdhcmRzX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGRpc2J1cnNlUmV3YXJkc19ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmZpbmFsaXplRGlzdHJpYnV0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKZmluYWxpemVEaXN0cmlidXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAzMQogICAgLy8gZmluYWxpemVEaXN0cmlidXRpb24ocmV3YXJkSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDMyCiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRzKHJld2FyZElEKS5leGlzdHMsICdyZXdhcmQgZG9lcyBub3QgZXhpc3QnKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2NwogICAgLy8gcmV3YXJkcyA9IEJveE1hcDx1aW50NjQsIFJld2FyZD4oeyBrZXlQcmVmaXg6IFBvb2xCb3hQcmVmaXhSZXdhcmRzIH0pCiAgICBieXRlYyAxOSAvLyAiciIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMzIKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHJld2FyZCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMzMKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGFjdGl2ZURpc2J1cnNlbWVudElEIH0gPSB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZGlnIDEKICAgIHB1c2hpbnQgMTAwIC8vIDEwMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBkdXAKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDM0CiAgICAvLyBhc3NlcnQocGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlRmluYWxpemF0aW9uLCBFUlJfRElTQlVSU0VNRU5UX05PVF9SRUFEWV9GT1JfRklOQUxJWkFUSU9OKQogICAgdW5jb3ZlciAyCiAgICBieXRlYyAxMyAvLyAweDFlCiAgICA9PQogICAgYXNzZXJ0IC8vIERpc2J1cnNlbWVudCBub3QgcmVhZHkgZm9yIGZpbmFsaXphdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYxMwogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYxMwogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYxMwogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjE1LTYxOAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuZmluYWxpemVEaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFtkaXNidXJzZW1lbnRJRF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgcHVzaGJ5dGVzIDB4NTQyNGE1OTEgLy8gbWV0aG9kICJmaW5hbGl6ZURpc2J1cnNlbWVudCh1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTAzOAogICAgLy8gdGhpcy5kaXNidXJzZW1lbnRzKGFjdGl2ZURpc2J1cnNlbWVudElEKS5jcmVhdGUoKQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2OQogICAgLy8gZGlzYnVyc2VtZW50cyA9IEJveE1hcDx1aW50NjQsIGJ5dGVzPDA+Pih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeERpc2J1cnNlbWVudHMgfSkKICAgIHB1c2hieXRlcyAiZCIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMzgKICAgIC8vIHRoaXMuZGlzYnVyc2VtZW50cyhhY3RpdmVEaXNidXJzZW1lbnRJRCkuY3JlYXRlKCkKICAgIGludGNfMCAvLyAwCiAgICBib3hfY3JlYXRlCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDQwCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLnBoYXNlID0gRGlzYnVyc2VtZW50UGhhc2VJZGxlCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDQxCiAgICAvLyB0aGlzLnJld2FyZHMocmV3YXJkSUQpLnZhbHVlLmFjdGl2ZURpc2J1cnNlbWVudElEID0gMAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGRpZyAxCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGRpZyAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDIKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuYWN0aXZlRGlzYnVyc2VtZW50Um91bmRTdGFydCA9IDAKICAgIGRpZyAxCiAgICBwdXNoaW50IDEwOCAvLyAxMDgKICAgIGRpZyAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDMKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUuZGlzYnVyc2VtZW50Q3Vyc29yID0gMAogICAgZGlnIDEKICAgIGludGNfMyAvLyA5MgogICAgZGlnIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0NAogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS5xdWFsaWZpZWRTdGFrZXJzID0gMAogICAgZGlnIDEKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGRpZyAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDUKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUucXVhbGlmaWVkU3Rha2UgPSAwCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMzEKICAgIC8vIGZpbmFsaXplRGlzdHJpYnV0aW9uKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmNoZWNrW3JvdXRpbmddKCkgLT4gdm9pZDoKY2hlY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0OAogICAgLy8gY2hlY2soYWRkcmVzczogQWNjb3VudCwgYXNzZXQ6IHVpbnQ2NCk6IHsgdmFsaWQ6IGJvb2xlYW4sIGJhbGFuY2U6IHVpbnQ2NCB9IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA0OQogICAgLy8gY29uc3Qga2V5OiBFbnRyeUtleSA9IHsgYWRkcmVzcywgYXNzZXQgfQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTY1CiAgICAvLyBlbnRyaWVzQnlBZGRyZXNzID0gQm94TWFwPEVudHJ5S2V5LCB1aW50NjQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4RW50cmllc0J5QWRkcmVzcyB9KQogICAgcHVzaGJ5dGVzICJhIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA1MAogICAgLy8gY29uc3QgaWQgPSB0aGlzLmVudHJpZXNCeUFkZHJlc3Moa2V5KS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDUxCiAgICAvLyByZXR1cm4gdGhpcy5jaGVja0J5SUQoaWQpCiAgICBjYWxsc3ViIGNoZWNrQnlJRAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNDgKICAgIC8vIGNoZWNrKGFkZHJlc3M6IEFjY291bnQsIGFzc2V0OiB1aW50NjQpOiB7IHZhbGlkOiBib29sZWFuLCBiYWxhbmNlOiB1aW50NjQgfSB7CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5zaWduVXBzT3Blbltyb3V0aW5nXSgpIC0+IHZvaWQ6CnNpZ25VcHNPcGVuOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjAKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTEzCiAgICAvLyBzdGF0dXMgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YXR1cz4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXR1cyB9KQogICAgYnl0ZWMgOSAvLyAic3RhdHVzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjAKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vIDB4MDAKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2MC0xMDYxCiAgICAvLyB0aGlzLnN0YXR1cy52YWx1ZSAhPT0gUG9vbFN0YXR1c0RyYWZ0ICYmCiAgICAvLyBHbG9iYWwubGF0ZXN0VGltZXN0YW1wID4gdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUgJiYKICAgIGJ6IHNpZ25VcHNPcGVuX2Jvb2xfZmFsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjEKICAgIC8vIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSAmJgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIHNpZ251cFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVNpZ251cFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMjcgLy8gInNpZ251cF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2MQogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjAtMTA2MQogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+IHRoaXMuc2lnbnVwVGltZXN0YW1wLnZhbHVlICYmCiAgICBieiBzaWduVXBzT3Blbl9ib29sX2ZhbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDYyCiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE4IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2MgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA8CiAgICBibnogc2lnblVwc09wZW5fYm9vbF90cnVlQDUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGJ5dGVjIDIzIC8vICJhbGxvd19sYXRlX3NpZ251cHMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA2MgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieiBzaWduVXBzT3Blbl9ib29sX2ZhbHNlQDYKCnNpZ25VcHNPcGVuX2Jvb2xfdHJ1ZUA1OgogICAgaW50Y18xIC8vIDEKCnNpZ25VcHNPcGVuX2Jvb2xfbWVyZ2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDU3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpzaWduVXBzT3Blbl9ib29sX2ZhbHNlQDY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzaWduVXBzT3Blbl9ib29sX21lcmdlQDcKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmlzTGl2ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmUKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0VudGVyZWRbcm91dGluZ10oKSAtPiB2b2lkOgppc0VudGVyZWQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyB1bmlxdWVzID0gQm94TWFwPEFjY291bnQsIHVpbnQ2ND4oeyBrZXlQcmVmaXg6IFBvb2xHbG9iYWxTdGF0ZUtleVVuaXF1ZXMgfSkKICAgIHB1c2hieXRlcyAidSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzkKICAgIC8vIHJldHVybiB0aGlzLnVuaXF1ZXMoYWRkcmVzcykuZXhpc3RzOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlY18zIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuZ2V0U3RhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRTdGF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDg1CiAgICAvLyBzdGF0dXM6IHRoaXMuc3RhdHVzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyA5IC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4NQogICAgLy8gc3RhdHVzOiB0aGlzLnN0YXR1cy52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4NgogICAgLy8gdGl0bGU6IHRoaXMudGl0bGUudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNQogICAgLy8gdGl0bGUgPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUaXRsZSB9KQogICAgYnl0ZWMgMjQgLy8gInRpdGxlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODYKICAgIC8vIHRpdGxlOiB0aGlzLnRpdGxlLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDg3CiAgICAvLyB0eXBlOiB0aGlzLnR5cGUudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODcKICAgIC8vIHR5cGU6IHRoaXMudHlwZS52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4OAogICAgLy8gc2lnbnVwVGltZXN0YW1wOiB0aGlzLnNpZ251cFRpbWVzdGFtcC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBzaWdudXBUaW1lc3RhbXAgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTaWdudXBUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDI3IC8vICJzaWdudXBfdGltZXN0YW1wIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODgKICAgIC8vIHNpZ251cFRpbWVzdGFtcDogdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwODkKICAgIC8vIGFsbG93TGF0ZVNpZ251cHM6IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBhbGxvd0xhdGVTaWdudXBzID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUFsbG93TGF0ZVNpZ251cHMgfSkKICAgIGJ5dGVjIDIzIC8vICJhbGxvd19sYXRlX3NpZ251cHMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA4OQogICAgLy8gYWxsb3dMYXRlU2lnbnVwczogdGhpcy5hbGxvd0xhdGVTaWdudXBzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDkwCiAgICAvLyBzdGFydFRpbWVzdGFtcDogdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTIzCiAgICAvLyBzdGFydFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVN0YXJ0VGltZXN0YW1wIH0pCiAgICBieXRlYyAxOCAvLyAic3RhcnRfdGltZXN0YW1wIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTAKICAgIC8vIHN0YXJ0VGltZXN0YW1wOiB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDkxCiAgICAvLyBlbmRUaW1lc3RhbXA6IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjUKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTYgLy8gImVuZF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5MQogICAgLy8gZW5kVGltZXN0YW1wOiB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5MgogICAgLy8gbWF4RW50cmllczogdGhpcy5tYXhFbnRyaWVzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5MgogICAgLy8gbWF4RW50cmllczogdGhpcy5tYXhFbnRyaWVzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDkzCiAgICAvLyBlbnRyeUNvdW50OiAodGhpcy5lbnRyeUlELnZhbHVlICsgMSksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gZW50cnlJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVudHJ5Q291bnQgfSkKICAgIGJ5dGVjXzEgLy8gImVudHJ5X2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTMKICAgIC8vIGVudHJ5Q291bnQ6ICh0aGlzLmVudHJ5SUQudmFsdWUgKyAxKSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTQKICAgIC8vIHJld2FyZENvdW50OiAodGhpcy5yZXdhcmRJRC52YWx1ZSArIDEpLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzEKICAgIC8vIHJld2FyZElEID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5UmV3YXJkQ291bnQgfSkKICAgIGJ5dGVjIDI4IC8vICJyZXdhcmRfY291bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NAogICAgLy8gcmV3YXJkQ291bnQ6ICh0aGlzLnJld2FyZElELnZhbHVlICsgMSksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk1CiAgICAvLyB0b3RhbFN0YWtlZDogdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTMzCiAgICAvLyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVRvdGFsU3Rha2VkIH0pCiAgICBwdXNoYnl0ZXMgInRvdGFsX3N0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDk1CiAgICAvLyB0b3RhbFN0YWtlZDogdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NgogICAgLy8gc3Rha2VLZXk6IHRoaXMuc3Rha2VLZXkudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gc3Rha2VLZXkgPSBHbG9iYWxTdGF0ZTxSb290S2V5Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3Rha2VLZXkgfSkKICAgIGJ5dGVjIDIxIC8vICJzdGFrZV9rZXkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NgogICAgLy8gc3Rha2VLZXk6IHRoaXMuc3Rha2VLZXkudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOTcKICAgIC8vIG1pbmltdW1TdGFrZUFtb3VudDogdGhpcy5taW5pbXVtU3Rha2VBbW91bnQudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0MAogICAgLy8gbWluaW11bVN0YWtlQW1vdW50ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5TWluaW11bVN0YWtlQW1vdW50IH0pCiAgICBieXRlYyAyNSAvLyAibWluaW11bV9zdGFrZV9hbW91bnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5NwogICAgLy8gbWluaW11bVN0YWtlQW1vdW50OiB0aGlzLm1pbmltdW1TdGFrZUFtb3VudC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5OAogICAgLy8gZ2F0ZUlEOiB0aGlzLmdhdGVJRC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBnYXRlSUQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQgfSkKICAgIGJ5dGVjIDggLy8gImdhdGVfaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5OAogICAgLy8gZ2F0ZUlEOiB0aGlzLmdhdGVJRC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5OQogICAgLy8gY3JlYXRvcjogdGhpcy5jcmVhdG9yLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNyZWF0b3IgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5Q3JlYXRvciB9KQogICAgYnl0ZWMgMTAgLy8gImNyZWF0b3IiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA5OQogICAgLy8gY3JlYXRvcjogdGhpcy5jcmVhdG9yLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDg0LTExMDAKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIHN0YXR1czogdGhpcy5zdGF0dXMudmFsdWUsCiAgICAvLyAgIHRpdGxlOiB0aGlzLnRpdGxlLnZhbHVlLAogICAgLy8gICB0eXBlOiB0aGlzLnR5cGUudmFsdWUsCiAgICAvLyAgIHNpZ251cFRpbWVzdGFtcDogdGhpcy5zaWdudXBUaW1lc3RhbXAudmFsdWUsCiAgICAvLyAgIGFsbG93TGF0ZVNpZ251cHM6IHRoaXMuYWxsb3dMYXRlU2lnbnVwcy52YWx1ZSwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXA6IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUsCiAgICAvLyAgIGVuZFRpbWVzdGFtcDogdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUsCiAgICAvLyAgIG1heEVudHJpZXM6IHRoaXMubWF4RW50cmllcy52YWx1ZSwKICAgIC8vICAgZW50cnlDb3VudDogKHRoaXMuZW50cnlJRC52YWx1ZSArIDEpLAogICAgLy8gICByZXdhcmRDb3VudDogKHRoaXMucmV3YXJkSUQudmFsdWUgKyAxKSwKICAgIC8vICAgdG90YWxTdGFrZWQ6IHRoaXMudG90YWxTdGFrZWQudmFsdWUsCiAgICAvLyAgIHN0YWtlS2V5OiB0aGlzLnN0YWtlS2V5LnZhbHVlLAogICAgLy8gICBtaW5pbXVtU3Rha2VBbW91bnQ6IHRoaXMubWluaW11bVN0YWtlQW1vdW50LnZhbHVlLAogICAgLy8gICBnYXRlSUQ6IHRoaXMuZ2F0ZUlELnZhbHVlLAogICAgLy8gICBjcmVhdG9yOiB0aGlzLmNyZWF0b3IudmFsdWUsCiAgICAvLyB9CiAgICBkaWcgMTMKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMTQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxNAogICAgcHVzaGJ5dGVzIDB4MDA2ZgogICAgY29uY2F0CiAgICBkaWcgMQogICAgbGVuCiAgICBwdXNoaW50IDExMSAvLyAxMTEKICAgICsKICAgIHN3YXAKICAgIHVuY292ZXIgMTUKICAgIGNvbmNhdAogICAgdW5jb3ZlciAxNAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDEyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMTQKICAgIHNldGJpdAogICAgY29uY2F0CiAgICB1bmNvdmVyIDExCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMTAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciA5CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgOAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDcKICAgIGl0b2IKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgdW5jb3ZlciA0CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDgyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QudXBkYXRlQWtpdGFEQU9Fc2Nyb3dbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBT0VzY3JvdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjEyMQogICAgLy8gdXBkYXRlQWtpdGFEQU9Fc2Nyb3coYXBwOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjEyMgogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNyAvLyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTIyCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NTkKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBieXRlYyAyNiAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTIzCiAgICAvLyB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlID0gYXBwCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTIxCiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OlVwZ3JhZGVhYmxlQWtpdGFCYXNlQ29udHJhY3QudXBkYXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDcKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0OQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGJ5dGVjIDE3IC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0OQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHVuY292ZXIgMgogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MwogICAgLy8gY29uc3QgW3BsdWdpbkFwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNQbHVnaW5BcHBMaXN0KSkKICAgIGJ5dGVjIDMxIC8vICJwbHVnbl9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjUwCiAgICAvLyBjb25zdCB1cGRhdGVQbHVnaW4gPSBnZXRQbHVnaW5BcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnVwZGF0ZQogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjUxCiAgICAvLyBhc3NlcnQoR2xvYmFsLmNhbGxlckFwcGxpY2F0aW9uSWQgPT09IHVwZGF0ZVBsdWdpbiwgRVJSX0lOVkFMSURfVVBHUkFERSkKICAgIGdsb2JhbCBDYWxsZXJBcHBsaWNhdGlvbklECiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgYXBwIHVwZ3JhZGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI2CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1MgogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gbmV3VmVyc2lvbgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ3CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU9bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBTzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM3CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMxCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNyAvLyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozNwogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjpCYXNlU3Rha2luZ1Bvb2wubWJyW3JvdXRpbmddKCkgLT4gdm9pZDoKbWJyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjEzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6OQogICAgLy8gcmV0dXJuIE1pblBvb2xSZXdhcmRzTUJSICsgKEJveENvc3RQZXJCeXRlICogd2lubmluZ1RpY2tldHMpCiAgICBpbnRjIDYgLy8gNDAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6MTUtMjEKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGVudHJpZXM6IFBvb2xFbnRyaWVzTUJSLAogICAgLy8gICB1bmlxdWVzOiBQb29sVW5pcXVlc01CUiwKICAgIC8vICAgZW50cmllc0J5QWRkcmVzczogUG9vbEVudHJpZXNCeUFkZHJlc3NNQlIsCiAgICAvLyAgIHJld2FyZHM6IHRoaXMucmV3YXJkc01icih3aW5uaW5nVGlja2V0cyksCiAgICAvLyAgIGRpc2J1cnNlbWVudHM6IFBvb2xEaXNidXJzZW1lbnRTTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDA2MmQ0MDAwMDAwMDAwMDAwNDlkNDAwMDAwMDAwMDAwMDYyZDQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjIwCiAgICAvLyBkaXNidXJzZW1lbnRzOiBQb29sRGlzYnVyc2VtZW50U01CUgogICAgcHVzaGludCA2MTAwIC8vIDYxMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czoxNS0yMQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgZW50cmllczogUG9vbEVudHJpZXNNQlIsCiAgICAvLyAgIHVuaXF1ZXM6IFBvb2xVbmlxdWVzTUJSLAogICAgLy8gICBlbnRyaWVzQnlBZGRyZXNzOiBQb29sRW50cmllc0J5QWRkcmVzc01CUiwKICAgIC8vICAgcmV3YXJkczogdGhpcy5yZXdhcmRzTWJyKHdpbm5pbmdUaWNrZXRzKSwKICAgIC8vICAgZGlzYnVyc2VtZW50czogUG9vbERpc2J1cnNlbWVudFNNQlIKICAgIC8vIH0KICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjEzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmNoZWNrQnlJRChpZDogdWludDY0KSAtPiBieXRlczoKY2hlY2tCeUlEOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3MwogICAgLy8gcHJpdmF0ZSBjaGVja0J5SUQoaWQ6IHVpbnQ2NCk6IHsgdmFsaWQ6IGJvb2xlYW4sIGJhbGFuY2U6IHVpbnQ2NCB9IHsKICAgIHByb3RvIDEgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gMgogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NzUKICAgIC8vIHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSB8fCB0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDc1CiAgICAvLyB0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX05PTkUgfHwgdGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9IRUFSVEJFQVQsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMyAvLyAweDAwCiAgICAhPQogICAgYm56IGNoZWNrQnlJRF9ib29sX3RydWVAMgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTcKICAgIC8vIHR5cGUgPSBHbG9iYWxTdGF0ZTxTdGFraW5nUG9vbFN0YWtpbmdUeXBlPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5VHlwZSB9KQogICAgYnl0ZWMgNSAvLyAidHlwZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NzUKICAgIC8vIHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSB8fCB0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlYyA3IC8vIDB4MGEKICAgICE9CiAgICBieiBjaGVja0J5SURfYm9vbF9mYWxzZUAzCgpjaGVja0J5SURfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKY2hlY2tCeUlEX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0NzQtNDc3CiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHRoaXMudHlwZS52YWx1ZSAhPT0gUE9PTF9TVEFLSU5HX1RZUEVfTk9ORSB8fCB0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX0hFQVJUQkVBVCwKICAgIC8vICAgRVJSX0lOVkFMSURfUE9PTF9UWVBFX0ZPUl9DSEVDSwogICAgLy8gKQogICAgYXNzZXJ0IC8vIEludmFsaWQgcG9vbCB0eXBlIGZvciBjaGVjawogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3OQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGFzc2V0LCBxdWFudGl0eSB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTYxCiAgICAvLyBlbnRyaWVzID0gQm94TWFwPHVpbnQ2NCwgRW50cnlEYXRhPih7IGtleVByZWZpeDogUG9vbEJveFByZWZpeEVudHJpZXMgfSkKICAgIGJ5dGVjIDEyIC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ3OQogICAgLy8gY29uc3QgeyBkaXNxdWFsaWZpZWQsIGFkZHJlc3MsIGFzc2V0LCBxdWFudGl0eSB9ID0gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGZyYW1lX2J1cnkgMAogICAgZGlnIDEKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGludGNfMiAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgMwogICAgc3dhcAogICAgcHVzaGludCA0MCAvLyA0MAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODEKICAgIC8vIGlmIChkaXNxdWFsaWZpZWQpIHsKICAgIGJ6IGNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODIKICAgIC8vIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgYmFsYW5jZTogMCB9CiAgICBieXRlYyAzNSAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDg1CiAgICAvLyBpZiAodGhpcy50eXBlLnZhbHVlID09PSBQT09MX1NUQUtJTkdfVFlQRV9TT0ZUKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gdHlwZSA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3Rha2luZ1R5cGU+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlUeXBlIH0pCiAgICBieXRlYyA1IC8vICJ0eXBlIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4NQogICAgLy8gaWYgKHRoaXMudHlwZS52YWx1ZSA9PT0gUE9PTF9TVEFLSU5HX1RZUEVfU09GVCkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDExIC8vIDB4MTQKICAgID09CiAgICBieiBjaGVja0J5SURfZWxzZV9ib2R5QDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NDg2LTQ4OQogICAgLy8gY29uc3QgY2hlY2sgPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5zb2Z0Q2hlY2s+KHsKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXRdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0ODcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ4Ni00ODkKICAgIC8vIGNvbnN0IGNoZWNrID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuc29mdENoZWNrPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogW2FkZHJlc3MsIGFzc2V0XSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHg0ODcxNmYxYSAvLyBtZXRob2QgInNvZnRDaGVjayhhZGRyZXNzLHVpbnQ2NCkoYm9vbCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCA5IC8vIDkKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChib29sMSx1aW50NjQpCiAgICBwdXNoaW50IDUgLy8gNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5MQogICAgLy8gaWYgKGNoZWNrLmJhbGFuY2UgPj0gcXVhbnRpdHkpIHsKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNQogICAgZnJhbWVfZGlnIDQKICAgID49CiAgICBieiBjaGVja0J5SURfYWZ0ZXJfaWZfZWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5MgogICAgLy8gcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGJhbGFuY2U6IGNoZWNrLmJhbGFuY2UgfQogICAgZnJhbWVfZGlnIDUKICAgIGl0b2IKICAgIGJ5dGVjIDE1IC8vIDB4ODAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUxMQogICAgLy8gdGhpcy5lbnRyaWVzKGlkKS52YWx1ZS5kaXNxdWFsaWZpZWQgPSB0cnVlCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGludGNfMCAvLyAwCiAgICBpbnRjXzEgLy8gMQogICAgc2V0Yml0CiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUxMgogICAgLy8gcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBiYWxhbmNlOiAwIH0KICAgIGJ5dGVjIDM1IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2hlY2tCeUlEX2Vsc2VfYm9keUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0OTUtNTA0CiAgICAvLyBjb25zdCBpbmZvID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuZ2V0SW5mbz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICAgIHsKICAgIC8vICAgICAgIGFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIHR5cGU6IHRoaXMuc3Rha2luZ1R5cGUoKSwKICAgIC8vICAgICB9LAogICAgLy8gICBdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0OTYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0OTYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlYyA0IC8vICJha2l0YV9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0OTYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUwMQogICAgLy8gdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgY2FsbHN1YiBzdGFraW5nVHlwZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5OS01MDIKICAgIC8vIHsKICAgIC8vICAgYXNzZXQ6IGFzc2V0LAogICAgLy8gICB0eXBlOiB0aGlzLnN0YWtpbmdUeXBlKCksCiAgICAvLyB9LAogICAgZnJhbWVfZGlnIDMKICAgIGl0b2IKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQ5NS01MDQKICAgIC8vIGNvbnN0IGluZm8gPSBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5nZXRJbmZvPih7CiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGFkZHJlc3MsCiAgICAvLyAgICAgewogICAgLy8gICAgICAgYXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgdHlwZTogdGhpcy5zdGFraW5nVHlwZSgpLAogICAgLy8gICAgIH0sCiAgICAvLyAgIF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgYnl0ZWMgMzIgLy8gbWV0aG9kICJnZXRJbmZvKGFkZHJlc3MsKHVpbnQ2NCx1aW50OCkpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCAyNCAvLyAyNAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgcHVzaGludCA0IC8vIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MDYKICAgIC8vIGlmIChpbmZvLmFtb3VudCA+PSBxdWFudGl0eSkgewogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBmcmFtZV9kaWcgNAogICAgPj0KICAgIGJ6IGNoZWNrQnlJRF9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTA3CiAgICAvLyByZXR1cm4geyB2YWxpZDogdHJ1ZSwgYmFsYW5jZTogaW5mby5hbW91bnQgfQogICAgZnJhbWVfZGlnIDYKICAgIGl0b2IKICAgIGJ5dGVjIDE1IC8vIDB4ODAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNoZWNrQnlJRF9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBjaGVja0J5SURfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5zdGFraW5nVHlwZSgpIC0+IGJ5dGVzOgpzdGFraW5nVHlwZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1MjUKICAgIC8vIGFzc2VydCh0aGlzLnR5cGUudmFsdWUgIT09IFBPT0xfU1RBS0lOR19UWVBFX05PTkUsICdwb29sIHN0YWtpbmcgdHlwZSBpcyBub3Qgc2V0JykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE3CiAgICAvLyB0eXBlID0gR2xvYmFsU3RhdGU8U3Rha2luZ1Bvb2xTdGFraW5nVHlwZT4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVR5cGUgfSkKICAgIGJ5dGVjIDUgLy8gInR5cGUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTI1CiAgICAvLyBhc3NlcnQodGhpcy50eXBlLnZhbHVlICE9PSBQT09MX1NUQUtJTkdfVFlQRV9OT05FLCAncG9vbCBzdGFraW5nIHR5cGUgaXMgbm90IHNldCcpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBieXRlY18zIC8vIDB4MDAKICAgICE9CiAgICBhc3NlcnQgLy8gcG9vbCBzdGFraW5nIHR5cGUgaXMgbm90IHNldAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjUyNgogICAgLy8gcmV0dXJuIG5ldyBVaW50OCh0aGlzLnR5cGUudmFsdWUuYXNVaW50NjQoKSAtIDEpCiAgICBidG9pCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIGludGNfMiAvLyA4CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDcgMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5jcmVhdGVSZXdhcmRBbGxvY2F0aW9ucyhkaXNidXJzZW1lbnRJRDogdWludDY0LCBhc3NldDogdWludDY0LCBhbGxvY2F0aW9uczogYnl0ZXMsIHN1bTogdWludDY0KSAtPiBieXRlczoKY3JlYXRlUmV3YXJkQWxsb2NhdGlvbnM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTY4LTU3MwogICAgLy8gcHJpdmF0ZSBjcmVhdGVSZXdhcmRBbGxvY2F0aW9ucygKICAgIC8vICAgZGlzYnVyc2VtZW50SUQ6IHVpbnQ2NCwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwKICAgIC8vICAgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10sCiAgICAvLyAgIHN1bTogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHByb3RvIDQgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU3NQogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI4CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU3NQogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU3NQogICAgLy8gY29uc3QgcmV3YXJkc0FwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjQ2CiAgICAvLyByZXR1cm4gMjRfOTAwICogYWxsb2NhdGlvbnMubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyNDkwMCAvLyAyNDkwMAogICAgKgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU3OAogICAgLy8gaWYgKGFzc2V0ID09PSAwKSB7CiAgICBmcmFtZV9kaWcgLTMKICAgIGJueiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9uc19lbHNlX2JvZHlANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4MC01OTAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZVVzZXJBbGxvY2F0aW9ucz4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZGlzYnVyc2VtZW50SUQsCiAgICAvLyAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4NAogICAgLy8gcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4NQogICAgLy8gYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU4My01ODYKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTgwLTU5MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCArIHN1bSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBkaXNidXJzZW1lbnRJRCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1ODcKICAgIC8vIGRpc2J1cnNlbWVudElELAogICAgZnJhbWVfZGlnIC00CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTgwLTU5MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCArIHN1bSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBkaXNidXJzZW1lbnRJRCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg1NjU2YWNmOSAvLyBtZXRob2QgImNyZWF0ZVVzZXJBbGxvY2F0aW9ucyhwYXksdWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpjcmVhdGVSZXdhcmRBbGxvY2F0aW9uc19hZnRlcl9pZl9lbHNlQDEwOgogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICByZXRzdWIKCmNyZWF0ZVJld2FyZEFsbG9jYXRpb25zX2Vsc2VfYm9keUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5My02MDgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucz4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGRpc2J1cnNlbWVudElELAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1OTcKICAgIC8vIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjU5Ni01OTkKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjAwLTYwNAogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gfSksCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MDEKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgLTMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MDAtNjA0CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyB9KSwKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo1OTMtNjA4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBkaXNidXJzZW1lbnRJRCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MDUKICAgIC8vIGRpc2J1cnNlbWVudElELAogICAgZnJhbWVfZGlnIC00CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTkzLTYwOAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIGFwcElkOiByZXdhcmRzQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZGlzYnVyc2VtZW50SUQsCiAgICAvLyAgICAgYWxsb2NhdGlvbnMsCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4M2M2MGRmYTAgLy8gbWV0aG9kICJjcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnMocGF5LGF4ZmVyLHVpbnQ2NCwoYWRkcmVzcyx1aW50NjQpW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBjcmVhdGVSZXdhcmRBbGxvY2F0aW9uc19hZnRlcl9pZl9lbHNlQDEwCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmQocGF5bWVudDogdWludDY0LCByZXdhcmQ6IGJ5dGVzKSAtPiBieXRlczoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzYyCiAgICAvLyBhZGRSZXdhcmQocGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCByZXdhcmQ6IFJld2FyZCk6IHZvaWQgewogICAgcHJvdG8gMiAxCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzYzCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCBFUlJfRk9SQklEREVOKQogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNyZWF0b3IgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5Q3JlYXRvciB9KQogICAgYnl0ZWMgMTAgLy8gImNyZWF0b3IiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzYzCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdG9yLnZhbHVlLCBFUlJfRk9SQklEREVOKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gRm9yYmlkZGVuCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzY0CiAgICAvLyBhc3NlcnQocmV3YXJkLmFzc2V0ID09PSAwLCBFUlJfTk9UX0FMR08pCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgIQogICAgYXNzZXJ0IC8vIE11c3QgYmUgYW4gQWxnbyBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYyOAogICAgLy8gdGhpcy5zdGFrZUtleS52YWx1ZS5hZGRyZXNzICE9PSBHbG9iYWwuemVyb0FkZHJlc3MgfHwgcmV3YXJkLmRpc3RyaWJ1dGlvbiAhPT0gRGlzdHJpYnV0aW9uVHlwZVBlcmNlbnRhZ2UsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gc3Rha2VLZXkgPSBHbG9iYWxTdGF0ZTxSb290S2V5Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3Rha2VLZXkgfSkKICAgIGJ5dGVjIDIxIC8vICJzdGFrZV9rZXkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjI4CiAgICAvLyB0aGlzLnN0YWtlS2V5LnZhbHVlLmFkZHJlc3MgIT09IEdsb2JhbC56ZXJvQWRkcmVzcyB8fCByZXdhcmQuZGlzdHJpYnV0aW9uICE9PSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBleHRyYWN0IDAgMzIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJueiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX3RydWVANwogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDggMQogICAgYnl0ZWMgNyAvLyAweDBhCiAgICAhPQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUA4CgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX3RydWVANzoKICAgIGludGNfMSAvLyAxCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjI3LTYzMAogICAgLy8gYXNzZXJ0KAogICAgLy8gICB0aGlzLnN0YWtlS2V5LnZhbHVlLmFkZHJlc3MgIT09IEdsb2JhbC56ZXJvQWRkcmVzcyB8fCByZXdhcmQuZGlzdHJpYnV0aW9uICE9PSBEaXN0cmlidXRpb25UeXBlUGVyY2VudGFnZSwKICAgIC8vICAgRVJSX1NUQUtFX0tFWV9SRVFVSVJFRAogICAgLy8gKQogICAgYXNzZXJ0IC8vIFN0YWtlIGtleSByZXF1aXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYzMwogICAgLy8gaWYgKHJld2FyZC5kaXN0cmlidXRpb24gPT09IERpc3RyaWJ1dGlvblR5cGVTaHVmZmxlKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgOCAxCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgcHVzaGJ5dGVzIDB4MjgKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9hZnRlcl9pZl9lbHNlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM0CiAgICAvLyBhc3NlcnQocmV3YXJkLnJhdGUgPiByZXdhcmQud2lubmVyQ291bnQgJiYgcmV3YXJkLndpbm5lckNvdW50IDw9IFdpbm5lckNvdW50Q2FwLCBFUlJfUkFURV9NVVNUX0JFX0dSRUFURVJfVEhBTl9XSU5ORVJfQ09VTlQpCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgID4KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfZmFsc2VAMTMKICAgIGZyYW1lX2RpZyAxCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICA8PQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUAxMwogICAgaW50Y18xIC8vIDEKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM0CiAgICAvLyBhc3NlcnQocmV3YXJkLnJhdGUgPiByZXdhcmQud2lubmVyQ291bnQgJiYgcmV3YXJkLndpbm5lckNvdW50IDw9IFdpbm5lckNvdW50Q2FwLCBFUlJfUkFURV9NVVNUX0JFX0dSRUFURVJfVEhBTl9XSU5ORVJfQ09VTlQpCiAgICBhc3NlcnQgLy8gUmF0ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB3aW5uZXIgY291bnQKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM4CiAgICAvLyBpZiAocmV3YXJkLmRpc3RyaWJ1dGlvbiA9PT0gRGlzdHJpYnV0aW9uVHlwZUV2ZW4pIHsKICAgIGZyYW1lX2RpZyAwCiAgICBieXRlYyAxMyAvLyAweDFlCiAgICA9PQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUAyMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYzOQogICAgLy8gYXNzZXJ0KHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCB8fCB0aGlzLm1heEVudHJpZXMudmFsdWUgPD0gcmV3YXJkLnJhdGUsIEVSUl9NQVhfRU5UUklFU19DQU5OT1RfQkVfR1JFQVRFUl9USEFOX1JBVEUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gbWF4RW50cmllcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleU1heEVudHJpZXMgfSkKICAgIGJ5dGVjIDE0IC8vICJtYXhfZW50cmllcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2MzkKICAgIC8vIGFzc2VydCh0aGlzLm1heEVudHJpZXMudmFsdWUgPT09IDAgfHwgdGhpcy5tYXhFbnRyaWVzLnZhbHVlIDw9IHJld2FyZC5yYXRlLCBFUlJfTUFYX0VOVFJJRVNfQ0FOTk9UX0JFX0dSRUFURVJfVEhBTl9SQVRFKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfdHJ1ZUAxOAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIG1heEVudHJpZXMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlNYXhFbnRyaWVzIH0pCiAgICBieXRlYyAxNCAvLyAibWF4X2VudHJpZXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjM5CiAgICAvLyBhc3NlcnQodGhpcy5tYXhFbnRyaWVzLnZhbHVlID09PSAwIHx8IHRoaXMubWF4RW50cmllcy52YWx1ZSA8PSByZXdhcmQucmF0ZSwgRVJSX01BWF9FTlRSSUVTX0NBTk5PVF9CRV9HUkVBVEVSX1RIQU5fUkFURSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgPD0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfZmFsc2VAMTkKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfdHJ1ZUAxODoKICAgIGludGNfMSAvLyAxCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX21lcmdlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYzOQogICAgLy8gYXNzZXJ0KHRoaXMubWF4RW50cmllcy52YWx1ZSA9PT0gMCB8fCB0aGlzLm1heEVudHJpZXMudmFsdWUgPD0gcmV3YXJkLnJhdGUsIEVSUl9NQVhfRU5UUklFU19DQU5OT1RfQkVfR1JFQVRFUl9USEFOX1JBVEUpCiAgICBhc3NlcnQgLy8gTWF4IGVudHJpZXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiByYXRlCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9hZnRlcl9pZl9lbHNlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY0MgogICAgLy8gYXNzZXJ0KHJld2FyZC5yYXRlID4gMCwgRVJSX1JBVEVfTVVTVF9CRV9HUkVBVEVSX1RIQU5fWkVSTykKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGludCA5IC8vIDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBhc3NlcnQgLy8gUmF0ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzY4LTc3NwogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbkVxOiB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc3MQogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NjgtNzc3CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHsKICAgIC8vICAgICAgIGdyZWF0ZXJUaGFuRXE6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NzMKICAgIC8vIGdyZWF0ZXJUaGFuRXE6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgNDkgLy8gNDkKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6OQogICAgLy8gcmV0dXJuIE1pblBvb2xSZXdhcmRzTUJSICsgKEJveENvc3RQZXJCeXRlICogd2lubmluZ1RpY2tldHMpCiAgICBpbnRjIDYgLy8gNDAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzY4LTc3NwogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbkVxOiB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPj0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgxCiAgICAvLyBjb25zdCBpZCA9IHRoaXMucmV3YXJkSUQudmFsdWUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTMxCiAgICAvLyByZXdhcmRJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVJld2FyZENvdW50IH0pCiAgICBieXRlYyAyOCAvLyAicmV3YXJkX2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4MQogICAgLy8gY29uc3QgaWQgPSB0aGlzLnJld2FyZElELnZhbHVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gdGhpcy5yZXdhcmRJRC52YWx1ZSArPSAxCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTMxCiAgICAvLyByZXdhcmRJRCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleVJld2FyZENvdW50IH0pCiAgICBieXRlYyAyOCAvLyAicmV3YXJkX2NvdW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gdGhpcy5yZXdhcmRJRC52YWx1ZSArPSAxCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc4MAogICAgLy8gdGhpcy5yZXdhcmRzKGlkKS52YWx1ZSA9IGNsb25lKHJld2FyZCkKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIHJld2FyZHMgPSBCb3hNYXA8dWludDY0LCBSZXdhcmQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4UmV3YXJkcyB9KQogICAgYnl0ZWMgMTkgLy8gInIiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3ODAKICAgIC8vIHRoaXMucmV3YXJkcyhpZCkudmFsdWUgPSBjbG9uZShyZXdhcmQpCiAgICBkdXAKICAgIGJveF9kZWwKICAgIHBvcAogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfcHV0CiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmFkZFJld2FyZF9ib29sX2ZhbHNlQDE5OgogICAgaW50Y18wIC8vIDAKICAgIGIgc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9tZXJnZUAyMAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5hZGRSZXdhcmRfYm9vbF9mYWxzZUAxMzoKICAgIGludGNfMCAvLyAwCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAMTQKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuYWRkUmV3YXJkX2Jvb2xfbWVyZ2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlKHJld2FyZElEOiB1aW50NjQpIC0+IHZvaWQ6CnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0OAogICAgLy8gcmFmZmxlKHJld2FyZElEOiB1aW50NjQpOiB2b2lkIHsKICAgIHByb3RvIDEgMAogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gMwogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NDkKICAgIC8vIGFzc2VydCh0aGlzLnJld2FyZHMocmV3YXJkSUQpLmV4aXN0cywgJ3Jld2FyZCBkb2VzIG5vdCBleGlzdCcpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIHJld2FyZHMgPSBCb3hNYXA8dWludDY0LCBSZXdhcmQ+KHsga2V5UHJlZml4OiBQb29sQm94UHJlZml4UmV3YXJkcyB9KQogICAgYnl0ZWMgMTkgLy8gInIiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk0OQogICAgLy8gYXNzZXJ0KHRoaXMucmV3YXJkcyhyZXdhcmRJRCkuZXhpc3RzLCAncmV3YXJkIGRvZXMgbm90IGV4aXN0JykKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHJld2FyZCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk1NgogICAgLy8gfSA9IGNsb25lKHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUpCiAgICBkdXAKICAgIHB1c2hpbnQgOTEgLy8gOTEKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZGlnIDEKICAgIHB1c2hpbnQgMTA4IC8vIDEwOAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMgogICAgcHVzaGludCA4MyAvLyA4MwogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMwogICAgcHVzaGludCA0MSAvLyA0MQogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU4CiAgICAvLyBhc3NlcnQocGhhc2UgPT09IERpc2J1cnNlbWVudFBoYXNlQWxsb2NhdGlvbiwgRVJSX0lOVkFMSURfRElTQlVSU0VNRU5UX1BIQVNFKQogICAgdW5jb3ZlciAyCiAgICBieXRlYyAxMSAvLyAweDE0CiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZGlzYnVyc2VtZW50IHBoYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTU5CiAgICAvLyBhc3NlcnQod2lubmluZ1RpY2tldHMubGVuZ3RoID09PSAwLCBFUlJfV0lOTklOR19USUNLRVRTX0FMUkVBRFlfRVhJU1QpCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnRzIDEyNCAyIC8vIDEyNCwgMgogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgICEKICAgIGFzc2VydCAvLyBXaW5uaW5nIHRpY2tldHMgYWxyZWFkeSBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk2MQogICAgLy8gY29uc3Qgcm91bmRUb1VzZTogdWludDY0ID0gYWN0aXZlRGlzYnVyc2VtZW50Um91bmRTdGFydCArIDEgKyAoNCAqIHZyZkZhaWx1cmVDb3VudCkKICAgIHN3YXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBwdXNoaW50IDQgLy8gNAogICAgdW5jb3ZlciAyCiAgICAqCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTYzLTk2NgogICAgLy8gY29uc3Qgc2VlZCA9IGFiaUNhbGw8dHlwZW9mIFJhbmRvbW5lc3NCZWFjb24ucHJvdG90eXBlLmdldD4oewogICAgLy8gICBhcHBJZDogZ2V0T3RoZXJBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkudnJmQmVhY29uLAogICAgLy8gICBhcmdzOiBbcm91bmRUb1VzZSwgdGhpcy5zYWx0LnZhbHVlXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTY0CiAgICAvLyBhcHBJZDogZ2V0T3RoZXJBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkudnJmQmVhY29uLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ4CiAgICAvLyBjb25zdCBbb3RoZXJBcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzT3RoZXJBcHBMaXN0KSkKICAgIGJ5dGVjIDI5IC8vICJvdGhlcl9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjQKICAgIC8vIGFwcElkOiBnZXRPdGhlckFwcExpc3QoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkKS52cmZCZWFjb24sCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjUKICAgIC8vIGFyZ3M6IFtyb3VuZFRvVXNlLCB0aGlzLnNhbHQudmFsdWVdLAogICAgc3dhcAogICAgaXRvYgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTYKICAgIC8vIHNhbHQgPSBHbG9iYWxTdGF0ZTxieXRlczwzMj4+KHsga2V5OiBQb29sR2xvYmFsU3RhdGVLZXlTYWx0IH0pCiAgICBieXRlYyAzMCAvLyAic2FsdCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjUKICAgIC8vIGFyZ3M6IFtyb3VuZFRvVXNlLCB0aGlzLnNhbHQudmFsdWVdLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTYzLTk2NgogICAgLy8gY29uc3Qgc2VlZCA9IGFiaUNhbGw8dHlwZW9mIFJhbmRvbW5lc3NCZWFjb24ucHJvdG90eXBlLmdldD4oewogICAgLy8gICBhcHBJZDogZ2V0T3RoZXJBcHBMaXN0KEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZCkudnJmQmVhY29uLAogICAgLy8gICBhcmdzOiBbcm91bmRUb1VzZSwgdGhpcy5zYWx0LnZhbHVlXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHgxODkzOTJjNSAvLyBtZXRob2QgImdldCh1aW50NjQsYnl0ZVtdKWJ5dGVbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgNiAwCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjgKICAgIC8vIGlmIChzZWVkLmxlbmd0aCA9PT0gMCkgewogICAgbGVuCiAgICBkdXAKICAgIGJueiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NjkKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUudnJmRmFpbHVyZUNvdW50ICs9IDEKICAgIGZyYW1lX2RpZyAxMgogICAgZHVwCiAgICBwdXNoaW50IDgzIC8vIDgzCiAgICBpbnRjXzIgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBwdXNoaW50IDgzIC8vIDgzCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3MAogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NzQKICAgIC8vIGNvbnN0IHJuZ1N0YXRlID0gcGNnNjRJbml0KHNlZWQuc2xpY2UoMCwgMTYpKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2RpZyAxNQogICAgZHVwCiAgICBjb3ZlciAyCiAgICA+PQogICAgaW50Y18wIC8vIDAKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZGlnIDIKICAgID49CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBmcmFtZV9kaWcgMTQKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTYKICAgIC8vIGFzc2VydChzZWVkLmxlbmd0aCA9PT0gMTYpCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxOQogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCAwKSwgcGNnRmlyc3RJbmNyZW1lbnQpLAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OTIKICAgIC8vIGNvbnN0IHN0YXRlID0gX19wY2czMlN0ZXAoMCwgaW5jcikKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGludGMgNSAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoxOQogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCAwKSwgcGNnRmlyc3RJbmNyZW1lbnQpLAogICAgaW50YyA3IC8vIDE0NDI2OTUwNDA4ODg5NjM0MDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czo5MwogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcoc3RhdGUsIGluaXRpYWxTdGF0ZSkKICAgIHVuY292ZXIgMgogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGludGMgNSAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTkKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgMCksIHBjZ0ZpcnN0SW5jcmVtZW50KSwKICAgIGludGMgNyAvLyAxNDQyNjk1MDQwODg4OTYzNDA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBhZGR3CiAgICBjb3ZlciAyCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MjAKICAgIC8vIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgOCksIHBjZ1NlY29uZEluY3JlbWVudCksCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnMzIuYWxnby50czoxOAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcobXVsTG93LCBpbmNyKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoyMAogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCA4KSwgcGNnU2Vjb25kSW5jcmVtZW50KSwKICAgIGludGMgOCAvLyAxNDQyNjk1MDQwODg4OTYzNDA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OTMKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KHN0YXRlLCBpbml0aWFsU3RhdGUpCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTcKICAgIC8vIGNvbnN0IFssIG11bExvd10gPSBvcC5tdWx3KHN0YXRlLCBwY2dNdWx0aXBsaWVyKQogICAgaW50YyA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIG11bHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czoyMAogICAgLy8gX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCA4KSwgcGNnU2Vjb25kSW5jcmVtZW50KSwKICAgIGludGMgOCAvLyAxNDQyNjk1MDQwODg4OTYzNDA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE4CiAgICAvLyBjb25zdCBbLCBhZGRMb3ddID0gb3AuYWRkdyhtdWxMb3csIGluY3IpCiAgICBhZGR3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTgtMjEKICAgIC8vIHJldHVybiBbCiAgICAvLyAgICAgX19wY2czMkluaXQob3AuZXh0cmFjdFVpbnQ2NChzZWVkLCAwKSwgcGNnRmlyc3RJbmNyZW1lbnQpLAogICAgLy8gICAgIF9fcGNnMzJJbml0KG9wLmV4dHJhY3RVaW50NjQoc2VlZCwgOCksIHBjZ1NlY29uZEluY3JlbWVudCksCiAgICAvLyBdCiAgICBzd2FwCiAgICBpdG9iCiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk3OAogICAgLy8gaWYgKHVwcGVyQm91bmQgPCBNQVhfVUlOVDY0KSB7CiAgICBmcmFtZV9kaWcgMTMKICAgIGludGMgMTAgLy8gMTg0NDY3NDQwNzM3MDk1NTE2MTUKICAgIDwKICAgIGJueiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9pZl9ib2R5QDQKICAgIGZyYW1lX2RpZyAxMwogICAgZnJhbWVfYnVyeSAxMQoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czozMAogICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IER5bmFtaWNBcnJheTxhcmM0LlVpbnQ2ND4oKQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGZyYW1lX2J1cnkgMAogICAgYnl0ZWMgNiAvLyAweDAwMDAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo0MgogICAgLy8gaWYgKHVwcGVyQm91bmQgIT09IDApIHsKICAgIGZyYW1lX2RpZyAxMQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjQzCiAgICAvLyBhc3NlcnQodXBwZXJCb3VuZCA+IDEpCiAgICBmcmFtZV9kaWcgMTEKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgID4KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo0NAogICAgLy8gYXNzZXJ0KGxvd2VyQm91bmQgPCB1cHBlckJvdW5kIC0gMSkKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4MgogICAgLy8gY29uc3Qgcm5nUmVzdWx0ID0gcGNnNjRSYW5kb20ocm5nU3RhdGUsIDEsIHVwcGVyQm91bmQsIE1heEdsb2JhbFN0YXRlVWludDY0QXJyYXkpCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo0NAogICAgLy8gYXNzZXJ0KGxvd2VyQm91bmQgPCB1cHBlckJvdW5kIC0gMSkKICAgID4KICAgIGFzc2VydAoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6OAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcofnZhbHVlLCAxKQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgfgogICAgaW50Y18xIC8vIDEKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1MwogICAgLy8gY29uc3QgdGhyZXNob2xkOiB1aW50NjQgPSBfX3VpbnQ2NFR3b3MoYWJzb2x1dGVCb3VuZCkgJSBhYnNvbHV0ZUJvdW5kCiAgICBzd2FwCiAgICAlCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU1CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDcKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDMKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3doaWxlX3RvcEAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTUKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgZnJhbWVfZGlnIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5ODIKICAgIC8vIGNvbnN0IHJuZ1Jlc3VsdCA9IHBjZzY0UmFuZG9tKHJuZ1N0YXRlLCAxLCB1cHBlckJvdW5kLCBNYXhHbG9iYWxTdGF0ZVVpbnQ2NEFycmF5KQogICAgcHVzaGludCAxNSAvLyAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1NQogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICA8CiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl93aGlsZUAyMgoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfd2hpbGVfdG9wQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo5CiAgICAvLyBjb25zdCBuZXdTdGF0ZTEgPSBfX3BjZzMyU3RlcChzdGF0ZVswXSwgcGNnRmlyc3RJbmNyZW1lbnQpCiAgICBmcmFtZV9kaWcgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGludGMgNSAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6OQogICAgLy8gY29uc3QgbmV3U3RhdGUxID0gX19wY2czMlN0ZXAoc3RhdGVbMF0sIHBjZ0ZpcnN0SW5jcmVtZW50KQogICAgaW50YyA3IC8vIDE0NDI2OTUwNDA4ODg5NjM0MDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIGFkZHcKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSA1CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6MTAKICAgIC8vIGNvbnN0IG5ld1N0YXRlMiA9IF9fcGNnMzJTdGVwKHN0YXRlWzFdLCBuZXdTdGF0ZTEgPT09IDAgPyBvcC5zaGwocGNnU2Vjb25kSW5jcmVtZW50LCAxKSA6IHBjZ1NlY29uZEluY3JlbWVudCkKICAgIHN3YXAKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSA4CiAgICBibnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfdGVybmFyeV9mYWxzZUAyNgogICAgcHVzaGludCAyODg1MzkwMDgxNzc3OTI2ODE4IC8vIDI4ODUzOTAwODE3Nzc5MjY4MTgKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3Rlcm5hcnlfbWVyZ2VAMjc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcikKICAgIGZyYW1lX2RpZyA4CiAgICBkdXAKICAgIGludGMgNSAvLyA2MzY0MTM2MjIzODQ2NzkzMDA1CiAgICBtdWx3CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcikKICAgIHVuY292ZXIgMgogICAgYWRkdwogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjEyCiAgICAvLyByZXR1cm4gW1tuZXdTdGF0ZTEsIG5ld1N0YXRlMl0sIG9wLnNobChfX3BjZzMyT3V0cHV0KHN0YXRlWzBdKSwgMzIpIHwgX19wY2czMk91dHB1dChzdGF0ZVsxXSldCiAgICBmcmFtZV9kaWcgNQogICAgaXRvYgogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgOQogICAgY2FsbHN1YiBfX3BjZzMyT3V0cHV0CiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBzaGwKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBfX3BjZzMyT3V0cHV0CiAgICB8CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NTcKICAgIC8vIGNvbnN0IFtuZXdTdGF0ZSwgY2FuZGlkYXRlXSA9IF9fcGNnNjRVbmJvdW5kZWRSYW5kb20oc3RhdGUpCiAgICBkdXAKICAgIGV4dHJhY3QgMCAxNgogICAgc3dhcAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjU5CiAgICAvLyBpZiAoY2FuZGlkYXRlID49IHRocmVzaG9sZCkgewogICAgZnJhbWVfZGlnIDEwCiAgICA+PQogICAgYnogc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo2MAogICAgLy8gcmVzdWx0LnB1c2gobmV3IGFyYzQuVWludDY0KChjYW5kaWRhdGUgJSBhYnNvbHV0ZUJvdW5kKSArIGxvd2VyQm91bmQpKQogICAgZnJhbWVfZGlnIDYKICAgIGZyYW1lX2RpZyA0CiAgICAlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTgyCiAgICAvLyBjb25zdCBybmdSZXN1bHQgPSBwY2c2NFJhbmRvbShybmdTdGF0ZSwgMSwgdXBwZXJCb3VuZCwgTWF4R2xvYmFsU3RhdGVVaW50NjRBcnJheSkKICAgIGludGNfMSAvLyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjYwCiAgICAvLyByZXN1bHQucHVzaChuZXcgYXJjNC5VaW50NjQoKGNhbmRpZGF0ZSAlIGFic29sdXRlQm91bmQpICsgbG93ZXJCb3VuZCkpCiAgICArCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1NQogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBmcmFtZV9kaWcgNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgNwogICAgZnJhbWVfYnVyeSAzCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3doaWxlX3RvcEAxNgoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfYWZ0ZXJfaWZfZWxzZUAyMDoKICAgIGZyYW1lX2J1cnkgMwogICAgYiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV93aGlsZV90b3BAMTgKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX3Rlcm5hcnlfZmFsc2VAMjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvbGliX3BjZy9wY2c2NC5hbGdvLnRzOjEwCiAgICAvLyBjb25zdCBuZXdTdGF0ZTIgPSBfX3BjZzMyU3RlcChzdGF0ZVsxXSwgbmV3U3RhdGUxID09PSAwID8gb3Auc2hsKHBjZ1NlY29uZEluY3JlbWVudCwgMSkgOiBwY2dTZWNvbmRJbmNyZW1lbnQpCiAgICBpbnRjIDggLy8gMTQ0MjY5NTA0MDg4ODk2MzQwOQogICAgYiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV90ZXJuYXJ5X21lcmdlQDI3CgpzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl93aGlsZUAyMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9saWJfcGNnL3BjZzY0LmFsZ28udHM6NjcKICAgIC8vIHJldHVybiBbc3RhdGUsIHJlc3VsdF0KICAgIGZyYW1lX2RpZyAzCiAgICBwdXNoYnl0ZXMgMHgwMDEyCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5ODQKICAgIC8vIHRoaXMucmV3YXJkcyhyZXdhcmRJRCkudmFsdWUud2lubmluZ1RpY2tldHMgPSBkZWNvZGVBcmM0PHVpbnQ2NFtdPihybmdSZXN1bHRbMV0uYnl0ZXMpCiAgICBkdXAKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBmcmFtZV9kaWcgMTIKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgcHVzaGludCA1NyAvLyA1NwogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICBleHRyYWN0MwogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMQogICAgYm94X2RlbAogICAgcG9wCiAgICBkaWcgMQogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4NQogICAgLy8gdGhpcy5yZXdhcmRzKHJld2FyZElEKS52YWx1ZS52cmZGYWlsdXJlQ291bnQgPSAwCiAgICBwdXNoaW50IDgzIC8vIDgzCiAgICBmcmFtZV9kaWcgMAogICAgYm94X3JlcGxhY2UKICAgIHJldHN1YgoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5yYWZmbGVfZWxzZV9ib2R5QDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2xpYl9wY2cvcGNnNjQuYWxnby50czo1MAogICAgLy8gYWJzb2x1dGVCb3VuZCA9IG9wLmJ0b2koQnl0ZXMoQmlnVWludCgyICoqIDY0KSAtIEJpZ1VpbnQobG93ZXJCb3VuZCkpKQogICAgaW50YyAxMCAvLyAxODQ0Njc0NDA3MzcwOTU1MTYxNQogICAgZnJhbWVfYnVyeSA0CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2FmdGVyX2lmX2Vsc2VAMTUKCnNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wucmFmZmxlX2lmX2JvZHlANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo5NzkKICAgIC8vIHVwcGVyQm91bmQgKz0gMQogICAgZnJhbWVfZGlnIDEzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAxMQogICAgYiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLnJhZmZsZV9hZnRlcl9pZl9lbHNlQDUKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZSgpIC0+IHVpbnQ2NDoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MAogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHN0YXR1cyA9IEdsb2JhbFN0YXRlPFN0YWtpbmdQb29sU3RhdHVzPih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhdHVzIH0pCiAgICBieXRlYyA5IC8vICJzdGF0dXMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MAogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gMHgwMAogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDcwLTEwNzEKICAgIC8vIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wID49IHRoaXMuc3RhcnRUaW1lc3RhbXAudmFsdWUpICYmCiAgICBieiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZV9ib29sX2ZhbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDcxCiAgICAvLyAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlKSAmJgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHN0YXJ0VGltZXN0YW1wID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogUG9vbEdsb2JhbFN0YXRlS2V5U3RhcnRUaW1lc3RhbXAgfSkKICAgIGJ5dGVjIDE4IC8vICJzdGFydF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MQogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA+PQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzAtMTA3MQogICAgLy8gdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlX2Jvb2xfZmFsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNzIKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDw9IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlIHx8IHRoaXMuZW5kVGltZXN0YW1wLnZhbHVlID09PSAwKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjUKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTYgLy8gImVuZF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgPD0KICAgIGJueiBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sLmlzTGl2ZV9ib29sX3RydWVANAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMjUKICAgIC8vIGVuZFRpbWVzdGFtcCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IFBvb2xHbG9iYWxTdGF0ZUtleUVuZFRpbWVzdGFtcCB9KQogICAgYnl0ZWMgMTYgLy8gImVuZF90aW1lc3RhbXAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTA3MgogICAgLy8gKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2wuaXNMaXZlX2Jvb2xfZmFsc2VANQoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmVfYm9vbF90cnVlQDQ6CiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNjktMTA3MwogICAgLy8gcmV0dXJuICgKICAgIC8vICAgdGhpcy5zdGF0dXMudmFsdWUgIT09IFBvb2xTdGF0dXNEcmFmdCAmJgogICAgLy8gICAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA+PSB0aGlzLnN0YXJ0VGltZXN0YW1wLnZhbHVlKSAmJgogICAgLy8gICAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8PSB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSB8fCB0aGlzLmVuZFRpbWVzdGFtcC52YWx1ZSA9PT0gMCkKICAgIC8vICkKICAgIHJldHN1YgoKc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbC5pc0xpdmVfYm9vbF9mYWxzZUA1OgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDY5LTEwNzMKICAgIC8vIHJldHVybiAoCiAgICAvLyAgIHRoaXMuc3RhdHVzLnZhbHVlICE9PSBQb29sU3RhdHVzRHJhZnQgJiYKICAgIC8vICAgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPj0gdGhpcy5zdGFydFRpbWVzdGFtcC52YWx1ZSkgJiYKICAgIC8vICAgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPD0gdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgfHwgdGhpcy5lbmRUaW1lc3RhbXAudmFsdWUgPT09IDApCiAgICAvLyApCiAgICByZXRzdWIK","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CyALAAEIXKCNBq3+1eTUhf2oWJADz4Keu+/v3oIU0YKeu+/v3oIU/////w////////////8BJiQEFR98dQtlbnRyeV9jb3VudAlha2l0YV9kYW8BAAhha2l0YV9hbAR0eXBlAgAAAQoHZ2F0ZV9pZAZzdGF0dXMHY3JlYXRvcgEUAWUBHgttYXhfZW50cmllcwGADWVuZF90aW1lc3RhbXAGd2FsbGV0D3N0YXJ0X3RpbWVzdGFtcAFyFGFraXRhX3JveWFsdHlfYW1vdW50CXN0YWtlX2tleQ1ha2l0YV9yb3lhbHR5EmFsbG93X2xhdGVfc2lnbnVwcwV0aXRsZRRtaW5pbXVtX3N0YWtlX2Ftb3VudAxha2l0YV9lc2Nyb3cQc2lnbnVwX3RpbWVzdGFtcAxyZXdhcmRfY291bnQIb3RoZXJfYWwEc2FsdAhwbHVnbl9hbATJBogJEmNvbnRyb2xsZWRfYWRkcmVzcxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAggIEq4shOgTqkYDdNhoAjgIAsgCmMRkURDEYQQCPghMEg/FHSAQ5Tq6yBGRae8wEDy/DEgQYHoKRBGhVjHAEqUGNNwT8aZyzBG52ssoEzbCsagSyI9NdBFku40EEj6ShYATjN3NCBHFwRkkEHq0gqQQz6SyUBIVN7eAEpLPniTYaAI4TAisCwAQLBB4EVAT2BxAIIAguD30P9RAaEFIQYBB8ES4RhwABEaQAI0OABHd+w+U2GgCOAQDbADEZgQQSMRgQREIRLzEZgQUSMRgQREICWIoBAYv/gRKRi/8bgRuRIQkai/+BO5FKkUwcIx5FAYEfGk8CTJAhCRoZiYoCAYv+Jx1lSIEYW7GABDwabzOyGov/shqyGIEGshAisgGztD5JVwQASwFXAAQoEkRJIlmBAghMFRJEVwYASRVJQQAHiwEkE0EABCKMAImLABdC//eKBAKxi/wnBGVIgShbi/4WgAQgD3QhshqL/bIashqL/7IashiBBrIQIrIBs7Q+SVcEAExXAAQoEkRJFSMSRCJTi/+JgABJNhoBSSJZgQIISwEVEkRXAgA2GgJJFSMSRDYaA0kVgSASRDYaBEkVgSgSRDYaBUkVgSASRDYaBjYaB0kVJBJEFzYaCEkVJBJEFzYaCUkVJBJEFzYaCkkVJBJEFzYaC0kVJBJEFycJK2cnGE8LZycFTwpnJwpPCWeABmZ1bmRlck8IZ4ALbWFya2V0cGxhY2VPB2cnFU8GZycZTwVnJwhPBGcnDk8DZyceMRdnKk8CZycaTGciKmVESYAMc3Rha2luZ19mZWVzZUhMJwRlSCJMgWhbQQA7IiplRCInCmVEsUwnBGVIgWhbgATVdLsQshqyGLIagQayECKyAbO0PklXBABMVwAEKBJESRUkEkQXRQFLAUkkW0UEgRBbRQRJIw1BABdJIwlLBElLBQlPAguB6AcKCScWTGcjQyNC/+gyDjIJEkQiJwhlREEARrEiKmVEJwRlSIEoWyInCGVEFoAE31awHrIashqyGIEGshAisgGztD5JVwQATFcABCgSREkVJBJEF4AJZ2F0ZV9zaXplTGcjQzYaAUkVgSASRDEAMgkSRCInCmVEEkQiJwllRCsSQAALMgciJxBlRA1BABAjRLEyCbIJI7IQIrIBsyNDIkL/7TEWIwlJOBAjEkQ2GgFJFSQSRBcxACInCmVEEkQyA0sBcABFARQyECOBBE8DTQtLAjgHMgoSTwM4CE8CgcA+CBIQRLEyCksBshEishKyFIEEshAisgGzIiplREknEWVITEknH2VISVcICEwkW08CJxFlSLGABKJAPd+yGoATAAEAAgANc3Rha2luZ19wb29sc7IashiBBrIQIrIBs7Q+SVcEAEsBVwAEKBJESSJZgQkLgQIITBUSRFcGCSJbSUQiJxplRExLARJEsYAEWC/zgrIaTwKyGicPshqADwANc3Rha2luZ19wb29sc7IaJwayGicGshpLArIYgQayECKyAbZyCEQyELIIsgcjshAisgG2SwEWTwMWgAIAAUxQgARoNeO8shpMshonD7IashqyGIEGshAisgG2gARsw/YGshqyGIEGshAisgGzI0MxFiMJSTgQIxJENhoBiA9/SCNDMRaBAglJOBAjEkQxFiMJSTgQgQQSRDYaAUsBOBQyChJLAjgRSwIiWxIQTwI4EhBEiA9JSCNDNhoBSRUkEkQXSTYaAkkVJBJEF0w2GgNJFSQSRBdMMQAiJwplRBJEIicJZUQrEkQyBw1AAA1LAkAAZCInF2VEQQBcI0RLAUEACEsBMgcNQQBJI0RLAUAAE0sCQAA5IicXZURBADEjRDIHRQJJQQALSwGBCghLAQxBABgjRCcbSwNnJxJLAmcnEEsBZycJJwdnI0MiQv/lIkL/zCJC/7QiQv+hIkcDgABHBDEWIwlJOBAjEkQ2GgE2GgKIEWNEIicIZURBACUyCDEAiPszSUUFMQBFCkAB3UsIMggiJwhlRExOAksDiPttRQJEIillRCMIIicOZUQMQAAIIicOZURAAa4jREsBIllJRQmBqIsDC4ABdTEAUL1FAUAABYHUkwEISwNJOAcyChJMOAhPAhIQRCInFWVESVcAIEUNSYEgWUsBFVJFCyJFBksFSwgMQQFdSwFXAgBLBklOAoECC0sBTFlPAiMISUUJSwpLAQlLAxVPAoECC0sETFlPAk1SSUULJFtJRQYiJxllRA9ESwsyAxNBAFuxIiplRCcEZUiBSFtLCklXAAgBAUsBgRBZSwIVTwNOAlIjFoAEK/PMWrIaSw+yGksOshpPArIaTLIashqyGIEGshAisgGztD5JVwQATFcABCgSREkVIxJEIlNEIicFZUQnBxJAAAsiJwVlRCcLEkEAGDEASwoiW3AATEUIQQCWSwZLBQ9BAI4jRLEiKmVEJwRlSCJbMQCIDG1LDFcACElPAlAnILIaTwKyGrIaTLIYgQayECKyAbO0PklXBABLAVcABCgSRBWBGBJEgQRbSwZJTgIPRCIpZURJIwgpTGcxAEsDUE8CFlCAAwAzAFBLA1BMFicMSwFQSbxITwK/MQBPAlBJVwAgTFcgCFCAAWFMUEy/Qv6fIkL/byNDIkL+T0sDJyFlSEL+HDYaAUkVJBJEF4gPV0QWJxNMUEcCvUUBREmBWyO6SwGBGSS6F0sCgXQkuhdOA08CgREkuhdOAkwrEkQyB0kiJxJlRAlPAhgJSTIHE0EAvksCSwEMQQC2I0QiJxhlRIAKIC0gUmV3YXJkc1AyB0lLBAgyCCcEZUgkW0sDFSEGSwELgeSTAghLAnIIRLGyB7III7IQIrIBthZXBgJPBFBPAxZPAxYiFoAEHJ6727IaTwOyGk8CshpMshonBrIaTLIYgQayECKyAbO3AT5JVwQATFcABCgSREkVJBJESwVJgSFLBLtJgSlLBLtJgVsnB7tJJU8Eu0mBZE8DuzIGFksBgWxPArsyBxaBdEy7I0MiQv9HNhoBSRUkEkQXiAwsI0MiRweAAEcZNhoBSRUkEkQXSTYaAkkVJBJEF0wWJxNMUEcCvUUBREmBWyO6SU8CJCO6TCcHEklAAAhLAicLEkEHCiNESUECIksDSSUkuhdJTgJFFkkkI7pFBEmBCSS6F0UPIiS6F0UcIkUaIkUKSwUIIillRA1BAAkiKWVESxQJRQVLE0URSxBLBQxBARhLEBYnDExQSUUjSb5ESwGBMiO6IlNLAiKBILpFK0sBgTBZSwIVTwNOAlJFI0yBKCS6F0UPQABdIicFZUQrEkEAdYAJgAAAAAAAAAAAIlNBAEMiJwhlREEARDIISyiI9zhJRQlAAEdLJzIIIicIZURMTgJLI4j3dkhAACIiJwVlRCcHE0EADkshSYEyI7oiI1SBMky7SxAjCEURQv9bSxgjCEUZSwhLDghFCUL/50sHJyFlSEL/siInBWVEJwcSQQBPSyFJIoEgukyBICS6sSIqZUQnBGVIIluABMb9DKWyGk8CshpMshonD7IashiBBrIQIrIBs7Q+SVcEAExXAAQoEkRJFSQSRBcWJw9MUEL/PEsQiAgIQv80SwNJgSEkuhdLGggWSwGBIU8Cu0mBKSS6F0sKCBaBKUy7IillREsUEkEAiEsDSYFbJwu7IhZLASVPAruBISS6F0UPSwEnCxJBAFRLDksNCyInFmVESSEEDkQdIQSXRRwnFEscZ0saQAASsTIDSxyyCLIHI7IQIrIBsyNDMgNLG0lOAnAARQFEsTIDTLIRSxyyErIUgQSyECKyAbNC/9siJxZlREkhBA5ESw0dIQSXRRxC/6xLA0klJLoXSwYIFiVMu0L/tUsBJwcSQQD8SwNJIiS6F0UcSSUkuhdJTgJFFkmBZCS6F0UiSYEpJLoXRRKBCSS6F0UdSwUIIillRA1BAAkiKWVESxQJRQUiJxRlREscTAlFHyIWRScnBkUjIkULSxNFEUsQSwUMQQBjSxAWJwxMUEmBMiO6IlNLAYEoJLoXRRBMIoEgukUpQAA5Sw1JSxFJTgMMRCEEHU8Cl0khBA5ESx8dIQSXSRZLKUxQSyRJTwJQTCJZIwgWVwYCXABFJEsLCEULSxAjCEURQv+VSwNJJSS6F0sGSU4DCBYlTLtLIEscSyVLDogHhkgiKWVESxVPAggSQf7ASwNJgVsnDbslSyi7Qv6xSwEnCxJBAPFLA0mBZCS6F0UhSSUkuhdJTgJFFkmBISS6F0sBgQkkuhdPAiIkuhdJTgNFH0xLAQsiJxRlRAkiJxZlREkhBA5ESwIdIQSXTwJMCUUgMgpPAnAASA5ESwUIIillRA1BAAkiKWVESxQJRQUiFkUmJwZFIyJFC0sTRRFLEEsFDEEAQUsQFicMTFBJgTIjuiJTTCKBILpFKUAAIEscSRZLKUxQSyRJTwJQTCJZIwgWVwYCXABFJEsLCEULSxAjCEURQv+3SxNLBQhJFksFJU8Cu0sgSxxLJUsOiAaISCIpZUQSQf3HSwNJgVsnDbslSye7Qv24SwEnDRJBAN5LA0mBZCS6F0UhSSUkuhdJTgJFFkmBISS6F0URSSIkuhdJTgJFHoEJJLoXSU4CRQ4yCkxwAEgiJxRlRE8CTAlJRSEPREsFCCIpZUQNQQAJIillREsUCUUFSx1LDwpFHCIWRSUnBkUjSxNFEUsQSwUMQQA7SxAWJwxMUEmBMiO6IlNMIoEgukUpQAAaSxsWSyhMUEsjSU8CUEwiWSMIFlcGAlwARSNLECMIRRFC/71LE0sFCEkWSwUlTwK7SyBLHEslSw6IBaJIIillRBJB/OFLA0mBWycNuyVLJrtC/NJLAYABKBJESwODAnwCuhdAAAhLBYgGx0L8uEsDSYFkJLoXRSFJJSS6F0lOAkUWSYExJLoXRQlJIiS6F0lOAkUegQkkuhdJTgJFDjIKTHAASCInFGVETwJMCUlFIQ9ESwUIIillRA1BAAkiKWVESxQJRQVLBkABfksdRRxLA0mDAjsYukkkW0lOA0UPSSJbSU4CRQ6BEFtFGCQLgX4IJLoXRRciFkUlJwZFJEUXSxNFEksRSwUMQQClSxEWJwxMUEmBMiO6IlNFFEkigSC6RSlJgSAkuhdFG4EoJLoXSxdJTwIIRRlLFg5BAPxLFUsYDkEA9EsSQAAgSxsWSyhMUEsjSU8CUEwiWSMIFlcGAlwARSNLFCMIRRVLA4MCfAK6FyMJSwoSQQCVSwZLFRNBAC5LA0klSya7SYE7JyK7Sb5ISYE5WSJMWCcGUEsBvEi/Sx9LGkskSw2IBDFIQvt1Sx9LG0skSw2IBCJISwZLFRJBAChLA0mBWycNu0klSya7SYE7JyK7Sb5ISYE5WSJMWCcGUEsBvEi/Qvs5SwNJJSS6F0sGCBZLASVPArtLChZLDRZQSxYWUIE7TLtC+xZLBEsSCUUFSwkjCElFCyQLgX4ISwRJTwIkuhdFFyVLJbsiRRIiRQwiRRhLFyMIRRdLESMIRRJC/rtLHUsHCkUcQv58IkL48zYaAUkVJBJEFxYnE0xQSb1FAURJgVsjuksBgWQkukkXTwInDRJEIiplRCcEZUgkW7GABFQkpZGyGk8CshqyGIEGshAisgGzFoABZExQIrlISYFbK7siFksBgWRLArtLAYFsSwK7SwElSwK7SwGBIUsCu4EpTLsjQzYaAUkVgSASRDYaAkkVJBJEFxZQgAFhTFC+RBeIAcQoTFCwI0MiJwllRCsTQQAqMgciJxtlRA1BAB8yByInEmVEDEAACCInF2VEQQAMIysiTwJUKExQsCNDIkL/8YgGHisiTwJUKExQsCNDNhoBSRWBIBJEgAF1TFC9RQErIk8CVChMULAjQyInCWVEIicYZUQiJwVlRCInG2VEIicXZUQiJxJlRCInEGVEIicOZUQiKWVEIwgiJxxlRCMIIoAMdG90YWxfc3Rha2VkZUQiJxVlRCInGWVEIicIZUQiJwplREsNFRZXBgJPDlBPDoACAG9QSwEVgW8ITE8PUE8OFlBPDBZQKyJPDlRQTwsWUE8KFlBPCRZQTwgWUE8HFlBMFlcGAlBPBBZQTwMWUE8CUExQTFAoTFCwI0M2GgFJFSQSRBcxACIqZUQnEWVIcghEEkQnGkxnI0M2GgFJIlmBAghLARUSRFcCADEAIiplREknEWVIcghETwISRCcfZUiBEFsyDRJEgAd2ZXJzaW9uTGcjQzYaAUkVJBJEFzEAIiplRCcRZUhyCEQSRCpMZyNDNhoBSRUkEkQXIQYLFoAYAAAAAAAAYtQAAAAAAABJ1AAAAAAAAGLUTFCB1C8WUChMULAjQ4oBASJHAoAARwMiJwVlRCsTQAALIicFZUQnBxNBAPMjRIv/FicMTFBJjAJJgTIjuiJTSwEigSC6jABLAYEgJLpJjAEXjANMgSgkuheMBEEABScjjACJIicFZUQnCxJBAGGxIiplRCcEZUgiW4AESHFvGrIaiwCyGosBshqyGIEGshAisgGztD5JVwQASwFXAAQoEkQVgQkSRIEFW0mMBYsED0EACosFFicPTFCMAImLAkmBMiO6IiNUgTJMuycjjACJsSIqZUQnBGVIIluIAEaLAxZMUCcgshqLALIashqyGIEGshAisgGztD5JVwQASwFXAAQoEkQVgRgSRIEEW0mMBosED0H/p4sGFicPTFCMAIkiQv8KIicFZURJKxNEFyMJFkmTJA5EVwcBiYoEASIqZUQnBGVIJFuL/iJZgcTCAQtMi/1AADSxSXIIRIsAi/8IsgiyByOyECKyAbaL/BaABFZWrPmyGrIai/6yGrIYgQayECKyAbOL/kyJsUlyCESLALIIsgcjshAisgG2SXIIRIv/shKL/bIRshSBBLIQIrIBtov8FoAEPGDfoLIashqL/rIashiBBrIQIrIBs0L/tooCASKAADEAIicKZUQSRIv/IlsURCInFWVEVwAgMgMTQAALi/9XCAEnBxNBAIwjRIv/VwgBSYwAgAEoEkEAG4v/gQlbi/+BMVtJjAENQQBmiwGBCg5BAF4jRIsAJw0SQQAYIicOZURBAA4iJw5lRIv/gQlbDkEAOiNEi/+BCVtEi/44BzIKEov+OAiL/4ExWyEGCw8QRCInHGVESSMIJxxMZxYnE0xQSbxIi/+/i/+MAIkiQv/DIkL/nyJC/3GKAQAiRwOAAEcHi/8WJxNMUEcCvUUBREmBWyO6SwGBbCS6F0sCgVMkuhdLA4EpJLoXTgRPAicLEkRPAoMCfAK6FxRETCMIgQRPAgsIsTIIJx1lSCJbTBYiJx5lREkVFlcGAkxQgAQYk5LFshpMshqyGrIYgQayECKyAbO0PklXBABLAVcABCgSREkiWYECCEwVEkRXBgBJFUlAABCLDEmBUyS6FyMIFoFTTLuJIosPSU4CDyJLAk8CTYEQSwIPgRBPA08CTYsOTgJSSRWBEBJESSJbIiEFHUUBSSEHHkUBTwIeRQEhBR1FASEHHk4CSE8CJFtMIQgeRQEeRQEhBR1FASEIHkUBTBZMFlCMAosNIQoMQAD9iw2MCyIWjAAnBowBiwtBAOWLC0kjDUQjCUmMBCMNRIsESRwjHkUBTBiMCiKMB4sCjAOLB4EPDEEAjIsDSSJbSYwJIQUdRQEhBx5JTgKMBUhMJFuMCEAAaYGihbz23t+9hSiLCEkhBR1FAU8CHkUBiwUWTBZQiwmI6kKBIJBPAojqOhkWUElXABBMgRBbSYwGiwoPQQAmiwaLBBgjCBaLAUlPAlBMIlkjCBZXBgJcAIwBiwcjCIwHjANC/3aMA0L/eSEIQv+ciwOAAgASUIsBUEmBEFlLARVSiwxJTgK+REmBOVkiTFhMUEsBvEhLAUy/gVOLALuJIQqMBEL/IosNIwiMC0L+/iInCWVEKxNBACAyByInEmVED0EAFTIHIicQZUQOQAAIIicQZURAAAIjiSKJ","clear":"C4EBQw=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type ObjectC3416591 = {
  valid: boolean,
  balance: bigint
}


/**
 * Converts the ABI tuple representation of a ObjectC3416591 to the struct representation
 */
export function ObjectC3416591FromTuple(abiTuple: [boolean, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ObjectC3416591, APP_SPEC.structs) as ObjectC3416591
}

export type RootKey = {
  address: string,
  name: string
}


/**
 * Converts the ABI tuple representation of a RootKey to the struct representation
 */
export function RootKeyFromTuple(abiTuple: [string, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RootKey, APP_SPEC.structs) as RootKey
}

export type EntryData = {
  address: string,
  asset: bigint,
  quantity: bigint,
  gateArgs: Uint8Array[],
  disqualified: boolean
}


/**
 * Converts the ABI tuple representation of a EntryData to the struct representation
 */
export function EntryDataFromTuple(abiTuple: [string, bigint, bigint, Uint8Array[], boolean]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryData, APP_SPEC.structs) as EntryData
}

export type EntryKey = {
  address: string,
  asset: bigint
}


/**
 * Converts the ABI tuple representation of a EntryKey to the struct representation
 */
export function EntryKeyFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EntryKey, APP_SPEC.structs) as EntryKey
}

export type RaffleCursor = {
  ticket: bigint,
  stake: bigint,
  disbursed: bigint
}


/**
 * Converts the ABI tuple representation of a RaffleCursor to the struct representation
 */
export function RaffleCursorFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.RaffleCursor, APP_SPEC.structs) as RaffleCursor
}

export type Reward = {
  asset: bigint,
  distribution: number,
  rate: bigint,
  expiration: bigint,
  interval: bigint,
  qualifiedStakers: bigint,
  qualifiedStake: bigint,
  winnerCount: bigint,
  winningTickets: bigint[],
  raffleCursor: RaffleCursor,
  vrfFailureCount: bigint,
  phase: number,
  disbursementCursor: bigint,
  activeDisbursementId: bigint,
  activeDisbursementRoundStart: bigint,
  lastDisbursementTimestamp: bigint
}


/**
 * Converts the ABI tuple representation of a Reward to the struct representation
 */
export function RewardFromTuple(abiTuple: [bigint, number, bigint, bigint, bigint, bigint, bigint, bigint, bigint[], [bigint, bigint, bigint], bigint, number, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Reward, APP_SPEC.structs) as Reward
}

export type StakingPoolMbrData = {
  entries: bigint,
  uniques: bigint,
  entriesByAddress: bigint,
  rewards: bigint,
  disbursements: bigint
}


/**
 * Converts the ABI tuple representation of a StakingPoolMBRData to the struct representation
 */
export function StakingPoolMbrDataFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakingPoolMBRData, APP_SPEC.structs) as StakingPoolMbrData
}

export type StakingPoolState = {
  status: number,
  title: string,
  type: number,
  signupTimestamp: bigint,
  startTimestamp: bigint,
  allowLateSignups: boolean,
  endTimestamp: bigint,
  maxEntries: bigint,
  entryCount: bigint,
  rewardCount: bigint,
  totalStaked: bigint,
  stakeKey: RootKey,
  minimumStakeAmount: bigint,
  gateId: bigint,
  creator: string
}


/**
 * Converts the ABI tuple representation of a StakingPoolState to the struct representation
 */
export function StakingPoolStateFromTuple(abiTuple: [number, string, number, bigint, bigint, boolean, bigint, bigint, bigint, bigint, bigint, [string, string], bigint, bigint, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakingPoolState, APP_SPEC.structs) as StakingPoolState
}

export type FunderInfo = {
  account: string,
  amount: bigint
}


/**
 * Converts the ABI tuple representation of a FunderInfo to the struct representation
 */
export function FunderInfoFromTuple(abiTuple: [string, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.FunderInfo, APP_SPEC.structs) as FunderInfo
}

/**
 * The argument types for the StakingPool contract
 */
export type StakingPoolArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': {
      title: string
      type: bigint | number
      creator: string
      funder: FunderInfo
      marketplace: string
      stakeKey: RootKey
      minimumStakeAmount: bigint | number
      gateId: bigint | number
      maxEntries: bigint | number
      akitaDao: bigint | number
      akitaDaoEscrow: bigint | number
    }
    'init()void': Record<string, never>
    'delete(address)void': {
      caller: string
    }
    'optIn(pay,uint64)void': {
      /**
       * The payment transaction
       */
      payment: AppMethodCallTransactionArgument
      /**
       * The asset to be opted into
       */
      asset: bigint | number
    }
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      reward: Reward
    }
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': {
      payment: AppMethodCallTransactionArgument
      assetXfer: AppMethodCallTransactionArgument
      reward: Reward
    }
    'finalize(uint64,uint64,uint64)void': {
      signupTimestamp: bigint | number
      startTimestamp: bigint | number
      endTimestamp: bigint | number
    }
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': {
      payment: AppMethodCallTransactionArgument
      entries: [bigint | number, bigint | number, Uint8Array[]][]
      args: Uint8Array[]
    }
    'startDisbursement(uint64)void': {
      rewardId: bigint | number
    }
    'raffle(uint64)void': {
      rewardId: bigint | number
    }
    'disburseRewards(uint64,uint64)void': {
      rewardId: bigint | number
      iterationAmount: bigint | number
    }
    'finalizeDistribution(uint64)void': {
      rewardId: bigint | number
    }
    'check(address,uint64)(bool,uint64)': {
      address: string
      asset: bigint | number
    }
    'signUpsOpen()bool': Record<string, never>
    'isLive()bool': Record<string, never>
    'isEntered(address)bool': {
      address: string
    }
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': Record<string, never>
    'updateAkitaDAOEscrow(uint64)void': {
      app: bigint | number
    }
    'update(string)void': {
      newVersion: string
    }
    'updateAkitaDAO(uint64)void': {
      akitaDao: bigint | number
    }
    'opUp()void': Record<string, never>
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': {
      winningTickets: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': [title: string, type: bigint | number, creator: string, funder: FunderInfo, marketplace: string, stakeKey: RootKey, minimumStakeAmount: bigint | number, gateId: bigint | number, maxEntries: bigint | number, akitaDao: bigint | number, akitaDaoEscrow: bigint | number]
    'init()void': []
    'delete(address)void': [caller: string]
    'optIn(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number]
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, reward: Reward]
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, reward: Reward]
    'finalize(uint64,uint64,uint64)void': [signupTimestamp: bigint | number, startTimestamp: bigint | number, endTimestamp: bigint | number]
    'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': [payment: AppMethodCallTransactionArgument, entries: [bigint | number, bigint | number, Uint8Array[]][], args: Uint8Array[]]
    'startDisbursement(uint64)void': [rewardId: bigint | number]
    'raffle(uint64)void': [rewardId: bigint | number]
    'disburseRewards(uint64,uint64)void': [rewardId: bigint | number, iterationAmount: bigint | number]
    'finalizeDistribution(uint64)void': [rewardId: bigint | number]
    'check(address,uint64)(bool,uint64)': [address: string, asset: bigint | number]
    'signUpsOpen()bool': []
    'isLive()bool': []
    'isEntered(address)bool': [address: string]
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': []
    'updateAkitaDAOEscrow(uint64)void': [app: bigint | number]
    'update(string)void': [newVersion: string]
    'updateAkitaDAO(uint64)void': [akitaDao: bigint | number]
    'opUp()void': []
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': [winningTickets: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type StakingPoolReturns = {
  'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void': void
  'init()void': void
  'delete(address)void': void
  'optIn(pay,uint64)void': void
  'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void': void
  'finalize(uint64,uint64,uint64)void': void
  'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void': void
  'startDisbursement(uint64)void': void
  'raffle(uint64)void': void
  'disburseRewards(uint64,uint64)void': void
  'finalizeDistribution(uint64)void': void
  'check(address,uint64)(bool,uint64)': ObjectC3416591
  'signUpsOpen()bool': boolean
  'isLive()bool': boolean
  'isEntered(address)bool': boolean
  'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': StakingPoolState
  'updateAkitaDAOEscrow(uint64)void': void
  'update(string)void': void
  'updateAkitaDAO(uint64)void': void
  'opUp()void': void
  'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': StakingPoolMbrData
}

/**
 * Defines the types of available calls and state of the StakingPool smart contract.
 */
export type StakingPoolTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void' | 'create', {
      argsObj: StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
      returns: StakingPoolReturns['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']
    }>
    & Record<'init()void' | 'init', {
      argsObj: StakingPoolArgs['obj']['init()void']
      argsTuple: StakingPoolArgs['tuple']['init()void']
      returns: StakingPoolReturns['init()void']
    }>
    & Record<'delete(address)void' | 'delete', {
      argsObj: StakingPoolArgs['obj']['delete(address)void']
      argsTuple: StakingPoolArgs['tuple']['delete(address)void']
      returns: StakingPoolReturns['delete(address)void']
    }>
    & Record<'optIn(pay,uint64)void' | 'optIn', {
      argsObj: StakingPoolArgs['obj']['optIn(pay,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['optIn(pay,uint64)void']
      returns: StakingPoolReturns['optIn(pay,uint64)void']
    }>
    & Record<'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addReward', {
      argsObj: StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addRewardAsa', {
      argsObj: StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      argsTuple: StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
      returns: StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'finalize(uint64,uint64,uint64)void' | 'finalize', {
      argsObj: StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']
      returns: StakingPoolReturns['finalize(uint64,uint64,uint64)void']
    }>
    & Record<'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' | 'enter', {
      argsObj: StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      argsTuple: StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
      returns: StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']
    }>
    & Record<'startDisbursement(uint64)void' | 'startDisbursement', {
      argsObj: StakingPoolArgs['obj']['startDisbursement(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['startDisbursement(uint64)void']
      returns: StakingPoolReturns['startDisbursement(uint64)void']
    }>
    & Record<'raffle(uint64)void' | 'raffle', {
      argsObj: StakingPoolArgs['obj']['raffle(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['raffle(uint64)void']
      returns: StakingPoolReturns['raffle(uint64)void']
    }>
    & Record<'disburseRewards(uint64,uint64)void' | 'disburseRewards', {
      argsObj: StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void']
      argsTuple: StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']
      returns: StakingPoolReturns['disburseRewards(uint64,uint64)void']
    }>
    & Record<'finalizeDistribution(uint64)void' | 'finalizeDistribution', {
      argsObj: StakingPoolArgs['obj']['finalizeDistribution(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']
      returns: StakingPoolReturns['finalizeDistribution(uint64)void']
    }>
    & Record<'check(address,uint64)(bool,uint64)' | 'check', {
      argsObj: StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)']
      argsTuple: StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']
      returns: StakingPoolReturns['check(address,uint64)(bool,uint64)']
    }>
    & Record<'signUpsOpen()bool' | 'signUpsOpen', {
      argsObj: StakingPoolArgs['obj']['signUpsOpen()bool']
      argsTuple: StakingPoolArgs['tuple']['signUpsOpen()bool']
      /**
       * a boolean of whether sign ups are open
       */
      returns: StakingPoolReturns['signUpsOpen()bool']
    }>
    & Record<'isLive()bool' | 'isLive', {
      argsObj: StakingPoolArgs['obj']['isLive()bool']
      argsTuple: StakingPoolArgs['tuple']['isLive()bool']
      /**
       * a boolean of whether the pool is live
       */
      returns: StakingPoolReturns['isLive()bool']
    }>
    & Record<'isEntered(address)bool' | 'isEntered', {
      argsObj: StakingPoolArgs['obj']['isEntered(address)bool']
      argsTuple: StakingPoolArgs['tuple']['isEntered(address)bool']
      /**
       * a boolean indicating if the address has entered the staking pool
       */
      returns: StakingPoolReturns['isEntered(address)bool']
    }>
    & Record<'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' | 'getState', {
      argsObj: StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      argsTuple: StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
      returns: StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
    }>
    & Record<'updateAkitaDAOEscrow(uint64)void' | 'updateAkitaDAOEscrow', {
      argsObj: StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']
      returns: StakingPoolReturns['updateAkitaDAOEscrow(uint64)void']
    }>
    & Record<'update(string)void' | 'update', {
      argsObj: StakingPoolArgs['obj']['update(string)void']
      argsTuple: StakingPoolArgs['tuple']['update(string)void']
      returns: StakingPoolReturns['update(string)void']
    }>
    & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
      argsObj: StakingPoolArgs['obj']['updateAkitaDAO(uint64)void']
      argsTuple: StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']
      returns: StakingPoolReturns['updateAkitaDAO(uint64)void']
    }>
    & Record<'opUp()void' | 'opUp', {
      argsObj: StakingPoolArgs['obj']['opUp()void']
      argsTuple: StakingPoolArgs['tuple']['opUp()void']
      returns: StakingPoolReturns['opUp()void']
    }>
    & Record<'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' | 'mbr', {
      argsObj: StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
      /**
       * the mbr created for each boxmap entry
       */
      returns: StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        /**
         * the status the pool is in
         */
        status: number
        /**
         * title of the staking pool
         */
        title: string
        /**
         * the method of staking to be used for the pool
         */
        type: number
        /**
         * the timestamp when sign ups for the pool are allowed
         */
        signupTimestamp: bigint
        /**
         * whether signups are allowed after the staking pool begins
         */
        allowLateSignups: bigint
        /**
         * the timestamp when the pool starts
         */
        startTimestamp: bigint
        /**
         * the timestamp when the pool ends
         */
        endTimestamp: bigint
        /**
         * the maximum entries allowed for the pool
         */
        maxEntries: bigint
        /**
         * the number of entries in a pool
         */
        entryId: bigint
        /**
         * the number of rewards for the pool
         */
        rewardId: bigint
        /**
         * the total amount staked in the pool
         */
        totalStaked: bigint
        /**
        * the name for the meta merkle asset group to validate staking
        stake key can be empty if distribution !== DistributionTypePercentage

         */
        stakeKey: RootKey
        /**
         * minimum stake amount
         */
        minimumStakeAmount: bigint
        /**
         * the gate id of the pool
         */
        gateId: bigint
        /**
         * the size of the gate were using
         */
        gateSize: bigint
        /**
         * the address of the creator of the staking pool
         */
        creator: string
        /**
         * marketplace is pool creation side marketplace
         */
        marketplace: string
        /**
         * the amount the marketplaces will get for the sale
         */
        marketplaceRoyalties: bigint
        /**
         * the akita royalty for the pool
         */
        akitaRoyalty: bigint
        /**
         * the amount of royalties that were paid in a disbursement
         */
        akitaRoyaltyAmount: bigint
        /**
         * salt for randomness
         */
        salt: BinaryState
        /**
         * the app ID for the akita DAO escrow to use
         */
        akitaDaoEscrow: bigint
        /**
         * the current version of the contract
         */
        version: string
        /**
         * the app ID of the Akita DAO
         */
        akitaDao: bigint
        funder: FunderInfo
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        /**
         * indexed entries for efficient iteration
         */
        entries: Map<bigint | number, EntryData>
        /**
         * the number of unique asset entries by address
         */
        uniques: Map<string, bigint>
        /**
         * the entries in the pool
         */
        entriesByAddress: Map<EntryKey, bigint>
        /**
         * the rewards for this staking pool
         */
        rewards: Map<bigint | number, Reward>
        /**
         * the disbursements this pool as created & finalized
         */
        disbursements: Map<bigint | number, Uint8Array>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type StakingPoolSignatures = keyof StakingPoolTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type StakingPoolNonVoidMethodSignatures = keyof StakingPoolTypes['methods'] extends infer T ? T extends keyof StakingPoolTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the StakingPool smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the StakingPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = StakingPoolTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = StakingPoolTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type StakingPoolCreateCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & {method: 'create'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & {method: 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines supported update method params for this smart contract
 */
export type StakingPoolUpdateCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {method: 'update'}>
  | Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {method: 'update(string)void'}>
/**
 * Defines supported delete method params for this smart contract
 */
export type StakingPoolDeleteCallParams =
  | Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {method: 'delete'}>
  | Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {method: 'delete(address)void'}>
/**
 * Defines arguments required for the deploy method.
 */
export type StakingPoolDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: StakingPoolCreateCallParams
  /**
   * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  updateParams?: StakingPoolUpdateCallParams
  /**
   * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  deleteParams?: StakingPoolDeleteCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the StakingPool smart contract
 */
export abstract class StakingPoolParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends StakingPoolCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'create':
          case 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void':
            return StakingPoolParamsFactory.create.create(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.title, params.args.type, params.args.creator, params.args.funder, params.args.marketplace, params.args.stakeKey, params.args.minimumStakeAmount, params.args.gateId, params.args.maxEntries, params.args.akitaDao, params.args.akitaDaoEscrow],
        }
      },
    }
  }

  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod<TParams extends StakingPoolUpdateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'update':
          case 'update(string)void':
            return StakingPoolParamsFactory.update.update(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs update ABI call params for the StakingPool smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams {
        return {
          ...params,
          method: 'update(string)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.newVersion],
        }
      },
    }
  }

  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod<TParams extends StakingPoolDeleteCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'delete':
          case 'delete(address)void':
            return StakingPoolParamsFactory.delete.delete(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs delete ABI call params for the StakingPool smart contract using the delete(address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      delete(params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'delete(address)void' as const,
          args: Array.isArray(params.args) ? params.args : [params.args.caller],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the init()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static init(params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'init()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the optIn(pay,uint64)void ABI method
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optIn(params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'optIn(pay,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addReward(params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addRewardAsa(params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.assetXfer, params.args.reward],
    }
  }
  /**
   * Constructs a no op call for the finalize(uint64,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalize(params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalize(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.signupTimestamp, params.args.startTimestamp, params.args.endTimestamp],
    }
  }
  /**
   * Constructs a no op call for the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static enter(params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'enter(pay,(uint64,uint64,byte[32][])[],byte[][])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.entries, params.args.args],
    }
  }
  /**
   * Constructs a no op call for the startDisbursement(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static startDisbursement(params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'startDisbursement(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the raffle(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static raffle(params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'raffle(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the disburseRewards(uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static disburseRewards(params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'disburseRewards(uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId, params.args.iterationAmount],
    }
  }
  /**
   * Constructs a no op call for the finalizeDistribution(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeDistribution(params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalizeDistribution(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.rewardId],
    }
  }
  /**
   * Constructs a no op call for the check(address,uint64)(bool,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static check(params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'check(address,uint64)(bool,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.asset],
    }
  }
  /**
   * Constructs a no op call for the signUpsOpen()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'signUpsOpen()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isLive()bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isLive()bool' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the isEntered(address)bool ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'isEntered(address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.address],
    }
  }
  /**
   * Constructs a no op call for the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoEscrow(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAOEscrow(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.app],
    }
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAkitaDAO(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao],
    }
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'opUp()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.winningTickets],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the StakingPool smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class StakingPoolFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `StakingPoolFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new StakingPoolClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new StakingPoolClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the StakingPool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: StakingPoolDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? StakingPoolParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (StakingPoolCreateCallParams & { args: Uint8Array[] }) : undefined,
      updateParams: params.updateParams?.method ? StakingPoolParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams as (StakingPoolUpdateCallParams & { args: Uint8Array[] }) : undefined,
      deleteParams: params.deleteParams?.method ? StakingPoolParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams as (StakingPoolDeleteCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new StakingPoolClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.params.create(StakingPoolParamsFactory.create.create(params))
      },
    },

    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appFactory.params.deployUpdate(StakingPoolParamsFactory.update.update(params))
      },
    },

    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appFactory.params.deployDelete(StakingPoolParamsFactory.delete.delete(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        return this.appFactory.createTransaction.create(StakingPoolParamsFactory.create.create(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPool smart contract using an ABI method call using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params: CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
        const result = await this.appFactory.send.create(StakingPoolParamsFactory.create.create(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | StakingPoolReturns['create(string,uint8,address,(address,uint64),address,(address,string),uint64,uint64,uint64,uint64,uint64)void']) }, appClient: new StakingPoolClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the StakingPool smart contract
 */
export class StakingPoolClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param appClient An `AppClient` instance which has been created with the StakingPool app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }

  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends StakingPoolNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }

  /**
   * Returns a new `StakingPoolClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<StakingPoolClient> {
    return new StakingPoolClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `StakingPoolClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<StakingPoolClient> {
    return new StakingPoolClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.params.update(StakingPoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.params.delete(StakingPoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    init: (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optIn: (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.optIn(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addReward: (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addRewardAsa: (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalize: (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    enter: (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    startDisbursement: (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    raffle: (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    disburseRewards: (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeDistribution: (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    check: (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getState: (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.opUp(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(StakingPoolParamsFactory.mbr(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
        return this.appClient.createTransaction.update(StakingPoolParamsFactory.update.update(params))
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
        return this.appClient.createTransaction.delete(StakingPoolParamsFactory.delete.delete(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    init: (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.init(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optIn: (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.optIn(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addReward: (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.addReward(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addRewardAsa: (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.addRewardAsa(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalize: (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.finalize(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    enter: (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.enter(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    startDisbursement: (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.startDisbursement(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    raffle: (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.raffle(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    disburseRewards: (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.disburseRewards(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeDistribution: (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.finalizeDistribution(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    check: (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.check(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether sign ups are open
     */
    signUpsOpen: (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.signUpsOpen(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean of whether the pool is live
     */
    isLive: (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.isLive(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: a boolean indicating if the address has entered the staking pool
     */
    isEntered: (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.isEntered(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getState: (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.getState(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.updateAkitaDao(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.opUp(params))
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: the mbr created for each boxmap entry
     */
    mbr: (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(StakingPoolParamsFactory.mbr(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams & SendParams) => {
        const result = await this.appClient.send.update(StakingPoolParamsFactory.update.update(params))
        return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['update(string)void'])}
      },

    },

    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      delete: async (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & SendParams) => {
        const result = await this.appClient.send.delete(StakingPoolParamsFactory.delete.delete(params))
        return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['delete(address)void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    init: async (params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.init(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['init()void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optIn: async (params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.optIn(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['optIn(pay,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addReward: async (params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.addReward(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addRewardAsa: async (params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.addRewardAsa(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalize: async (params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.finalize(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['finalize(uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    enter: async (params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.enter(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    startDisbursement: async (params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.startDisbursement(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['startDisbursement(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    raffle: async (params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.raffle(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['raffle(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    disburseRewards: async (params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.disburseRewards(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['disburseRewards(uint64,uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeDistribution: async (params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.finalizeDistribution(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['finalizeDistribution(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    check: async (params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.check(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['check(address,uint64)(bool,uint64)'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether sign ups are open
     */
    signUpsOpen: async (params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.signUpsOpen(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['signUpsOpen()bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether the pool is live
     */
    isLive: async (params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.isLive(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['isLive()bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean indicating if the address has entered the staking pool
     */
    isEntered: async (params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.isEntered(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['isEntered(address)bool'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getState: async (params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.getState(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoEscrow: async (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.updateAkitaDaoEscrow(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.updateAkitaDao(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['updateAkitaDAO(uint64)void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.opUp(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['opUp()void'])}
    },

    /**
     * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: the mbr created for each boxmap entry
     */
    mbr: async (params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(StakingPoolParamsFactory.mbr(params))
      return {...result, return: result.return as unknown as (undefined | StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new StakingPoolClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether sign ups are open
   */
  async signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.signUpsOpen(params))
    return result.return as unknown as StakingPoolReturns['signUpsOpen()bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `isLive()bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean of whether the pool is live
   */
  async isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.isLive(params))
    return result.return as unknown as StakingPoolReturns['isLive()bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: a boolean indicating if the address has entered the staking pool
   */
  async isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.isEntered(params))
    return result.return as unknown as StakingPoolReturns['isEntered(address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> = {args: []}) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.getState(params))
    return result.return as unknown as StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']
  }

  /**
   * Makes a readonly (simulated) call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: the mbr created for each boxmap entry
   */
  async mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(StakingPoolParamsFactory.mbr(params))
    return result.return as unknown as StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Methods to access state for the current StakingPool app
   */
  state = {
    /**
     * Methods to access global state for the current StakingPool app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          status: result.status,
          title: result.title,
          type: result.type,
          signupTimestamp: result.signupTimestamp,
          allowLateSignups: result.allowLateSignups,
          startTimestamp: result.startTimestamp,
          endTimestamp: result.endTimestamp,
          maxEntries: result.maxEntries,
          entryId: result.entryID,
          rewardId: result.rewardID,
          totalStaked: result.totalStaked,
          stakeKey: result.stakeKey,
          minimumStakeAmount: result.minimumStakeAmount,
          gateId: result.gateID,
          gateSize: result.gateSize,
          creator: result.creator,
          marketplace: result.marketplace,
          marketplaceRoyalties: result.marketplaceRoyalties,
          akitaRoyalty: result.akitaRoyalty,
          akitaRoyaltyAmount: result.akitaRoyaltyAmount,
          salt: new BinaryStateValue(result.salt),
          akitaDaoEscrow: result.akitaDAOEscrow,
          version: result.version,
          akitaDao: result.akitaDAO,
          funder: result.funder,
        }
      },
      /**
       * Get the current value of the status key in global state
       */
      status: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("status")) as number | undefined },
      /**
       * Get the current value of the title key in global state
       */
      title: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("title")) as string | undefined },
      /**
       * Get the current value of the type key in global state
       */
      type: async (): Promise<number | undefined> => { return (await this.appClient.state.global.getValue("type")) as number | undefined },
      /**
       * Get the current value of the signupTimestamp key in global state
       */
      signupTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("signupTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the allowLateSignups key in global state
       */
      allowLateSignups: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("allowLateSignups")) as bigint | undefined },
      /**
       * Get the current value of the startTimestamp key in global state
       */
      startTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("startTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the endTimestamp key in global state
       */
      endTimestamp: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("endTimestamp")) as bigint | undefined },
      /**
       * Get the current value of the maxEntries key in global state
       */
      maxEntries: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("maxEntries")) as bigint | undefined },
      /**
       * Get the current value of the entryID key in global state
       */
      entryId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("entryID")) as bigint | undefined },
      /**
       * Get the current value of the rewardID key in global state
       */
      rewardId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("rewardID")) as bigint | undefined },
      /**
       * Get the current value of the totalStaked key in global state
       */
      totalStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("totalStaked")) as bigint | undefined },
      /**
       * Get the current value of the stakeKey key in global state
       */
      stakeKey: async (): Promise<RootKey | undefined> => { return (await this.appClient.state.global.getValue("stakeKey")) as RootKey | undefined },
      /**
       * Get the current value of the minimumStakeAmount key in global state
       */
      minimumStakeAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("minimumStakeAmount")) as bigint | undefined },
      /**
       * Get the current value of the gateID key in global state
       */
      gateId: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateID")) as bigint | undefined },
      /**
       * Get the current value of the gateSize key in global state
       */
      gateSize: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("gateSize")) as bigint | undefined },
      /**
       * Get the current value of the creator key in global state
       */
      creator: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("creator")) as string | undefined },
      /**
       * Get the current value of the marketplace key in global state
       */
      marketplace: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("marketplace")) as string | undefined },
      /**
       * Get the current value of the marketplaceRoyalties key in global state
       */
      marketplaceRoyalties: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("marketplaceRoyalties")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyalty key in global state
       */
      akitaRoyalty: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyalty")) as bigint | undefined },
      /**
       * Get the current value of the akitaRoyaltyAmount key in global state
       */
      akitaRoyaltyAmount: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaRoyaltyAmount")) as bigint | undefined },
      /**
       * Get the current value of the salt key in global state
       */
      salt: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.global.getValue("salt")) as Uint8Array | undefined) },
      /**
       * Get the current value of the akitaDAOEscrow key in global state
       */
      akitaDaoEscrow: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAOEscrow")) as bigint | undefined },
      /**
       * Get the current value of the version key in global state
       */
      version: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("version")) as string | undefined },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("akitaDAO")) as bigint | undefined },
      /**
       * Get the current value of the funder key in global state
       */
      funder: async (): Promise<FunderInfo | undefined> => { return (await this.appClient.state.global.getValue("funder")) as FunderInfo | undefined },
    },
    /**
     * Methods to access box state for the current StakingPool app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the entries map in box state
       */
      entries: {
        /**
         * Get all current values of the entries map in box state
         */
        getMap: async (): Promise<Map<bigint, EntryData>> => { return (await this.appClient.state.box.getMap("entries")) as Map<bigint, EntryData> },
        /**
         * Get a current value of the entries map by key from box state
         */
        value: async (key: bigint | number): Promise<EntryData | undefined> => { return await this.appClient.state.box.getMapValue("entries", key) as EntryData | undefined },
      },
      /**
       * Get values from the uniques map in box state
       */
      uniques: {
        /**
         * Get all current values of the uniques map in box state
         */
        getMap: async (): Promise<Map<string, bigint>> => { return (await this.appClient.state.box.getMap("uniques")) as Map<string, bigint> },
        /**
         * Get a current value of the uniques map by key from box state
         */
        value: async (key: string): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("uniques", key) as bigint | undefined },
      },
      /**
       * Get values from the entriesByAddress map in box state
       */
      entriesByAddress: {
        /**
         * Get all current values of the entriesByAddress map in box state
         */
        getMap: async (): Promise<Map<EntryKey, bigint>> => { return (await this.appClient.state.box.getMap("entriesByAddress")) as Map<EntryKey, bigint> },
        /**
         * Get a current value of the entriesByAddress map by key from box state
         */
        value: async (key: EntryKey): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("entriesByAddress", key) as bigint | undefined },
      },
      /**
       * Get values from the rewards map in box state
       */
      rewards: {
        /**
         * Get all current values of the rewards map in box state
         */
        getMap: async (): Promise<Map<bigint, Reward>> => { return (await this.appClient.state.box.getMap("rewards")) as Map<bigint, Reward> },
        /**
         * Get a current value of the rewards map by key from box state
         */
        value: async (key: bigint | number): Promise<Reward | undefined> => { return await this.appClient.state.box.getMapValue("rewards", key) as Reward | undefined },
      },
      /**
       * Get values from the disbursements map in box state
       */
      disbursements: {
        /**
         * Get all current values of the disbursements map in box state
         */
        getMap: async (): Promise<Map<bigint, Uint8Array>> => { return (await this.appClient.state.box.getMap("disbursements")) as Map<bigint, Uint8Array> },
        /**
         * Get a current value of the disbursements map by key from box state
         */
        value: async (key: bigint | number): Promise<Uint8Array | undefined> => { return await this.appClient.state.box.getMapValue("disbursements", key) as Uint8Array | undefined },
      },
    },
  }

  public newGroup(): StakingPoolComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a init()void method call against the StakingPool contract
       */
      init(params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.init(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a optIn(pay,uint64)void method call against the StakingPool contract
       */
      optIn(params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the StakingPool contract
       */
      addReward(params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addReward(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void method call against the StakingPool contract
       */
      addRewardAsa(params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addRewardAsa(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalize(uint64,uint64,uint64)void method call against the StakingPool contract
       */
      finalize(params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalize(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a enter(pay,(uint64,uint64,byte[32][])[],byte[][])void method call against the StakingPool contract
       */
      enter(params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.enter(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a startDisbursement(uint64)void method call against the StakingPool contract
       */
      startDisbursement(params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.startDisbursement(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a raffle(uint64)void method call against the StakingPool contract
       */
      raffle(params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.raffle(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a disburseRewards(uint64,uint64)void method call against the StakingPool contract
       */
      disburseRewards(params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.disburseRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalizeDistribution(uint64)void method call against the StakingPool contract
       */
      finalizeDistribution(params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeDistribution(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a check(address,uint64)(bool,uint64) method call against the StakingPool contract
       */
      check(params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.check(params)))
        resultMappers.push((v) => client.decodeReturnValue('check(address,uint64)(bool,uint64)', v))
        return this
      },
      /**
       * Add a signUpsOpen()bool method call against the StakingPool contract
       */
      signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.signUpsOpen(params)))
        resultMappers.push((v) => client.decodeReturnValue('signUpsOpen()bool', v))
        return this
      },
      /**
       * Add a isLive()bool method call against the StakingPool contract
       */
      isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isLive(params)))
        resultMappers.push((v) => client.decodeReturnValue('isLive()bool', v))
        return this
      },
      /**
       * Add a isEntered(address)bool method call against the StakingPool contract
       */
      isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.isEntered(params)))
        resultMappers.push((v) => client.decodeReturnValue('isEntered(address)bool', v))
        return this
      },
      /**
       * Add a getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) method call against the StakingPool contract
       */
      getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getState(params)))
        resultMappers.push((v) => client.decodeReturnValue('getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)', v))
        return this
      },
      /**
       * Add a updateAkitaDAOEscrow(uint64)void method call against the StakingPool contract
       */
      updateAkitaDaoEscrow(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoEscrow(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the StakingPool contract
       */
      updateAkitaDao(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a opUp()void method call against the StakingPool contract
       */
      opUp(params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a mbr(uint64)(uint64,uint64,uint64,uint64,uint64) method call against the StakingPool contract
       */
      mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)))
        resultMappers.push((v) => client.decodeReturnValue('mbr(uint64)(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      get update() {
        return {
          update: (params: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & AppClientCompilationParams) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      get delete() {
        return {
          delete: (params: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.delete(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the StakingPool contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as StakingPoolComposer
  }
}
export type StakingPoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the init()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  init(params?: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['init()void'] | undefined]>

  /**
   * Calls the optIn(pay,uint64)void ABI method.
   *
   * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  optIn(params?: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['optIn(pay,uint64)void'] | undefined]>

  /**
   * Calls the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addReward(params?: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addRewardAsa(params?: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the finalize(uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalize(params?: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalize(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the enter(pay,(uint64,uint64,byte[32][])[],byte[][])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  enter(params?: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[],byte[][])void'] | undefined]>

  /**
   * Calls the startDisbursement(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startDisbursement(params?: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['startDisbursement(uint64)void'] | undefined]>

  /**
   * Calls the raffle(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  raffle(params?: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['raffle(uint64)void'] | undefined]>

  /**
   * Calls the disburseRewards(uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  disburseRewards(params?: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['disburseRewards(uint64,uint64)void'] | undefined]>

  /**
   * Calls the finalizeDistribution(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalizeDistribution(params?: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalizeDistribution(uint64)void'] | undefined]>

  /**
   * Calls the check(address,uint64)(bool,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  check(params?: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['check(address,uint64)(bool,uint64)'] | undefined]>

  /**
   * Calls the signUpsOpen()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  signUpsOpen(params?: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['signUpsOpen()bool'] | undefined]>

  /**
   * Calls the isLive()bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isLive(params?: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isLive()bool'] | undefined]>

  /**
   * Calls the isEntered(address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isEntered(params?: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isEntered(address)bool'] | undefined]>

  /**
   * Calls the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getState(params?: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | undefined]>

  /**
   * Calls the updateAkitaDAOEscrow(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDaoEscrow(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'] | undefined]>

  /**
   * Calls the updateAkitaDAO(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAkitaDao(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAO(uint64)void'] | undefined]>

  /**
   * Calls the opUp()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  opUp(params?: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['opUp()void'] | undefined]>

  /**
   * Calls the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mbr(params?: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    update(params?: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['update(string)void'] | undefined]>
  }

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    delete(params?: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['delete(address)void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): StakingPoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): StakingPoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<StakingPoolComposerResults<TReturns>>
}
export type StakingPoolComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

